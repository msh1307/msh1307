<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux kernel SLUB allocator | msh1307</title>
<meta name="keywords" content="kernel slub, kernel slub allocator, Linux kernel">
<meta name="description" content="SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.
Terms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.
slab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2.">
<meta name="author" content="">
<link rel="canonical" href="https://msh1307.kr/blog/linux-kernel-slub-allocator/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9c43e0c7cae3b38c51e79921ad3cf2685d9811a56593a817d9b57ac4fdebf2b.css" integrity="sha256-2cQ&#43;DHyuOzjFHnmSGtPPJoXZgRpWWTqBfZtXrE/evys=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BR89V2WEC0');
</script>
<link rel="icon" href="https://msh1307.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://msh1307.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://msh1307.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://msh1307.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://msh1307.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Linux kernel SLUB allocator" />
<meta property="og:description" content="SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.
Terms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.
slab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msh1307.kr/blog/linux-kernel-slub-allocator/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-03-12T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-03-12T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux kernel SLUB allocator"/>
<meta name="twitter:description" content="SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.
Terms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.
slab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://msh1307.kr/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Linux kernel SLUB allocator",
      "item": "https://msh1307.kr/blog/linux-kernel-slub-allocator/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux kernel SLUB allocator",
  "name": "Linux kernel SLUB allocator",
  "description": "SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.\nTerms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.\nslab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2.",
  "keywords": [
    "kernel slub", "kernel slub allocator", "Linux kernel"
  ],
  "articleBody": "SLUB Allocator Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다. 초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다. 기존 SLAB allocator의 단점을 개선한 버전이다. kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다. kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다. kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.\nTerms slab SLAB allocator랑 다른말이다. slab cache (= kmem_cache)를 확보하고 관리하는 주체다.\nslab cache msh@raspberrypi:~ $ sudo cat /proc/slabinfo slabinfo - version: 2.1 # name : tunables : slabdata fuse_request 0 0 144 113 1 : tunables 0 0 0 : slabdata 0 0 0 fuse_inode 0 0 832 19 1 : tunables 0 0 0 : slabdata 0 0 0 kcopyd_job 0 0 3240 20 4 : tunables 0 0 0 : slabdata 0 0 0 ip6-frags 0 0 184 89 1 : tunables 0 0 0 : slabdata 0 0 0 PINGv6 0 0 1216 26 2 : tunables 0 0 0 : slabdata 0 0 0 RAWv6 78 78 1216 26 2 : tunables 0 0 0 : slabdata 3 3 0 UDPv6 96 96 1344 24 2 : tunables 0 0 0 : slabdata 4 4 0 tw_sock_TCPv6 0 0 264 62 1 : tunables 0 0 0 : slabdata 0 0 0 request_sock_TCPv6 0 0 312 52 1 : tunables 0 0 0 : slabdata 0 0 0 TCPv6 108 108 2368 27 4 : tunables 0 0 0 : slabdata 4 4 0 ext4_groupinfo_4k 11303 11303 184 89 1 : tunables 0 0 0 : slabdata 127 127 0 scsi_sense_cache 256 256 128 128 1 : tunables 0 0 0 : slabdata 2 2 0 fscrypt_info 0 0 128 128 1 : tunables 0 0 0 : slabdata 0 0 0 bio-120 640 640 128 128 1 : tunables 0 0 0 : slabdata 5 5 0 mqueue_inode_cache 17 17 960 17 1 : tunables 0 0 0 : slabdata 1 1 0 nfs4_xattr_cache_cache 0 0 2128 30 4 : tunables 0 0 0 : slabdata 0 0 0 nfs_direct_cache 0 0 224 73 1 : tunables 0 0 0 : slabdata 0 0 0 nfs_commit_data 23 23 704 23 1 : tunables 0 0 0 : slabdata 1 1 0 nfs_read_data 36 36 896 18 1 : tunables 0 0 0 : slabdata 2 2 0 nfs_inode_cache 0 0 1072 30 2 : tunables 0 0 0 : slabdata 0 0 0 fat_inode_cache 60 60 784 20 1 : tunables 0 0 0 : slabdata 3 3 0 fat_cache 818 818 40 409 1 : tunables 0 0 0 : slabdata 2 2 0 jbd2_journal_head 680 680 120 136 1 : tunables 0 0 0 : slabdata 5 5 0 jbd2_revoke_table_s 2048 2048 16 1024 1 : tunables 0 0 0 : slabdata 2 2 0 ext4_fc_dentry_update 0 0 96 170 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_inode_cache 11274 11286 1184 27 2 : tunables 0 0 0 : slabdata 418 418 0 ext4_allocation_context 480 480 136 120 1 : tunables 0 0 0 : slabdata 4 4 0 ext4_system_zone 1227 1227 40 409 1 : tunables 0 0 0 : slabdata 3 3 0 ext4_io_end 1024 1024 64 256 1 : tunables 0 0 0 : slabdata 4 4 0 ext4_bio_post_read_ctx 341 341 48 341 1 : tunables 0 0 0 : slabdata 1 1 0 ext4_pending_reservation 2048 2048 32 512 1 : tunables 0 0 0 : slabdata 4 4 0 ext4_extent_status 6119 6135 40 409 1 : tunables 0 0 0 : slabdata 15 15 0 mbcache 1168 1168 56 292 1 : tunables 0 0 0 : slabdata 4 4 0 kioctx 0 0 576 28 1 : tunables 0 0 0 : slabdata 0 0 0 fanotify_fid_event 0 0 72 227 1 : tunables 0 0 0 : slabdata 0 0 0 dnotify_struct 0 0 32 512 1 : tunables 0 0 0 : slabdata 0 0 0 audit_tree_mark 0 0 80 204 1 : tunables 0 0 0 : slabdata 0 0 0 kvm_vcpu 0 0 9680 13 8 : tunables 0 0 0 : slabdata 0 0 0 rpc_inode_cache 23 23 704 23 1 : tunables 0 0 0 : slabdata 1 1 0 UNIX 210 210 1088 30 2 : tunables 0 0 0 : slabdata 7 7 0 ip4-frags 0 0 200 81 1 : tunables 0 0 0 : slabdata 0 0 0 MPTCP 0 0 1920 17 2 : tunables 0 0 0 : slabdata 0 0 0 request_sock_subflow_v4 0 0 384 42 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_dst_cache 0 0 320 51 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_state 0 0 768 21 1 : tunables 0 0 0 : slabdata 0 0 0 ip_fib_trie 1364 1364 48 341 1 : tunables 0 0 0 : slabdata 4 4 0 ip_fib_alias 1168 1168 56 292 1 : tunables 0 0 0 : slabdata 4 4 0 PING 0 0 1024 16 1 : tunables 0 0 0 : slabdata 0 0 0 RAW 16 16 1024 16 1 : tunables 0 0 0 : slabdata 1 1 0 커널에는 이런식으로 미리 여러 슬랩캐시들이 확보되어있다. 주로 프로세스 생성에 자주 사용되는 task struct, cred 들도 미리 확보되어있다.\nslab page slab object 할당을 위해 Buddy system에서 할당받은 order-n 단위의 page.\nslab object slab cache에서 관리하는 object.\nBuddy system 외부 단편화를 줄이기위해 4k 사이즈의 page 단위로 할당한다. slab allocator는 반대로 buddy system에서 받은 page를 잘 관리해서 내부 단편화를 줄이기 위해 사용된다.\nInternal Structure SLAB vs SLUB SLAB allocator의 구조다. SLUB allocator의 구조다. struct page는 struct slab으로 구조체 이름이 변경되었다. cpu 별 cache를 둠으로써 lock less한 처리가 가능해졌다.\n왜 이런 구조가 되었는지 이해하려면 NUMA 아키텍쳐에 대해서 알아보아야한다.\nNUMA (Non-uniform memory access) 한 개 이상의 CPU가 동일한 시스템 자원을 사용하는 시스템을 SMP (Symmetric Multi-Processors) 환경이라고 부른다. SMP 환경에서는 동일한 자원에 대한 병목이 발생한다. 특정 프로세서가 하나의 주요 자원을 선점하고 lock을 걸어놓으면 당연하게 지연이 발생한다.\n멀티 프로세서 시스템에서의 메모리 설계 아키텍쳐를 NUMA라고 부른다. 위와 같은 구조다. Node를 만들어서 구분해놓은 것을 볼 수 있다. CPU에 메모리 버스를 하나씩 물려놓고 각자 memory를 붙여놨다. local memory에 access 하는건 빠르지만, 상대적으로 다른 node의 메모리 access는 느리다는게 특징이다.\n실제로 물리적인 cpu의 성능도 올라가고 core, thread 수도 올라가고 하이퍼쓰레딩같은 기술도 나오다보니 이러한 아키텍쳐가 많이 활용된다. SLUB allocator도 예외는 아니다.\nkmem_cache struct kmem_cache { struct kmem_cache_cpu __percpu *cpu_slab; /* Used for retriving partial slabs etc */ unsigned long flags; unsigned long min_partial; int size;\t/* The size of an object including meta data */ int object_size;\t/* The size of an object without meta data */ int offset;\t/* Free pointer offset. */ #ifdef CONFIG_SLUB_CPU_PARTIAL int cpu_partial;\t/* Number of per cpu partial objects to keep around */ #endif struct kmem_cache_order_objects oo; /* Allocation and freeing of slabs */ struct kmem_cache_order_objects max; struct kmem_cache_order_objects min; gfp_t allocflags;\t/* gfp flags to use on each alloc */ int refcount;\t/* Refcount for slab cache destroy */ void (*ctor)(void *); int inuse;\t/* Offset to metadata */ int align;\t/* Alignment */ int reserved;\t/* Reserved bytes at the end of slabs */ int red_left_pad;\t/* Left redzone padding size */ const char *name;\t/* Name (only for display!) */ struct list_head list;\t/* List of slab caches */ #ifdef CONFIG_SYSFS struct kobject kobj;\t/* For sysfs */ struct work_struct kobj_remove_work; #endif #ifdef CONFIG_MEMCG struct memcg_cache_params memcg_params; int max_attr_size; /* for propagation, maximum size of a stored attr */ #ifdef CONFIG_SYSFS struct kset *memcg_kset; #endif #endif #ifdef CONFIG_SLAB_FREELIST_HARDENED unsigned long random; #endif #ifdef CONFIG_NUMA /* * Defragmentation by allocating from a remote node. */ int remote_node_defrag_ratio; #endif #ifdef CONFIG_SLAB_FREELIST_RANDOM unsigned int *random_seq; #endif #ifdef CONFIG_KASAN struct kasan_cache kasan_info; #endif struct kmem_cache_node *node[MAX_NUMNODES]; }; struct kmem_cache_cpu __percpu *cpu_slab은 cpu별 슬랩 캐시를 관리하는 구조체다. struct kmem_cache_node *node[MAX_NUMNODES]는 앞서 설명한 NUMA node별로 관리하기 위한 구조체이다. unsigned int *random_seq은 Freelist randomization이 적용되면서 추가되었다.\nFlags 이런식으로 slab cache마다 플래그가 다르다. rcl은 자주 reclaim 하는 inode같은 객체들을 위해 이용된다. cg는 가변 크기 객체에 대해서 사용이 많이된다. dma는 dma 관련 메모리 할당에 이용된다\n그중 SLAB_ACCOUNT는 GFP_KERNEL_ACCOUNT와 독립된 캐시를 이용한다. 중간에 패치로 동일한 캐시를 이용한적이 있었지만 다시 독립된 캐시로 변경되었다. 위와 같이 이용된다.\nFreelist randomization #ifdef CONFIG_SLAB_FREELIST_RANDOM /* Pre-initialize the random sequence cache */ static int init_cache_random_seq(struct kmem_cache *s) { unsigned int count = oo_objects(s-\u003eoo); int err; /* Bailout if already initialised */ if (s-\u003erandom_seq) return 0; err = cache_random_seq_create(s, count, GFP_KERNEL); if (err) { pr_err(\"SLUB: Unable to initialize free list for %s\\n\", s-\u003ename); return err; } /* Transform to an offset on the set of pages */ if (s-\u003erandom_seq) { unsigned int i; for (i = 0; i \u003c count; i++) s-\u003erandom_seq[i] *= s-\u003esize; } return 0; } /* Get the next entry on the pre-computed freelist randomized */ static void *next_freelist_entry(struct kmem_cache *s, struct slab *slab, unsigned long *pos, void *start, unsigned long page_limit, unsigned long freelist_count) { unsigned int idx; /* * If the target page allocation failed, the number of objects on the * page might be smaller than the usual size defined by the cache. */ do { idx = s-\u003erandom_seq[*pos]; *pos += 1; if (*pos \u003e= freelist_count) *pos = 0; } while (unlikely(idx \u003e= page_limit)); return (char *)start + idx; } freelist가 랜덤화되면서 객체의 순차적 할당이나 재할당을 어렵게 만든다.\nkmem_cache_cpu #ifndef CONFIG_SLUB_TINY /* * When changing the layout, make sure freelist and tid are still compatible * with this_cpu_cmpxchg_double() alignment requirements. */ struct kmem_cache_cpu { union { struct { void **freelist;\t/* Pointer to next available object */ unsigned long tid;\t/* Globally unique transaction id */ }; freelist_aba_t freelist_tid; }; struct slab *slab;\t/* The slab from which we are allocating */ #ifdef CONFIG_SLUB_CPU_PARTIAL struct slab *partial;\t/* Partially allocated frozen slabs */ #endif local_lock_t lock;\t/* Protects the fields above */ #ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS]; #endif }; #endif /* CONFIG_SLUB_TINY */ freelist는 cpu별 free objects의 리스트이다. slab은 cpu에서 할당에 사용중인 슬랩이다. 원래 이름은 struct page였는데, kernel 5.17부터 struct slab으로 명칭이 변경되었다. partial은 해당 page내 일부 object가 cpu에서 사용중인 경우 partial list로 관리된다. 이런식으로 현재 할당에 이용할 slab엔 하나의 slab page가 링크되고, partial slabs에는 대기중인 slab page들이 링크되어있다. cpu slab의 page의 freelist와 percpu struct의 freelist는 같다. 하지만 다른 NUMA node에서 remote free 할때 실제 slab struct의 freelist와 약간 달라질 수 있다.\nstruct slab /* Reuses the bits in struct page */ struct slab { unsigned long __page_flags; #if defined(CONFIG_SLAB) struct kmem_cache *slab_cache; union { struct { struct list_head slab_list; void *freelist;\t/* array of free object indexes */ void *s_mem;\t/* first object */ }; struct rcu_head rcu_head; }; unsigned int active; #elif defined(CONFIG_SLUB) struct kmem_cache *slab_cache; union { struct { union { struct list_head slab_list; #ifdef CONFIG_SLUB_CPU_PARTIAL struct { struct slab *next; int slabs;\t/* Nr of slabs left */ }; #endif }; /* Double-word boundary */ union { struct { void *freelist;\t/* first free object */ union { unsigned long counters; struct { unsigned inuse:16; unsigned objects:15; unsigned frozen:1; }; }; }; #ifdef system_has_freelist_aba freelist_aba_t freelist_counter; #endif }; }; struct rcu_head rcu_head; }; unsigned int __unused; #else #error \"Unexpected slab allocator configured\" #endif atomic_t __page_refcount; #ifdef CONFIG_MEMCG unsigned long memcg_data; #endif }; struct page에서 이름이 바뀌었다. percpu에서도 있지만, slab page 구조체에서도 freelist가 있다. 이 둘을 이용해서 할당 \u0026 해제를 좀 더 효율적으로 진행한다. 이에 대해선 Allocation 관련 설명을 하면서 후술한다.\nkmem_cache_node struct kmem_cache_node { #ifdef CONFIG_SLAB raw_spinlock_t list_lock; struct list_head slabs_partial;\t/* partial list first, better asm code */ struct list_head slabs_full; struct list_head slabs_free; unsigned long total_slabs;\t/* length of all slab lists */ unsigned long free_slabs;\t/* length of free slab list only */ unsigned long free_objects; unsigned int free_limit; unsigned int colour_next;\t/* Per-node cache coloring */ struct array_cache *shared;\t/* shared per node */ struct alien_cache **alien;\t/* on other nodes */ unsigned long next_reap;\t/* updated without locking */ int free_touched;\t/* updated without locking */ #endif #ifdef CONFIG_SLUB spinlock_t list_lock; unsigned long nr_partial; struct list_head partial; #ifdef CONFIG_SLUB_DEBUG atomic_long_t nr_slabs; atomic_long_t total_objects; struct list_head full; #endif #endif }; spinlock_t list_lock은 node에 동시접근 방지하기 위한 lock이다. 그리고 struct list_head partial은 node별로 관리되는 partial page list이다.\nAllocation 정리하자면, kmem_cache_cpu는 CPU 별로 각자의 슬랩 페이지를 주고 관리하게 한다. 그리고 kmem_cache_cpu struct의 freelist는 할당에 이용되는 slab에 대한 freelist이다. lockless하게 할당과 해제를 진행하게 된다.\n근데 struct slab에서도 freelist가 존재했다. cpu -\u003e freelist와 cpu -\u003e slab -\u003e freelist는 차이가 있다. 전자는 현재 CPU가 관리하며 free시 추가된다. 후자는 현재 CPU가 관리하는 slab page에 속한 object를 remote CPU가 free시에 리스트에 추가된다. 이러한 remote cpu, 즉 전담 cpu가 아닌 경우엔 항상 free만 가능하다.\nfrozen page는 list management에서 제외되는 페이지를 뜻한다. freeze한 cpu만이 list operation을 수행하며, object를 freelist에서 뽑아오는 연산등을 할 수 있다. frozen page여도 다른 cpu가 object를 freelist를 넣을 수는 있다.\n이러한 frozen page에서 cpu -\u003e freelist가 가리키는 free object들과 in-use object들은 cpu -\u003e page.inuse의 값과 같으며 remote cpu가 free 할때만 감소한다. 즉 현재 CPU가 컨트롤하고 있는 object 개수만 inuse로 취급한다는 뜻이다. 앞서 remote cpu는 전담 cpu의 slab object에 대한 free만 가능하다는 사실과 일맥상통한다.\nFast-Path cpu -\u003e freelist에서 object 할당한다. Slow-Path 1, 2 Slow-Path 1 cpu -\u003e slab에 freelist를 cpu -\u003e freelist로 옮긴다. cpu -\u003e freelist에서 object를 할당한다 Slow-Path 2 cpu -\u003e partial를 cpu -\u003e page로 옮긴다. cpu -\u003e page -\u003e freelist를 cpu -\u003e freelist로 옮긴다. cpu -\u003e freelist에서 object를 할당한다. Slow-Path 3, 4 Slow-Path 3 이번엔 slab_cache -\u003e cpu가 아니라 slab_cache -\u003e node 이다.\nnode -\u003e partial를 freeze freeze 하는 이유는 아주 당연하지만 node의 동시 접근 때문이다. node -\u003e partial를 탐색하다가 page를 cpu -\u003e slab으로 옮긴다. cpu -\u003e slab -\u003e freelist를 cpu -\u003e freelist로 옮긴다. node -\u003e partial의 slab page 일부를 cpu -\u003epartial로 옮긴다. moved partial_slabs \u003e s-\u003ecpu_partial_slabs / 2 속한 node의 partial list가 비었으면 인접한 node도 탐색한다.\nSlow-Path 4 Buddy System으로부터 신규 slab page를 할당한다. 신규 page는 모든 object가 freelist에 존재한다. new slab을 cpu -\u003e slab로 옮긴다. cpu -\u003e freelist로도 옮긴다. Deallocation 할당과 비슷하게 fast, slow path가 있다.\nFast-Path frozen page에 대해서 percpu의 freelist에 바로 반환한다.\nSlow-Path 오브젝트가 속한 slab page freelist에 반환한다. 여러 케이스들이 있다.\nremote cpu가 다른 cpu slab을 free해서 리턴한다. node의 partial에 리턴한다. inuse가 0이면, 관할 cpu가 더이상 효율적으로 이용하지 못한다는 의미이므로 node로 옮긴다. 근데 이때 min_partial 보다 크거나 같아지면 buddy system에 다시 리턴한다. node partial이 아니고 모든 객체가 할당된 상태이며 frozen 상태가 아니면 cpu partial에 추가한다. 마지막 부분은 아직 잘 모르겠다.\nOptimization From: Christoph Lameter To: Tejun Heo Cc: akpm@linux-foundation.org Cc: Pekka Enberg Cc: linux-kernel@vger.kernel.org Cc: Eric Dumazet Cc: \"H. Peter Anvin\" Cc: Mathieu Desnoyers Subject: [[cpuops cmpxchg double V2 4/4] Lockless (and preemptless) fastpaths for slub](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/#r) Date: Thu, 06 Jan 2011 14:45:17 -0600\t[[thread overview]](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/#r) Message-ID: \u003c20110106204526.977812009@linux.com\u003e ([raw](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/raw)) In-Reply-To: 20110106204513.669098445@linux.com [[-- /blog/Linux_kernel_SLUB_Allocator #1: cpuops_double_slub_fastpath --] [-- Type: text/plain, Size: 12414 bytes --]](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/1-cpuops_double_slub_fastpath) Use the this_cpu_cmpxchg_double functionality to implement a lockless allocation algorithm on arches that support fast this_cpu_ops. Each of the per cpu pointers is paired with a transaction id that ensures that updates of the per cpu information can only occur in sequence on a certain cpu. A transaction id is a \"long\" integer that is comprised of an event number and the cpu number. The event number is incremented for every change to the per cpu state. The cmpxchg instruction can therefore verify for an update that nothing else has interfered and that we are updating the percpu' structure for the processor where we initially picked up the information and that we are also currently on that processor. So there is no need even to disable preemption. Test results show that the fastpath cycle count is reduced by up to ~ 40% (alloc/free test goes from ~140 cycles down to ~80). The slowpath for kfree adds a few cycles. Sadly this does nothing for the slowpath which is where the main issues with performance in slub are but the best case performance rises significantly. (For that see the more complex slub patches that require cmpxchg_double) Kmalloc: alloc/free test Before: 10000 times kmalloc(8)/kfree -\u003e 134 cycles 10000 times kmalloc(16)/kfree -\u003e 152 cycles 10000 times kmalloc(32)/kfree -\u003e 144 cycles 10000 times kmalloc(64)/kfree -\u003e 142 cycles 10000 times kmalloc(128)/kfree -\u003e 142 cycles 10000 times kmalloc(256)/kfree -\u003e 132 cycles 10000 times kmalloc(512)/kfree -\u003e 132 cycles 10000 times kmalloc(1024)/kfree -\u003e 135 cycles 10000 times kmalloc(2048)/kfree -\u003e 135 cycles 10000 times kmalloc(4096)/kfree -\u003e 135 cycles 10000 times kmalloc(8192)/kfree -\u003e 144 cycles 10000 times kmalloc(16384)/kfree -\u003e 754 cycles After: 10000 times kmalloc(8)/kfree -\u003e 78 cycles 10000 times kmalloc(16)/kfree -\u003e 78 cycles 10000 times kmalloc(32)/kfree -\u003e 82 cycles 10000 times kmalloc(64)/kfree -\u003e 88 cycles 10000 times kmalloc(128)/kfree -\u003e 79 cycles 10000 times kmalloc(256)/kfree -\u003e 79 cycles 10000 times kmalloc(512)/kfree -\u003e 85 cycles 10000 times kmalloc(1024)/kfree -\u003e 82 cycles 10000 times kmalloc(2048)/kfree -\u003e 82 cycles 10000 times kmalloc(4096)/kfree -\u003e 85 cycles 10000 times kmalloc(8192)/kfree -\u003e 82 cycles 10000 times kmalloc(16384)/kfree -\u003e 706 cycles Kmalloc: Repeatedly allocate then free test Before: 10000 times kmalloc(8) -\u003e 211 cycles kfree -\u003e 113 cycles 10000 times kmalloc(16) -\u003e 174 cycles kfree -\u003e 115 cycles 10000 times kmalloc(32) -\u003e 235 cycles kfree -\u003e 129 cycles 10000 times kmalloc(64) -\u003e 222 cycles kfree -\u003e 120 cycles 10000 times kmalloc(128) -\u003e 343 cycles kfree -\u003e 139 cycles 10000 times kmalloc(256) -\u003e 827 cycles kfree -\u003e 147 cycles 10000 times kmalloc(512) -\u003e 1048 cycles kfree -\u003e 272 cycles 10000 times kmalloc(1024) -\u003e 2043 cycles kfree -\u003e 528 cycles 10000 times kmalloc(2048) -\u003e 4002 cycles kfree -\u003e 571 cycles 10000 times kmalloc(4096) -\u003e 7740 cycles kfree -\u003e 628 cycles 10000 times kmalloc(8192) -\u003e 8062 cycles kfree -\u003e 850 cycles 10000 times kmalloc(16384) -\u003e 8895 cycles kfree -\u003e 1249 cycles After: 10000 times kmalloc(8) -\u003e 190 cycles kfree -\u003e 129 cycles 10000 times kmalloc(16) -\u003e 76 cycles kfree -\u003e 123 cycles 10000 times kmalloc(32) -\u003e 126 cycles kfree -\u003e 124 cycles 10000 times kmalloc(64) -\u003e 181 cycles kfree -\u003e 128 cycles 10000 times kmalloc(128) -\u003e 310 cycles kfree -\u003e 140 cycles 10000 times kmalloc(256) -\u003e 809 cycles kfree -\u003e 165 cycles 10000 times kmalloc(512) -\u003e 1005 cycles kfree -\u003e 269 cycles 10000 times kmalloc(1024) -\u003e 1999 cycles kfree -\u003e 527 cycles 10000 times kmalloc(2048) -\u003e 3967 cycles kfree -\u003e 570 cycles 10000 times kmalloc(4096) -\u003e 7658 cycles kfree -\u003e 637 cycles 10000 times kmalloc(8192) -\u003e 8111 cycles kfree -\u003e 859 cycles 10000 times kmalloc(16384) -\u003e 8791 cycles kfree -\u003e 1173 cycles Signed-off-by: Christoph Lameter --- include/linux/slub_def.h | 5 - mm/slub.c | 205 ++++++++++++++++++++++++++++++++++++++++++++++- 2 files changed, 207 insertions(+), 3 deletions(-) 찾아보니 위와 같은 패치를 찾을 수 있었다. percpu의 tid는 percpu update마다 증가되며 순차적인 업데이트를 보장한다. 중간에 interrupt로 인해 실행흐름이 넘어갈때 똑같이 percpu에 접근해서 할당을 하거나 하면 순차적인 업데이트를 보장하지 못한다.\n왜냐하면 allocation request가 왔을때 freelist를 읽었는데, 이때 실행흐름이 새로운 allocation request로 넘어가면 분명 다른 두가지 요청인데 같은 메모리를 리턴하게 될 수도 있기 때문이다. 이를 방지하기 위해서 원래는 interrupt disable 했었다.\n근데 만약 cmpxchg double을 지원하는 아키텍쳐에서 이를 이용하면 단순히 tid에 대한 검증과 리턴을 하나의 명령내에서 처리가 가능하다. 당연히 interrupt를 쓰지 않아도 되며, tid를 모든 allocation request가 순차적이라는 것을 보장할 수 있게 되었다.\n또한 free시에도 lockless하게 구현할 수 있게 되었다. 원래 freelist를 가져가서 lock 걸고 list에서 뽑고 counter를 줄였는데, cmpxchg double로 그때 그때 counter 비교해서 다른 cpu가 counter 건들면 retry하면 된다.\nDebugging 직접 디버깅해보면, 슬랩 캐시도 보이고 random도 보인다. 5.19 기준으로 random 값이 있었고 청크의 next가 mangling 되어있었다. 나머지는 앞에서 살펴봤던 구조와 같았다.\npercpu를 확인해보면 이런식으로 freelist가 존재한다. 정상적으로 첫번째 slab object가 리턴되는것을 확인할 수 있다.\n",
  "wordCount" : "3201",
  "inLanguage": "en",
  "datePublished": "2024-03-12T00:00:00Z",
  "dateModified": "2024-03-12T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://msh1307.kr/blog/linux-kernel-slub-allocator/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "msh1307",
    "logo": {
      "@type": "ImageObject",
      "url": "https://msh1307.kr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR89V2WEC0');
    </script>
    <nav class="nav">
        <div class="logo">
            <a href="https://msh1307.kr" accesskey="h" title="msh1307 (Alt + H)">msh1307</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://msh1307.kr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://msh1307.kr">Home</a>&nbsp;»&nbsp;<a href="https://msh1307.kr/blog/">Blogs</a></div>
    <h1 class="post-title">
      Linux kernel SLUB allocator
    </h1>
    <div class="post-meta">


March 2024

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#slub-allocator" aria-label="SLUB Allocator">SLUB Allocator</a><ul>
                        
                <li>
                    <a href="#terms" aria-label="Terms">Terms</a><ul>
                        
                <li>
                    <a href="#slab" aria-label="slab">slab</a></li>
                <li>
                    <a href="#slab-cache" aria-label="slab cache">slab cache</a></li>
                <li>
                    <a href="#slab-page" aria-label="slab page">slab page</a></li>
                <li>
                    <a href="#slab-object" aria-label="slab object">slab object</a></li>
                <li>
                    <a href="#buddy-system" aria-label="Buddy system">Buddy system</a></li></ul>
                </li>
                <li>
                    <a href="#internal-structure" aria-label="Internal Structure">Internal Structure</a><ul>
                        
                <li>
                    <a href="#slab-vs-slub" aria-label="SLAB vs SLUB">SLAB vs SLUB</a><ul>
                        
                <li>
                    <a href="#numa-non-uniform-memory-access" aria-label="NUMA (Non-uniform memory access)">NUMA (Non-uniform memory access)</a></li></ul>
                </li>
                <li>
                    <a href="#kmem_cache" aria-label="kmem_cache">kmem_cache</a><ul>
                        
                <li>
                    <a href="#flags" aria-label="Flags">Flags</a></li></ul>
                </li>
                <li>
                    <a href="#freelist-randomization" aria-label="Freelist randomization">Freelist randomization</a></li>
                <li>
                    <a href="#kmem_cache_cpu" aria-label="kmem_cache_cpu">kmem_cache_cpu</a></li>
                <li>
                    <a href="#struct-slab" aria-label="struct slab">struct slab</a></li>
                <li>
                    <a href="#kmem_cache_node" aria-label="kmem_cache_node">kmem_cache_node</a></li></ul>
                </li>
                <li>
                    <a href="#allocation" aria-label="Allocation">Allocation</a><ul>
                        
                <li>
                    <a href="#fast-path" aria-label="Fast-Path">Fast-Path</a></li>
                <li>
                    <a href="#slow-path-1-2" aria-label="Slow-Path 1, 2">Slow-Path 1, 2</a><ul>
                        
                <li>
                    <a href="#slow-path-1" aria-label="Slow-Path 1">Slow-Path 1</a></li>
                <li>
                    <a href="#slow-path-2" aria-label="Slow-Path 2">Slow-Path 2</a></li></ul>
                </li>
                <li>
                    <a href="#slow-path-3-4" aria-label="Slow-Path 3, 4">Slow-Path 3, 4</a><ul>
                        
                <li>
                    <a href="#slow-path-3" aria-label="Slow-Path 3">Slow-Path 3</a></li>
                <li>
                    <a href="#slow-path-4" aria-label="Slow-Path 4">Slow-Path 4</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#deallocation" aria-label="Deallocation">Deallocation</a><ul>
                        
                <li>
                    <a href="#fast-path-1" aria-label="Fast-Path">Fast-Path</a></li>
                <li>
                    <a href="#slow-path" aria-label="Slow-Path">Slow-Path</a></li></ul>
                </li>
                <li>
                    <a href="#optimization" aria-label="Optimization">Optimization</a></li>
                <li>
                    <a href="#debugging" aria-label="Debugging">Debugging</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="slub-allocator">SLUB Allocator<a hidden class="anchor" aria-hidden="true" href="#slub-allocator">#</a></h1>
<p>Userland에선 ptmalloc2가 있는 반면, Kernelland에선 SLUB이 있다.
초기엔 SLAB Allocator를 사용했지만, 현재 대부분의 배포판은 SLUB을 이용한다.
기존 SLAB allocator의 단점을 개선한 버전이다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/6d795cd6c84f0ace0e2f1a96e04987a9.png" alt=""  />

kmem_cache_create로 slab cache를 생성하고 kmem_cache_alloc으로 지정된 slab cache에서 object를 할당한다.
kmem_cache_free로 free하고 kmem_cache_destroy로 slab cache를 제거한다.
kmalloc, kzalloc 같은 함수는 kmalloc-N 캐시에서 적합한 size인 object를 할당한다.</p>
<h2 id="terms">Terms<a hidden class="anchor" aria-hidden="true" href="#terms">#</a></h2>
<h3 id="slab">slab<a hidden class="anchor" aria-hidden="true" href="#slab">#</a></h3>
<p>SLAB allocator랑 다른말이다.
slab cache (= kmem_cache)를 확보하고 관리하는 주체다.</p>
<h3 id="slab-cache">slab cache<a hidden class="anchor" aria-hidden="true" href="#slab-cache">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>msh@raspberrypi:~ $ sudo cat /proc/slabinfo
</span></span><span style="display:flex;"><span>slabinfo - version: 2.1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span>
</span></span><span style="display:flex;"><span>fuse_request           <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">144</span>  <span style="color:#ae81ff">113</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>fuse_inode             <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">832</span>   <span style="color:#ae81ff">19</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>kcopyd_job             <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">3240</span>   <span style="color:#ae81ff">20</span>    <span style="color:#ae81ff">4</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ip6-frags              <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">184</span>   <span style="color:#ae81ff">89</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>PINGv6                 <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">1216</span>   <span style="color:#ae81ff">26</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>RAWv6                 <span style="color:#ae81ff">78</span>     <span style="color:#ae81ff">78</span>   <span style="color:#ae81ff">1216</span>   <span style="color:#ae81ff">26</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">3</span>      <span style="color:#ae81ff">3</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>UDPv6                 <span style="color:#ae81ff">96</span>     <span style="color:#ae81ff">96</span>   <span style="color:#ae81ff">1344</span>   <span style="color:#ae81ff">24</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>tw_sock_TCPv6          <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">264</span>   <span style="color:#ae81ff">62</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>request_sock_TCPv6      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">312</span>   <span style="color:#ae81ff">52</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>TCPv6                <span style="color:#ae81ff">108</span>    <span style="color:#ae81ff">108</span>   <span style="color:#ae81ff">2368</span>   <span style="color:#ae81ff">27</span>    <span style="color:#ae81ff">4</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_groupinfo_4k  <span style="color:#ae81ff">11303</span>  <span style="color:#ae81ff">11303</span>    <span style="color:#ae81ff">184</span>   <span style="color:#ae81ff">89</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata    <span style="color:#ae81ff">127</span>    <span style="color:#ae81ff">127</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>scsi_sense_cache     <span style="color:#ae81ff">256</span>    <span style="color:#ae81ff">256</span>    <span style="color:#ae81ff">128</span>  <span style="color:#ae81ff">128</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>fscrypt_info           <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">128</span>  <span style="color:#ae81ff">128</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>bio-120              <span style="color:#ae81ff">640</span>    <span style="color:#ae81ff">640</span>    <span style="color:#ae81ff">128</span>  <span style="color:#ae81ff">128</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">5</span>      <span style="color:#ae81ff">5</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>mqueue_inode_cache     <span style="color:#ae81ff">17</span>     <span style="color:#ae81ff">17</span>    <span style="color:#ae81ff">960</span>   <span style="color:#ae81ff">17</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>nfs4_xattr_cache_cache      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">2128</span>   <span style="color:#ae81ff">30</span>    <span style="color:#ae81ff">4</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>nfs_direct_cache       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">224</span>   <span style="color:#ae81ff">73</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>nfs_commit_data       <span style="color:#ae81ff">23</span>     <span style="color:#ae81ff">23</span>    <span style="color:#ae81ff">704</span>   <span style="color:#ae81ff">23</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>nfs_read_data         <span style="color:#ae81ff">36</span>     <span style="color:#ae81ff">36</span>    <span style="color:#ae81ff">896</span>   <span style="color:#ae81ff">18</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>nfs_inode_cache        <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">1072</span>   <span style="color:#ae81ff">30</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>fat_inode_cache       <span style="color:#ae81ff">60</span>     <span style="color:#ae81ff">60</span>    <span style="color:#ae81ff">784</span>   <span style="color:#ae81ff">20</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">3</span>      <span style="color:#ae81ff">3</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>fat_cache            <span style="color:#ae81ff">818</span>    <span style="color:#ae81ff">818</span>     <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">409</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>jbd2_journal_head    <span style="color:#ae81ff">680</span>    <span style="color:#ae81ff">680</span>    <span style="color:#ae81ff">120</span>  <span style="color:#ae81ff">136</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">5</span>      <span style="color:#ae81ff">5</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>jbd2_revoke_table_s   <span style="color:#ae81ff">2048</span>   <span style="color:#ae81ff">2048</span>     <span style="color:#ae81ff">16</span> <span style="color:#ae81ff">1024</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">2</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_fc_dentry_update      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">96</span>  <span style="color:#ae81ff">170</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_inode_cache   <span style="color:#ae81ff">11274</span>  <span style="color:#ae81ff">11286</span>   <span style="color:#ae81ff">1184</span>   <span style="color:#ae81ff">27</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata    <span style="color:#ae81ff">418</span>    <span style="color:#ae81ff">418</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_allocation_context    <span style="color:#ae81ff">480</span>    <span style="color:#ae81ff">480</span>    <span style="color:#ae81ff">136</span>  <span style="color:#ae81ff">120</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_system_zone    <span style="color:#ae81ff">1227</span>   <span style="color:#ae81ff">1227</span>     <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">409</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">3</span>      <span style="color:#ae81ff">3</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_io_end         <span style="color:#ae81ff">1024</span>   <span style="color:#ae81ff">1024</span>     <span style="color:#ae81ff">64</span>  <span style="color:#ae81ff">256</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_bio_post_read_ctx    <span style="color:#ae81ff">341</span>    <span style="color:#ae81ff">341</span>     <span style="color:#ae81ff">48</span>  <span style="color:#ae81ff">341</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_pending_reservation   <span style="color:#ae81ff">2048</span>   <span style="color:#ae81ff">2048</span>     <span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">512</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ext4_extent_status   <span style="color:#ae81ff">6119</span>   <span style="color:#ae81ff">6135</span>     <span style="color:#ae81ff">40</span>  <span style="color:#ae81ff">409</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata     <span style="color:#ae81ff">15</span>     <span style="color:#ae81ff">15</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>mbcache             <span style="color:#ae81ff">1168</span>   <span style="color:#ae81ff">1168</span>     <span style="color:#ae81ff">56</span>  <span style="color:#ae81ff">292</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>kioctx                 <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">576</span>   <span style="color:#ae81ff">28</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>fanotify_fid_event      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">72</span>  <span style="color:#ae81ff">227</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dnotify_struct         <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">512</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>audit_tree_mark        <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">80</span>  <span style="color:#ae81ff">204</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>kvm_vcpu               <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">9680</span>   <span style="color:#ae81ff">13</span>    <span style="color:#ae81ff">8</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>rpc_inode_cache       <span style="color:#ae81ff">23</span>     <span style="color:#ae81ff">23</span>    <span style="color:#ae81ff">704</span>   <span style="color:#ae81ff">23</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>UNIX                 <span style="color:#ae81ff">210</span>    <span style="color:#ae81ff">210</span>   <span style="color:#ae81ff">1088</span>   <span style="color:#ae81ff">30</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">7</span>      <span style="color:#ae81ff">7</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ip4-frags              <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">200</span>   <span style="color:#ae81ff">81</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>MPTCP                  <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">1920</span>   <span style="color:#ae81ff">17</span>    <span style="color:#ae81ff">2</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>request_sock_subflow_v4      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">384</span>   <span style="color:#ae81ff">42</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>xfrm_dst_cache         <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">320</span>   <span style="color:#ae81ff">51</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>xfrm_state             <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">768</span>   <span style="color:#ae81ff">21</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ip_fib_trie         <span style="color:#ae81ff">1364</span>   <span style="color:#ae81ff">1364</span>     <span style="color:#ae81ff">48</span>  <span style="color:#ae81ff">341</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>ip_fib_alias        <span style="color:#ae81ff">1168</span>   <span style="color:#ae81ff">1168</span>     <span style="color:#ae81ff">56</span>  <span style="color:#ae81ff">292</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">4</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>PING                   <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">1024</span>   <span style="color:#ae81ff">16</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>RAW                   <span style="color:#ae81ff">16</span>     <span style="color:#ae81ff">16</span>   <span style="color:#ae81ff">1024</span>   <span style="color:#ae81ff">16</span>    <span style="color:#ae81ff">1</span> : tunables    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> : slabdata      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>커널에는 이런식으로 미리 여러 슬랩캐시들이 확보되어있다.
주로 프로세스 생성에 자주 사용되는 task struct, cred 들도 미리 확보되어있다.</p>
<h3 id="slab-page">slab page<a hidden class="anchor" aria-hidden="true" href="#slab-page">#</a></h3>
<p>slab object 할당을 위해 Buddy system에서 할당받은 order-n 단위의 page.</p>
<h3 id="slab-object">slab object<a hidden class="anchor" aria-hidden="true" href="#slab-object">#</a></h3>
<p>slab cache에서 관리하는 object.</p>
<h3 id="buddy-system">Buddy system<a hidden class="anchor" aria-hidden="true" href="#buddy-system">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/58dcaf76652a6d7b87f9847b21fe67a7.png" alt=""  />

외부 단편화를 줄이기위해 4k 사이즈의 page 단위로 할당한다.
slab allocator는 반대로 buddy system에서 받은 page를 잘 관리해서 내부 단편화를 줄이기 위해 사용된다.</p>
<h2 id="internal-structure">Internal Structure<a hidden class="anchor" aria-hidden="true" href="#internal-structure">#</a></h2>
<h3 id="slab-vs-slub">SLAB vs SLUB<a hidden class="anchor" aria-hidden="true" href="#slab-vs-slub">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/73c4ccd6a7d04fe2efd757f90883cf56.png" alt=""  />

SLAB allocator의 구조다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/2f416de1b4bb8e4239713346b1030ce6.png" alt=""  />

SLUB allocator의 구조다.
struct page는 struct slab으로 구조체 이름이 변경되었다.
cpu 별 cache를 둠으로써 lock less한 처리가 가능해졌다.</p>
<p>왜 이런 구조가 되었는지 이해하려면 NUMA 아키텍쳐에 대해서 알아보아야한다.</p>
<h4 id="numa-non-uniform-memory-access">NUMA (Non-uniform memory access)<a hidden class="anchor" aria-hidden="true" href="#numa-non-uniform-memory-access">#</a></h4>
<p>한 개 이상의 CPU가 동일한 시스템 자원을 사용하는 시스템을 SMP (Symmetric Multi-Processors) 환경이라고 부른다.
SMP 환경에서는 동일한 자원에 대한 병목이 발생한다.
특정 프로세서가 하나의 주요 자원을 선점하고 lock을 걸어놓으면 당연하게 지연이 발생한다.</p>
<p>멀티 프로세서 시스템에서의 메모리 설계 아키텍쳐를 NUMA라고 부른다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/fdf5395b0ddcb0dccb8e37b992a90725.png" alt=""  />

위와 같은 구조다.
Node를 만들어서 구분해놓은 것을 볼 수 있다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/de1564283f0fd2df0efb5f789fd97411.jpg" alt=""  />

CPU에 메모리 버스를 하나씩 물려놓고 각자 memory를 붙여놨다.
local memory에 access 하는건 빠르지만, 상대적으로 다른 node의 메모리 access는 느리다는게 특징이다.</p>
<p>실제로 물리적인 cpu의 성능도 올라가고 core, thread 수도 올라가고 하이퍼쓰레딩같은 기술도 나오다보니 이러한 아키텍쳐가 많이 활용된다.
SLUB allocator도 예외는 아니다.</p>
<h3 id="kmem_cache">kmem_cache<a hidden class="anchor" aria-hidden="true" href="#kmem_cache">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_cpu __percpu <span style="color:#f92672">*</span>cpu_slab;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Used for retriving partial slabs etc */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> min_partial;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> size;		<span style="color:#75715e">/* The size of an object including meta data */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> object_size;	<span style="color:#75715e">/* The size of an object without meta data */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> offset;		<span style="color:#75715e">/* Free pointer offset. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> cpu_partial;	<span style="color:#75715e">/* Number of per cpu partial objects to keep around */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kmem_cache_order_objects oo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Allocation and freeing of slabs */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_order_objects max;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_order_objects min;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">gfp_t</span> allocflags;	<span style="color:#75715e">/* gfp flags to use on each alloc */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> refcount;		<span style="color:#75715e">/* Refcount for slab cache destroy */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>ctor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> inuse;		<span style="color:#75715e">/* Offset to metadata */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> align;		<span style="color:#75715e">/* Alignment */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> reserved;		<span style="color:#75715e">/* Reserved bytes at the end of slabs */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> red_left_pad;	<span style="color:#75715e">/* Left redzone padding size */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;	<span style="color:#75715e">/* Name (only for display!) */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head list;	<span style="color:#75715e">/* List of slab caches */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SYSFS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kobject kobj;	<span style="color:#75715e">/* For sysfs */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> work_struct kobj_remove_work;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MEMCG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> memcg_cache_params memcg_params;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max_attr_size; <span style="color:#75715e">/* for propagation, maximum size of a stored attr */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SYSFS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kset <span style="color:#f92672">*</span>memcg_kset;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLAB_FREELIST_HARDENED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> random;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_NUMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Defragmentation by allocating from a remote node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> remote_node_defrag_ratio;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLAB_FREELIST_RANDOM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>random_seq;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_KASAN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kasan_cache kasan_info;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_node <span style="color:#f92672">*</span>node[MAX_NUMNODES];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>struct kmem_cache_cpu __percpu *cpu_slab은 cpu별 슬랩 캐시를 관리하는 구조체다.
struct kmem_cache_node *node[MAX_NUMNODES]는 앞서 설명한 NUMA node별로 관리하기 위한 구조체이다.
unsigned int *random_seq은 Freelist randomization이 적용되면서 추가되었다.</p>
<h4 id="flags">Flags<a hidden class="anchor" aria-hidden="true" href="#flags">#</a></h4>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/e1854155c165c78d0b994d5e2f88678a.png" alt=""  />

<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/fe5bb4c5bf2fbba491235b0f4bcd5343.png" alt=""  />

<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/c27cd4d95eb3f5930259775f0ea2ff68.png" alt=""  />

<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/728a221bd58285fb1b289b0825d41392.png" alt=""  />

이런식으로 slab cache마다 플래그가 다르다.
rcl은 자주 reclaim 하는 inode같은 객체들을 위해 이용된다.
cg는 가변 크기 객체에 대해서 사용이 많이된다.
dma는 dma 관련 메모리 할당에 이용된다</p>
<p>그중 SLAB_ACCOUNT는 GFP_KERNEL_ACCOUNT와 독립된 캐시를 이용한다.
중간에 패치로 동일한 캐시를 이용한적이 있었지만 다시 독립된 캐시로 변경되었다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/061c2890ebb11b469159d2b97dc13bae.png" alt=""  />

위와 같이 이용된다.</p>
<h3 id="freelist-randomization">Freelist randomization<a hidden class="anchor" aria-hidden="true" href="#freelist-randomization">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLAB_FREELIST_RANDOM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* Pre-initialize the random sequence cache */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">init_cache_random_seq</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#a6e22e">oo_objects</span>(s<span style="color:#f92672">-&gt;</span>oo);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Bailout if already initialised */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>random_seq)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">cache_random_seq_create</span>(s, count, GFP_KERNEL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pr_err</span>(<span style="color:#e6db74">&#34;SLUB: Unable to initialize free list for %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			s<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Transform to an offset on the set of pages */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>random_seq) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			s<span style="color:#f92672">-&gt;</span>random_seq[i] <span style="color:#f92672">*=</span> s<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Get the next entry on the pre-computed freelist randomized */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">next_freelist_entry</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> slab <span style="color:#f92672">*</span>slab,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pos, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>start,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> page_limit,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> freelist_count)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> idx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * If the target page allocation failed, the number of objects on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * page might be smaller than the usual size defined by the cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		idx <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>random_seq[<span style="color:#f92672">*</span>pos];
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>pos <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>pos <span style="color:#f92672">&gt;=</span> freelist_count)
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span>pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">unlikely</span>(idx <span style="color:#f92672">&gt;=</span> page_limit));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)start <span style="color:#f92672">+</span> idx;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>freelist가 랜덤화되면서 객체의 순차적 할당이나 재할당을 어렵게 만든다.</p>
<h3 id="kmem_cache_cpu">kmem_cache_cpu<a hidden class="anchor" aria-hidden="true" href="#kmem_cache_cpu">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifndef CONFIG_SLUB_TINY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * When changing the layout, make sure freelist and tid are still compatible
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * with this_cpu_cmpxchg_double() alignment requirements.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache_cpu {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>freelist;	<span style="color:#75715e">/* Pointer to next available object */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tid;	<span style="color:#75715e">/* Globally unique transaction id */</span>
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">freelist_aba_t</span> freelist_tid;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> slab <span style="color:#f92672">*</span>slab;	<span style="color:#75715e">/* The slab from which we are allocating */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> slab <span style="color:#f92672">*</span>partial;	<span style="color:#75715e">/* Partially allocated frozen slabs */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">local_lock_t</span> lock;	<span style="color:#75715e">/* Protects the fields above */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLUB_STATS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> stat[NR_SLUB_STAT_ITEMS];
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* CONFIG_SLUB_TINY */</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>freelist는 cpu별 free objects의 리스트이다.
slab은 cpu에서 할당에 사용중인 슬랩이다.
원래 이름은 struct page였는데, kernel 5.17부터 struct slab으로 명칭이 변경되었다.
partial은 해당 page내 일부 object가 cpu에서 사용중인 경우 partial list로 관리된다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/8d32adcd624b293caaaac3fe6abbfa96.png" alt=""  />

이런식으로 현재 할당에 이용할 slab엔 하나의 slab page가 링크되고, partial slabs에는 대기중인 slab page들이 링크되어있다.
cpu slab의 page의 freelist와 percpu struct의 freelist는 같다.
하지만 다른 NUMA node에서 remote free 할때 실제 slab struct의 freelist와 약간 달라질 수 있다.</p>
<h3 id="struct-slab">struct slab<a hidden class="anchor" aria-hidden="true" href="#struct-slab">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Reuses the bits in struct page */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> slab {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> __page_flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_SLAB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>slab_cache;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> list_head slab_list;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>freelist;	<span style="color:#75715e">/* array of free object indexes */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>s_mem;	<span style="color:#75715e">/* first object */</span>
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rcu_head rcu_head;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> active;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#elif defined(CONFIG_SLUB)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>slab_cache;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> list_head slab_list;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> slab <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> slabs;	<span style="color:#75715e">/* Nr of slabs left */</span>
</span></span><span style="display:flex;"><span>				};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			};
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/* Double-word boundary */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>freelist;		<span style="color:#75715e">/* first free object */</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> counters;
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">unsigned</span> inuse:<span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">unsigned</span> objects:<span style="color:#ae81ff">15</span>;
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">unsigned</span> frozen:<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>						};
</span></span><span style="display:flex;"><span>					};
</span></span><span style="display:flex;"><span>				};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef system_has_freelist_aba
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">freelist_aba_t</span> freelist_counter;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			};
</span></span><span style="display:flex;"><span>		};
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rcu_head rcu_head;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> __unused;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#error &#34;Unexpected slab allocator configured&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">atomic_t</span> __page_refcount;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MEMCG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> memcg_data;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/be12a010b5af61c01ff4b128928a5c61.png" alt=""  />

struct page에서 이름이 바뀌었다.
percpu에서도 있지만, slab page 구조체에서도 freelist가 있다.
이 둘을 이용해서 할당 &amp; 해제를 좀 더 효율적으로 진행한다.
이에 대해선 Allocation 관련 설명을 하면서 후술한다.</p>
<h3 id="kmem_cache_node">kmem_cache_node<a hidden class="anchor" aria-hidden="true" href="#kmem_cache_node">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache_node {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLAB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">raw_spinlock_t</span> list_lock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head slabs_partial;	<span style="color:#75715e">/* partial list first, better asm code */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head slabs_full;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head slabs_free;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> total_slabs;	<span style="color:#75715e">/* length of all slab lists */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> free_slabs;	<span style="color:#75715e">/* length of free slab list only */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> free_objects;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> free_limit;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> colour_next;	<span style="color:#75715e">/* Per-node cache coloring */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> array_cache <span style="color:#f92672">*</span>shared;	<span style="color:#75715e">/* shared per node */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> alien_cache <span style="color:#f92672">**</span>alien;	<span style="color:#75715e">/* on other nodes */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> next_reap;	<span style="color:#75715e">/* updated without locking */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> free_touched;		<span style="color:#75715e">/* updated without locking */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLUB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">spinlock_t</span> list_lock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> nr_partial;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head partial;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_SLUB_DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">atomic_long_t</span> nr_slabs;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">atomic_long_t</span> total_objects;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head full;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>spinlock_t list_lock은 node에 동시접근 방지하기 위한 lock이다.
그리고 struct list_head partial은 node별로 관리되는 partial page list이다.</p>
<h2 id="allocation">Allocation<a hidden class="anchor" aria-hidden="true" href="#allocation">#</a></h2>
<p>정리하자면, kmem_cache_cpu는 CPU 별로 각자의 슬랩 페이지를 주고 관리하게 한다.
그리고 kmem_cache_cpu struct의 freelist는 할당에 이용되는 slab에 대한 freelist이다.
lockless하게 할당과 해제를 진행하게 된다.</p>
<p>근데 struct slab에서도 freelist가 존재했다.
cpu -&gt; freelist와 cpu -&gt; slab -&gt; freelist는 차이가 있다.
전자는 현재 CPU가 관리하며 free시 추가된다.
후자는 현재 CPU가 관리하는 slab page에 속한 object를 remote CPU가 free시에 리스트에 추가된다.
이러한 remote cpu, 즉 전담 cpu가 아닌 경우엔 항상 free만 가능하다.</p>
<p>frozen page는 list management에서 제외되는 페이지를 뜻한다.
freeze한 cpu만이 list operation을 수행하며, object를 freelist에서 뽑아오는 연산등을 할 수 있다.
frozen page여도 다른 cpu가 object를 freelist를 넣을 수는 있다.</p>
<p>이러한 frozen page에서 cpu -&gt; freelist가 가리키는 free object들과 in-use object들은 cpu -&gt; page.inuse의 값과 같으며 remote cpu가 free 할때만 감소한다.
즉 현재 CPU가 컨트롤하고 있는 object 개수만 inuse로 취급한다는 뜻이다.
앞서 remote cpu는 전담 cpu의 slab object에 대한 free만 가능하다는 사실과 일맥상통한다.</p>
<h3 id="fast-path">Fast-Path<a hidden class="anchor" aria-hidden="true" href="#fast-path">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/addce386b1140e7650301c995f47f2e0.png" alt=""  />
</p>
<ol>
<li>cpu -&gt; freelist에서 object 할당한다.</li>
</ol>
<h3 id="slow-path-1-2">Slow-Path 1, 2<a hidden class="anchor" aria-hidden="true" href="#slow-path-1-2">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/5b50c1acb12193d5f859e8f9e41a4ac9.png" alt=""  />
</p>
<h4 id="slow-path-1">Slow-Path 1<a hidden class="anchor" aria-hidden="true" href="#slow-path-1">#</a></h4>
<ol>
<li>cpu -&gt; slab에 freelist를 cpu -&gt; freelist로 옮긴다.</li>
<li>cpu -&gt; freelist에서 object를 할당한다</li>
</ol>
<h4 id="slow-path-2">Slow-Path 2<a hidden class="anchor" aria-hidden="true" href="#slow-path-2">#</a></h4>
<ol>
<li>cpu -&gt; partial를 cpu -&gt; page로 옮긴다.</li>
<li>cpu -&gt; page -&gt; freelist를 cpu -&gt; freelist로 옮긴다.</li>
<li>cpu -&gt; freelist에서 object를 할당한다.</li>
</ol>
<h3 id="slow-path-3-4">Slow-Path 3, 4<a hidden class="anchor" aria-hidden="true" href="#slow-path-3-4">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/8cc8599a01238ed12a404da423592727.png" alt=""  />
</p>
<h4 id="slow-path-3">Slow-Path 3<a hidden class="anchor" aria-hidden="true" href="#slow-path-3">#</a></h4>
<p>이번엔 slab_cache -&gt; cpu가 아니라 slab_cache -&gt; node 이다.</p>
<ol>
<li>node -&gt; partial를 freeze
freeze 하는 이유는 아주 당연하지만 node의 동시 접근 때문이다.</li>
<li>node -&gt; partial를 탐색하다가 page를 cpu -&gt; slab으로 옮긴다.</li>
<li>cpu -&gt; slab -&gt; freelist를 cpu -&gt; freelist로 옮긴다.</li>
<li>node -&gt; partial의 slab page 일부를 cpu -&gt;partial로 옮긴다.
moved partial_slabs &gt; s-&gt;cpu_partial_slabs / 2</li>
</ol>
<p>속한 node의 partial list가 비었으면 인접한 node도 탐색한다.</p>
<h4 id="slow-path-4">Slow-Path 4<a hidden class="anchor" aria-hidden="true" href="#slow-path-4">#</a></h4>
<ol>
<li>Buddy System으로부터 신규 slab page를 할당한다.
신규 page는 모든 object가 freelist에 존재한다.</li>
<li>new slab을 cpu -&gt; slab로 옮긴다.</li>
<li>cpu -&gt; freelist로도 옮긴다.</li>
</ol>
<h2 id="deallocation">Deallocation<a hidden class="anchor" aria-hidden="true" href="#deallocation">#</a></h2>
<p>할당과 비슷하게 fast, slow path가 있다.</p>
<h3 id="fast-path-1">Fast-Path<a hidden class="anchor" aria-hidden="true" href="#fast-path-1">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/d71fb2936c42b893ca639b24530f458b.png" alt=""  />

frozen page에 대해서 percpu의 freelist에 바로 반환한다.</p>
<h3 id="slow-path">Slow-Path<a hidden class="anchor" aria-hidden="true" href="#slow-path">#</a></h3>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/e6631aa6329123c28ef472d2cca432a2.png" alt=""  />

오브젝트가 속한 slab page freelist에 반환한다.
여러 케이스들이 있다.</p>
<ol>
<li>remote cpu가 다른 cpu slab을 free해서 리턴한다.</li>
<li>node의 partial에 리턴한다.</li>
<li>inuse가 0이면, 관할 cpu가 더이상 효율적으로 이용하지 못한다는 의미이므로 node로 옮긴다. 근데 이때 min_partial 보다 크거나 같아지면 buddy system에 다시 리턴한다.</li>
<li>node partial이 아니고 모든 객체가 할당된 상태이며 frozen 상태가 아니면 cpu partial에 추가한다.</li>
</ol>
<p>마지막 부분은 아직 잘 모르겠다.</p>
<h2 id="optimization">Optimization<a hidden class="anchor" aria-hidden="true" href="#optimization">#</a></h2>
<pre tabindex="0"><code>From: Christoph Lameter &lt;cl@linux.com&gt;
To: Tejun Heo &lt;tj@kernel.org&gt;
Cc: akpm@linux-foundation.org
Cc: Pekka Enberg &lt;penberg@cs.helsinki.fi&gt;
Cc: linux-kernel@vger.kernel.org
Cc: Eric Dumazet &lt;eric.dumazet@gmail.com&gt;
Cc: &#34;H. Peter Anvin&#34; &lt;hpa@zytor.com&gt;
Cc: Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;
Subject: [[cpuops cmpxchg double V2 4/4] Lockless (and preemptless) fastpaths for slub](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/#r)
Date: Thu, 06 Jan 2011 14:45:17 -0600	[[thread overview]](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/#r)
Message-ID: &lt;20110106204526.977812009@linux.com&gt; ([raw](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/raw))
In-Reply-To: 20110106204513.669098445@linux.com

[[-- /blog/Linux_kernel_SLUB_Allocator #1: cpuops_double_slub_fastpath --]
[-- Type: text/plain, Size: 12414 bytes --]](https://lore.kernel.org/lkml/20110106204526.977812009@linux.com/1-cpuops_double_slub_fastpath)

Use the this_cpu_cmpxchg_double functionality to implement a lockless
allocation algorithm on arches that support fast this_cpu_ops.

Each of the per cpu pointers is paired with a transaction id that ensures
that updates of the per cpu information can only occur in sequence on
a certain cpu.

A transaction id is a &#34;long&#34; integer that is comprised of an event number
and the cpu number. The event number is incremented for every change to the
per cpu state. The cmpxchg instruction can therefore verify for an
update that nothing else has interfered and that we are updating the percpu&#39;
structure for the processor where we initially picked up the information
and that we are also currently on that processor.

So there is no need even to disable preemption.

Test results show that the fastpath cycle count is reduced by up to ~ 40%
(alloc/free test goes from ~140 cycles down to ~80). The slowpath for kfree
adds a few cycles.

Sadly this does nothing for the slowpath which is where the main issues with
performance in slub are but the best case performance rises significantly.
(For that see the more complex slub patches that require cmpxchg_double)

Kmalloc: alloc/free test

Before:

10000 times kmalloc(8)/kfree -&gt; 134 cycles
10000 times kmalloc(16)/kfree -&gt; 152 cycles
10000 times kmalloc(32)/kfree -&gt; 144 cycles
10000 times kmalloc(64)/kfree -&gt; 142 cycles
10000 times kmalloc(128)/kfree -&gt; 142 cycles
10000 times kmalloc(256)/kfree -&gt; 132 cycles
10000 times kmalloc(512)/kfree -&gt; 132 cycles
10000 times kmalloc(1024)/kfree -&gt; 135 cycles
10000 times kmalloc(2048)/kfree -&gt; 135 cycles
10000 times kmalloc(4096)/kfree -&gt; 135 cycles
10000 times kmalloc(8192)/kfree -&gt; 144 cycles
10000 times kmalloc(16384)/kfree -&gt; 754 cycles

After:

10000 times kmalloc(8)/kfree -&gt; 78 cycles
10000 times kmalloc(16)/kfree -&gt; 78 cycles
10000 times kmalloc(32)/kfree -&gt; 82 cycles
10000 times kmalloc(64)/kfree -&gt; 88 cycles
10000 times kmalloc(128)/kfree -&gt; 79 cycles
10000 times kmalloc(256)/kfree -&gt; 79 cycles
10000 times kmalloc(512)/kfree -&gt; 85 cycles
10000 times kmalloc(1024)/kfree -&gt; 82 cycles
10000 times kmalloc(2048)/kfree -&gt; 82 cycles
10000 times kmalloc(4096)/kfree -&gt; 85 cycles
10000 times kmalloc(8192)/kfree -&gt; 82 cycles
10000 times kmalloc(16384)/kfree -&gt; 706 cycles


Kmalloc: Repeatedly allocate then free test

Before:

10000 times kmalloc(8) -&gt; 211 cycles kfree -&gt; 113 cycles
10000 times kmalloc(16) -&gt; 174 cycles kfree -&gt; 115 cycles
10000 times kmalloc(32) -&gt; 235 cycles kfree -&gt; 129 cycles
10000 times kmalloc(64) -&gt; 222 cycles kfree -&gt; 120 cycles
10000 times kmalloc(128) -&gt; 343 cycles kfree -&gt; 139 cycles
10000 times kmalloc(256) -&gt; 827 cycles kfree -&gt; 147 cycles
10000 times kmalloc(512) -&gt; 1048 cycles kfree -&gt; 272 cycles
10000 times kmalloc(1024) -&gt; 2043 cycles kfree -&gt; 528 cycles
10000 times kmalloc(2048) -&gt; 4002 cycles kfree -&gt; 571 cycles
10000 times kmalloc(4096) -&gt; 7740 cycles kfree -&gt; 628 cycles
10000 times kmalloc(8192) -&gt; 8062 cycles kfree -&gt; 850 cycles
10000 times kmalloc(16384) -&gt; 8895 cycles kfree -&gt; 1249 cycles

After:

10000 times kmalloc(8) -&gt; 190 cycles kfree -&gt; 129 cycles
10000 times kmalloc(16) -&gt; 76 cycles kfree -&gt; 123 cycles
10000 times kmalloc(32) -&gt; 126 cycles kfree -&gt; 124 cycles
10000 times kmalloc(64) -&gt; 181 cycles kfree -&gt; 128 cycles
10000 times kmalloc(128) -&gt; 310 cycles kfree -&gt; 140 cycles
10000 times kmalloc(256) -&gt; 809 cycles kfree -&gt; 165 cycles
10000 times kmalloc(512) -&gt; 1005 cycles kfree -&gt; 269 cycles
10000 times kmalloc(1024) -&gt; 1999 cycles kfree -&gt; 527 cycles
10000 times kmalloc(2048) -&gt; 3967 cycles kfree -&gt; 570 cycles
10000 times kmalloc(4096) -&gt; 7658 cycles kfree -&gt; 637 cycles
10000 times kmalloc(8192) -&gt; 8111 cycles kfree -&gt; 859 cycles
10000 times kmalloc(16384) -&gt; 8791 cycles kfree -&gt; 1173 cycles

Signed-off-by: Christoph Lameter &lt;cl@linux.com&gt;

---
 include/linux/slub_def.h |    5 -
 mm/slub.c                |  205 ++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 207 insertions(+), 3 deletions(-)
</code></pre><p>찾아보니 위와 같은 패치를 찾을 수 있었다.
percpu의 tid는 percpu update마다 증가되며 순차적인 업데이트를 보장한다.
중간에 interrupt로 인해 실행흐름이 넘어갈때 똑같이 percpu에 접근해서 할당을 하거나 하면 순차적인 업데이트를 보장하지 못한다.</p>
<p>왜냐하면 allocation request가 왔을때 freelist를 읽었는데, 이때 실행흐름이 새로운 allocation request로 넘어가면 분명 다른 두가지 요청인데 같은 메모리를 리턴하게 될 수도 있기 때문이다.
이를 방지하기 위해서 원래는 interrupt disable 했었다.</p>
<p>근데 만약 cmpxchg double을 지원하는 아키텍쳐에서 이를 이용하면 단순히 tid에 대한 검증과 리턴을 하나의 명령내에서 처리가 가능하다.
당연히 interrupt를 쓰지 않아도 되며, tid를 모든 allocation request가 순차적이라는 것을 보장할 수 있게 되었다.</p>
<p>또한 free시에도 lockless하게 구현할 수 있게 되었다.
원래 freelist를 가져가서 lock 걸고 list에서 뽑고 counter를 줄였는데, cmpxchg double로 그때 그때 counter 비교해서 다른 cpu가 counter 건들면 retry하면 된다.</p>
<h2 id="debugging">Debugging<a hidden class="anchor" aria-hidden="true" href="#debugging">#</a></h2>
<p><img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/55e491a5dd99ed0f677b6f676fa07ded.png" alt=""  />

직접 디버깅해보면, 슬랩 캐시도 보이고 random도 보인다.
5.19 기준으로 random 값이 있었고 청크의 next가 mangling 되어있었다.
나머지는 앞에서 살펴봤던 구조와 같았다.</p>
<p>percpu를 확인해보면
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/744f7af8ec835649c44190013daeb1bf.png" alt=""  />

이런식으로 freelist가 존재한다.
<img loading="lazy" src="/blog/Linux_kernel_SLUB_Allocator/fa0002ce906b355f3309e93abc516364.png" alt=""  />

정상적으로 첫번째 slab object가 리턴되는것을 확인할 수 있다.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://msh1307.kr/tags/kernel-slub/">kernel slub</a></li>
      <li><a href="https://msh1307.kr/tags/kernel-slub-allocator/">kernel slub allocator</a></li>
      <li><a href="https://msh1307.kr/tags/linux-kernel/">Linux kernel</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://msh1307.kr">msh1307</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
